// this file was auto-generated by wrapit v1.0.0-dirty
#include "jlcxx/jlcxx.hpp"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

#include "jlMFEM.h"
#include "dbg_msg.h"
#include "Wrapper.h"

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Vector> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Vector> : std::false_type { };
}

struct Jlmfem_Vector: public Wrapper {

  Jlmfem_Vector(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Vector (" __HERE__ ")");
    // defined in mfem/linalg/vector.hpp:58:7
    jlcxx::TypeWrapper<mfem::Vector>  t = jlModule.add_type<mfem::Vector>("mfem!Vector");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Vector>>(new jlcxx::TypeWrapper<mfem::Vector>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(const mfem::Vector &) (" __HERE__ ")");
    // defined in mfem/linalg/vector.hpp:72:4
    t.constructor<const mfem::Vector &>(/*finalize=*/true);



    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(int) (" __HERE__ ")");
    // defined in mfem/linalg/vector.hpp:79:13
    t.constructor<int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(double *, int) (" __HERE__ ")");
    // defined in mfem/linalg/vector.hpp:84:4
    t.constructor<double *, int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(mfem::Vector &, int, int) (" __HERE__ ")");
    // defined in mfem/linalg/vector.hpp:89:4
    t.constructor<mfem::Vector &, int, int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(int, mfem::MemoryType) (" __HERE__ ")");
    // defined in mfem/linalg/vector.hpp:93:4
    t.constructor<int, mfem::MemoryType>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(int, mfem::MemoryType, mfem::MemoryType) (" __HERE__ ")");
    // defined in mfem/linalg/vector.hpp:98:4
    t.constructor<int, mfem::MemoryType, mfem::MemoryType>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::Vector::UseDevice(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::UseDevice(bool)
    // defined in mfem/linalg/vector.hpp:115:17
    t.method("UseDevice", static_cast<void (mfem::Vector::*)(bool)  const>(&mfem::Vector::UseDevice));

    DEBUG_MSG("Adding wrapper for bool mfem::Vector::UseDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Vector::UseDevice()
    // defined in mfem/linalg/vector.hpp:118:17
    t.method("UseDevice", static_cast<bool (mfem::Vector::*)()  const>(&mfem::Vector::UseDevice));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSize(int)
    // defined in mfem/linalg/vector.hpp:137:9
    t.method("SetSize", static_cast<void (mfem::Vector::*)(int) >(&mfem::Vector::SetSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSize(int, mfem::MemoryType) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSize(int, mfem::MemoryType)
    // defined in mfem/linalg/vector.hpp:140:9
    t.method("SetSize", static_cast<void (mfem::Vector::*)(int, mfem::MemoryType) >(&mfem::Vector::SetSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSize(int, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSize(int, const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:143:9
    t.method("SetSize", static_cast<void (mfem::Vector::*)(int, const mfem::Vector &) >(&mfem::Vector::SetSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetData(double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetData(double *)
    // defined in mfem/linalg/vector.hpp:147:9
    t.method("SetData", static_cast<void (mfem::Vector::*)(double *) >(&mfem::Vector::SetData));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetDataAndSize(double *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetDataAndSize(double *, int)
    // defined in mfem/linalg/vector.hpp:154:9
    t.method("SetDataAndSize", static_cast<void (mfem::Vector::*)(double *, int) >(&mfem::Vector::SetDataAndSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::NewDataAndSize(double *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::NewDataAndSize(double *, int)
    // defined in mfem/linalg/vector.hpp:160:9
    t.method("NewDataAndSize", static_cast<void (mfem::Vector::*)(double *, int) >(&mfem::Vector::NewDataAndSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::MakeRef(mfem::Vector &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::MakeRef(mfem::Vector &, int, int)
    // defined in mfem/linalg/vector.hpp:178:16
    t.method("MakeRef", static_cast<void (mfem::Vector::*)(mfem::Vector &, int, int) >(&mfem::Vector::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::MakeRef(mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::MakeRef(mfem::Vector &, int)
    // defined in mfem/linalg/vector.hpp:182:16
    t.method("MakeRef", static_cast<void (mfem::Vector::*)(mfem::Vector &, int) >(&mfem::Vector::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::MakeDataOwner() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::MakeDataOwner()
    // defined in mfem/linalg/vector.hpp:185:9
    t.method("MakeDataOwner", static_cast<void (mfem::Vector::*)()  const>(&mfem::Vector::MakeDataOwner));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Destroy() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Destroy()
    // defined in mfem/linalg/vector.hpp:188:9
    t.method("Destroy", static_cast<void (mfem::Vector::*)() >(&mfem::Vector::Destroy));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::DeleteDevice(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::DeleteDevice(bool)
    // defined in mfem/linalg/vector.hpp:193:9
    t.method("DeleteDevice", static_cast<void (mfem::Vector::*)(bool) >(&mfem::Vector::DeleteDevice));
    t.method("DeleteDevice", [](mfem::Vector& a)->void{ a.DeleteDevice(); });
    t.method("DeleteDevice", [](mfem::Vector* a)->void{ a->DeleteDevice(); });

    DEBUG_MSG("Adding wrapper for int mfem::Vector::Size() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Vector::Size()
    // defined in mfem/linalg/vector.hpp:197:15
    t.method("Size", static_cast<int (mfem::Vector::*)()  const>(&mfem::Vector::Size));

    DEBUG_MSG("Adding wrapper for int mfem::Vector::Capacity() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Vector::Capacity()
    // defined in mfem/linalg/vector.hpp:201:15
    t.method("Capacity", static_cast<int (mfem::Vector::*)()  const>(&mfem::Vector::Capacity));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::GetData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::GetData()
    // defined in mfem/linalg/vector.hpp:206:19
    t.method("GetData", static_cast<double * (mfem::Vector::*)()  const>(&mfem::Vector::GetData));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::begin() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::begin()
    // defined in mfem/linalg/vector.hpp:216:19
    t.method("begin", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::begin));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::end() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::end()
    // defined in mfem/linalg/vector.hpp:219:19
    t.method("end", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::end));

    DEBUG_MSG("Adding wrapper for const double * mfem::Vector::begin() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Vector::begin()
    // defined in mfem/linalg/vector.hpp:222:25
    t.method("begin", static_cast<const double * (mfem::Vector::*)()  const>(&mfem::Vector::begin));

    DEBUG_MSG("Adding wrapper for const double * mfem::Vector::end() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Vector::end()
    // defined in mfem/linalg/vector.hpp:225:25
    t.method("end", static_cast<const double * (mfem::Vector::*)()  const>(&mfem::Vector::end));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SyncMemory(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SyncMemory(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:235:9
    t.method("SyncMemory", static_cast<void (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::SyncMemory));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SyncAliasMemory(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SyncAliasMemory(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:238:9
    t.method("SyncAliasMemory", static_cast<void (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::SyncAliasMemory));

    DEBUG_MSG("Adding wrapper for bool mfem::Vector::OwnsData() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Vector::OwnsData()
    // defined in mfem/linalg/vector.hpp:242:16
    t.method("OwnsData", static_cast<bool (mfem::Vector::*)()  const>(&mfem::Vector::OwnsData));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::StealData(double **) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::StealData(double **)
    // defined in mfem/linalg/vector.hpp:245:16
    t.method("StealData", static_cast<void (mfem::Vector::*)(double **) >(&mfem::Vector::StealData));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::StealData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::StealData()
    // defined in mfem/linalg/vector.hpp:249:19
    t.method("StealData", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::StealData));

    DEBUG_MSG("Adding wrapper for double & mfem::Vector::Elem(int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::Vector::Elem(int)
    // defined in mfem/linalg/vector.hpp:252:12
    t.method("Elem", static_cast<double & (mfem::Vector::*)(int) >(&mfem::Vector::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::Vector::Elem(int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::Vector::Elem(int)
    // defined in mfem/linalg/vector.hpp:255:18
    t.method("Elem", static_cast<const double & (mfem::Vector::*)(int)  const>(&mfem::Vector::Elem));

    DEBUG_MSG("Adding wrapper for double & mfem::Vector::operator()(int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::Vector::operator()(int)
    // defined in mfem/linalg/vector.hpp:259:19
    t.method("paren", static_cast<double & (mfem::Vector::*)(int) >(&mfem::Vector::operator()));

    DEBUG_MSG("Adding wrapper for const double & mfem::Vector::operator()(int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::Vector::operator()(int)
    // defined in mfem/linalg/vector.hpp:263:25
    t.method("paren", static_cast<const double & (mfem::Vector::*)(int)  const>(&mfem::Vector::operator()));
  module_.set_override_module(jl_base_module);


    DEBUG_MSG("Adding setindex! method  to wrap double & mfem::Vector::operator[](int) (" __HERE__ ")");
// defined in mfem/linalg/vector.hpp:267:19
    t.method("setindex!",
      [](mfem::Vector& a, int i, double const & val){
      return a[i] = val;
    });

    DEBUG_MSG("Adding getindex method to wrap double & mfem::Vector::operator[](int) (" __HERE__ ")");
    // defined in mfem/linalg/vector.hpp:267:19
    t.method("getindex",
      [](mfem::Vector& a, int i){
      return a[i];
    });


    DEBUG_MSG("Adding wrapper for double mfem::Vector::operator*(const double *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::operator*(const double *)
    // defined in mfem/linalg/vector.hpp:274:11
    t.method("*", static_cast<double (mfem::Vector::*)(const double *)  const>(&mfem::Vector::operator*));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::operator*(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::operator*(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:277:11
    t.method("*", static_cast<double (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::operator*));

  module_.unset_override_module();

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator=(const double *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator=(const double *)
    // defined in mfem/linalg/vector.hpp:280:12
    t.method("assign", static_cast<mfem::Vector & (mfem::Vector::*)(const double *) >(&mfem::Vector::operator=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator=(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:285:12
    t.method("assign", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator=));


    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator=(double)
    // defined in mfem/linalg/vector.hpp:291:12
    t.method("assign", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator*=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator*=(double)
    // defined in mfem/linalg/vector.hpp:293:12
    t.method("mult!", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator*=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator*=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator*=(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:296:12
    t.method("mult!", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator*=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator/=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator/=(double)
    // defined in mfem/linalg/vector.hpp:298:12
    t.method("fdiv!", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator/=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator/=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator/=(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:301:12
    t.method("fdiv!", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator/=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator-=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator-=(double)
    // defined in mfem/linalg/vector.hpp:303:12
    t.method("sub!", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator-=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator-=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator-=(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:305:12
    t.method("sub!", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator-=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator+=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator+=(double)
    // defined in mfem/linalg/vector.hpp:307:12
    t.method("add!", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator+=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator+=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator+=(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:309:12
    t.method("add!", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator+=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::Add(const double, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::Add(const double, const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:312:12
    t.method("Add", static_cast<mfem::Vector & (mfem::Vector::*)(const double, const mfem::Vector &) >(&mfem::Vector::Add));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::Set(const double, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::Set(const double, const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:315:12
    t.method("Set", static_cast<mfem::Vector & (mfem::Vector::*)(const double, const mfem::Vector &) >(&mfem::Vector::Set));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetVector(const mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetVector(const mfem::Vector &, int)
    // defined in mfem/linalg/vector.hpp:317:9
    t.method("SetVector", static_cast<void (mfem::Vector::*)(const mfem::Vector &, int) >(&mfem::Vector::SetVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::AddSubVector(const mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::AddSubVector(const mfem::Vector &, int)
    // defined in mfem/linalg/vector.hpp:319:9
    t.method("AddSubVector", static_cast<void (mfem::Vector::*)(const mfem::Vector &, int) >(&mfem::Vector::AddSubVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Neg() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Neg()
    // defined in mfem/linalg/vector.hpp:322:9
    t.method("Neg", static_cast<void (mfem::Vector::*)() >(&mfem::Vector::Neg));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Reciprocal() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Reciprocal()
    // defined in mfem/linalg/vector.hpp:325:9
    t.method("Reciprocal", static_cast<void (mfem::Vector::*)() >(&mfem::Vector::Reciprocal));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Swap(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Swap(mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:328:16
    t.method("Swap", static_cast<void (mfem::Vector::*)(mfem::Vector &) >(&mfem::Vector::Swap));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::cross3D(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::cross3D(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:352:9
    t.method("cross3D", static_cast<void (mfem::Vector::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::Vector::cross3D));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::median(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::median(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:355:9
    t.method("median", static_cast<void (mfem::Vector::*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::Vector::median));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Randomize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Randomize(int)
    // defined in mfem/linalg/vector.hpp:421:9
    t.method("Randomize", static_cast<void (mfem::Vector::*)(int) >(&mfem::Vector::Randomize));
    t.method("Randomize", [](mfem::Vector& a)->void{ a.Randomize(); });
    t.method("Randomize", [](mfem::Vector* a)->void{ a->Randomize(); });

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Norml2() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Norml2()
    // defined in mfem/linalg/vector.hpp:423:11
    t.method("Norml2", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Norml2));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Normlinf() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Normlinf()
    // defined in mfem/linalg/vector.hpp:425:11
    t.method("Normlinf", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Normlinf));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Norml1() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Norml1()
    // defined in mfem/linalg/vector.hpp:427:11
    t.method("Norml1", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Norml1));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Normlp(double) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Normlp(double)
    // defined in mfem/linalg/vector.hpp:429:11
    t.method("Normlp", static_cast<double (mfem::Vector::*)(double)  const>(&mfem::Vector::Normlp));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Max() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Max()
    // defined in mfem/linalg/vector.hpp:431:11
    t.method("Max", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Max));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Min() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Min()
    // defined in mfem/linalg/vector.hpp:433:11
    t.method("Min", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Min));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Sum() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Sum()
    // defined in mfem/linalg/vector.hpp:435:11
    t.method("Sum", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Sum));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::DistanceSquaredTo(const double *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::DistanceSquaredTo(const double *)
    // defined in mfem/linalg/vector.hpp:437:18
    t.method("DistanceSquaredTo", static_cast<double (mfem::Vector::*)(const double *)  const>(&mfem::Vector::DistanceSquaredTo));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::DistanceSquaredTo(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::DistanceSquaredTo(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:439:18
    t.method("DistanceSquaredTo", static_cast<double (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::DistanceSquaredTo));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::DistanceTo(const double *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::DistanceTo(const double *)
    // defined in mfem/linalg/vector.hpp:441:18
    t.method("DistanceTo", static_cast<double (mfem::Vector::*)(const double *)  const>(&mfem::Vector::DistanceTo));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::DistanceTo(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::DistanceTo(const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:443:18
    t.method("DistanceTo", static_cast<double (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::DistanceTo));

    DEBUG_MSG("Adding wrapper for int mfem::Vector::CheckFinite() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Vector::CheckFinite()
    // defined in mfem/linalg/vector.hpp:447:8
    t.method("CheckFinite", static_cast<int (mfem::Vector::*)()  const>(&mfem::Vector::CheckFinite));

    DEBUG_MSG("Adding wrapper for const double * mfem::Vector::Read(bool) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Vector::Read(bool)
    // defined in mfem/linalg/vector.hpp:453:26
    t.method("Read", static_cast<const double * (mfem::Vector::*)(bool)  const>(&mfem::Vector::Read));
    t.method("Read", [](mfem::Vector const& a)->const double *{ return a.Read(); });
    t.method("Read", [](mfem::Vector const* a)->const double *{ return a->Read(); });

    DEBUG_MSG("Adding wrapper for const double * mfem::Vector::HostRead() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Vector::HostRead()
    // defined in mfem/linalg/vector.hpp:457:26
    t.method("HostRead", static_cast<const double * (mfem::Vector::*)()  const>(&mfem::Vector::HostRead));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::Write(bool) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::Write(bool)
    // defined in mfem/linalg/vector.hpp:461:20
    t.method("Write", static_cast<double * (mfem::Vector::*)(bool) >(&mfem::Vector::Write));
    t.method("Write", [](mfem::Vector& a)->double *{ return a.Write(); });
    t.method("Write", [](mfem::Vector* a)->double *{ return a->Write(); });

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::HostWrite() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::HostWrite()
    // defined in mfem/linalg/vector.hpp:465:20
    t.method("HostWrite", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::HostWrite));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::ReadWrite(bool) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::ReadWrite(bool)
    // defined in mfem/linalg/vector.hpp:469:20
    t.method("ReadWrite", static_cast<double * (mfem::Vector::*)(bool) >(&mfem::Vector::ReadWrite));
    t.method("ReadWrite", [](mfem::Vector& a)->double *{ return a.ReadWrite(); });
    t.method("ReadWrite", [](mfem::Vector* a)->double *{ return a->ReadWrite(); });

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::HostReadWrite() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::HostReadWrite()
    // defined in mfem/linalg/vector.hpp:473:20
    t.method("HostReadWrite", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::HostReadWrite));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Vector>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Vector(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Vector(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RowNode> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RowNode> : std::false_type { };
}

struct Jlmfem_RowNode: public Wrapper {

  Jlmfem_RowNode(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RowNode (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:41:4
    jlcxx::TypeWrapper<mfem::RowNode>  t = jlModule.add_type<mfem::RowNode>("mfem!RowNode");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RowNode>>(new jlcxx::TypeWrapper<mfem::RowNode>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding Value methods  to provide read access to the field Value (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:44:11
    // signature to use in the veto list: mfem::RowNode::Value
    t.method("Value", [](const mfem::RowNode& a) -> double { return a.Value; });
    t.method("Value", [](mfem::RowNode& a) -> double { return a.Value; });
    t.method("Value", [](const mfem::RowNode* a) -> double { return a->Value; });
    t.method("Value", [](mfem::RowNode* a) -> double { return a->Value; });
    // defined in mfem/linalg/sparsemat.hpp:44:11
    // signature to use in the veto list: mfem::RowNode::Value
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding Value! methods to provide write access to the field Value (" __HERE__ ")");
    t.method("Value!", [](mfem::RowNode& a, double val) -> double { return a.Value = val; });

    DEBUG_MSG("Adding Value! methods to provide write access to the field Value (" __HERE__ ")");
    t.method("Value!", [](mfem::RowNode* a, double val) -> double { return a->Value = val; });

    DEBUG_MSG("Adding Prev methods  to provide read access to the field Prev (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:45:13
    // signature to use in the veto list: mfem::RowNode::Prev
    t.method("Prev", [](const mfem::RowNode& a) -> mfem::RowNode * { return a.Prev; });
    t.method("Prev", [](mfem::RowNode& a) -> mfem::RowNode * { return a.Prev; });
    t.method("Prev", [](const mfem::RowNode* a) -> mfem::RowNode * { return a->Prev; });
    t.method("Prev", [](mfem::RowNode* a) -> mfem::RowNode * { return a->Prev; });
    // defined in mfem/linalg/sparsemat.hpp:45:13
    // signature to use in the veto list: mfem::RowNode::Prev
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding Prev! methods to provide write access to the field Prev (" __HERE__ ")");
    t.method("Prev!", [](mfem::RowNode& a, mfem::RowNode * val) -> mfem::RowNode * { return a.Prev = val; });

    DEBUG_MSG("Adding Prev! methods to provide write access to the field Prev (" __HERE__ ")");
    t.method("Prev!", [](mfem::RowNode* a, mfem::RowNode * val) -> mfem::RowNode * { return a->Prev = val; });

    DEBUG_MSG("Adding Column methods  to provide read access to the field Column (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:46:8
    // signature to use in the veto list: mfem::RowNode::Column
    t.method("Column", [](const mfem::RowNode& a) -> int { return a.Column; });
    t.method("Column", [](mfem::RowNode& a) -> int { return a.Column; });
    t.method("Column", [](const mfem::RowNode* a) -> int { return a->Column; });
    t.method("Column", [](mfem::RowNode* a) -> int { return a->Column; });
    // defined in mfem/linalg/sparsemat.hpp:46:8
    // signature to use in the veto list: mfem::RowNode::Column
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding Column! methods to provide write access to the field Column (" __HERE__ ")");
    t.method("Column!", [](mfem::RowNode& a, int val) -> int { return a.Column = val; });

    DEBUG_MSG("Adding Column! methods to provide write access to the field Column (" __HERE__ ")");
    t.method("Column!", [](mfem::RowNode* a, int val) -> int { return a->Column = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RowNode>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RowNode(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RowNode(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::AbstractSparseMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::AbstractSparseMatrix> : std::false_type { };
}

struct Jlmfem_AbstractSparseMatrix: public Wrapper {

  Jlmfem_AbstractSparseMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::AbstractSparseMatrix (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../linalg/matrix.hpp:73:7
    jlcxx::TypeWrapper<mfem::AbstractSparseMatrix>  t = jlModule.add_type<mfem::AbstractSparseMatrix>("mfem!AbstractSparseMatrix");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::AbstractSparseMatrix>>(new jlcxx::TypeWrapper<mfem::AbstractSparseMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::AbstractSparseMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_AbstractSparseMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_AbstractSparseMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DenseMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DenseMatrix> : std::false_type { };
}

struct Jlmfem_DenseMatrix: public Wrapper {

  Jlmfem_DenseMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DenseMatrix (" __HERE__ ")");
    // defined in mfem/mesh/../linalg/densemat.hpp:23:7
    jlcxx::TypeWrapper<mfem::DenseMatrix>  t = jlModule.add_type<mfem::DenseMatrix>("mfem!DenseMatrix");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseMatrix>>(new jlcxx::TypeWrapper<mfem::DenseMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DenseMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DenseMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Operator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Operator> : std::false_type { };
}

struct Jlmfem_Operator: public Wrapper {

  Jlmfem_Operator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Operator (" __HERE__ ")");
    // defined in mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:24:7
    jlcxx::TypeWrapper<mfem::Operator>  t = jlModule.add_type<mfem::Operator>("mfem!Operator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Operator>>(new jlcxx::TypeWrapper<mfem::Operator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Operator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Operator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Operator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SparseMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SparseMatrix> : std::false_type { };
template<> struct SuperType<mfem::SparseMatrix> { typedef mfem::AbstractSparseMatrix type; };
}

struct Jlmfem_SparseMatrix: public Wrapper {

  Jlmfem_SparseMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SparseMatrix (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:50:7
    jlcxx::TypeWrapper<mfem::SparseMatrix>  t = jlModule.add_type<mfem::SparseMatrix>("mfem!SparseMatrix"    , jlcxx::julia_base_type<mfem::AbstractSparseMatrix>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SparseMatrix>>(new jlcxx::TypeWrapper<mfem::SparseMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(int, int) (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:143:13
    t.constructor<int>(/*finalize=*/true);
    t.constructor<int, int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(int *, int *, double *, int, int) (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:147:4
    t.constructor<int *, int *, double *, int, int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(int *, int *, double *, int, int, bool, bool, bool) (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:154:4
    t.constructor<int *, int *, double *, int, int, bool, bool, bool>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(int, int, int) (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:161:4
    t.constructor<int, int, int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(const mfem::SparseMatrix &, bool, mfem::MemoryType) (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:171:4
    t.constructor<const mfem::SparseMatrix &>(/*finalize=*/true);
    t.constructor<const mfem::SparseMatrix &, bool>(/*finalize=*/true);
    t.constructor<const mfem::SparseMatrix &, bool, mfem::MemoryType>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(const mfem::Vector &) (" __HERE__ ")");
    // defined in mfem/linalg/sparsemat.hpp:175:4
    t.constructor<const mfem::Vector &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::OverrideSize(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::OverrideSize(int, int)
    // defined in mfem/linalg/sparsemat.hpp:184:9
    t.method("OverrideSize", static_cast<void (mfem::SparseMatrix::*)(int, int) >(&mfem::SparseMatrix::OverrideSize));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::UseGPUSparse(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::UseGPUSparse(bool)
    // defined in mfem/linalg/sparsemat.hpp:191:9
    t.method("UseGPUSparse", static_cast<void (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::UseGPUSparse));
    t.method("UseGPUSparse", [](mfem::SparseMatrix& a)->void{ a.UseGPUSparse(); });
    t.method("UseGPUSparse", [](mfem::SparseMatrix* a)->void{ a->UseGPUSparse(); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::UseCuSparse(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::UseCuSparse(bool)
    // defined in mfem/linalg/sparsemat.hpp:194:9
    t.method("UseCuSparse", static_cast<void (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::UseCuSparse));
    t.method("UseCuSparse", [](mfem::SparseMatrix& a)->void{ a.UseCuSparse(); });
    t.method("UseCuSparse", [](mfem::SparseMatrix* a)->void{ a->UseCuSparse(); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::SparseMatrix::operator=(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::SparseMatrix::operator=(const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:197:18
    t.method("assign", static_cast<mfem::SparseMatrix & (mfem::SparseMatrix::*)(const mfem::SparseMatrix &) >(&mfem::SparseMatrix::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::MakeRef(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::MakeRef(const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:203:9
    t.method("MakeRef", static_cast<void (mfem::SparseMatrix::*)(const mfem::SparseMatrix &) >(&mfem::SparseMatrix::MakeRef));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::Size() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::Size()
    // defined in mfem/linalg/sparsemat.hpp:206:8
    t.method("Size", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::Size));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Clear()
    // defined in mfem/linalg/sparsemat.hpp:209:9
    t.method("Clear", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::Clear));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ClearGPUSparse() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ClearGPUSparse()
    // defined in mfem/linalg/sparsemat.hpp:213:9
    t.method("ClearGPUSparse", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::ClearGPUSparse));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ClearCuSparse() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ClearCuSparse()
    // defined in mfem/linalg/sparsemat.hpp:216:9
    t.method("ClearCuSparse", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::ClearCuSparse));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::Empty() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::Empty()
    // defined in mfem/linalg/sparsemat.hpp:219:9
    t.method("Empty", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::Empty));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::GetI() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::GetI()
    // defined in mfem/linalg/sparsemat.hpp:222:16
    t.method("GetI", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetI));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::GetI() (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::GetI()
    // defined in mfem/linalg/sparsemat.hpp:224:22
    t.method("GetI", static_cast<const int * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetI));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::GetJ() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::GetJ()
    // defined in mfem/linalg/sparsemat.hpp:227:16
    t.method("GetJ", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetJ));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::GetJ() (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::GetJ()
    // defined in mfem/linalg/sparsemat.hpp:229:22
    t.method("GetJ", static_cast<const int * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetJ));

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::GetData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::GetData()
    // defined in mfem/linalg/sparsemat.hpp:232:19
    t.method("GetData", static_cast<double * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetData));

    DEBUG_MSG("Adding wrapper for const double * mfem::SparseMatrix::GetData() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::SparseMatrix::GetData()
    // defined in mfem/linalg/sparsemat.hpp:234:25
    t.method("GetData", static_cast<const double * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetData));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::ReadI(bool) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::ReadI(bool)
    // defined in mfem/linalg/sparsemat.hpp:239:15
    t.method("ReadI", static_cast<const int * (mfem::SparseMatrix::*)(bool)  const>(&mfem::SparseMatrix::ReadI));
    t.method("ReadI", [](mfem::SparseMatrix const& a)->const int *{ return a.ReadI(); });
    t.method("ReadI", [](mfem::SparseMatrix const* a)->const int *{ return a->ReadI(); });

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::WriteI(bool) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::WriteI(bool)
    // defined in mfem/linalg/sparsemat.hpp:241:9
    t.method("WriteI", static_cast<int * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::WriteI));
    t.method("WriteI", [](mfem::SparseMatrix& a)->int *{ return a.WriteI(); });
    t.method("WriteI", [](mfem::SparseMatrix* a)->int *{ return a->WriteI(); });

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::ReadWriteI(bool) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::ReadWriteI(bool)
    // defined in mfem/linalg/sparsemat.hpp:243:9
    t.method("ReadWriteI", static_cast<int * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::ReadWriteI));
    t.method("ReadWriteI", [](mfem::SparseMatrix& a)->int *{ return a.ReadWriteI(); });
    t.method("ReadWriteI", [](mfem::SparseMatrix* a)->int *{ return a->ReadWriteI(); });

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::HostReadI() (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::HostReadI()
    // defined in mfem/linalg/sparsemat.hpp:245:15
    t.method("HostReadI", static_cast<const int * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::HostReadI));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::HostWriteI() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::HostWriteI()
    // defined in mfem/linalg/sparsemat.hpp:247:9
    t.method("HostWriteI", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostWriteI));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::HostReadWriteI() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::HostReadWriteI()
    // defined in mfem/linalg/sparsemat.hpp:249:9
    t.method("HostReadWriteI", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostReadWriteI));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::ReadJ(bool) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::ReadJ(bool)
    // defined in mfem/linalg/sparsemat.hpp:255:15
    t.method("ReadJ", static_cast<const int * (mfem::SparseMatrix::*)(bool)  const>(&mfem::SparseMatrix::ReadJ));
    t.method("ReadJ", [](mfem::SparseMatrix const& a)->const int *{ return a.ReadJ(); });
    t.method("ReadJ", [](mfem::SparseMatrix const* a)->const int *{ return a->ReadJ(); });

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::WriteJ(bool) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::WriteJ(bool)
    // defined in mfem/linalg/sparsemat.hpp:257:9
    t.method("WriteJ", static_cast<int * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::WriteJ));
    t.method("WriteJ", [](mfem::SparseMatrix& a)->int *{ return a.WriteJ(); });
    t.method("WriteJ", [](mfem::SparseMatrix* a)->int *{ return a->WriteJ(); });

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::ReadWriteJ(bool) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::ReadWriteJ(bool)
    // defined in mfem/linalg/sparsemat.hpp:259:9
    t.method("ReadWriteJ", static_cast<int * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::ReadWriteJ));
    t.method("ReadWriteJ", [](mfem::SparseMatrix& a)->int *{ return a.ReadWriteJ(); });
    t.method("ReadWriteJ", [](mfem::SparseMatrix* a)->int *{ return a->ReadWriteJ(); });

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::HostReadJ() (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::HostReadJ()
    // defined in mfem/linalg/sparsemat.hpp:261:15
    t.method("HostReadJ", static_cast<const int * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::HostReadJ));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::HostWriteJ() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::HostWriteJ()
    // defined in mfem/linalg/sparsemat.hpp:263:9
    t.method("HostWriteJ", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostWriteJ));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::HostReadWriteJ() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::HostReadWriteJ()
    // defined in mfem/linalg/sparsemat.hpp:265:9
    t.method("HostReadWriteJ", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostReadWriteJ));

    DEBUG_MSG("Adding wrapper for const double * mfem::SparseMatrix::ReadData(bool) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::SparseMatrix::ReadData(bool)
    // defined in mfem/linalg/sparsemat.hpp:271:18
    t.method("ReadData", static_cast<const double * (mfem::SparseMatrix::*)(bool)  const>(&mfem::SparseMatrix::ReadData));
    t.method("ReadData", [](mfem::SparseMatrix const& a)->const double *{ return a.ReadData(); });
    t.method("ReadData", [](mfem::SparseMatrix const* a)->const double *{ return a->ReadData(); });

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::WriteData(bool) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::WriteData(bool)
    // defined in mfem/linalg/sparsemat.hpp:273:12
    t.method("WriteData", static_cast<double * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::WriteData));
    t.method("WriteData", [](mfem::SparseMatrix& a)->double *{ return a.WriteData(); });
    t.method("WriteData", [](mfem::SparseMatrix* a)->double *{ return a->WriteData(); });

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::ReadWriteData(bool) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::ReadWriteData(bool)
    // defined in mfem/linalg/sparsemat.hpp:275:12
    t.method("ReadWriteData", static_cast<double * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::ReadWriteData));
    t.method("ReadWriteData", [](mfem::SparseMatrix& a)->double *{ return a.ReadWriteData(); });
    t.method("ReadWriteData", [](mfem::SparseMatrix* a)->double *{ return a->ReadWriteData(); });

    DEBUG_MSG("Adding wrapper for const double * mfem::SparseMatrix::HostReadData() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::SparseMatrix::HostReadData()
    // defined in mfem/linalg/sparsemat.hpp:277:18
    t.method("HostReadData", static_cast<const double * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::HostReadData));

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::HostWriteData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::HostWriteData()
    // defined in mfem/linalg/sparsemat.hpp:279:12
    t.method("HostWriteData", static_cast<double * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostWriteData));

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::HostReadWriteData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::HostReadWriteData()
    // defined in mfem/linalg/sparsemat.hpp:281:12
    t.method("HostReadWriteData", static_cast<double * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostReadWriteData));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::RowSize(const int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::RowSize(const int)
    // defined in mfem/linalg/sparsemat.hpp:285:8
    t.method("RowSize", static_cast<int (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::RowSize));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::MaxRowSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::MaxRowSize()
    // defined in mfem/linalg/sparsemat.hpp:288:8
    t.method("MaxRowSize", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::MaxRowSize));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::GetRowColumns(const int) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::GetRowColumns(const int)
    // defined in mfem/linalg/sparsemat.hpp:291:9
    t.method("GetRowColumns", static_cast<int * (mfem::SparseMatrix::*)(const int) >(&mfem::SparseMatrix::GetRowColumns));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::GetRowColumns(const int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::GetRowColumns(const int)
    // defined in mfem/linalg/sparsemat.hpp:293:15
    t.method("GetRowColumns", static_cast<const int * (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::GetRowColumns));

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::GetRowEntries(const int) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::GetRowEntries(const int)
    // defined in mfem/linalg/sparsemat.hpp:296:12
    t.method("GetRowEntries", static_cast<double * (mfem::SparseMatrix::*)(const int) >(&mfem::SparseMatrix::GetRowEntries));

    DEBUG_MSG("Adding wrapper for const double * mfem::SparseMatrix::GetRowEntries(const int) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::SparseMatrix::GetRowEntries(const int)
    // defined in mfem/linalg/sparsemat.hpp:298:18
    t.method("GetRowEntries", static_cast<const double * (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::GetRowEntries));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetWidth(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetWidth(int)
    // defined in mfem/linalg/sparsemat.hpp:308:9
    t.method("SetWidth", static_cast<void (mfem::SparseMatrix::*)(int) >(&mfem::SparseMatrix::SetWidth));
    t.method("SetWidth", [](mfem::SparseMatrix& a)->void{ a.SetWidth(); });
    t.method("SetWidth", [](mfem::SparseMatrix* a)->void{ a->SetWidth(); });

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::ActualWidth() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::ActualWidth()
    // defined in mfem/linalg/sparsemat.hpp:312:8
    t.method("ActualWidth", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ActualWidth));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SortColumnIndices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SortColumnIndices()
    // defined in mfem/linalg/sparsemat.hpp:315:9
    t.method("SortColumnIndices", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::SortColumnIndices));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::MoveDiagonalFirst() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::MoveDiagonalFirst()
    // defined in mfem/linalg/sparsemat.hpp:319:9
    t.method("MoveDiagonalFirst", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::MoveDiagonalFirst));

    DEBUG_MSG("Adding wrapper for double & mfem::SparseMatrix::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::SparseMatrix::Elem(int, int)
    // defined in mfem/linalg/sparsemat.hpp:322:20
    t.method("Elem", static_cast<double & (mfem::SparseMatrix::*)(int, int) >(&mfem::SparseMatrix::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::SparseMatrix::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::SparseMatrix::Elem(int, int)
    // defined in mfem/linalg/sparsemat.hpp:325:26
    t.method("Elem", static_cast<const double & (mfem::SparseMatrix::*)(int, int)  const>(&mfem::SparseMatrix::Elem));

    DEBUG_MSG("Adding wrapper for double & mfem::SparseMatrix::operator()(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::SparseMatrix::operator()(int, int)
    // defined in mfem/linalg/sparsemat.hpp:328:12
    t.method("paren", static_cast<double & (mfem::SparseMatrix::*)(int, int) >(&mfem::SparseMatrix::operator()));

    DEBUG_MSG("Adding wrapper for const double & mfem::SparseMatrix::operator()(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::SparseMatrix::operator()(int, int)
    // defined in mfem/linalg/sparsemat.hpp:331:18
    t.method("paren", static_cast<const double & (mfem::SparseMatrix::*)(int, int)  const>(&mfem::SparseMatrix::operator()));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::GetDiag(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::GetDiag(mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:334:9
    t.method("GetDiag", static_cast<void (mfem::SparseMatrix::*)(mfem::Vector &)  const>(&mfem::SparseMatrix::GetDiag));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::SparseMatrix::ToDenseMatrix() (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::SparseMatrix::ToDenseMatrix()
    // defined in mfem/linalg/sparsemat.hpp:337:17
    t.method("ToDenseMatrix", static_cast<mfem::DenseMatrix * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ToDenseMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ToDenseMatrix(mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ToDenseMatrix(mfem::DenseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:340:9
    t.method("ToDenseMatrix", static_cast<void (mfem::SparseMatrix::*)(mfem::DenseMatrix &)  const>(&mfem::SparseMatrix::ToDenseMatrix));

    DEBUG_MSG("Adding wrapper for mfem::MemoryClass mfem::SparseMatrix::GetMemoryClass() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MemoryClass mfem::SparseMatrix::GetMemoryClass()
    // defined in mfem/linalg/sparsemat.hpp:342:24
    t.method("GetMemoryClass", static_cast<mfem::MemoryClass (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetMemoryClass));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:349:17
    t.method("Mult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AddMult(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AddMult(const mfem::Vector &, mfem::Vector &, const double)
    // defined in mfem/linalg/sparsemat.hpp:352:17
    t.method("AddMult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::SparseMatrix::AddMult));
    t.method("AddMult", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a.AddMult(arg0, arg1); });
    t.method("AddMult", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a->AddMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:359:17
    t.method("MultTranspose", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double)
    // defined in mfem/linalg/sparsemat.hpp:365:17
    t.method("AddMultTranspose", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::SparseMatrix::AddMultTranspose));
    t.method("AddMultTranspose", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a.AddMultTranspose(arg0, arg1); });
    t.method("AddMultTranspose", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a->AddMultTranspose(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::BuildTranspose() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::BuildTranspose()
    // defined in mfem/linalg/sparsemat.hpp:390:9
    t.method("BuildTranspose", static_cast<void (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::BuildTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ResetTranspose() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ResetTranspose()
    // defined in mfem/linalg/sparsemat.hpp:394:9
    t.method("ResetTranspose", static_cast<void (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ResetTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EnsureMultTranspose() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EnsureMultTranspose()
    // defined in mfem/linalg/sparsemat.hpp:406:9
    t.method("EnsureMultTranspose", static_cast<void (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::EnsureMultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AbsMult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AbsMult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:425:9
    t.method("AbsMult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::AbsMult));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AbsMultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AbsMultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:431:9
    t.method("AbsMultTranspose", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::AbsMultTranspose));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::InnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::InnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:434:11
    t.method("InnerProduct", static_cast<double (mfem::SparseMatrix::*)(const mfem::Vector &, const mfem::Vector &)  const>(&mfem::SparseMatrix::InnerProduct));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::GetRowSums(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::GetRowSums(mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:437:9
    t.method("GetRowSums", static_cast<void (mfem::SparseMatrix::*)(mfem::Vector &)  const>(&mfem::SparseMatrix::GetRowSums));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::GetRowNorml1(int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::GetRowNorml1(int)
    // defined in mfem/linalg/sparsemat.hpp:439:11
    t.method("GetRowNorml1", static_cast<double (mfem::SparseMatrix::*)(int)  const>(&mfem::SparseMatrix::GetRowNorml1));

    DEBUG_MSG("Adding wrapper for mfem::MatrixInverse * mfem::SparseMatrix::Inverse() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixInverse * mfem::SparseMatrix::Inverse()
    // defined in mfem/linalg/sparsemat.hpp:442:27
    t.method("Inverse", static_cast<mfem::MatrixInverse * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::Inverse));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRow(int, const double, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRow(int, const double, mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:445:9
    t.method("EliminateRow", static_cast<void (mfem::SparseMatrix::*)(int, const double, mfem::Vector &) >(&mfem::SparseMatrix::EliminateRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRow(int, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRow(int, mfem::Operator::DiagonalPolicy)
    // defined in mfem/linalg/sparsemat.hpp:454:9
    t.method("EliminateRow", static_cast<void (mfem::SparseMatrix::*)(int, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRow));
    t.method("EliminateRow", [](mfem::SparseMatrix& a, int arg0)->void{ a.EliminateRow(arg0); });
    t.method("EliminateRow", [](mfem::SparseMatrix* a, int arg0)->void{ a->EliminateRow(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateCol(int, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateCol(int, mfem::Operator::DiagonalPolicy)
    // defined in mfem/linalg/sparsemat.hpp:461:9
    t.method("EliminateCol", static_cast<void (mfem::SparseMatrix::*)(int, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateCol));
    t.method("EliminateCol", [](mfem::SparseMatrix& a, int arg0)->void{ a.EliminateCol(arg0); });
    t.method("EliminateCol", [](mfem::SparseMatrix* a, int arg0)->void{ a->EliminateCol(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowCol(int, const double, mfem::Vector &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowCol(int, const double, mfem::Vector &, mfem::Operator::DiagonalPolicy)
    // defined in mfem/linalg/sparsemat.hpp:481:9
    t.method("EliminateRowCol", static_cast<void (mfem::SparseMatrix::*)(int, const double, mfem::Vector &, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRowCol));
    t.method("EliminateRowCol", [](mfem::SparseMatrix& a, int arg0, const double arg1, mfem::Vector & arg2)->void{ a.EliminateRowCol(arg0, arg1, arg2); });
    t.method("EliminateRowCol", [](mfem::SparseMatrix* a, int arg0, const double arg1, mfem::Vector & arg2)->void{ a->EliminateRowCol(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowColMultipleRHS(int, const mfem::Vector &, mfem::DenseMatrix &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowColMultipleRHS(int, const mfem::Vector &, mfem::DenseMatrix &, mfem::Operator::DiagonalPolicy)
    // defined in mfem/linalg/sparsemat.hpp:488:9
    t.method("EliminateRowColMultipleRHS", static_cast<void (mfem::SparseMatrix::*)(int, const mfem::Vector &, mfem::DenseMatrix &, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRowColMultipleRHS));
    t.method("EliminateRowColMultipleRHS", [](mfem::SparseMatrix& a, int arg0, const mfem::Vector & arg1, mfem::DenseMatrix & arg2)->void{ a.EliminateRowColMultipleRHS(arg0, arg1, arg2); });
    t.method("EliminateRowColMultipleRHS", [](mfem::SparseMatrix* a, int arg0, const mfem::Vector & arg1, mfem::DenseMatrix & arg2)->void{ a->EliminateRowColMultipleRHS(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowColDiag(int, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowColDiag(int, double)
    // defined in mfem/linalg/sparsemat.hpp:493:9
    t.method("EliminateRowColDiag", static_cast<void (mfem::SparseMatrix::*)(int, double) >(&mfem::SparseMatrix::EliminateRowColDiag));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowCol(int, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowCol(int, mfem::Operator::DiagonalPolicy)
    // defined in mfem/linalg/sparsemat.hpp:496:9
    t.method("EliminateRowCol", static_cast<void (mfem::SparseMatrix::*)(int, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRowCol));
    t.method("EliminateRowCol", [](mfem::SparseMatrix& a, int arg0)->void{ a.EliminateRowCol(arg0); });
    t.method("EliminateRowCol", [](mfem::SparseMatrix* a, int arg0)->void{ a->EliminateRowCol(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowCol(int, mfem::SparseMatrix &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowCol(int, mfem::SparseMatrix &, mfem::Operator::DiagonalPolicy)
    // defined in mfem/linalg/sparsemat.hpp:501:9
    t.method("EliminateRowCol", static_cast<void (mfem::SparseMatrix::*)(int, mfem::SparseMatrix &, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRowCol));
    t.method("EliminateRowCol", [](mfem::SparseMatrix& a, int arg0, mfem::SparseMatrix & arg1)->void{ a.EliminateRowCol(arg0, arg1); });
    t.method("EliminateRowCol", [](mfem::SparseMatrix* a, int arg0, mfem::SparseMatrix & arg1)->void{ a->EliminateRowCol(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetDiagIdentity() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetDiagIdentity()
    // defined in mfem/linalg/sparsemat.hpp:513:9
    t.method("SetDiagIdentity", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::SetDiagIdentity));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateZeroRows(const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateZeroRows(const double)
    // defined in mfem/linalg/sparsemat.hpp:515:17
    t.method("EliminateZeroRows", static_cast<void (mfem::SparseMatrix::*)(const double) >(&mfem::SparseMatrix::EliminateZeroRows));
    t.method("EliminateZeroRows", [](mfem::SparseMatrix& a)->void{ a.EliminateZeroRows(); });
    t.method("EliminateZeroRows", [](mfem::SparseMatrix* a)->void{ a->EliminateZeroRows(); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Gauss_Seidel_forw(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Gauss_Seidel_forw(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:518:9
    t.method("Gauss_Seidel_forw", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::Gauss_Seidel_forw));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Gauss_Seidel_back(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Gauss_Seidel_back(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:519:9
    t.method("Gauss_Seidel_back", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::Gauss_Seidel_back));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::GetJacobiScaling() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::GetJacobiScaling()
    // defined in mfem/linalg/sparsemat.hpp:522:11
    t.method("GetJacobiScaling", static_cast<double (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetJacobiScaling));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Jacobi(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Jacobi(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, bool)
    // defined in mfem/linalg/sparsemat.hpp:526:9
    t.method("Jacobi", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, bool)  const>(&mfem::SparseMatrix::Jacobi));
    t.method("Jacobi", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, double arg3)->void{ a.Jacobi(arg0, arg1, arg2, arg3); });
    t.method("Jacobi", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, double arg3)->void{ a->Jacobi(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::DiagScale(const mfem::Vector &, mfem::Vector &, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::DiagScale(const mfem::Vector &, mfem::Vector &, double, bool)
    // defined in mfem/linalg/sparsemat.hpp:530:9
    t.method("DiagScale", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &, double, bool)  const>(&mfem::SparseMatrix::DiagScale));
    t.method("DiagScale", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a.DiagScale(arg0, arg1); });
    t.method("DiagScale", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1, double arg2)->void{ a.DiagScale(arg0, arg1, arg2); });
    t.method("DiagScale", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a->DiagScale(arg0, arg1); });
    t.method("DiagScale", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1, double arg2)->void{ a->DiagScale(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Jacobi2(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Jacobi2(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double)
    // defined in mfem/linalg/sparsemat.hpp:534:9
    t.method("Jacobi2", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double)  const>(&mfem::SparseMatrix::Jacobi2));
    t.method("Jacobi2", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void{ a.Jacobi2(arg0, arg1, arg2); });
    t.method("Jacobi2", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void{ a->Jacobi2(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Jacobi3(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Jacobi3(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double)
    // defined in mfem/linalg/sparsemat.hpp:538:9
    t.method("Jacobi3", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double)  const>(&mfem::SparseMatrix::Jacobi3));
    t.method("Jacobi3", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void{ a.Jacobi3(arg0, arg1, arg2); });
    t.method("Jacobi3", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void{ a->Jacobi3(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Finalize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Finalize(int)
    // defined in mfem/linalg/sparsemat.hpp:546:17
    t.method("Finalize", static_cast<void (mfem::SparseMatrix::*)(int) >(&mfem::SparseMatrix::Finalize));
    t.method("Finalize", [](mfem::SparseMatrix& a)->void{ a.Finalize(); });
    t.method("Finalize", [](mfem::SparseMatrix* a)->void{ a->Finalize(); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Finalize(int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Finalize(int, bool)
    // defined in mfem/linalg/sparsemat.hpp:549:9
    t.method("Finalize", static_cast<void (mfem::SparseMatrix::*)(int, bool) >(&mfem::SparseMatrix::Finalize));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::Finalized() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::Finalized()
    // defined in mfem/linalg/sparsemat.hpp:552:9
    t.method("Finalized", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::Finalized));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::ColumnsAreSorted() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::ColumnsAreSorted()
    // defined in mfem/linalg/sparsemat.hpp:554:9
    t.method("ColumnsAreSorted", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ColumnsAreSorted));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Threshold(double, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Threshold(double, bool)
    // defined in mfem/linalg/sparsemat.hpp:559:9
    t.method("Threshold", static_cast<void (mfem::SparseMatrix::*)(double, bool) >(&mfem::SparseMatrix::Threshold));
    t.method("Threshold", [](mfem::SparseMatrix& a, double arg0)->void{ a.Threshold(arg0); });
    t.method("Threshold", [](mfem::SparseMatrix* a, double arg0)->void{ a->Threshold(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetColPtr(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetColPtr(const int)
    // defined in mfem/linalg/sparsemat.hpp:574:16
    t.method("SetColPtr", static_cast<void (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::SetColPtr));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ClearColPtr() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ClearColPtr()
    // defined in mfem/linalg/sparsemat.hpp:577:16
    t.method("ClearColPtr", static_cast<void (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ClearColPtr));

    DEBUG_MSG("Adding wrapper for double & mfem::SparseMatrix::SearchRow(const int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::SparseMatrix::SearchRow(const int)
    // defined in mfem/linalg/sparsemat.hpp:583:19
    t.method("SearchRow", static_cast<double & (mfem::SparseMatrix::*)(const int) >(&mfem::SparseMatrix::SearchRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::_Add_(const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::_Add_(const int, const double)
    // defined in mfem/linalg/sparsemat.hpp:585:16
    t.method("_Add_", static_cast<void (mfem::SparseMatrix::*)(const int, const double) >(&mfem::SparseMatrix::_Add_));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::_Set_(const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::_Set_(const int, const double)
    // defined in mfem/linalg/sparsemat.hpp:588:16
    t.method("_Set_", static_cast<void (mfem::SparseMatrix::*)(const int, const double) >(&mfem::SparseMatrix::_Set_));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::_Get_(const int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::_Get_(const int)
    // defined in mfem/linalg/sparsemat.hpp:591:18
    t.method("_Get_", static_cast<double (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::_Get_));

    DEBUG_MSG("Adding wrapper for double & mfem::SparseMatrix::SearchRow(const int, const int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::SparseMatrix::SearchRow(const int, const int)
    // defined in mfem/linalg/sparsemat.hpp:593:19
    t.method("SearchRow", static_cast<double & (mfem::SparseMatrix::*)(const int, const int) >(&mfem::SparseMatrix::SearchRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::_Add_(const int, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::_Add_(const int, const int, const double)
    // defined in mfem/linalg/sparsemat.hpp:594:16
    t.method("_Add_", static_cast<void (mfem::SparseMatrix::*)(const int, const int, const double) >(&mfem::SparseMatrix::_Add_));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::_Set_(const int, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::_Set_(const int, const int, const double)
    // defined in mfem/linalg/sparsemat.hpp:596:16
    t.method("_Set_", static_cast<void (mfem::SparseMatrix::*)(const int, const int, const double) >(&mfem::SparseMatrix::_Set_));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Set(const int, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Set(const int, const int, const double)
    // defined in mfem/linalg/sparsemat.hpp:599:9
    t.method("Set", static_cast<void (mfem::SparseMatrix::*)(const int, const int, const double) >(&mfem::SparseMatrix::Set));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Add(const int, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Add(const int, const int, const double)
    // defined in mfem/linalg/sparsemat.hpp:600:9
    t.method("Add", static_cast<void (mfem::SparseMatrix::*)(const int, const int, const double) >(&mfem::SparseMatrix::Add));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::RowIsEmpty(const int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::RowIsEmpty(const int)
    // defined in mfem/linalg/sparsemat.hpp:617:9
    t.method("RowIsEmpty", static_cast<bool (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::RowIsEmpty));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ScaleRow(const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ScaleRow(const int, const double)
    // defined in mfem/linalg/sparsemat.hpp:634:9
    t.method("ScaleRow", static_cast<void (mfem::SparseMatrix::*)(const int, const double) >(&mfem::SparseMatrix::ScaleRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ScaleRows(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ScaleRows(const mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:636:9
    t.method("ScaleRows", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &) >(&mfem::SparseMatrix::ScaleRows));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ScaleColumns(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ScaleColumns(const mfem::Vector &)
    // defined in mfem/linalg/sparsemat.hpp:638:9
    t.method("ScaleColumns", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &) >(&mfem::SparseMatrix::ScaleColumns));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::SparseMatrix::operator+=(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::SparseMatrix::operator+=(const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:642:18
    t.method("add!", static_cast<mfem::SparseMatrix & (mfem::SparseMatrix::*)(const mfem::SparseMatrix &) >(&mfem::SparseMatrix::operator+=));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Add(const double, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Add(const double, const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:646:9
    t.method("Add", static_cast<void (mfem::SparseMatrix::*)(const double, const mfem::SparseMatrix &) >(&mfem::SparseMatrix::Add));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::SparseMatrix::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::SparseMatrix::operator=(double)
    // defined in mfem/linalg/sparsemat.hpp:648:18
    t.method("assign", static_cast<mfem::SparseMatrix & (mfem::SparseMatrix::*)(double) >(&mfem::SparseMatrix::operator=));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::SparseMatrix::operator*=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::SparseMatrix::operator*=(double)
    // defined in mfem/linalg/sparsemat.hpp:650:18
    t.method("mult!", static_cast<mfem::SparseMatrix & (mfem::SparseMatrix::*)(double) >(&mfem::SparseMatrix::operator*=));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::IsSymmetric() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::IsSymmetric()
    // defined in mfem/linalg/sparsemat.hpp:671:11
    t.method("IsSymmetric", static_cast<double (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::IsSymmetric));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Symmetrize() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Symmetrize()
    // defined in mfem/linalg/sparsemat.hpp:674:9
    t.method("Symmetrize", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::Symmetrize));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::NumNonZeroElems() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::NumNonZeroElems()
    // defined in mfem/linalg/sparsemat.hpp:677:16
    t.method("NumNonZeroElems", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::NumNonZeroElems));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::MaxNorm() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::MaxNorm()
    // defined in mfem/linalg/sparsemat.hpp:679:11
    t.method("MaxNorm", static_cast<double (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::MaxNorm));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::CountSmallElems(double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::CountSmallElems(double)
    // defined in mfem/linalg/sparsemat.hpp:682:8
    t.method("CountSmallElems", static_cast<int (mfem::SparseMatrix::*)(double)  const>(&mfem::SparseMatrix::CountSmallElems));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::CheckFinite() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::CheckFinite()
    // defined in mfem/linalg/sparsemat.hpp:685:8
    t.method("CheckFinite", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::CheckFinite));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetGraphOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetGraphOwner(bool)
    // defined in mfem/linalg/sparsemat.hpp:688:9
    t.method("SetGraphOwner", static_cast<void (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::SetGraphOwner));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetDataOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetDataOwner(bool)
    // defined in mfem/linalg/sparsemat.hpp:692:9
    t.method("SetDataOwner", static_cast<void (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::SetDataOwner));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::OwnsGraph() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::OwnsGraph()
    // defined in mfem/linalg/sparsemat.hpp:695:9
    t.method("OwnsGraph", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::OwnsGraph));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::OwnsData() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::OwnsData()
    // defined in mfem/linalg/sparsemat.hpp:698:9
    t.method("OwnsData", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::OwnsData));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::LoseData() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::LoseData()
    // defined in mfem/linalg/sparsemat.hpp:701:9
    t.method("LoseData", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::LoseData));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Swap(mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Swap(mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:703:9
    t.method("Swap", static_cast<void (mfem::SparseMatrix::*)(mfem::SparseMatrix &) >(&mfem::SparseMatrix::Swap));

    DEBUG_MSG("Adding wrapper for mfem::Operator::Type mfem::SparseMatrix::GetType() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator::Type mfem::SparseMatrix::GetType()
    // defined in mfem/linalg/sparsemat.hpp:708:9
    t.method("GetType", static_cast<mfem::Operator::Type (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SparseMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SparseMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SparseMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IterativeSolverMonitor> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IterativeSolverMonitor> : std::false_type { };
}

struct Jlmfem_IterativeSolverMonitor: public Wrapper {

  Jlmfem_IterativeSolverMonitor(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IterativeSolverMonitor (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:36:7
    jlcxx::TypeWrapper<mfem::IterativeSolverMonitor>  t = jlModule.add_type<mfem::IterativeSolverMonitor>("mfem!IterativeSolverMonitor");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolverMonitor>>(new jlcxx::TypeWrapper<mfem::IterativeSolverMonitor>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolverMonitor::MonitorResidual(int, double, const mfem::Vector &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolverMonitor::MonitorResidual(int, double, const mfem::Vector &, bool)
    // defined in mfem/linalg/solvers.hpp:48:17
    t.method("MonitorResidual", static_cast<void (mfem::IterativeSolverMonitor::*)(int, double, const mfem::Vector &, bool) >(&mfem::IterativeSolverMonitor::MonitorResidual));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolverMonitor::MonitorSolution(int, double, const mfem::Vector &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolverMonitor::MonitorSolution(int, double, const mfem::Vector &, bool)
    // defined in mfem/linalg/solvers.hpp:54:17
    t.method("MonitorSolution", static_cast<void (mfem::IterativeSolverMonitor::*)(int, double, const mfem::Vector &, bool) >(&mfem::IterativeSolverMonitor::MonitorSolution));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolverMonitor::SetIterativeSolver(const mfem::IterativeSolver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolverMonitor::SetIterativeSolver(const mfem::IterativeSolver &)
    // defined in mfem/linalg/solvers.hpp:61:9
    t.method("SetIterativeSolver", static_cast<void (mfem::IterativeSolverMonitor::*)(const mfem::IterativeSolver &) >(&mfem::IterativeSolverMonitor::SetIterativeSolver));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolverMonitor>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IterativeSolverMonitor(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IterativeSolverMonitor(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Solver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Solver> : std::false_type { };
template<> struct SuperType<mfem::Solver> { typedef mfem::Operator type; };
}

struct Jlmfem_Solver: public Wrapper {

  Jlmfem_Solver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Solver (" __HERE__ ")");
    // defined in mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:698:7
    jlcxx::TypeWrapper<mfem::Solver>  t = jlModule.add_type<mfem::Solver>("mfem!Solver"    , jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Solver>>(new jlcxx::TypeWrapper<mfem::Solver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Solver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Solver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Solver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IterativeSolver::PrintLevel> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IterativeSolver::PrintLevel> : std::false_type { };
}

struct Jlmfem_IterativeSolver_PrintLevel: public Wrapper {

  Jlmfem_IterativeSolver_PrintLevel(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IterativeSolver::PrintLevel (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:78:11
    jlcxx::TypeWrapper<mfem::IterativeSolver::PrintLevel>  t = jlModule.add_type<mfem::IterativeSolver::PrintLevel>("mfem!IterativeSolver!PrintLevel");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolver::PrintLevel>>(new jlcxx::TypeWrapper<mfem::IterativeSolver::PrintLevel>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::None() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::None()
    // defined in mfem/linalg/solvers.hpp:103:19
    t.method("None", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::None));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Warnings() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Warnings()
    // defined in mfem/linalg/solvers.hpp:104:19
    t.method("Warnings", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::Warnings));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Errors() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Errors()
    // defined in mfem/linalg/solvers.hpp:105:19
    t.method("Errors", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::Errors));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Iterations() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Iterations()
    // defined in mfem/linalg/solvers.hpp:106:19
    t.method("Iterations", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::Iterations));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::FirstAndLast() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::FirstAndLast()
    // defined in mfem/linalg/solvers.hpp:107:19
    t.method("FirstAndLast", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::FirstAndLast));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Summary() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Summary()
    // defined in mfem/linalg/solvers.hpp:108:19
    t.method("Summary", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::Summary));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::All() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::All()
    // defined in mfem/linalg/solvers.hpp:109:19
    t.method("All", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::All));

    DEBUG_MSG("Adding errors methods  to provide read access to the field errors (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:82:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::errors
    t.method("errors", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.errors; });
    t.method("errors", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.errors; });
    t.method("errors", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->errors; });
    t.method("errors", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->errors; });
    // defined in mfem/linalg/solvers.hpp:82:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::errors
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding errors! methods to provide write access to the field errors (" __HERE__ ")");
    t.method("errors!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.errors = val; });

    DEBUG_MSG("Adding errors! methods to provide write access to the field errors (" __HERE__ ")");
    t.method("errors!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->errors = val; });

    DEBUG_MSG("Adding warnings methods  to provide read access to the field warnings (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:85:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::warnings
    t.method("warnings", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.warnings; });
    t.method("warnings", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.warnings; });
    t.method("warnings", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->warnings; });
    t.method("warnings", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->warnings; });
    // defined in mfem/linalg/solvers.hpp:85:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::warnings
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding warnings! methods to provide write access to the field warnings (" __HERE__ ")");
    t.method("warnings!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.warnings = val; });

    DEBUG_MSG("Adding warnings! methods to provide write access to the field warnings (" __HERE__ ")");
    t.method("warnings!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->warnings = val; });

    DEBUG_MSG("Adding iterations methods  to provide read access to the field iterations (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:88:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::iterations
    t.method("iterations", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.iterations; });
    t.method("iterations", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.iterations; });
    t.method("iterations", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->iterations; });
    t.method("iterations", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->iterations; });
    // defined in mfem/linalg/solvers.hpp:88:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::iterations
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding iterations! methods to provide write access to the field iterations (" __HERE__ ")");
    t.method("iterations!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.iterations = val; });

    DEBUG_MSG("Adding iterations! methods to provide write access to the field iterations (" __HERE__ ")");
    t.method("iterations!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->iterations = val; });

    DEBUG_MSG("Adding summary methods  to provide read access to the field summary (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:91:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::summary
    t.method("summary", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.summary; });
    t.method("summary", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.summary; });
    t.method("summary", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->summary; });
    t.method("summary", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->summary; });
    // defined in mfem/linalg/solvers.hpp:91:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::summary
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding summary! methods to provide write access to the field summary (" __HERE__ ")");
    t.method("summary!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.summary = val; });

    DEBUG_MSG("Adding summary! methods to provide write access to the field summary (" __HERE__ ")");
    t.method("summary!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->summary = val; });

    DEBUG_MSG("Adding first_and_last methods  to provide read access to the field first_and_last (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:94:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::first_and_last
    t.method("first_and_last", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.first_and_last; });
    t.method("first_and_last", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.first_and_last; });
    t.method("first_and_last", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->first_and_last; });
    t.method("first_and_last", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->first_and_last; });
    // defined in mfem/linalg/solvers.hpp:94:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::first_and_last
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding first_and_last! methods to provide write access to the field first_and_last (" __HERE__ ")");
    t.method("first_and_last!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.first_and_last = val; });

    DEBUG_MSG("Adding first_and_last! methods to provide write access to the field first_and_last (" __HERE__ ")");
    t.method("first_and_last!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->first_and_last = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolver::PrintLevel>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IterativeSolver_PrintLevel(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IterativeSolver_PrintLevel(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixInverse> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixInverse> : std::false_type { };
template<> struct SuperType<mfem::MatrixInverse> { typedef mfem::Solver type; };
}

struct Jlmfem_MatrixInverse: public Wrapper {

  Jlmfem_MatrixInverse(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixInverse (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../linalg/matrix.hpp:62:7
    jlcxx::TypeWrapper<mfem::MatrixInverse>  t = jlModule.add_type<mfem::MatrixInverse>("mfem!MatrixInverse"    , jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixInverse>>(new jlcxx::TypeWrapper<mfem::MatrixInverse>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixInverse>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixInverse(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixInverse(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IterativeSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IterativeSolver> : std::false_type { };
template<> struct SuperType<mfem::IterativeSolver> { typedef mfem::Solver type; };
}

struct Jlmfem_IterativeSolver: public Wrapper {

  Jlmfem_IterativeSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IterativeSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:66:7
    jlcxx::TypeWrapper<mfem::IterativeSolver>  t = jlModule.add_type<mfem::IterativeSolver>("mfem!IterativeSolver"    , jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolver>>(new jlcxx::TypeWrapper<mfem::IterativeSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetRelTol(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetRelTol(double)
    // defined in mfem/linalg/solvers.hpp:199:9
    t.method("SetRelTol", static_cast<void (mfem::IterativeSolver::*)(double) >(&mfem::IterativeSolver::SetRelTol));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetAbsTol(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetAbsTol(double)
    // defined in mfem/linalg/solvers.hpp:200:9
    t.method("SetAbsTol", static_cast<void (mfem::IterativeSolver::*)(double) >(&mfem::IterativeSolver::SetAbsTol));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetMaxIter(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetMaxIter(int)
    // defined in mfem/linalg/solvers.hpp:201:9
    t.method("SetMaxIter", static_cast<void (mfem::IterativeSolver::*)(int) >(&mfem::IterativeSolver::SetMaxIter));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetPrintLevel(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetPrintLevel(int)
    // defined in mfem/linalg/solvers.hpp:229:17
    t.method("SetPrintLevel", static_cast<void (mfem::IterativeSolver::*)(int) >(&mfem::IterativeSolver::SetPrintLevel));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetPrintLevel(mfem::IterativeSolver::PrintLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetPrintLevel(mfem::IterativeSolver::PrintLevel)
    // defined in mfem/linalg/solvers.hpp:242:17
    t.method("SetPrintLevel", static_cast<void (mfem::IterativeSolver::*)(mfem::IterativeSolver::PrintLevel) >(&mfem::IterativeSolver::SetPrintLevel));

    DEBUG_MSG("Adding wrapper for int mfem::IterativeSolver::GetNumIterations() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::IterativeSolver::GetNumIterations()
    // defined in mfem/linalg/solvers.hpp:250:8
    t.method("GetNumIterations", static_cast<int (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetNumIterations));

    DEBUG_MSG("Adding wrapper for bool mfem::IterativeSolver::GetConverged() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::IterativeSolver::GetConverged()
    // defined in mfem/linalg/solvers.hpp:252:9
    t.method("GetConverged", static_cast<bool (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetConverged));

    DEBUG_MSG("Adding wrapper for double mfem::IterativeSolver::GetInitialNorm() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::IterativeSolver::GetInitialNorm()
    // defined in mfem/linalg/solvers.hpp:258:11
    t.method("GetInitialNorm", static_cast<double (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetInitialNorm));

    DEBUG_MSG("Adding wrapper for double mfem::IterativeSolver::GetFinalNorm() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::IterativeSolver::GetFinalNorm()
    // defined in mfem/linalg/solvers.hpp:265:11
    t.method("GetFinalNorm", static_cast<double (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetFinalNorm));

    DEBUG_MSG("Adding wrapper for double mfem::IterativeSolver::GetFinalRelNorm() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::IterativeSolver::GetFinalRelNorm()
    // defined in mfem/linalg/solvers.hpp:271:11
    t.method("GetFinalRelNorm", static_cast<double (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetFinalRelNorm));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetPreconditioner(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetPreconditioner(mfem::Solver &)
    // defined in mfem/linalg/solvers.hpp:280:17
    t.method("SetPreconditioner", static_cast<void (mfem::IterativeSolver::*)(mfem::Solver &) >(&mfem::IterativeSolver::SetPreconditioner));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:283:17
    t.method("SetOperator", static_cast<void (mfem::IterativeSolver::*)(const mfem::Operator &) >(&mfem::IterativeSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetMonitor(mfem::IterativeSolverMonitor &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetMonitor(mfem::IterativeSolverMonitor &)
    // defined in mfem/linalg/solvers.hpp:286:9
    t.method("SetMonitor", static_cast<void (mfem::IterativeSolver::*)(mfem::IterativeSolverMonitor &) >(&mfem::IterativeSolver::SetMonitor));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IterativeSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IterativeSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OperatorJacobiSmoother> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OperatorJacobiSmoother> : std::false_type { };
template<> struct SuperType<mfem::OperatorJacobiSmoother> { typedef mfem::Solver type; };
}

struct Jlmfem_OperatorJacobiSmoother: public Wrapper {

  Jlmfem_OperatorJacobiSmoother(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OperatorJacobiSmoother (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:302:7
    jlcxx::TypeWrapper<mfem::OperatorJacobiSmoother>  t = jlModule.add_type<mfem::OperatorJacobiSmoother>("mfem!OperatorJacobiSmoother"    , jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorJacobiSmoother>>(new jlcxx::TypeWrapper<mfem::OperatorJacobiSmoother>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::OperatorJacobiSmoother(const double) (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:308:4
    t.constructor<const double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::SetPositiveDiagonal(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::SetPositiveDiagonal(bool)
    // defined in mfem/linalg/solvers.hpp:339:9
    t.method("SetPositiveDiagonal", static_cast<void (mfem::OperatorJacobiSmoother::*)(bool) >(&mfem::OperatorJacobiSmoother::SetPositiveDiagonal));
    t.method("SetPositiveDiagonal", [](mfem::OperatorJacobiSmoother& a)->void{ a.SetPositiveDiagonal(); });
    t.method("SetPositiveDiagonal", [](mfem::OperatorJacobiSmoother* a)->void{ a->SetPositiveDiagonal(); });

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:341:9
    t.method("Mult", static_cast<void (mfem::OperatorJacobiSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorJacobiSmoother::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:342:9
    t.method("MultTranspose", static_cast<void (mfem::OperatorJacobiSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorJacobiSmoother::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:355:9
    t.method("SetOperator", static_cast<void (mfem::OperatorJacobiSmoother::*)(const mfem::Operator &) >(&mfem::OperatorJacobiSmoother::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::Setup(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::Setup(const mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:372:9
    t.method("Setup", static_cast<void (mfem::OperatorJacobiSmoother::*)(const mfem::Vector &) >(&mfem::OperatorJacobiSmoother::Setup));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorJacobiSmoother>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OperatorJacobiSmoother(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OperatorJacobiSmoother(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BilinearForm> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BilinearForm> : std::false_type { };
}

struct Jlmfem_BilinearForm: public Wrapper {

  Jlmfem_BilinearForm(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BilinearForm (" __HERE__ ")");
    // defined in mfem/fem/bilinearform.hpp:60:7
    jlcxx::TypeWrapper<mfem::BilinearForm>  t = jlModule.add_type<mfem::BilinearForm>("mfem!BilinearForm");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearForm>>(new jlcxx::TypeWrapper<mfem::BilinearForm>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::BilinearForm(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in mfem/fem/bilinearform.hpp:158:4
    t.constructor<mfem::FiniteElementSpace *>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::BilinearForm(mfem::FiniteElementSpace *, mfem::BilinearForm *, int) (" __HERE__ ")");
    // defined in mfem/fem/bilinearform.hpp:170:4
    t.constructor<mfem::FiniteElementSpace *, mfem::BilinearForm *>(/*finalize=*/true);
    t.constructor<mfem::FiniteElementSpace *, mfem::BilinearForm *, int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for int mfem::BilinearForm::Size() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::BilinearForm::Size()
    // defined in mfem/fem/bilinearform.hpp:173:8
    t.method("Size", static_cast<int (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::Size));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::SetAssemblyLevel(mfem::AssemblyLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::SetAssemblyLevel(mfem::AssemblyLevel)
    // defined in mfem/fem/bilinearform.hpp:185:9
    t.method("SetAssemblyLevel", static_cast<void (mfem::BilinearForm::*)(mfem::AssemblyLevel) >(&mfem::BilinearForm::SetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EnableSparseMatrixSorting(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EnableSparseMatrixSorting(bool)
    // defined in mfem/fem/bilinearform.hpp:197:9
    t.method("EnableSparseMatrixSorting", static_cast<void (mfem::BilinearForm::*)(bool) >(&mfem::BilinearForm::EnableSparseMatrixSorting));

    DEBUG_MSG("Adding wrapper for mfem::AssemblyLevel mfem::BilinearForm::GetAssemblyLevel() (" __HERE__ ")");
    // signature to use in the veto list: mfem::AssemblyLevel mfem::BilinearForm::GetAssemblyLevel()
    // defined in mfem/fem/bilinearform.hpp:203:18
    t.method("GetAssemblyLevel", static_cast<mfem::AssemblyLevel (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for mfem::Hybridization * mfem::BilinearForm::GetHybridization() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Hybridization * mfem::BilinearForm::GetHybridization()
    // defined in mfem/fem/bilinearform.hpp:205:19
    t.method("GetHybridization", static_cast<mfem::Hybridization * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetHybridization));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EnableStaticCondensation() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EnableStaticCondensation()
    // defined in mfem/fem/bilinearform.hpp:211:9
    t.method("EnableStaticCondensation", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::EnableStaticCondensation));

    DEBUG_MSG("Adding wrapper for bool mfem::BilinearForm::StaticCondensationIsEnabled() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::BilinearForm::StaticCondensationIsEnabled()
    // defined in mfem/fem/bilinearform.hpp:215:9
    t.method("StaticCondensationIsEnabled", static_cast<bool (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::StaticCondensationIsEnabled));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::BilinearForm::SCFESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::BilinearForm::SCFESpace()
    // defined in mfem/fem/bilinearform.hpp:218:24
    t.method("SCFESpace", static_cast<mfem::FiniteElementSpace * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::SCFESpace));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::UsePrecomputedSparsity(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::UsePrecomputedSparsity(int)
    // defined in mfem/fem/bilinearform.hpp:232:9
    t.method("UsePrecomputedSparsity", static_cast<void (mfem::BilinearForm::*)(int) >(&mfem::BilinearForm::UsePrecomputedSparsity));
    t.method("UsePrecomputedSparsity", [](mfem::BilinearForm& a)->void{ a.UsePrecomputedSparsity(); });
    t.method("UsePrecomputedSparsity", [](mfem::BilinearForm* a)->void{ a->UsePrecomputedSparsity(); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::UseSparsity(int *, int *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::UseSparsity(int *, int *, bool)
    // defined in mfem/fem/bilinearform.hpp:243:9
    t.method("UseSparsity", static_cast<void (mfem::BilinearForm::*)(int *, int *, bool) >(&mfem::BilinearForm::UseSparsity));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::UseSparsity(mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::UseSparsity(mfem::SparseMatrix &)
    // defined in mfem/fem/bilinearform.hpp:246:9
    t.method("UseSparsity", static_cast<void (mfem::BilinearForm::*)(mfem::SparseMatrix &) >(&mfem::BilinearForm::UseSparsity));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AllocateMatrix() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AllocateMatrix()
    // defined in mfem/fem/bilinearform.hpp:252:9
    t.method("AllocateMatrix", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::AllocateMatrix));

    DEBUG_MSG("Adding wrapper for const double & mfem::BilinearForm::operator()(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::BilinearForm::operator()(int, int)
    // defined in mfem/fem/bilinearform.hpp:276:18
    t.method("paren", static_cast<const double & (mfem::BilinearForm::*)(int, int) >(&mfem::BilinearForm::operator()));

    DEBUG_MSG("Adding wrapper for double & mfem::BilinearForm::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::BilinearForm::Elem(int, int)
    // defined in mfem/fem/bilinearform.hpp:279:20
    t.method("Elem", static_cast<double & (mfem::BilinearForm::*)(int, int) >(&mfem::BilinearForm::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::BilinearForm::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::BilinearForm::Elem(int, int)
    // defined in mfem/fem/bilinearform.hpp:282:26
    t.method("Elem", static_cast<const double & (mfem::BilinearForm::*)(int, int)  const>(&mfem::BilinearForm::Elem));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:285:17
    t.method("Mult", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FullMult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FullMult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:290:9
    t.method("FullMult", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::FullMult));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddMult(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddMult(const mfem::Vector &, mfem::Vector &, const double)
    // defined in mfem/fem/bilinearform.hpp:294:17
    t.method("AddMult", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::BilinearForm::AddMult));
    t.method("AddMult", [](mfem::BilinearForm const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a.AddMult(arg0, arg1); });
    t.method("AddMult", [](mfem::BilinearForm const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a->AddMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FullAddMult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FullAddMult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:300:9
    t.method("FullAddMult", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::FullAddMult));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double)
    // defined in mfem/fem/bilinearform.hpp:304:17
    t.method("AddMultTranspose", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::BilinearForm::AddMultTranspose));
    t.method("AddMultTranspose", [](mfem::BilinearForm const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a.AddMultTranspose(arg0, arg1); });
    t.method("AddMultTranspose", [](mfem::BilinearForm const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a->AddMultTranspose(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FullAddMultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FullAddMultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:311:9
    t.method("FullAddMultTranspose", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::FullAddMultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:315:17
    t.method("MultTranspose", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::MultTranspose));

    DEBUG_MSG("Adding wrapper for double mfem::BilinearForm::InnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::BilinearForm::InnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:318:11
    t.method("InnerProduct", static_cast<double (mfem::BilinearForm::*)(const mfem::Vector &, const mfem::Vector &)  const>(&mfem::BilinearForm::InnerProduct));

    DEBUG_MSG("Adding wrapper for mfem::MatrixInverse * mfem::BilinearForm::Inverse() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixInverse * mfem::BilinearForm::Inverse()
    // defined in mfem/fem/bilinearform.hpp:322:27
    t.method("Inverse", static_cast<mfem::MatrixInverse * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::Inverse));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::Finalize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::Finalize(int)
    // defined in mfem/fem/bilinearform.hpp:325:17
    t.method("Finalize", static_cast<void (mfem::BilinearForm::*)(int) >(&mfem::BilinearForm::Finalize));
    t.method("Finalize", [](mfem::BilinearForm& a)->void{ a.Finalize(); });
    t.method("Finalize", [](mfem::BilinearForm* a)->void{ a->Finalize(); });

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix & mfem::BilinearForm::SpMat() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix & mfem::BilinearForm::SpMat()
    // defined in mfem/fem/bilinearform.hpp:330:24
    t.method("SpMat", static_cast<const mfem::SparseMatrix & (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::SpMat));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::BilinearForm::SpMat() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::BilinearForm::SpMat()
    // defined in mfem/fem/bilinearform.hpp:339:18
    t.method("SpMat", static_cast<mfem::SparseMatrix & (mfem::BilinearForm::*)() >(&mfem::BilinearForm::SpMat));

    DEBUG_MSG("Adding wrapper for bool mfem::BilinearForm::HasSpMat() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::BilinearForm::HasSpMat()
    // defined in mfem/fem/bilinearform.hpp:348:9
    t.method("HasSpMat", static_cast<bool (mfem::BilinearForm::*)() >(&mfem::BilinearForm::HasSpMat));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::BilinearForm::LoseMat() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::BilinearForm::LoseMat()
    // defined in mfem/fem/bilinearform.hpp:356:18
    t.method("LoseMat", static_cast<mfem::SparseMatrix * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::LoseMat));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix & mfem::BilinearForm::SpMatElim() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix & mfem::BilinearForm::SpMatElim()
    // defined in mfem/fem/bilinearform.hpp:362:24
    t.method("SpMatElim", static_cast<const mfem::SparseMatrix & (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::SpMatElim));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::BilinearForm::SpMatElim() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::BilinearForm::SpMatElim()
    // defined in mfem/fem/bilinearform.hpp:372:18
    t.method("SpMatElim", static_cast<mfem::SparseMatrix & (mfem::BilinearForm::*)() >(&mfem::BilinearForm::SpMatElim));

    DEBUG_MSG("Adding wrapper for bool mfem::BilinearForm::HasSpMatElim() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::BilinearForm::HasSpMatElim()
    // defined in mfem/fem/bilinearform.hpp:382:9
    t.method("HasSpMatElim", static_cast<bool (mfem::BilinearForm::*)() >(&mfem::BilinearForm::HasSpMatElim));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *)
    // defined in mfem/fem/bilinearform.hpp:388:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::BilinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *)
    // defined in mfem/fem/bilinearform.hpp:395:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::BilinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddInteriorFaceIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddInteriorFaceIntegrator(mfem::BilinearFormIntegrator *)
    // defined in mfem/fem/bilinearform.hpp:406:9
    t.method("AddInteriorFaceIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::BilinearForm::AddInteriorFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddBdrFaceIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddBdrFaceIntegrator(mfem::BilinearFormIntegrator *)
    // defined in mfem/fem/bilinearform.hpp:409:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::BilinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::operator=(const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::operator=(const double)
    // defined in mfem/fem/bilinearform.hpp:420:9
    t.method("assign", static_cast<void (mfem::BilinearForm::*)(const double) >(&mfem::BilinearForm::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::Assemble(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::Assemble(int)
    // defined in mfem/fem/bilinearform.hpp:427:9
    t.method("Assemble", static_cast<void (mfem::BilinearForm::*)(int) >(&mfem::BilinearForm::Assemble));
    t.method("Assemble", [](mfem::BilinearForm& a)->void{ a.Assemble(); });
    t.method("Assemble", [](mfem::BilinearForm* a)->void{ a->Assemble(); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AssembleDiagonal(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AssembleDiagonal(mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:438:17
    t.method("AssembleDiagonal", static_cast<void (mfem::BilinearForm::*)(mfem::Vector &)  const>(&mfem::BilinearForm::AssembleDiagonal));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetProlongation()
    // defined in mfem/fem/bilinearform.hpp:441:28
    t.method("GetProlongation", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetRestriction()
    // defined in mfem/fem/bilinearform.hpp:444:28
    t.method("GetRestriction", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetOutputProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetOutputProlongation()
    // defined in mfem/fem/bilinearform.hpp:447:28
    t.method("GetOutputProlongation", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetOutputProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetOutputRestrictionTranspose() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetOutputRestrictionTranspose()
    // defined in mfem/fem/bilinearform.hpp:454:28
    t.method("GetOutputRestrictionTranspose", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetOutputRestrictionTranspose));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetOutputRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetOutputRestriction()
    // defined in mfem/fem/bilinearform.hpp:457:28
    t.method("GetOutputRestriction", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetOutputRestriction));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::SerialRAP(mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::SerialRAP(mfem::OperatorHandle &)
    // defined in mfem/fem/bilinearform.hpp:461:9
    t.method("SerialRAP", static_cast<void (mfem::BilinearForm::*)(mfem::OperatorHandle &) >(&mfem::BilinearForm::SerialRAP));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::RecoverFEMSolution(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::RecoverFEMSolution(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:542:17
    t.method("RecoverFEMSolution", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) >(&mfem::BilinearForm::RecoverFEMSolution));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::ComputeElementMatrices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::ComputeElementMatrices()
    // defined in mfem/fem/bilinearform.hpp:545:9
    t.method("ComputeElementMatrices", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::ComputeElementMatrices));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FreeElementMatrices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FreeElementMatrices()
    // defined in mfem/fem/bilinearform.hpp:548:9
    t.method("FreeElementMatrices", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::FreeElementMatrices));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::ComputeElementMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::ComputeElementMatrix(int, mfem::DenseMatrix &)
    // defined in mfem/fem/bilinearform.hpp:556:9
    t.method("ComputeElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, mfem::DenseMatrix &) >(&mfem::BilinearForm::ComputeElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::ComputeBdrElementMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::ComputeBdrElementMatrix(int, mfem::DenseMatrix &)
    // defined in mfem/fem/bilinearform.hpp:559:9
    t.method("ComputeBdrElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, mfem::DenseMatrix &) >(&mfem::BilinearForm::ComputeBdrElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, int)
    // defined in mfem/fem/bilinearform.hpp:567:9
    t.method("AssembleElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, const mfem::DenseMatrix &, int) >(&mfem::BilinearForm::AssembleElementMatrix));
    t.method("AssembleElementMatrix", [](mfem::BilinearForm& a, int arg0, const mfem::DenseMatrix & arg1)->void{ a.AssembleElementMatrix(arg0, arg1); });
    t.method("AssembleElementMatrix", [](mfem::BilinearForm* a, int arg0, const mfem::DenseMatrix & arg1)->void{ a->AssembleElementMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, int)
    // defined in mfem/fem/bilinearform.hpp:585:9
    t.method("AssembleBdrElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, const mfem::DenseMatrix &, int) >(&mfem::BilinearForm::AssembleBdrElementMatrix));
    t.method("AssembleBdrElementMatrix", [](mfem::BilinearForm& a, int arg0, const mfem::DenseMatrix & arg1)->void{ a.AssembleBdrElementMatrix(arg0, arg1); });
    t.method("AssembleBdrElementMatrix", [](mfem::BilinearForm* a, int arg0, const mfem::DenseMatrix & arg1)->void{ a->AssembleBdrElementMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for double mfem::BilinearForm::FullInnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::BilinearForm::FullInnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:649:11
    t.method("FullInnerProduct", static_cast<double (mfem::BilinearForm::*)(const mfem::Vector &, const mfem::Vector &)  const>(&mfem::BilinearForm::FullInnerProduct));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::Update(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::Update(mfem::FiniteElementSpace *)
    // defined in mfem/fem/bilinearform.hpp:653:17
    t.method("Update", static_cast<void (mfem::BilinearForm::*)(mfem::FiniteElementSpace *) >(&mfem::BilinearForm::Update));
    t.method("Update", [](mfem::BilinearForm& a)->void{ a.Update(); });
    t.method("Update", [](mfem::BilinearForm* a)->void{ a->Update(); });

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::BilinearForm::GetFES() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::BilinearForm::GetFES()
    // defined in mfem/fem/bilinearform.hpp:657:40
    t.method("GetFES", static_cast<mfem::FiniteElementSpace * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetFES));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::BilinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::BilinearForm::FESpace()
    // defined in mfem/fem/bilinearform.hpp:660:24
    t.method("FESpace", static_cast<mfem::FiniteElementSpace * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::BilinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::BilinearForm::FESpace()
    // defined in mfem/fem/bilinearform.hpp:662:30
    t.method("FESpace", static_cast<const mfem::FiniteElementSpace * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::SetDiagonalPolicy(mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::SetDiagonalPolicy(mfem::Operator::DiagonalPolicy)
    // defined in mfem/fem/bilinearform.hpp:671:9
    t.method("SetDiagonalPolicy", static_cast<void (mfem::BilinearForm::*)(mfem::Operator::DiagonalPolicy) >(&mfem::BilinearForm::SetDiagonalPolicy));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::UseExternalIntegrators() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::UseExternalIntegrators()
    // defined in mfem/fem/bilinearform.hpp:674:9
    t.method("UseExternalIntegrators", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::UseExternalIntegrators));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearForm>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BilinearForm(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BilinearForm(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OperatorChebyshevSmoother> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OperatorChebyshevSmoother> : std::false_type { };
template<> struct SuperType<mfem::OperatorChebyshevSmoother> { typedef mfem::Solver type; };
}

struct Jlmfem_OperatorChebyshevSmoother: public Wrapper {

  Jlmfem_OperatorChebyshevSmoother(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OperatorChebyshevSmoother (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:379:7
    jlcxx::TypeWrapper<mfem::OperatorChebyshevSmoother>  t = jlModule.add_type<mfem::OperatorChebyshevSmoother>("mfem!OperatorChebyshevSmoother"    , jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorChebyshevSmoother>>(new jlcxx::TypeWrapper<mfem::OperatorChebyshevSmoother>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorChebyshevSmoother::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:435:9
    t.method("Mult", static_cast<void (mfem::OperatorChebyshevSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorChebyshevSmoother::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorChebyshevSmoother::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:437:9
    t.method("MultTranspose", static_cast<void (mfem::OperatorChebyshevSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorChebyshevSmoother::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorChebyshevSmoother::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:439:9
    t.method("SetOperator", static_cast<void (mfem::OperatorChebyshevSmoother::*)(const mfem::Operator &) >(&mfem::OperatorChebyshevSmoother::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::Setup() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorChebyshevSmoother::Setup()
    // defined in mfem/linalg/solvers.hpp:444:9
    t.method("Setup", static_cast<void (mfem::OperatorChebyshevSmoother::*)() >(&mfem::OperatorChebyshevSmoother::Setup));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorChebyshevSmoother>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OperatorChebyshevSmoother(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OperatorChebyshevSmoother(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SLISolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SLISolver> : std::false_type { };
template<> struct SuperType<mfem::SLISolver> { typedef mfem::IterativeSolver type; };
}

struct Jlmfem_SLISolver: public Wrapper {

  Jlmfem_SLISolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SLISolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:461:7
    jlcxx::TypeWrapper<mfem::SLISolver>  t = jlModule.add_type<mfem::SLISolver>("mfem!SLISolver"    , jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SLISolver>>(new jlcxx::TypeWrapper<mfem::SLISolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::SLISolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLISolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:475:17
    t.method("SetOperator", static_cast<void (mfem::SLISolver::*)(const mfem::Operator &) >(&mfem::SLISolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::SLISolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLISolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:478:17
    t.method("Mult", static_cast<void (mfem::SLISolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SLISolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SLISolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SLISolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SLISolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CGSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CGSolver> : std::false_type { };
template<> struct SuperType<mfem::CGSolver> { typedef mfem::IterativeSolver type; };
}

struct Jlmfem_CGSolver: public Wrapper {

  Jlmfem_CGSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CGSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:493:7
    jlcxx::TypeWrapper<mfem::CGSolver>  t = jlModule.add_type<mfem::CGSolver>("mfem!CGSolver"    , jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CGSolver>>(new jlcxx::TypeWrapper<mfem::CGSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::CGSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CGSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:507:17
    t.method("SetOperator", static_cast<void (mfem::CGSolver::*)(const mfem::Operator &) >(&mfem::CGSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::CGSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CGSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:510:17
    t.method("Mult", static_cast<void (mfem::CGSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::CGSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CGSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CGSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CGSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GMRESSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GMRESSolver> : std::false_type { };
template<> struct SuperType<mfem::GMRESSolver> { typedef mfem::IterativeSolver type; };
}

struct Jlmfem_GMRESSolver: public Wrapper {

  Jlmfem_GMRESSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GMRESSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:525:7
    jlcxx::TypeWrapper<mfem::GMRESSolver>  t = jlModule.add_type<mfem::GMRESSolver>("mfem!GMRESSolver"    , jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GMRESSolver>>(new jlcxx::TypeWrapper<mfem::GMRESSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::GMRESSolver::SetKDim(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GMRESSolver::SetKDim(int)
    // defined in mfem/linalg/solvers.hpp:538:9
    t.method("SetKDim", static_cast<void (mfem::GMRESSolver::*)(int) >(&mfem::GMRESSolver::SetKDim));

    DEBUG_MSG("Adding wrapper for void mfem::GMRESSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GMRESSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:540:17
    t.method("Mult", static_cast<void (mfem::GMRESSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::GMRESSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GMRESSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GMRESSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GMRESSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FGMRESSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FGMRESSolver> : std::false_type { };
template<> struct SuperType<mfem::FGMRESSolver> { typedef mfem::IterativeSolver type; };
}

struct Jlmfem_FGMRESSolver: public Wrapper {

  Jlmfem_FGMRESSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FGMRESSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:544:7
    jlcxx::TypeWrapper<mfem::FGMRESSolver>  t = jlModule.add_type<mfem::FGMRESSolver>("mfem!FGMRESSolver"    , jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FGMRESSolver>>(new jlcxx::TypeWrapper<mfem::FGMRESSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::FGMRESSolver::SetKDim(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FGMRESSolver::SetKDim(int)
    // defined in mfem/linalg/solvers.hpp:556:9
    t.method("SetKDim", static_cast<void (mfem::FGMRESSolver::*)(int) >(&mfem::FGMRESSolver::SetKDim));

    DEBUG_MSG("Adding wrapper for void mfem::FGMRESSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FGMRESSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:558:17
    t.method("Mult", static_cast<void (mfem::FGMRESSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::FGMRESSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FGMRESSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FGMRESSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FGMRESSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BiCGSTABSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BiCGSTABSolver> : std::false_type { };
template<> struct SuperType<mfem::BiCGSTABSolver> { typedef mfem::IterativeSolver type; };
}

struct Jlmfem_BiCGSTABSolver: public Wrapper {

  Jlmfem_BiCGSTABSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BiCGSTABSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:572:7
    jlcxx::TypeWrapper<mfem::BiCGSTABSolver>  t = jlModule.add_type<mfem::BiCGSTABSolver>("mfem!BiCGSTABSolver"    , jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BiCGSTABSolver>>(new jlcxx::TypeWrapper<mfem::BiCGSTABSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::BiCGSTABSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BiCGSTABSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:586:17
    t.method("SetOperator", static_cast<void (mfem::BiCGSTABSolver::*)(const mfem::Operator &) >(&mfem::BiCGSTABSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::BiCGSTABSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BiCGSTABSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:589:17
    t.method("Mult", static_cast<void (mfem::BiCGSTABSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BiCGSTABSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BiCGSTABSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BiCGSTABSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BiCGSTABSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MINRESSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MINRESSolver> : std::false_type { };
template<> struct SuperType<mfem::MINRESSolver> { typedef mfem::IterativeSolver type; };
}

struct Jlmfem_MINRESSolver: public Wrapper {

  Jlmfem_MINRESSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MINRESSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:603:7
    jlcxx::TypeWrapper<mfem::MINRESSolver>  t = jlModule.add_type<mfem::MINRESSolver>("mfem!MINRESSolver"    , jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MINRESSolver>>(new jlcxx::TypeWrapper<mfem::MINRESSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::MINRESSolver::SetPreconditioner(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRESSolver::SetPreconditioner(mfem::Solver &)
    // defined in mfem/linalg/solvers.hpp:616:17
    t.method("SetPreconditioner", static_cast<void (mfem::MINRESSolver::*)(mfem::Solver &) >(&mfem::MINRESSolver::SetPreconditioner));

    DEBUG_MSG("Adding wrapper for void mfem::MINRESSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRESSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:622:17
    t.method("SetOperator", static_cast<void (mfem::MINRESSolver::*)(const mfem::Operator &) >(&mfem::MINRESSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::MINRESSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRESSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:624:17
    t.method("Mult", static_cast<void (mfem::MINRESSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MINRESSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MINRESSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MINRESSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MINRESSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NewtonSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NewtonSolver> : std::false_type { };
template<> struct SuperType<mfem::NewtonSolver> { typedef mfem::IterativeSolver type; };
}

struct Jlmfem_NewtonSolver: public Wrapper {

  Jlmfem_NewtonSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NewtonSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:641:7
    jlcxx::TypeWrapper<mfem::NewtonSolver>  t = jlModule.add_type<mfem::NewtonSolver>("mfem!NewtonSolver"    , jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NewtonSolver>>(new jlcxx::TypeWrapper<mfem::NewtonSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:685:17
    t.method("SetOperator", static_cast<void (mfem::NewtonSolver::*)(const mfem::Operator &) >(&mfem::NewtonSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::SetSolver(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::SetSolver(mfem::Solver &)
    // defined in mfem/linalg/solvers.hpp:689:17
    t.method("SetSolver", static_cast<void (mfem::NewtonSolver::*)(mfem::Solver &) >(&mfem::NewtonSolver::SetSolver));

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:693:17
    t.method("Mult", static_cast<void (mfem::NewtonSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::NewtonSolver::Mult));

    DEBUG_MSG("Adding wrapper for double mfem::NewtonSolver::ComputeScalingFactor(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::NewtonSolver::ComputeScalingFactor(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:699:19
    t.method("ComputeScalingFactor", static_cast<double (mfem::NewtonSolver::*)(const mfem::Vector &, const mfem::Vector &)  const>(&mfem::NewtonSolver::ComputeScalingFactor));

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::ProcessNewState(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::ProcessNewState(const mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:704:17
    t.method("ProcessNewState", static_cast<void (mfem::NewtonSolver::*)(const mfem::Vector &)  const>(&mfem::NewtonSolver::ProcessNewState));

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::SetAdaptiveLinRtol(const int, const double, const double, const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::SetAdaptiveLinRtol(const int, const double, const double, const double, const double)
    // defined in mfem/linalg/solvers.hpp:717:9
    t.method("SetAdaptiveLinRtol", static_cast<void (mfem::NewtonSolver::*)(const int, const double, const double, const double, const double) >(&mfem::NewtonSolver::SetAdaptiveLinRtol));
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a)->void{ a.SetAdaptiveLinRtol(); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a, const int arg0)->void{ a.SetAdaptiveLinRtol(arg0); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a, const int arg0, const double arg1)->void{ a.SetAdaptiveLinRtol(arg0, arg1); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a, const int arg0, const double arg1, const double arg2)->void{ a.SetAdaptiveLinRtol(arg0, arg1, arg2); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a, const int arg0, const double arg1, const double arg2, const double arg3)->void{ a.SetAdaptiveLinRtol(arg0, arg1, arg2, arg3); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a)->void{ a->SetAdaptiveLinRtol(); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a, const int arg0)->void{ a->SetAdaptiveLinRtol(arg0); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a, const int arg0, const double arg1)->void{ a->SetAdaptiveLinRtol(arg0, arg1); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a, const int arg0, const double arg1, const double arg2)->void{ a->SetAdaptiveLinRtol(arg0, arg1, arg2); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a, const int arg0, const double arg1, const double arg2, const double arg3)->void{ a->SetAdaptiveLinRtol(arg0, arg1, arg2, arg3); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NewtonSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NewtonSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NewtonSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LBFGSSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LBFGSSolver> : std::false_type { };
template<> struct SuperType<mfem::LBFGSSolver> { typedef mfem::NewtonSolver type; };
}

struct Jlmfem_LBFGSSolver: public Wrapper {

  Jlmfem_LBFGSSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LBFGSSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:726:7
    jlcxx::TypeWrapper<mfem::LBFGSSolver>  t = jlModule.add_type<mfem::LBFGSSolver>("mfem!LBFGSSolver"    , jlcxx::julia_base_type<mfem::NewtonSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LBFGSSolver>>(new jlcxx::TypeWrapper<mfem::LBFGSSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:762:17
    t.method("SetOperator", static_cast<void (mfem::LBFGSSolver::*)(const mfem::Operator &) >(&mfem::LBFGSSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::SetHistorySize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::SetHistorySize(int)
    // defined in mfem/linalg/solvers.hpp:768:9
    t.method("SetHistorySize", static_cast<void (mfem::LBFGSSolver::*)(int) >(&mfem::LBFGSSolver::SetHistorySize));

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:776:17
    t.method("Mult", static_cast<void (mfem::LBFGSSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::LBFGSSolver::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::SetPreconditioner(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::SetPreconditioner(mfem::Solver &)
    // defined in mfem/linalg/solvers.hpp:778:17
    t.method("SetPreconditioner", static_cast<void (mfem::LBFGSSolver::*)(mfem::Solver &) >(&mfem::LBFGSSolver::SetPreconditioner));

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::SetSolver(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::SetSolver(mfem::Solver &)
    // defined in mfem/linalg/solvers.hpp:780:17
    t.method("SetSolver", static_cast<void (mfem::LBFGSSolver::*)(mfem::Solver &) >(&mfem::LBFGSSolver::SetSolver));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LBFGSSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LBFGSSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LBFGSSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OptimizationProblem> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OptimizationProblem> : std::false_type { };
}

struct Jlmfem_OptimizationProblem: public Wrapper {

  Jlmfem_OptimizationProblem(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OptimizationProblem (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:816:7
    jlcxx::TypeWrapper<mfem::OptimizationProblem>  t = jlModule.add_type<mfem::OptimizationProblem>("mfem!OptimizationProblem");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OptimizationProblem>>(new jlcxx::TypeWrapper<mfem::OptimizationProblem>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for double mfem::OptimizationProblem::CalcObjective(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::OptimizationProblem::CalcObjective(const mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:844:19
    t.method("CalcObjective", static_cast<double (mfem::OptimizationProblem::*)(const mfem::Vector &)  const>(&mfem::OptimizationProblem::CalcObjective));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationProblem::CalcObjectiveGrad(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationProblem::CalcObjectiveGrad(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:846:17
    t.method("CalcObjectiveGrad", static_cast<void (mfem::OptimizationProblem::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OptimizationProblem::CalcObjectiveGrad));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationProblem::SetEqualityConstraint(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationProblem::SetEqualityConstraint(const mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:849:9
    t.method("SetEqualityConstraint", static_cast<void (mfem::OptimizationProblem::*)(const mfem::Vector &) >(&mfem::OptimizationProblem::SetEqualityConstraint));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationProblem::SetInequalityConstraint(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationProblem::SetInequalityConstraint(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:850:9
    t.method("SetInequalityConstraint", static_cast<void (mfem::OptimizationProblem::*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::OptimizationProblem::SetInequalityConstraint));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationProblem::SetSolutionBounds(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationProblem::SetSolutionBounds(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:851:9
    t.method("SetSolutionBounds", static_cast<void (mfem::OptimizationProblem::*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::OptimizationProblem::SetSolutionBounds));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::OptimizationProblem::GetC() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::OptimizationProblem::GetC()
    // defined in mfem/linalg/solvers.hpp:853:20
    t.method("GetC", static_cast<const mfem::Operator * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetC));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::OptimizationProblem::GetD() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::OptimizationProblem::GetD()
    // defined in mfem/linalg/solvers.hpp:854:20
    t.method("GetD", static_cast<const mfem::Operator * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetD));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetEqualityVec() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetEqualityVec()
    // defined in mfem/linalg/solvers.hpp:855:18
    t.method("GetEqualityVec", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetEqualityVec));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetInequalityVec_Lo() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetInequalityVec_Lo()
    // defined in mfem/linalg/solvers.hpp:856:18
    t.method("GetInequalityVec_Lo", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetInequalityVec_Lo));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetInequalityVec_Hi() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetInequalityVec_Hi()
    // defined in mfem/linalg/solvers.hpp:857:18
    t.method("GetInequalityVec_Hi", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetInequalityVec_Hi));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetBoundsVec_Lo() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetBoundsVec_Lo()
    // defined in mfem/linalg/solvers.hpp:858:18
    t.method("GetBoundsVec_Lo", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetBoundsVec_Lo));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetBoundsVec_Hi() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetBoundsVec_Hi()
    // defined in mfem/linalg/solvers.hpp:859:18
    t.method("GetBoundsVec_Hi", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetBoundsVec_Hi));

    DEBUG_MSG("Adding wrapper for int mfem::OptimizationProblem::GetNumConstraints() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::OptimizationProblem::GetNumConstraints()
    // defined in mfem/linalg/solvers.hpp:861:8
    t.method("GetNumConstraints", static_cast<int (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetNumConstraints));

    DEBUG_MSG("Adding input_size methods  to provide read access to the field input_size (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:838:14
    // signature to use in the veto list: mfem::OptimizationProblem::input_size
    t.method("input_size", [](const mfem::OptimizationProblem& a) -> int { return a.input_size; });
    t.method("input_size", [](const mfem::OptimizationProblem* a) -> int { return a->input_size; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OptimizationProblem>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OptimizationProblem(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OptimizationProblem(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OptimizationSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OptimizationSolver> : std::false_type { };
template<> struct SuperType<mfem::OptimizationSolver> { typedef mfem::IterativeSolver type; };
}

struct Jlmfem_OptimizationSolver: public Wrapper {

  Jlmfem_OptimizationSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OptimizationSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:865:7
    jlcxx::TypeWrapper<mfem::OptimizationSolver>  t = jlModule.add_type<mfem::OptimizationSolver>("mfem!OptimizationSolver"    , jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OptimizationSolver>>(new jlcxx::TypeWrapper<mfem::OptimizationSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationSolver::SetOptimizationProblem(const mfem::OptimizationProblem &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationSolver::SetOptimizationProblem(const mfem::OptimizationProblem &)
    // defined in mfem/linalg/solvers.hpp:879:17
    t.method("SetOptimizationProblem", static_cast<void (mfem::OptimizationSolver::*)(const mfem::OptimizationProblem &) >(&mfem::OptimizationSolver::SetOptimizationProblem));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:882:17
    t.method("Mult", static_cast<void (mfem::OptimizationSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OptimizationSolver::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationSolver::SetPreconditioner(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationSolver::SetPreconditioner(mfem::Solver &)
    // defined in mfem/linalg/solvers.hpp:884:17
    t.method("SetPreconditioner", static_cast<void (mfem::OptimizationSolver::*)(mfem::Solver &) >(&mfem::OptimizationSolver::SetPreconditioner));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:886:17
    t.method("SetOperator", static_cast<void (mfem::OptimizationSolver::*)(const mfem::Operator &) >(&mfem::OptimizationSolver::SetOperator));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OptimizationSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OptimizationSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OptimizationSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SLBQPOptimizer> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SLBQPOptimizer> : std::false_type { };
template<> struct SuperType<mfem::SLBQPOptimizer> { typedef mfem::OptimizationSolver type; };
}

struct Jlmfem_SLBQPOptimizer: public Wrapper {

  Jlmfem_SLBQPOptimizer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SLBQPOptimizer (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:897:7
    jlcxx::TypeWrapper<mfem::SLBQPOptimizer>  t = jlModule.add_type<mfem::SLBQPOptimizer>("mfem!SLBQPOptimizer"    , jlcxx::julia_base_type<mfem::OptimizationSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SLBQPOptimizer>>(new jlcxx::TypeWrapper<mfem::SLBQPOptimizer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::SLBQPOptimizer::SetOptimizationProblem(const mfem::OptimizationProblem &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLBQPOptimizer::SetOptimizationProblem(const mfem::OptimizationProblem &)
    // defined in mfem/linalg/solvers.hpp:937:17
    t.method("SetOptimizationProblem", static_cast<void (mfem::SLBQPOptimizer::*)(const mfem::OptimizationProblem &) >(&mfem::SLBQPOptimizer::SetOptimizationProblem));

    DEBUG_MSG("Adding wrapper for void mfem::SLBQPOptimizer::SetBounds(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLBQPOptimizer::SetBounds(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:939:9
    t.method("SetBounds", static_cast<void (mfem::SLBQPOptimizer::*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::SLBQPOptimizer::SetBounds));

    DEBUG_MSG("Adding wrapper for void mfem::SLBQPOptimizer::SetLinearConstraint(const mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLBQPOptimizer::SetLinearConstraint(const mfem::Vector &, double)
    // defined in mfem/linalg/solvers.hpp:940:9
    t.method("SetLinearConstraint", static_cast<void (mfem::SLBQPOptimizer::*)(const mfem::Vector &, double) >(&mfem::SLBQPOptimizer::SetLinearConstraint));

    DEBUG_MSG("Adding wrapper for void mfem::SLBQPOptimizer::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLBQPOptimizer::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:944:17
    t.method("Mult", static_cast<void (mfem::SLBQPOptimizer::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SLBQPOptimizer::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SLBQPOptimizer>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SLBQPOptimizer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SLBQPOptimizer(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BlockILU> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BlockILU> : std::false_type { };
template<> struct SuperType<mfem::BlockILU> { typedef mfem::Solver type; };
}

struct Jlmfem_BlockILU: public Wrapper {

  Jlmfem_BlockILU(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BlockILU (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:963:7
    jlcxx::TypeWrapper<mfem::BlockILU>  t = jlModule.add_type<mfem::BlockILU>("mfem!BlockILU"    , jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BlockILU>>(new jlcxx::TypeWrapper<mfem::BlockILU>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BlockILU::BlockILU(int, mfem::BlockILU::Reordering, int) (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:977:4
    t.constructor<int>(/*finalize=*/true);
    t.constructor<int, mfem::BlockILU::Reordering>(/*finalize=*/true);
    t.constructor<int, mfem::BlockILU::Reordering, int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::BlockILU::BlockILU(const mfem::Operator &, int, mfem::BlockILU::Reordering, int) (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:986:4
    t.constructor<const mfem::Operator &>(/*finalize=*/true);
    t.constructor<const mfem::Operator &, int>(/*finalize=*/true);
    t.constructor<const mfem::Operator &, int, mfem::BlockILU::Reordering>(/*finalize=*/true);
    t.constructor<const mfem::Operator &, int, mfem::BlockILU::Reordering, int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::BlockILU::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockILU::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:994:9
    t.method("SetOperator", static_cast<void (mfem::BlockILU::*)(const mfem::Operator &) >(&mfem::BlockILU::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::BlockILU::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockILU::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:997:9
    t.method("Mult", static_cast<void (mfem::BlockILU::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BlockILU::Mult));

    DEBUG_MSG("Adding wrapper for int * mfem::BlockILU::GetBlockI() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::BlockILU::GetBlockI()
    // defined in mfem/linalg/solvers.hpp:1002:9
    t.method("GetBlockI", static_cast<int * (mfem::BlockILU::*)() >(&mfem::BlockILU::GetBlockI));

    DEBUG_MSG("Adding wrapper for int * mfem::BlockILU::GetBlockJ() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::BlockILU::GetBlockJ()
    // defined in mfem/linalg/solvers.hpp:1007:9
    t.method("GetBlockJ", static_cast<int * (mfem::BlockILU::*)() >(&mfem::BlockILU::GetBlockJ));

    DEBUG_MSG("Adding wrapper for double * mfem::BlockILU::GetBlockData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::BlockILU::GetBlockData()
    // defined in mfem/linalg/solvers.hpp:1012:12
    t.method("GetBlockData", static_cast<double * (mfem::BlockILU::*)() >(&mfem::BlockILU::GetBlockData));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BlockILU>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BlockILU(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BlockILU(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ResidualBCMonitor> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ResidualBCMonitor> : std::false_type { };
template<> struct SuperType<mfem::ResidualBCMonitor> { typedef mfem::IterativeSolverMonitor type; };
}

struct Jlmfem_ResidualBCMonitor: public Wrapper {

  Jlmfem_ResidualBCMonitor(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ResidualBCMonitor (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:1053:7
    jlcxx::TypeWrapper<mfem::ResidualBCMonitor>  t = jlModule.add_type<mfem::ResidualBCMonitor>("mfem!ResidualBCMonitor"    , jlcxx::julia_base_type<mfem::IterativeSolverMonitor>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ResidualBCMonitor>>(new jlcxx::TypeWrapper<mfem::ResidualBCMonitor>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::ResidualBCMonitor::MonitorResidual(int, double, const mfem::Vector &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ResidualBCMonitor::MonitorResidual(int, double, const mfem::Vector &, bool)
    // defined in mfem/linalg/solvers.hpp:1062:9
    t.method("MonitorResidual", static_cast<void (mfem::ResidualBCMonitor::*)(int, double, const mfem::Vector &, bool) >(&mfem::ResidualBCMonitor::MonitorResidual));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ResidualBCMonitor>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ResidualBCMonitor(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ResidualBCMonitor(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DirectSubBlockSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DirectSubBlockSolver> : std::false_type { };
template<> struct SuperType<mfem::DirectSubBlockSolver> { typedef mfem::Solver type; };
}

struct Jlmfem_DirectSubBlockSolver: public Wrapper {

  Jlmfem_DirectSubBlockSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DirectSubBlockSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:1142:7
    jlcxx::TypeWrapper<mfem::DirectSubBlockSolver>  t = jlModule.add_type<mfem::DirectSubBlockSolver>("mfem!DirectSubBlockSolver"    , jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DirectSubBlockSolver>>(new jlcxx::TypeWrapper<mfem::DirectSubBlockSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DirectSubBlockSolver::DirectSubBlockSolver(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:1152:4
    t.constructor<const mfem::SparseMatrix &, const mfem::SparseMatrix &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::DirectSubBlockSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DirectSubBlockSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:1153:17
    t.method("Mult", static_cast<void (mfem::DirectSubBlockSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DirectSubBlockSolver::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::DirectSubBlockSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DirectSubBlockSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:1154:17
    t.method("SetOperator", static_cast<void (mfem::DirectSubBlockSolver::*)(const mfem::Operator &) >(&mfem::DirectSubBlockSolver::SetOperator));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DirectSubBlockSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DirectSubBlockSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DirectSubBlockSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ProductSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ProductSolver> : std::false_type { };
template<> struct SuperType<mfem::ProductSolver> { typedef mfem::Solver type; };
}

struct Jlmfem_ProductSolver: public Wrapper {

  Jlmfem_ProductSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ProductSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:1159:7
    jlcxx::TypeWrapper<mfem::ProductSolver>  t = jlModule.add_type<mfem::ProductSolver>("mfem!ProductSolver"    , jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductSolver>>(new jlcxx::TypeWrapper<mfem::ProductSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ProductSolver::ProductSolver(mfem::Operator *, mfem::Solver *, mfem::Solver *, bool, bool, bool) (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:1165:4
    t.constructor<mfem::Operator *, mfem::Solver *, mfem::Solver *, bool, bool, bool>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::ProductSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:1168:17
    t.method("Mult", static_cast<void (mfem::ProductSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ProductSolver::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::ProductSolver::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductSolver::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:1169:17
    t.method("MultTranspose", static_cast<void (mfem::ProductSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ProductSolver::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::ProductSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:1170:17
    t.method("SetOperator", static_cast<void (mfem::ProductSolver::*)(const mfem::Operator &) >(&mfem::ProductSolver::SetOperator));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ProductSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ProductSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OrthoSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OrthoSolver> : std::false_type { };
template<> struct SuperType<mfem::OrthoSolver> { typedef mfem::Solver type; };
}

struct Jlmfem_OrthoSolver: public Wrapper {

  Jlmfem_OrthoSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OrthoSolver (" __HERE__ ")");
    // defined in mfem/linalg/solvers.hpp:1180:7
    jlcxx::TypeWrapper<mfem::OrthoSolver>  t = jlModule.add_type<mfem::OrthoSolver>("mfem!OrthoSolver"    , jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OrthoSolver>>(new jlcxx::TypeWrapper<mfem::OrthoSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::OrthoSolver::SetSolver(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OrthoSolver::SetSolver(mfem::Solver &)
    // defined in mfem/linalg/solvers.hpp:1201:9
    t.method("SetSolver", static_cast<void (mfem::OrthoSolver::*)(mfem::Solver &) >(&mfem::OrthoSolver::SetSolver));

    DEBUG_MSG("Adding wrapper for void mfem::OrthoSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OrthoSolver::SetOperator(const mfem::Operator &)
    // defined in mfem/linalg/solvers.hpp:1207:17
    t.method("SetOperator", static_cast<void (mfem::OrthoSolver::*)(const mfem::Operator &) >(&mfem::OrthoSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::OrthoSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OrthoSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/solvers.hpp:1214:9
    t.method("Mult", static_cast<void (mfem::OrthoSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OrthoSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OrthoSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OrthoSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OrthoSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IntegrationPoint> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IntegrationPoint> : std::false_type { };
}

struct Jlmfem_IntegrationPoint: public Wrapper {

  Jlmfem_IntegrationPoint(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IntegrationPoint (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:31:7
    jlcxx::TypeWrapper<mfem::IntegrationPoint>  t = jlModule.add_type<mfem::IntegrationPoint>("mfem!IntegrationPoint");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationPoint>>(new jlcxx::TypeWrapper<mfem::IntegrationPoint>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Init(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Init(const int)
    // defined in mfem/fem/intrules.hpp:37:9
    t.method("Init", static_cast<void (mfem::IntegrationPoint::*)(const int) >(&mfem::IntegrationPoint::Init));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set(const double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set(const double *, const int)
    // defined in mfem/fem/intrules.hpp:43:9
    t.method("Set", static_cast<void (mfem::IntegrationPoint::*)(const double *, const int) >(&mfem::IntegrationPoint::Set));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Get(double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Get(double *, const int)
    // defined in mfem/fem/intrules.hpp:57:9
    t.method("Get", static_cast<void (mfem::IntegrationPoint::*)(double *, const int)  const>(&mfem::IntegrationPoint::Get));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set(const double, const double, const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set(const double, const double, const double, const double)
    // defined in mfem/fem/intrules.hpp:71:9
    t.method("Set", static_cast<void (mfem::IntegrationPoint::*)(const double, const double, const double, const double) >(&mfem::IntegrationPoint::Set));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set3w(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set3w(const double *)
    // defined in mfem/fem/intrules.hpp:74:9
    t.method("Set3w", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set3w));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set3(const double, const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set3(const double, const double, const double)
    // defined in mfem/fem/intrules.hpp:76:9
    t.method("Set3", static_cast<void (mfem::IntegrationPoint::*)(const double, const double, const double) >(&mfem::IntegrationPoint::Set3));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set3(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set3(const double *)
    // defined in mfem/fem/intrules.hpp:79:9
    t.method("Set3", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set3));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set2w(const double, const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set2w(const double, const double, const double)
    // defined in mfem/fem/intrules.hpp:81:9
    t.method("Set2w", static_cast<void (mfem::IntegrationPoint::*)(const double, const double, const double) >(&mfem::IntegrationPoint::Set2w));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set2w(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set2w(const double *)
    // defined in mfem/fem/intrules.hpp:84:9
    t.method("Set2w", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set2w));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set2(const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set2(const double, const double)
    // defined in mfem/fem/intrules.hpp:86:9
    t.method("Set2", static_cast<void (mfem::IntegrationPoint::*)(const double, const double) >(&mfem::IntegrationPoint::Set2));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set2(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set2(const double *)
    // defined in mfem/fem/intrules.hpp:88:9
    t.method("Set2", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set2));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set1w(const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set1w(const double, const double)
    // defined in mfem/fem/intrules.hpp:90:9
    t.method("Set1w", static_cast<void (mfem::IntegrationPoint::*)(const double, const double) >(&mfem::IntegrationPoint::Set1w));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set1w(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set1w(const double *)
    // defined in mfem/fem/intrules.hpp:92:9
    t.method("Set1w", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set1w));

    DEBUG_MSG("Adding x methods  to provide read access to the field x (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:34:11
    // signature to use in the veto list: mfem::IntegrationPoint::x
    t.method("x", [](const mfem::IntegrationPoint& a) -> double { return a.x; });
    t.method("x", [](mfem::IntegrationPoint& a) -> double { return a.x; });
    t.method("x", [](const mfem::IntegrationPoint* a) -> double { return a->x; });
    t.method("x", [](mfem::IntegrationPoint* a) -> double { return a->x; });
    // defined in mfem/fem/intrules.hpp:34:11
    // signature to use in the veto list: mfem::IntegrationPoint::x
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding x! methods to provide write access to the field x (" __HERE__ ")");
    t.method("x!", [](mfem::IntegrationPoint& a, double val) -> double { return a.x = val; });

    DEBUG_MSG("Adding x! methods to provide write access to the field x (" __HERE__ ")");
    t.method("x!", [](mfem::IntegrationPoint* a, double val) -> double { return a->x = val; });

    DEBUG_MSG("Adding y methods  to provide read access to the field y (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:34:14
    // signature to use in the veto list: mfem::IntegrationPoint::y
    t.method("y", [](const mfem::IntegrationPoint& a) -> double { return a.y; });
    t.method("y", [](mfem::IntegrationPoint& a) -> double { return a.y; });
    t.method("y", [](const mfem::IntegrationPoint* a) -> double { return a->y; });
    t.method("y", [](mfem::IntegrationPoint* a) -> double { return a->y; });
    // defined in mfem/fem/intrules.hpp:34:14
    // signature to use in the veto list: mfem::IntegrationPoint::y
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding y! methods to provide write access to the field y (" __HERE__ ")");
    t.method("y!", [](mfem::IntegrationPoint& a, double val) -> double { return a.y = val; });

    DEBUG_MSG("Adding y! methods to provide write access to the field y (" __HERE__ ")");
    t.method("y!", [](mfem::IntegrationPoint* a, double val) -> double { return a->y = val; });

    DEBUG_MSG("Adding z methods  to provide read access to the field z (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:34:17
    // signature to use in the veto list: mfem::IntegrationPoint::z
    t.method("z", [](const mfem::IntegrationPoint& a) -> double { return a.z; });
    t.method("z", [](mfem::IntegrationPoint& a) -> double { return a.z; });
    t.method("z", [](const mfem::IntegrationPoint* a) -> double { return a->z; });
    t.method("z", [](mfem::IntegrationPoint* a) -> double { return a->z; });
    // defined in mfem/fem/intrules.hpp:34:17
    // signature to use in the veto list: mfem::IntegrationPoint::z
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding z! methods to provide write access to the field z (" __HERE__ ")");
    t.method("z!", [](mfem::IntegrationPoint& a, double val) -> double { return a.z = val; });

    DEBUG_MSG("Adding z! methods to provide write access to the field z (" __HERE__ ")");
    t.method("z!", [](mfem::IntegrationPoint* a, double val) -> double { return a->z = val; });

    DEBUG_MSG("Adding weight methods  to provide read access to the field weight (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:34:20
    // signature to use in the veto list: mfem::IntegrationPoint::weight
    t.method("weight", [](const mfem::IntegrationPoint& a) -> double { return a.weight; });
    t.method("weight", [](mfem::IntegrationPoint& a) -> double { return a.weight; });
    t.method("weight", [](const mfem::IntegrationPoint* a) -> double { return a->weight; });
    t.method("weight", [](mfem::IntegrationPoint* a) -> double { return a->weight; });
    // defined in mfem/fem/intrules.hpp:34:20
    // signature to use in the veto list: mfem::IntegrationPoint::weight
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding weight! methods to provide write access to the field weight (" __HERE__ ")");
    t.method("weight!", [](mfem::IntegrationPoint& a, double val) -> double { return a.weight = val; });

    DEBUG_MSG("Adding weight! methods to provide write access to the field weight (" __HERE__ ")");
    t.method("weight!", [](mfem::IntegrationPoint* a, double val) -> double { return a->weight = val; });

    DEBUG_MSG("Adding index methods  to provide read access to the field index (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:35:8
    // signature to use in the veto list: mfem::IntegrationPoint::index
    t.method("index", [](const mfem::IntegrationPoint& a) -> int { return a.index; });
    t.method("index", [](mfem::IntegrationPoint& a) -> int { return a.index; });
    t.method("index", [](const mfem::IntegrationPoint* a) -> int { return a->index; });
    t.method("index", [](mfem::IntegrationPoint* a) -> int { return a->index; });
    // defined in mfem/fem/intrules.hpp:35:8
    // signature to use in the veto list: mfem::IntegrationPoint::index
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding index! methods to provide write access to the field index (" __HERE__ ")");
    t.method("index!", [](mfem::IntegrationPoint& a, int val) -> int { return a.index = val; });

    DEBUG_MSG("Adding index! methods to provide write access to the field index (" __HERE__ ")");
    t.method("index!", [](mfem::IntegrationPoint* a, int val) -> int { return a->index = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationPoint>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IntegrationPoint(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IntegrationPoint(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IntegrationRule> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IntegrationRule> : std::false_type { };
}

struct Jlmfem_IntegrationRule: public Wrapper {

  Jlmfem_IntegrationRule(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IntegrationRule (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:96:7
    jlcxx::TypeWrapper<mfem::IntegrationRule>  t = jlModule.add_type<mfem::IntegrationRule>("mfem!IntegrationRule");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRule>>(new jlcxx::TypeWrapper<mfem::IntegrationRule>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::IntegrationRule(int) (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:224:13
    t.constructor<int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::SetPointIndices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationRule::SetPointIndices()
    // defined in mfem/fem/intrules.hpp:236:9
    t.method("SetPointIndices", static_cast<void (mfem::IntegrationRule::*)() >(&mfem::IntegrationRule::SetPointIndices));


    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::IntegrationRule(mfem::IntegrationRule &, mfem::IntegrationRule &) (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:239:4
    t.constructor<mfem::IntegrationRule &, mfem::IntegrationRule &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::IntegrationRule(mfem::IntegrationRule &, mfem::IntegrationRule &, mfem::IntegrationRule &) (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:242:4
    t.constructor<mfem::IntegrationRule &, mfem::IntegrationRule &, mfem::IntegrationRule &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for int mfem::IntegrationRule::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::IntegrationRule::GetOrder()
    // defined in mfem/fem/intrules.hpp:246:8
    t.method("GetOrder", static_cast<int (mfem::IntegrationRule::*)()  const>(&mfem::IntegrationRule::GetOrder));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::SetOrder(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationRule::SetOrder(const int)
    // defined in mfem/fem/intrules.hpp:250:9
    t.method("SetOrder", static_cast<void (mfem::IntegrationRule::*)(const int) >(&mfem::IntegrationRule::SetOrder));

    DEBUG_MSG("Adding wrapper for int mfem::IntegrationRule::GetNPoints() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::IntegrationRule::GetNPoints()
    // defined in mfem/fem/intrules.hpp:253:8
    t.method("GetNPoints", static_cast<int (mfem::IntegrationRule::*)()  const>(&mfem::IntegrationRule::GetNPoints));

    DEBUG_MSG("Adding wrapper for mfem::IntegrationPoint & mfem::IntegrationRule::IntPoint(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::IntegrationPoint & mfem::IntegrationRule::IntPoint(int)
    // defined in mfem/fem/intrules.hpp:256:22
    t.method("IntPoint", static_cast<mfem::IntegrationPoint & (mfem::IntegrationRule::*)(int) >(&mfem::IntegrationRule::IntPoint));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationPoint & mfem::IntegrationRule::IntPoint(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationPoint & mfem::IntegrationRule::IntPoint(int)
    // defined in mfem/fem/intrules.hpp:259:28
    t.method("IntPoint", static_cast<const mfem::IntegrationPoint & (mfem::IntegrationRule::*)(int)  const>(&mfem::IntegrationRule::IntPoint));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRule>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IntegrationRule(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IntegrationRule(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSMeshRules> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSMeshRules> : std::false_type { };
}

struct Jlmfem_NURBSMeshRules: public Wrapper {

  Jlmfem_NURBSMeshRules(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSMeshRules (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:275:7
    jlcxx::TypeWrapper<mfem::NURBSMeshRules>  t = jlModule.add_type<mfem::NURBSMeshRules>("mfem!NURBSMeshRules");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSMeshRules>>(new jlcxx::TypeWrapper<mfem::NURBSMeshRules>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::NURBSMeshRules(const int, const int) (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:279:4
    t.constructor<const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for std::size_t mfem::NURBSMeshRules::AddElementRule(mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: std::size_t mfem::NURBSMeshRules::AddElementRule(mfem::IntegrationRule *)
    // defined in mfem/fem/intrules.hpp:290:16
    t.method("AddElementRule", static_cast<std::size_t (mfem::NURBSMeshRules::*)(mfem::IntegrationRule *) >(&mfem::NURBSMeshRules::AddElementRule));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::SetElementRule(const std::size_t, const std::size_t) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSMeshRules::SetElementRule(const std::size_t, const std::size_t)
    // defined in mfem/fem/intrules.hpp:298:9
    t.method("SetElementRule", static_cast<void (mfem::NURBSMeshRules::*)(const std::size_t, const std::size_t) >(&mfem::NURBSMeshRules::SetElementRule));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule * mfem::NURBSMeshRules::GetPatchRule1D(const int, const int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule * mfem::NURBSMeshRules::GetPatchRule1D(const int, const int)
    // defined in mfem/fem/intrules.hpp:312:27
    t.method("GetPatchRule1D", static_cast<const mfem::IntegrationRule * (mfem::NURBSMeshRules::*)(const int, const int)  const>(&mfem::NURBSMeshRules::GetPatchRule1D));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::GetIntegrationPointFrom1D(const int, int, int, int, mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSMeshRules::GetIntegrationPointFrom1D(const int, int, int, int, mfem::IntegrationPoint &)
    // defined in mfem/fem/intrules.hpp:320:9
    t.method("GetIntegrationPointFrom1D", static_cast<void (mfem::NURBSMeshRules::*)(const int, int, int, int, mfem::IntegrationPoint &) >(&mfem::NURBSMeshRules::GetIntegrationPointFrom1D));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::Finalize(const mfem::Mesh &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSMeshRules::Finalize(const mfem::Mesh &)
    // defined in mfem/fem/intrules.hpp:325:9
    t.method("Finalize", static_cast<void (mfem::NURBSMeshRules::*)(const mfem::Mesh &) >(&mfem::NURBSMeshRules::Finalize));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSMeshRules::GetPointElement(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSMeshRules::GetPointElement(int, int, int, int)
    // defined in mfem/fem/intrules.hpp:331:8
    t.method("GetPointElement", static_cast<int (mfem::NURBSMeshRules::*)(int, int, int, int)  const>(&mfem::NURBSMeshRules::GetPointElement));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSMeshRules::GetDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSMeshRules::GetDim()
    // defined in mfem/fem/intrules.hpp:336:8
    t.method("GetDim", static_cast<int (mfem::NURBSMeshRules::*)()  const>(&mfem::NURBSMeshRules::GetDim));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSMeshRules>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSMeshRules(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSMeshRules(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh> : std::false_type { };
}

struct Jlmfem_Mesh: public Wrapper {

  Jlmfem_Mesh(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:52:7
    jlcxx::TypeWrapper<mfem::Mesh>  t = jlModule.add_type<mfem::Mesh>("mfem!Mesh");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh>>(new jlcxx::TypeWrapper<mfem::Mesh>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(const mfem::Mesh &, bool) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:601:13
    t.constructor<const mfem::Mesh &>(/*finalize=*/true);
    t.constructor<const mfem::Mesh &, bool>(/*finalize=*/true);




    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int, int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:622:4
    t.constructor<double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int>(/*finalize=*/true);
    t.constructor<double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int, int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, int, int, int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:637:4
    // TODO investigate these. They break incremental compilation somehow.
    // t.constructor<int, int, int>(/*finalize=*/true);
    // t.constructor<int, int, int, int>(/*finalize=*/true);
    t.constructor<int, int, int, int, int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(const std::string &, int, int, bool) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:646:13
    t.constructor<const std::string &>(/*finalize=*/true);
    t.constructor<const std::string &, int>(/*finalize=*/true);
    t.constructor<const std::string &, int, int>(/*finalize=*/true);
    t.constructor<const std::string &, int, int, bool>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(mfem::Mesh *[], int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:658:4
    t.constructor<mfem::Mesh *[], int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Swap(mfem::Mesh &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Swap(mfem::Mesh &, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:675:9
    t.method("Swap", static_cast<void (mfem::Mesh::*)(mfem::Mesh &, bool) >(&mfem::Mesh::Swap));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Clear()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:678:9
    t.method("Clear", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::Clear));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::LoadFromFile(const std::string &, int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::LoadFromFile(const std::string &, int, int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:700:16
    t.method("mfem!Mesh!LoadFromFile", static_cast<mfem::Mesh (*)(const std::string &, int, int, bool) >(&mfem::Mesh::LoadFromFile));
    t.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0)->mfem::Mesh{ return mfem::Mesh::LoadFromFile(arg0); });
    t.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0, int arg1)->mfem::Mesh{ return mfem::Mesh::LoadFromFile(arg0, arg1); });
    t.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0, int arg1, int arg2)->mfem::Mesh{ return mfem::Mesh::LoadFromFile(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian1D(int, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian1D(int, double)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:705:16
    t.method("mfem!Mesh!MakeCartesian1D", static_cast<mfem::Mesh (*)(int, double) >(&mfem::Mesh::MakeCartesian1D));
    t.method("mfem!Mesh!MakeCartesian1D", [](int arg0)->mfem::Mesh{ return mfem::Mesh::MakeCartesian1D(arg0); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian2D(int, int, mfem::Element::Type, bool, double, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian2D(int, int, mfem::Element::Type, bool, double, double, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:712:16
    t.method("mfem!Mesh!MakeCartesian2D", static_cast<mfem::Mesh (*)(int, int, mfem::Element::Type, bool, double, double, bool) >(&mfem::Mesh::MakeCartesian2D));
    t.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2)->mfem::Mesh{ return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2); });
    t.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3)->mfem::Mesh{ return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3); });
    t.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3, double arg4)->mfem::Mesh{ return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3, double arg4, double arg5)->mfem::Mesh{ return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian3D(int, int, int, mfem::Element::Type, double, double, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian3D(int, int, int, mfem::Element::Type, double, double, double, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:720:16
    t.method("mfem!Mesh!MakeCartesian3D", static_cast<mfem::Mesh (*)(int, int, int, mfem::Element::Type, double, double, double, bool) >(&mfem::Mesh::MakeCartesian3D));
    t.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3)->mfem::Mesh{ return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3); });
    t.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4)->mfem::Mesh{ return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4, double arg5)->mfem::Mesh{ return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4, double arg5, double arg6)->mfem::Mesh{ return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:736:16
    t.method("mfem!Mesh!MakeRefined", static_cast<mfem::Mesh (*)(mfem::Mesh &, int, int) >(&mfem::Mesh::MakeRefined));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeSimplicial(const mfem::Mesh &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeSimplicial(const mfem::Mesh &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:763:16
    t.method("mfem!Mesh!MakeSimplicial", static_cast<mfem::Mesh (*)(const mfem::Mesh &) >(&mfem::Mesh::MakeSimplicial));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::NewElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::NewElement(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:785:13
    t.method("NewElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::NewElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(double, double, double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(double, double, double)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:787:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(double, double, double) >(&mfem::Mesh::AddVertex));
    t.method("AddVertex", [](mfem::Mesh& a, double arg0)->int{ return a.AddVertex(arg0); });
    t.method("AddVertex", [](mfem::Mesh& a, double arg0, double arg1)->int{ return a.AddVertex(arg0, arg1); });
    t.method("AddVertex", [](mfem::Mesh* a, double arg0)->int{ return a->AddVertex(arg0); });
    t.method("AddVertex", [](mfem::Mesh* a, double arg0, double arg1)->int{ return a->AddVertex(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(const double *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(const double *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:788:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(const double *) >(&mfem::Mesh::AddVertex));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(const mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:789:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::AddVertex));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddVertexParents(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddVertexParents(int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:791:9
    t.method("AddVertexParents", static_cast<void (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddVertexParents));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddSegment(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddSegment(int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:793:8
    t.method("AddSegment", static_cast<int (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddSegment));
    t.method("AddSegment", [](mfem::Mesh& a, int arg0, int arg1)->int{ return a.AddSegment(arg0, arg1); });
    t.method("AddSegment", [](mfem::Mesh* a, int arg0, int arg1)->int{ return a->AddSegment(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddSegment(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddSegment(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:794:8
    t.method("AddSegment", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddSegment));
    t.method("AddSegment", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddSegment(arg0); });
    t.method("AddSegment", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddSegment(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTriangle(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTriangle(int, int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:796:8
    t.method("AddTriangle", static_cast<int (mfem::Mesh::*)(int, int, int, int) >(&mfem::Mesh::AddTriangle));
    t.method("AddTriangle", [](mfem::Mesh& a, int arg0, int arg1, int arg2)->int{ return a.AddTriangle(arg0, arg1, arg2); });
    t.method("AddTriangle", [](mfem::Mesh* a, int arg0, int arg1, int arg2)->int{ return a->AddTriangle(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTriangle(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTriangle(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:797:8
    t.method("AddTriangle", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTriangle));
    t.method("AddTriangle", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddTriangle(arg0); });
    t.method("AddTriangle", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddTriangle(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTri(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTri(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:798:8
    t.method("AddTri", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTri));
    t.method("AddTri", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddTri(arg0); });
    t.method("AddTri", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddTri(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddQuad(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddQuad(int, int, int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:800:8
    t.method("AddQuad", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddQuad));
    t.method("AddQuad", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int{ return a.AddQuad(arg0, arg1, arg2, arg3); });
    t.method("AddQuad", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int{ return a->AddQuad(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddQuad(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddQuad(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:801:8
    t.method("AddQuad", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddQuad));
    t.method("AddQuad", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddQuad(arg0); });
    t.method("AddQuad", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddQuad(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTet(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTet(int, int, int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:803:8
    t.method("AddTet", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddTet));
    t.method("AddTet", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int{ return a.AddTet(arg0, arg1, arg2, arg3); });
    t.method("AddTet", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int{ return a->AddTet(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTet(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTet(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:804:8
    t.method("AddTet", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTet));
    t.method("AddTet", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddTet(arg0); });
    t.method("AddTet", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddTet(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddWedge(int, int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddWedge(int, int, int, int, int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:806:8
    t.method("AddWedge", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int, int) >(&mfem::Mesh::AddWedge));
    t.method("AddWedge", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)->int{ return a.AddWedge(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("AddWedge", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)->int{ return a->AddWedge(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddWedge(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddWedge(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:807:8
    t.method("AddWedge", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddWedge));
    t.method("AddWedge", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddWedge(arg0); });
    t.method("AddWedge", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddWedge(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddPyramid(int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddPyramid(int, int, int, int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:809:8
    t.method("AddPyramid", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int) >(&mfem::Mesh::AddPyramid));
    t.method("AddPyramid", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4)->int{ return a.AddPyramid(arg0, arg1, arg2, arg3, arg4); });
    t.method("AddPyramid", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4)->int{ return a->AddPyramid(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddPyramid(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddPyramid(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:810:8
    t.method("AddPyramid", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddPyramid));
    t.method("AddPyramid", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddPyramid(arg0); });
    t.method("AddPyramid", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddPyramid(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddHex(int, int, int, int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddHex(int, int, int, int, int, int, int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:812:8
    t.method("AddHex", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int, int, int, int) >(&mfem::Mesh::AddHex));
    t.method("AddHex", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7)->int{ return a.AddHex(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });
    t.method("AddHex", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7)->int{ return a->AddHex(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddHex(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddHex(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:814:8
    t.method("AddHex", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHex));
    t.method("AddHex", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddHex(arg0); });
    t.method("AddHex", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddHex(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsTets(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsTets(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:815:9
    t.method("AddHexAsTets", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsTets));
    t.method("AddHexAsTets", [](mfem::Mesh& a, const int * arg0)->void{ a.AddHexAsTets(arg0); });
    t.method("AddHexAsTets", [](mfem::Mesh* a, const int * arg0)->void{ a->AddHexAsTets(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsWedges(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsWedges(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:816:9
    t.method("AddHexAsWedges", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsWedges));
    t.method("AddHexAsWedges", [](mfem::Mesh& a, const int * arg0)->void{ a.AddHexAsWedges(arg0); });
    t.method("AddHexAsWedges", [](mfem::Mesh* a, const int * arg0)->void{ a->AddHexAsWedges(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsPyramids(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsPyramids(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:817:9
    t.method("AddHexAsPyramids", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsPyramids));
    t.method("AddHexAsPyramids", [](mfem::Mesh& a, const int * arg0)->void{ a.AddHexAsPyramids(arg0); });
    t.method("AddHexAsPyramids", [](mfem::Mesh* a, const int * arg0)->void{ a->AddHexAsPyramids(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddElement(mfem::Element *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddElement(mfem::Element *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:821:8
    t.method("AddElement", static_cast<int (mfem::Mesh::*)(mfem::Element *) >(&mfem::Mesh::AddElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrElement(mfem::Element *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrElement(mfem::Element *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:824:8
    t.method("AddBdrElement", static_cast<int (mfem::Mesh::*)(mfem::Element *) >(&mfem::Mesh::AddBdrElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrSegment(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrSegment(int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:826:8
    t.method("AddBdrSegment", static_cast<int (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddBdrSegment));
    t.method("AddBdrSegment", [](mfem::Mesh& a, int arg0, int arg1)->int{ return a.AddBdrSegment(arg0, arg1); });
    t.method("AddBdrSegment", [](mfem::Mesh* a, int arg0, int arg1)->int{ return a->AddBdrSegment(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrSegment(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrSegment(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:827:8
    t.method("AddBdrSegment", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrSegment));
    t.method("AddBdrSegment", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddBdrSegment(arg0); });
    t.method("AddBdrSegment", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddBdrSegment(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrTriangle(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrTriangle(int, int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:829:8
    t.method("AddBdrTriangle", static_cast<int (mfem::Mesh::*)(int, int, int, int) >(&mfem::Mesh::AddBdrTriangle));
    t.method("AddBdrTriangle", [](mfem::Mesh& a, int arg0, int arg1, int arg2)->int{ return a.AddBdrTriangle(arg0, arg1, arg2); });
    t.method("AddBdrTriangle", [](mfem::Mesh* a, int arg0, int arg1, int arg2)->int{ return a->AddBdrTriangle(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrTriangle(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrTriangle(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:830:8
    t.method("AddBdrTriangle", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrTriangle));
    t.method("AddBdrTriangle", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddBdrTriangle(arg0); });
    t.method("AddBdrTriangle", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddBdrTriangle(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrQuad(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrQuad(int, int, int, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:832:8
    t.method("AddBdrQuad", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddBdrQuad));
    t.method("AddBdrQuad", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int{ return a.AddBdrQuad(arg0, arg1, arg2, arg3); });
    t.method("AddBdrQuad", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int{ return a->AddBdrQuad(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrQuad(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrQuad(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:833:8
    t.method("AddBdrQuad", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrQuad));
    t.method("AddBdrQuad", [](mfem::Mesh& a, const int * arg0)->int{ return a.AddBdrQuad(arg0); });
    t.method("AddBdrQuad", [](mfem::Mesh* a, const int * arg0)->int{ return a->AddBdrQuad(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddBdrQuadAsTriangles(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddBdrQuadAsTriangles(const int *, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:834:9
    t.method("AddBdrQuadAsTriangles", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrQuadAsTriangles));
    t.method("AddBdrQuadAsTriangles", [](mfem::Mesh& a, const int * arg0)->void{ a.AddBdrQuadAsTriangles(arg0); });
    t.method("AddBdrQuadAsTriangles", [](mfem::Mesh* a, const int * arg0)->void{ a->AddBdrQuadAsTriangles(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrPoint(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrPoint(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:836:8
    t.method("AddBdrPoint", static_cast<int (mfem::Mesh::*)(int, int) >(&mfem::Mesh::AddBdrPoint));
    t.method("AddBdrPoint", [](mfem::Mesh& a, int arg0)->int{ return a.AddBdrPoint(arg0); });
    t.method("AddBdrPoint", [](mfem::Mesh* a, int arg0)->int{ return a->AddBdrPoint(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GenerateBoundaryElements() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GenerateBoundaryElements()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:838:9
    t.method("GenerateBoundaryElements", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::GenerateBoundaryElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTriMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTriMesh(int, int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:840:9
    t.method("FinalizeTriMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeTriMesh));
    t.method("FinalizeTriMesh", [](mfem::Mesh& a)->void{ a.FinalizeTriMesh(); });
    t.method("FinalizeTriMesh", [](mfem::Mesh& a, int arg0)->void{ a.FinalizeTriMesh(arg0); });
    t.method("FinalizeTriMesh", [](mfem::Mesh& a, int arg0, int arg1)->void{ a.FinalizeTriMesh(arg0, arg1); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a)->void{ a->FinalizeTriMesh(); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a, int arg0)->void{ a->FinalizeTriMesh(arg0); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a, int arg0, int arg1)->void{ a->FinalizeTriMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeQuadMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeQuadMesh(int, int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:843:9
    t.method("FinalizeQuadMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeQuadMesh));
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a)->void{ a.FinalizeQuadMesh(); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a, int arg0)->void{ a.FinalizeQuadMesh(arg0); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a, int arg0, int arg1)->void{ a.FinalizeQuadMesh(arg0, arg1); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a)->void{ a->FinalizeQuadMesh(); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a, int arg0)->void{ a->FinalizeQuadMesh(arg0); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a, int arg0, int arg1)->void{ a->FinalizeQuadMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTetMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTetMesh(int, int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:846:9
    t.method("FinalizeTetMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeTetMesh));
    t.method("FinalizeTetMesh", [](mfem::Mesh& a)->void{ a.FinalizeTetMesh(); });
    t.method("FinalizeTetMesh", [](mfem::Mesh& a, int arg0)->void{ a.FinalizeTetMesh(arg0); });
    t.method("FinalizeTetMesh", [](mfem::Mesh& a, int arg0, int arg1)->void{ a.FinalizeTetMesh(arg0, arg1); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a)->void{ a->FinalizeTetMesh(); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a, int arg0)->void{ a->FinalizeTetMesh(arg0); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a, int arg0, int arg1)->void{ a->FinalizeTetMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeWedgeMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeWedgeMesh(int, int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:849:9
    t.method("FinalizeWedgeMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeWedgeMesh));
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a)->void{ a.FinalizeWedgeMesh(); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a, int arg0)->void{ a.FinalizeWedgeMesh(arg0); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a, int arg0, int arg1)->void{ a.FinalizeWedgeMesh(arg0, arg1); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a)->void{ a->FinalizeWedgeMesh(); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a, int arg0)->void{ a->FinalizeWedgeMesh(arg0); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a, int arg0, int arg1)->void{ a->FinalizeWedgeMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeHexMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeHexMesh(int, int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:852:9
    t.method("FinalizeHexMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeHexMesh));
    t.method("FinalizeHexMesh", [](mfem::Mesh& a)->void{ a.FinalizeHexMesh(); });
    t.method("FinalizeHexMesh", [](mfem::Mesh& a, int arg0)->void{ a.FinalizeHexMesh(arg0); });
    t.method("FinalizeHexMesh", [](mfem::Mesh& a, int arg0, int arg1)->void{ a.FinalizeHexMesh(arg0, arg1); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a)->void{ a->FinalizeHexMesh(); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a, int arg0)->void{ a->FinalizeHexMesh(arg0); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a, int arg0, int arg1)->void{ a->FinalizeHexMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeMesh(int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeMesh(int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:856:9
    t.method("FinalizeMesh", static_cast<void (mfem::Mesh::*)(int, bool) >(&mfem::Mesh::FinalizeMesh));
    t.method("FinalizeMesh", [](mfem::Mesh& a)->void{ a.FinalizeMesh(); });
    t.method("FinalizeMesh", [](mfem::Mesh& a, int arg0)->void{ a.FinalizeMesh(arg0); });
    t.method("FinalizeMesh", [](mfem::Mesh* a)->void{ a->FinalizeMesh(); });
    t.method("FinalizeMesh", [](mfem::Mesh* a, int arg0)->void{ a->FinalizeMesh(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTopology(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTopology(bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:872:9
    t.method("FinalizeTopology", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::FinalizeTopology));
    t.method("FinalizeTopology", [](mfem::Mesh& a)->void{ a.FinalizeTopology(); });
    t.method("FinalizeTopology", [](mfem::Mesh* a)->void{ a->FinalizeTopology(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Finalize(bool, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Finalize(bool, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:888:17
    t.method("Finalize", static_cast<void (mfem::Mesh::*)(bool, bool) >(&mfem::Mesh::Finalize));
    t.method("Finalize", [](mfem::Mesh& a)->void{ a.Finalize(); });
    t.method("Finalize", [](mfem::Mesh& a, bool arg0)->void{ a.Finalize(arg0); });
    t.method("Finalize", [](mfem::Mesh* a)->void{ a->Finalize(); });
    t.method("Finalize", [](mfem::Mesh* a, bool arg0)->void{ a->Finalize(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetAttributes() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetAttributes()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:896:17
    t.method("SetAttributes", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::SetAttributes));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::CheckElementOrientation(bool) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::CheckElementOrientation(bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:912:8
    t.method("CheckElementOrientation", static_cast<int (mfem::Mesh::*)(bool) >(&mfem::Mesh::CheckElementOrientation));
    t.method("CheckElementOrientation", [](mfem::Mesh& a)->int{ return a.CheckElementOrientation(); });
    t.method("CheckElementOrientation", [](mfem::Mesh* a)->int{ return a->CheckElementOrientation(); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::CheckBdrElementOrientation(bool) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::CheckBdrElementOrientation(bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:916:8
    t.method("CheckBdrElementOrientation", static_cast<int (mfem::Mesh::*)(bool) >(&mfem::Mesh::CheckBdrElementOrientation));
    t.method("CheckBdrElementOrientation", [](mfem::Mesh& a)->int{ return a.CheckBdrElementOrientation(); });
    t.method("CheckBdrElementOrientation", [](mfem::Mesh* a)->int{ return a->CheckBdrElementOrientation(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ReorientTetMesh() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ReorientTetMesh()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:926:33
    t.method("ReorientTetMesh", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::ReorientTetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RemoveUnusedVertices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RemoveUnusedVertices()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:929:9
    t.method("RemoveUnusedVertices", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::RemoveUnusedVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RemoveInternalBoundaries() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RemoveInternalBoundaries()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:933:9
    t.method("RemoveInternalBoundaries", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::RemoveInternalBoundaries));


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, int, mfem::Element::Type, bool, double, double, double, bool) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:985:4
    t.constructor<int, int, int, mfem::Element::Type>(/*finalize=*/true);
    t.constructor<int, int, int, mfem::Element::Type, bool>(/*finalize=*/true);
    t.constructor<int, int, int, mfem::Element::Type, bool, double>(/*finalize=*/true);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double>(/*finalize=*/true);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double, double>(/*finalize=*/true);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double, double, bool>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, mfem::Element::Type, bool, double, double, bool) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:995:4
    t.constructor<int, int, mfem::Element::Type>(/*finalize=*/true);
    t.constructor<int, int, mfem::Element::Type, bool>(/*finalize=*/true);
    t.constructor<int, int, mfem::Element::Type, bool, double>(/*finalize=*/true);
    t.constructor<int, int, mfem::Element::Type, bool, double, double>(/*finalize=*/true);
    t.constructor<int, int, mfem::Element::Type, bool, double, double, bool>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, double) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1004:13
    t.constructor<int>(/*finalize=*/true);
    t.constructor<int, double>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(mfem::Mesh *, int, int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1012:4
    t.constructor<mfem::Mesh *, int, int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::Dimension() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::Dimension()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1020:8
    t.method("Dimension", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::Dimension));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::SpaceDimension() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::SpaceDimension()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1023:8
    t.method("SpaceDimension", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::SpaceDimension));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::EulerNumber() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::EulerNumber()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1026:15
    t.method("EulerNumber", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::EulerNumber));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::EulerNumber2D() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::EulerNumber2D()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1029:15
    t.method("EulerNumber2D", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::EulerNumber2D));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::MeshGenerator() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::MeshGenerator()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1047:15
    t.method("MeshGenerator", static_cast<int (mfem::Mesh::*)() >(&mfem::Mesh::MeshGenerator));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::HasBoundaryElements() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::HasBoundaryElements()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1050:17
    t.method("HasBoundaryElements", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::HasBoundaryElements));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::HasGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::HasGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1054:9
    t.method("HasGeometry", static_cast<bool (mfem::Mesh::*)(mfem::Geometry::Type)  const>(&mfem::Mesh::HasGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumGeometries(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumGeometries(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1060:8
    t.method("GetNumGeometries", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetNumGeometries));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBoundingBox(mfem::Vector &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBoundingBox(mfem::Vector &, mfem::Vector &, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1070:9
    t.method("GetBoundingBox", static_cast<void (mfem::Mesh::*)(mfem::Vector &, mfem::Vector &, int) >(&mfem::Mesh::GetBoundingBox));
    t.method("GetBoundingBox", [](mfem::Mesh& a, mfem::Vector & arg0, mfem::Vector & arg1)->void{ a.GetBoundingBox(arg0, arg1); });
    t.method("GetBoundingBox", [](mfem::Mesh* a, mfem::Vector & arg0, mfem::Vector & arg1)->void{ a->GetBoundingBox(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetCharacteristics(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetCharacteristics(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1072:9
    t.method("GetCharacteristics", static_cast<void (mfem::Mesh::*)(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *) >(&mfem::Mesh::GetCharacteristics));
    t.method("GetCharacteristics", [](mfem::Mesh& a, double & arg0, double & arg1, double & arg2, double & arg3)->void{ a.GetCharacteristics(arg0, arg1, arg2, arg3); });
    t.method("GetCharacteristics", [](mfem::Mesh& a, double & arg0, double & arg1, double & arg2, double & arg3, mfem::Vector * arg4)->void{ a.GetCharacteristics(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetCharacteristics", [](mfem::Mesh* a, double & arg0, double & arg1, double & arg2, double & arg3)->void{ a->GetCharacteristics(arg0, arg1, arg2, arg3); });
    t.method("GetCharacteristics", [](mfem::Mesh* a, double & arg0, double & arg1, double & arg2, double & arg3, mfem::Vector * arg4)->void{ a->GetCharacteristics(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNV()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1083:15
    t.method("GetNV", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNV));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNE()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1086:15
    t.method("GetNE", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNE));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNBE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNBE()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1089:15
    t.method("GetNBE", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNBE));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNEdges() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNEdges()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1092:15
    t.method("GetNEdges", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNEdges));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNFaces() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNFaces()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1095:15
    t.method("GetNFaces", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNFaces));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumFaces() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumFaces()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1098:8
    t.method("GetNumFaces", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNumFaces));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumFacesWithGhost() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumFacesWithGhost()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1102:8
    t.method("GetNumFacesWithGhost", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNumFacesWithGhost));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNFbyType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNFbyType(mfem::FaceType)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1112:16
    t.method("GetNFbyType", static_cast<int (mfem::Mesh::*)(mfem::FaceType)  const>(&mfem::Mesh::GetNFbyType));

    DEBUG_MSG("Adding wrapper for long long mfem::Mesh::GetGlobalNE() (" __HERE__ ")");
    // signature to use in the veto list: long long mfem::Mesh::GetGlobalNE()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1115:14
    t.method("GetGlobalNE", static_cast<long long (mfem::Mesh::*)()  const>(&mfem::Mesh::GetGlobalNE));

    DEBUG_MSG("Adding wrapper for const double * mfem::Mesh::GetVertex(int) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Mesh::GetVertex(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1125:18
    t.method("GetVertex", static_cast<const double * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetVertex));

    DEBUG_MSG("Adding wrapper for double * mfem::Mesh::GetVertex(int) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Mesh::GetVertex(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1135:12
    t.method("GetVertex", static_cast<double * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetVertex));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetElement(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1143:19
    t.method("GetElement", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElement));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::GetElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::GetElement(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1150:13
    t.method("GetElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElement));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetBdrElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetBdrElement(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1158:19
    t.method("GetBdrElement", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElement));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::GetBdrElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::GetBdrElement(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1165:13
    t.method("GetBdrElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrElement));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetFace(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetFace(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1167:19
    t.method("GetFace", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFace));

    DEBUG_MSG("Adding wrapper for const mfem::Element *const * mfem::Mesh::GetElementsArray() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element *const * mfem::Mesh::GetElementsArray()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1174:26
    t.method("GetElementsArray", static_cast<const mfem::Element *const * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetElementsArray));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetAttribute(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1190:8
    t.method("GetAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetAttribute(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1193:9
    t.method("SetAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrAttribute(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1196:8
    t.method("GetBdrAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetBdrAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetBdrAttribute(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1199:9
    t.method("SetBdrAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetBdrAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetPatchAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetPatchAttribute(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1202:8
    t.method("GetPatchAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetPatchAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetPatchAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetPatchAttribute(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1205:9
    t.method("SetPatchAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetPatchAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetPatchBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetPatchBdrAttribute(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1208:8
    t.method("GetPatchBdrAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetPatchBdrAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetPatchBdrAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetPatchBdrAttribute(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1211:9
    t.method("SetPatchBdrAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetPatchBdrAttribute));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetElementType(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1214:18
    t.method("GetElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementType));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetBdrElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetBdrElementType(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1217:18
    t.method("GetBdrElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementType));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceGeometryType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceGeometryType(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1220:35
    t.method("GetFaceGeometryType", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceGeometryType));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetFaceElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetFaceElementType(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1223:19
    t.method("GetFaceElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceElementType));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceGeometry(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1226:19
    t.method("GetFaceGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetElementGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetElementGeometry(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1228:19
    t.method("GetElementGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetBdrElementGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetBdrElementGeometry(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1233:19
    t.method("GetBdrElementGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceBaseGeometry(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1239:35
    t.method("GetFaceBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceBaseGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetElementBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetElementBaseGeometry(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1242:19
    t.method("GetElementBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementBaseGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetBdrElementBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetBdrElementBaseGeometry(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1245:19
    t.method("GetBdrElementBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementBaseGeometry));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceIsInterior(int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceIsInterior(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1249:9
    t.method("FaceIsInterior", static_cast<bool (mfem::Mesh::*)(int)  const>(&mfem::Mesh::FaceIsInterior));

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementSize(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementSize(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1256:11
    t.method("GetElementSize", static_cast<double (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GetElementSize));
    t.method("GetElementSize", [](mfem::Mesh& a, int arg0)->double{ return a.GetElementSize(arg0); });
    t.method("GetElementSize", [](mfem::Mesh* a, int arg0)->double{ return a->GetElementSize(arg0); });

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementSize(int, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementSize(int, const mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1258:11
    t.method("GetElementSize", static_cast<double (mfem::Mesh::*)(int, const mfem::Vector &) >(&mfem::Mesh::GetElementSize));

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementVolume(int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementVolume(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1260:11
    t.method("GetElementVolume", static_cast<double (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElementVolume));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementCenter(int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementCenter(int, mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1262:9
    t.method("GetElementCenter", static_cast<void (mfem::Mesh::*)(int, mfem::Vector &) >(&mfem::Mesh::GetElementCenter));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementJacobian(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementJacobian(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1267:9
    t.method("GetElementJacobian", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *) >(&mfem::Mesh::GetElementJacobian));
    t.method("GetElementJacobian", [](mfem::Mesh& a, int arg0, mfem::DenseMatrix & arg1)->void{ a.GetElementJacobian(arg0, arg1); });
    t.method("GetElementJacobian", [](mfem::Mesh* a, int arg0, mfem::DenseMatrix & arg1)->void{ a->GetElementJacobian(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementFace(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementFace(int, int *, int *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1334:9
    t.method("GetBdrElementFace", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetBdrElementFace));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrElementEdgeIndex(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrElementEdgeIndex(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1339:8
    t.method("GetBdrElementEdgeIndex", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementEdgeIndex));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementAdjacentElement(int, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementAdjacentElement(int, int &, int &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1348:9
    t.method("GetBdrElementAdjacentElement", static_cast<void (mfem::Mesh::*)(int, int &, int &)  const>(&mfem::Mesh::GetBdrElementAdjacentElement));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementAdjacentElement2(int, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementAdjacentElement2(int, int &, int &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1359:9
    t.method("GetBdrElementAdjacentElement2", static_cast<void (mfem::Mesh::*)(int, int &, int &)  const>(&mfem::Mesh::GetBdrElementAdjacentElement2));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrFace(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrFace(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1362:8
    t.method("GetBdrFace", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrFace));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetVertexToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetVertexToElementTable()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1370:11
    t.method("GetVertexToElementTable", static_cast<mfem::Table * (mfem::Mesh::*)() >(&mfem::Mesh::GetVertexToElementTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetFaceToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetFaceToElementTable()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1375:11
    t.method("GetFaceToElementTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetFaceToElementTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetFaceEdgeTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetFaceEdgeTable()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1380:11
    t.method("GetFaceEdgeTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetFaceEdgeTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetEdgeVertexTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetEdgeVertexTable()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1384:11
    t.method("GetEdgeVertexTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetEdgeVertexTable));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetVertexToVertexTable(mfem::DSTable &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetVertexToVertexTable(mfem::DSTable &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1394:9
    t.method("GetVertexToVertexTable", static_cast<void (mfem::Mesh::*)(mfem::DSTable &)  const>(&mfem::Mesh::GetVertexToVertexTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToElementTable()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1396:17
    t.method("ElementToElementTable", static_cast<const mfem::Table & (mfem::Mesh::*)() >(&mfem::Mesh::ElementToElementTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToFaceTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToFaceTable()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1398:17
    t.method("ElementToFaceTable", static_cast<const mfem::Table & (mfem::Mesh::*)()  const>(&mfem::Mesh::ElementToFaceTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToEdgeTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToEdgeTable()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1400:17
    t.method("ElementToEdgeTable", static_cast<const mfem::Table & (mfem::Mesh::*)()  const>(&mfem::Mesh::ElementToEdgeTable));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElement * mfem::Mesh::GetTransformationFEforElementType(mfem::Element::Type) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElement * mfem::Mesh::GetTransformationFEforElementType(mfem::Element::Type)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1410:26
    t.method("mfem!Mesh!GetTransformationFEforElementType", static_cast<mfem::FiniteElement * (*)(mfem::Element::Type) >(&mfem::Mesh::GetTransformationFEforElementType));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1422:9
    t.method("GetElementTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *) >(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetElementTransformation(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1429:27
    t.method("GetElementTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementTransformation(int, const mfem::Vector &, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementTransformation(int, const mfem::Vector &, mfem::IsoparametricTransformation *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1434:9
    t.method("GetElementTransformation", static_cast<void (mfem::Mesh::*)(int, const mfem::Vector &, mfem::IsoparametricTransformation *) >(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetBdrElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetBdrElementTransformation(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1442:27
    t.method("GetBdrElementTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1446:9
    t.method("GetBdrElementTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *) >(&mfem::Mesh::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceTransformation(int, mfem::IsoparametricTransformation *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1450:9
    t.method("GetFaceTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *) >(&mfem::Mesh::GetFaceTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetLocalFaceTransformation(int, int, mfem::IsoparametricTransformation &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetLocalFaceTransformation(int, int, mfem::IsoparametricTransformation &, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1457:9
    t.method("GetLocalFaceTransformation", static_cast<void (mfem::Mesh::*)(int, int, mfem::IsoparametricTransformation &, int) >(&mfem::Mesh::GetLocalFaceTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetFaceTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetFaceTransformation(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1465:27
    t.method("GetFaceTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetFaceTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetEdgeTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetEdgeTransformation(int, mfem::IsoparametricTransformation *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1469:9
    t.method("GetEdgeTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *) >(&mfem::Mesh::GetEdgeTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetEdgeTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetEdgeTransformation(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1475:27
    t.method("GetEdgeTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetEdgeTransformation));

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetFaceElementTransformations(int, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetFaceElementTransformations(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1511:40
    t.method("GetFaceElementTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GetFaceElementTransformations));
    t.method("GetFaceElementTransformations", [](mfem::Mesh& a, int arg0)->mfem::FaceElementTransformations *{ return a.GetFaceElementTransformations(arg0); });
    t.method("GetFaceElementTransformations", [](mfem::Mesh* a, int arg0)->mfem::FaceElementTransformations *{ return a->GetFaceElementTransformations(arg0); });

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetInteriorFaceTransformations(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetInteriorFaceTransformations(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1517:32
    t.method("GetInteriorFaceTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetInteriorFaceTransformations));

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetBdrFaceTransformations(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetBdrFaceTransformations(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1525:32
    t.method("GetBdrFaceTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrFaceTransformations));

    DEBUG_MSG("Adding wrapper for const mfem::GeometricFactors * mfem::Mesh::GetGeometricFactors(const mfem::IntegrationRule &, const int, mfem::MemoryType) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GeometricFactors * mfem::Mesh::GetGeometricFactors(const mfem::IntegrationRule &, const int, mfem::MemoryType)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1554:28
    t.method("GetGeometricFactors", static_cast<const mfem::GeometricFactors * (mfem::Mesh::*)(const mfem::IntegrationRule &, const int, mfem::MemoryType) >(&mfem::Mesh::GetGeometricFactors));
    t.method("GetGeometricFactors", [](mfem::Mesh& a, const mfem::IntegrationRule & arg0, const int arg1)->const mfem::GeometricFactors *{ return a.GetGeometricFactors(arg0, arg1); });
    t.method("GetGeometricFactors", [](mfem::Mesh* a, const mfem::IntegrationRule & arg0, const int arg1)->const mfem::GeometricFactors *{ return a->GetGeometricFactors(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for const mfem::FaceGeometricFactors * mfem::Mesh::GetFaceGeometricFactors(const mfem::IntegrationRule &, const int, mfem::FaceType, mfem::MemoryType) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FaceGeometricFactors * mfem::Mesh::GetFaceGeometricFactors(const mfem::IntegrationRule &, const int, mfem::FaceType, mfem::MemoryType)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1577:32
    t.method("GetFaceGeometricFactors", static_cast<const mfem::FaceGeometricFactors * (mfem::Mesh::*)(const mfem::IntegrationRule &, const int, mfem::FaceType, mfem::MemoryType) >(&mfem::Mesh::GetFaceGeometricFactors));
    t.method("GetFaceGeometricFactors", [](mfem::Mesh& a, const mfem::IntegrationRule & arg0, const int arg1, mfem::FaceType arg2)->const mfem::FaceGeometricFactors *{ return a.GetFaceGeometricFactors(arg0, arg1, arg2); });
    t.method("GetFaceGeometricFactors", [](mfem::Mesh* a, const mfem::IntegrationRule & arg0, const int arg1, mfem::FaceType arg2)->const mfem::FaceGeometricFactors *{ return a->GetFaceGeometricFactors(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::DeleteGeometricFactors() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::DeleteGeometricFactors()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1589:9
    t.method("DeleteGeometricFactors", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::DeleteGeometricFactors));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetPointMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetPointMatrix(int, mfem::DenseMatrix &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1758:9
    t.method("GetPointMatrix", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &)  const>(&mfem::Mesh::GetPointMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrPointMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrPointMatrix(int, mfem::DenseMatrix &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1762:9
    t.method("GetBdrPointMatrix", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &)  const>(&mfem::Mesh::GetBdrPointMatrix));

    DEBUG_MSG("Adding wrapper for mfem::Mesh::FaceInformation mfem::Mesh::GetFaceInformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh::FaceInformation mfem::Mesh::GetFaceInformation(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1767:20
    t.method("GetFaceInformation", static_cast<mfem::Mesh::FaceInformation (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceInformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceElements(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceElements(int, int *, int *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1769:9
    t.method("GetFaceElements", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetFaceElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceInfos(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceInfos(int, int *, int *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1770:9
    t.method("GetFaceInfos", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetFaceInfos));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceInfos(int, int *, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceInfos(int, int *, int *, int *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1771:9
    t.method("GetFaceInfos", static_cast<void (mfem::Mesh::*)(int, int *, int *, int *)  const>(&mfem::Mesh::GetFaceInfos));

    DEBUG_MSG("Adding wrapper for int * mfem::Mesh::CartesianPartitioning(int []) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::Mesh::CartesianPartitioning(int [])
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1779:9
    t.method("CartesianPartitioning", static_cast<int * (mfem::Mesh::*)(int []) >(&mfem::Mesh::CartesianPartitioning));

    DEBUG_MSG("Adding wrapper for int * mfem::Mesh::GeneratePartitioning(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::Mesh::GeneratePartitioning(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1781:9
    t.method("GeneratePartitioning", static_cast<int * (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GeneratePartitioning));
    t.method("GeneratePartitioning", [](mfem::Mesh& a, int arg0)->int *{ return a.GeneratePartitioning(arg0); });
    t.method("GeneratePartitioning", [](mfem::Mesh* a, int arg0)->int *{ return a->GeneratePartitioning(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::CheckPartitioning(int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::CheckPartitioning(int *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1783:9
    t.method("CheckPartitioning", static_cast<void (mfem::Mesh::*)(int *) >(&mfem::Mesh::CheckPartitioning));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::MoveVertices(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::MoveVertices(const mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1795:9
    t.method("MoveVertices", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::MoveVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetVertices(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetVertices(mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1796:9
    t.method("GetVertices", static_cast<void (mfem::Mesh::*)(mfem::Vector &)  const>(&mfem::Mesh::GetVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetVertices(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetVertices(const mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1797:9
    t.method("SetVertices", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::SetVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ChangeVertexDataOwnership(double *, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ChangeVertexDataOwnership(double *, int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1804:9
    t.method("ChangeVertexDataOwnership", static_cast<void (mfem::Mesh::*)(double *, int, bool) >(&mfem::Mesh::ChangeVertexDataOwnership));
    t.method("ChangeVertexDataOwnership", [](mfem::Mesh& a, double * arg0, int arg1)->void{ a.ChangeVertexDataOwnership(arg0, arg1); });
    t.method("ChangeVertexDataOwnership", [](mfem::Mesh* a, double * arg0, int arg1)->void{ a->ChangeVertexDataOwnership(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNode(int, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNode(int, double *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1810:9
    t.method("GetNode", static_cast<void (mfem::Mesh::*)(int, double *)  const>(&mfem::Mesh::GetNode));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNode(int, const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNode(int, const double *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1811:9
    t.method("SetNode", static_cast<void (mfem::Mesh::*)(int, const double *) >(&mfem::Mesh::SetNode));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::MoveNodes(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::MoveNodes(const mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1816:9
    t.method("MoveNodes", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::MoveNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNodes(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNodes(mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1817:9
    t.method("GetNodes", static_cast<void (mfem::Mesh::*)(mfem::Vector &)  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodes(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodes(const mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1819:9
    t.method("SetNodes", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::SetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ScaleSubdomains(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ScaleSubdomains(double)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1821:9
    t.method("ScaleSubdomains", static_cast<void (mfem::Mesh::*)(double) >(&mfem::Mesh::ScaleSubdomains));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ScaleElements(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ScaleElements(double)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1822:9
    t.method("ScaleElements", static_cast<void (mfem::Mesh::*)(double) >(&mfem::Mesh::ScaleElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Transform(void (*)(const mfem::Vector &, mfem::Vector &)) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Transform(void (*)(const mfem::Vector &, mfem::Vector &))
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1824:9
    t.method("Transform", static_cast<void (mfem::Mesh::*)(void (*)(const mfem::Vector &, mfem::Vector &)) >(&mfem::Mesh::Transform));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Transform(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Transform(mfem::VectorCoefficient &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1825:9
    t.method("Transform", static_cast<void (mfem::Mesh::*)(mfem::VectorCoefficient &) >(&mfem::Mesh::Transform));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::NodesUpdated() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::NodesUpdated()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1835:9
    t.method("NodesUpdated", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::NodesUpdated));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction * mfem::Mesh::GetNodes() (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction * mfem::Mesh::GetNodes()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1853:18
    t.method("GetNodes", static_cast<mfem::GridFunction * (mfem::Mesh::*)() >(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::Mesh::GetNodes() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::Mesh::GetNodes()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1854:24
    t.method("GetNodes", static_cast<const mfem::GridFunction * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::OwnsNodes() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::OwnsNodes()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1856:9
    t.method("OwnsNodes", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::OwnsNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodesOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodesOwner(bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1858:9
    t.method("SetNodesOwner", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::SetNodesOwner));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::NewNodes(mfem::GridFunction &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::NewNodes(mfem::GridFunction &, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1861:9
    t.method("NewNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction &, bool) >(&mfem::Mesh::NewNodes));
    t.method("NewNodes", [](mfem::Mesh& a, mfem::GridFunction & arg0)->void{ a.NewNodes(arg0); });
    t.method("NewNodes", [](mfem::Mesh* a, mfem::GridFunction & arg0)->void{ a->NewNodes(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SwapNodes(mfem::GridFunction *&, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SwapNodes(mfem::GridFunction *&, int &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1865:9
    t.method("SwapNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction *&, int &) >(&mfem::Mesh::SwapNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNodes(mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNodes(mfem::GridFunction &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1868:9
    t.method("GetNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction &)  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodalFESpace(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodalFESpace(mfem::FiniteElementSpace *)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1872:17
    t.method("SetNodalFESpace", static_cast<void (mfem::Mesh::*)(mfem::FiniteElementSpace *) >(&mfem::Mesh::SetNodalFESpace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodalGridFunction(mfem::GridFunction *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodalGridFunction(mfem::GridFunction *, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1876:9
    t.method("SetNodalGridFunction", static_cast<void (mfem::Mesh::*)(mfem::GridFunction *, bool) >(&mfem::Mesh::SetNodalGridFunction));
    t.method("SetNodalGridFunction", [](mfem::Mesh& a, mfem::GridFunction * arg0)->void{ a.SetNodalGridFunction(arg0); });
    t.method("SetNodalGridFunction", [](mfem::Mesh* a, mfem::GridFunction * arg0)->void{ a->SetNodalGridFunction(arg0); });

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::Mesh::GetNodalFESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::Mesh::GetNodalFESpace()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1879:30
    t.method("GetNodalFESpace", static_cast<const mfem::FiniteElementSpace * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNodalFESpace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::EnsureNodes() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::EnsureNodes()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1885:9
    t.method("EnsureNodes", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::EnsureNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetCurvature(int, bool, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetCurvature(int, bool, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1896:17
    t.method("SetCurvature", static_cast<void (mfem::Mesh::*)(int, bool, int, int) >(&mfem::Mesh::SetCurvature));
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0)->void{ a.SetCurvature(arg0); });
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0, bool arg1)->void{ a.SetCurvature(arg0, arg1); });
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0, bool arg1, int arg2)->void{ a.SetCurvature(arg0, arg1, arg2); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0)->void{ a->SetCurvature(arg0); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0, bool arg1)->void{ a->SetCurvature(arg0, arg1); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0, bool arg1, int arg2)->void{ a->SetCurvature(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::UniformRefinement(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::UniformRefinement(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1915:9
    t.method("UniformRefinement", static_cast<void (mfem::Mesh::*)(int) >(&mfem::Mesh::UniformRefinement));
    t.method("UniformRefinement", [](mfem::Mesh& a)->void{ a.UniformRefinement(); });
    t.method("UniformRefinement", [](mfem::Mesh* a)->void{ a->UniformRefinement(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RandomRefinement(double, bool, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RandomRefinement(double, bool, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1934:9
    t.method("RandomRefinement", static_cast<void (mfem::Mesh::*)(double, bool, int, int) >(&mfem::Mesh::RandomRefinement));
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0)->void{ a.RandomRefinement(arg0); });
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0, bool arg1)->void{ a.RandomRefinement(arg0, arg1); });
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0, bool arg1, int arg2)->void{ a.RandomRefinement(arg0, arg1, arg2); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0)->void{ a->RandomRefinement(arg0); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0, bool arg1)->void{ a->RandomRefinement(arg0, arg1); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0, bool arg1, int arg2)->void{ a->RandomRefinement(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RefineAtVertex(const mfem::Vertex &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RefineAtVertex(const mfem::Vertex &, double, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1938:9
    t.method("RefineAtVertex", static_cast<void (mfem::Mesh::*)(const mfem::Vertex &, double, int) >(&mfem::Mesh::RefineAtVertex));
    t.method("RefineAtVertex", [](mfem::Mesh& a, const mfem::Vertex & arg0)->void{ a.RefineAtVertex(arg0); });
    t.method("RefineAtVertex", [](mfem::Mesh& a, const mfem::Vertex & arg0, double arg1)->void{ a.RefineAtVertex(arg0, arg1); });
    t.method("RefineAtVertex", [](mfem::Mesh* a, const mfem::Vertex & arg0)->void{ a->RefineAtVertex(arg0); });
    t.method("RefineAtVertex", [](mfem::Mesh* a, const mfem::Vertex & arg0, double arg1)->void{ a->RefineAtVertex(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::RefineByError(const mfem::Vector &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::RefineByError(const mfem::Vector &, double, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1948:9
    t.method("RefineByError", static_cast<bool (mfem::Mesh::*)(const mfem::Vector &, double, int, int) >(&mfem::Mesh::RefineByError));
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1)->bool{ return a.RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1, int arg2)->bool{ return a.RefineByError(arg0, arg1, arg2); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1)->bool{ return a->RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1, int arg2)->bool{ return a->RefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::DerefineByError(const mfem::Vector &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::DerefineByError(const mfem::Vector &, double, int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1960:9
    t.method("DerefineByError", static_cast<bool (mfem::Mesh::*)(const mfem::Vector &, double, int, int) >(&mfem::Mesh::DerefineByError));
    t.method("DerefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1)->bool{ return a.DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1, int arg2)->bool{ return a.DerefineByError(arg0, arg1, arg2); });
    t.method("DerefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1)->bool{ return a->DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1, int arg2)->bool{ return a->DerefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::EnsureNCMesh(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::EnsureNCMesh(bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1966:9
    t.method("EnsureNCMesh", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::EnsureNCMesh));
    t.method("EnsureNCMesh", [](mfem::Mesh& a)->void{ a.EnsureNCMesh(); });
    t.method("EnsureNCMesh", [](mfem::Mesh* a)->void{ a->EnsureNCMesh(); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::Conforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::Conforming()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1968:9
    t.method("Conforming", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::Conforming));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::Nonconforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::Nonconforming()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1969:9
    t.method("Nonconforming", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::Nonconforming));

    DEBUG_MSG("Adding wrapper for const mfem::CoarseFineTransformations & mfem::Mesh::GetRefinementTransforms() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::CoarseFineTransformations & mfem::Mesh::GetRefinementTransforms()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1973:37
    t.method("GetRefinementTransforms", static_cast<const mfem::CoarseFineTransformations & (mfem::Mesh::*)() >(&mfem::Mesh::GetRefinementTransforms));

    DEBUG_MSG("Adding wrapper for mfem::Mesh::Operation mfem::Mesh::GetLastOperation() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh::Operation mfem::Mesh::GetLastOperation()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1976:14
    t.method("GetLastOperation", static_cast<mfem::Mesh::Operation (mfem::Mesh::*)()  const>(&mfem::Mesh::GetLastOperation));

    DEBUG_MSG("Adding wrapper for long mfem::Mesh::GetSequence() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::Mesh::GetSequence()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1982:9
    t.method("GetSequence", static_cast<long (mfem::Mesh::*)()  const>(&mfem::Mesh::GetSequence));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RefineNURBSFromFile(std::string) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RefineNURBSFromFile(std::string)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1995:9
    t.method("RefineNURBSFromFile", static_cast<void (mfem::Mesh::*)(std::string) >(&mfem::Mesh::RefineNURBSFromFile));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::DegreeElevate(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::DegreeElevate(int, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2000:9
    t.method("DegreeElevate", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::DegreeElevate));
    t.method("DegreeElevate", [](mfem::Mesh& a, int arg0)->void{ a.DegreeElevate(arg0); });
    t.method("DegreeElevate", [](mfem::Mesh* a, int arg0)->void{ a->DegreeElevate(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Save(const std::string &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Save(const std::string &, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2015:17
    t.method("Save", static_cast<void (mfem::Mesh::*)(const std::string &, int)  const>(&mfem::Mesh::Save));
    t.method("Save", [](mfem::Mesh const& a, const std::string & arg0)->void{ a.Save(arg0); });
    t.method("Save", [](mfem::Mesh const* a, const std::string & arg0)->void{ a->Save(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::PrintVTU(std::string, mfem::VTKFormat, bool, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::PrintVTU(std::string, mfem::VTKFormat, bool, int, bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2041:17
    t.method("PrintVTU", static_cast<void (mfem::Mesh::*)(std::string, mfem::VTKFormat, bool, int, bool) >(&mfem::Mesh::PrintVTU));
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0)->void{ a.PrintVTU(arg0); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1)->void{ a.PrintVTU(arg0, arg1); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void{ a.PrintVTU(arg0, arg1, arg2); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2, int arg3)->void{ a.PrintVTU(arg0, arg1, arg2, arg3); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0)->void{ a->PrintVTU(arg0); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1)->void{ a->PrintVTU(arg0, arg1); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void{ a->PrintVTU(arg0, arg1, arg2); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2, int arg3)->void{ a->PrintVTU(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::PrintBdrVTU(std::string, mfem::VTKFormat, bool, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::PrintBdrVTU(std::string, mfem::VTKFormat, bool, int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2048:9
    t.method("PrintBdrVTU", static_cast<void (mfem::Mesh::*)(std::string, mfem::VTKFormat, bool, int) >(&mfem::Mesh::PrintBdrVTU));
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0)->void{ a.PrintBdrVTU(arg0); });
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1)->void{ a.PrintBdrVTU(arg0, arg1); });
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void{ a.PrintBdrVTU(arg0, arg1, arg2); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0)->void{ a->PrintBdrVTU(arg0); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1)->void{ a->PrintBdrVTU(arg0, arg1); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void{ a->PrintBdrVTU(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetGeometricParametersFromJacobian(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetGeometricParametersFromJacobian(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2153:9
    t.method("GetGeometricParametersFromJacobian", static_cast<void (mfem::Mesh::*)(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &)  const>(&mfem::Mesh::GetGeometricParametersFromJacobian));

    DEBUG_MSG("Adding wrapper for long long mfem::Mesh::ReduceInt(int) (" __HERE__ ")");
    // signature to use in the veto list: long long mfem::Mesh::ReduceInt(int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2160:22
    t.method("ReduceInt", static_cast<long long (mfem::Mesh::*)(int)  const>(&mfem::Mesh::ReduceInt));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::CheckDisplacements(const mfem::Vector &, double &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::CheckDisplacements(const mfem::Vector &, double &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2169:9
    t.method("CheckDisplacements", static_cast<void (mfem::Mesh::*)(const mfem::Vector &, double &) >(&mfem::Mesh::CheckDisplacements));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureFunctions1D> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureFunctions1D> : std::false_type { };
}

struct Jlmfem_QuadratureFunctions1D: public Wrapper {

  Jlmfem_QuadratureFunctions1D(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureFunctions1D (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:366:7
    jlcxx::TypeWrapper<mfem::QuadratureFunctions1D>  t = jlModule.add_type<mfem::QuadratureFunctions1D>("mfem!QuadratureFunctions1D");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunctions1D>>(new jlcxx::TypeWrapper<mfem::QuadratureFunctions1D>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::GaussLegendre(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::GaussLegendre(const int, mfem::IntegrationRule *)
    // defined in mfem/fem/intrules.hpp:373:16
    t.method("mfem!QuadratureFunctions1D!GaussLegendre", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::GaussLegendre));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::GaussLobatto(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::GaussLobatto(const int, mfem::IntegrationRule *)
    // defined in mfem/fem/intrules.hpp:374:16
    t.method("mfem!QuadratureFunctions1D!GaussLobatto", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::GaussLobatto));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::OpenUniform(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::OpenUniform(const int, mfem::IntegrationRule *)
    // defined in mfem/fem/intrules.hpp:375:16
    t.method("mfem!QuadratureFunctions1D!OpenUniform", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::OpenUniform));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::ClosedUniform(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::ClosedUniform(const int, mfem::IntegrationRule *)
    // defined in mfem/fem/intrules.hpp:376:16
    t.method("mfem!QuadratureFunctions1D!ClosedUniform", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::ClosedUniform));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::OpenHalfUniform(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::OpenHalfUniform(const int, mfem::IntegrationRule *)
    // defined in mfem/fem/intrules.hpp:377:16
    t.method("mfem!QuadratureFunctions1D!OpenHalfUniform", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::OpenHalfUniform));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::ClosedGL(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::ClosedGL(const int, mfem::IntegrationRule *)
    // defined in mfem/fem/intrules.hpp:378:16
    t.method("mfem!QuadratureFunctions1D!ClosedGL", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::ClosedGL));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::GivePolyPoints(const int, double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::GivePolyPoints(const int, double *, const int)
    // defined in mfem/fem/intrules.hpp:383:16
    t.method("mfem!QuadratureFunctions1D!GivePolyPoints", static_cast<void (*)(const int, double *, const int) >(&mfem::QuadratureFunctions1D::GivePolyPoints));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunctions1D>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunctions1D(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureFunctions1D(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Quadrature1D> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Quadrature1D> : std::false_type { };
}

struct Jlmfem_Quadrature1D: public Wrapper {

  Jlmfem_Quadrature1D(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Quadrature1D (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:390:7
    jlcxx::TypeWrapper<mfem::Quadrature1D>  t = jlModule.add_type<mfem::Quadrature1D>("mfem!Quadrature1D");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Quadrature1D>>(new jlcxx::TypeWrapper<mfem::Quadrature1D>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for int mfem::Quadrature1D::CheckClosed(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Quadrature1D::CheckClosed(int)
    // defined in mfem/fem/intrules.hpp:405:15
    t.method("mfem!Quadrature1D!CheckClosed", static_cast<int (*)(int) >(&mfem::Quadrature1D::CheckClosed));

    DEBUG_MSG("Adding wrapper for int mfem::Quadrature1D::CheckOpen(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Quadrature1D::CheckOpen(int)
    // defined in mfem/fem/intrules.hpp:408:15
    t.method("mfem!Quadrature1D!CheckOpen", static_cast<int (*)(int) >(&mfem::Quadrature1D::CheckOpen));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Quadrature1D>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Quadrature1D(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Quadrature1D(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IntegrationRules> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IntegrationRules> : std::false_type { };
}

struct Jlmfem_IntegrationRules: public Wrapper {

  Jlmfem_IntegrationRules(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IntegrationRules (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:412:7
    jlcxx::TypeWrapper<mfem::IntegrationRules>  t = jlModule.add_type<mfem::IntegrationRules>("mfem!IntegrationRules");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRules>>(new jlcxx::TypeWrapper<mfem::IntegrationRules>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRules::IntegrationRules(int, int) (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:465:13
    t.constructor<int>(/*finalize=*/true);
    t.constructor<int, int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::IntegrationRules::Get(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::IntegrationRules::Get(int, int)
    // defined in mfem/fem/intrules.hpp:469:27
    t.method("Get", static_cast<const mfem::IntegrationRule & (mfem::IntegrationRules::*)(int, int) >(&mfem::IntegrationRules::Get));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRules::Set(int, int, mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationRules::Set(int, int, mfem::IntegrationRule &)
    // defined in mfem/fem/intrules.hpp:471:9
    t.method("Set", static_cast<void (mfem::IntegrationRules::*)(int, int, mfem::IntegrationRule &) >(&mfem::IntegrationRules::Set));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRules::SetOwnRules(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationRules::SetOwnRules(int)
    // defined in mfem/fem/intrules.hpp:473:9
    t.method("SetOwnRules", static_cast<void (mfem::IntegrationRules::*)(int) >(&mfem::IntegrationRules::SetOwnRules));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRules>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IntegrationRules(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IntegrationRules(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Coefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Coefficient> : std::false_type { };
}

struct Jlmfem_Coefficient: public Wrapper {

  Jlmfem_Coefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Coefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:41:7
    jlcxx::TypeWrapper<mfem::Coefficient>  t = jlModule.add_type<mfem::Coefficient>("mfem!Coefficient");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Coefficient>>(new jlcxx::TypeWrapper<mfem::Coefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::Coefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Coefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:50:17
    t.method("SetTime", static_cast<void (mfem::Coefficient::*)(double) >(&mfem::Coefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::Coefficient::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Coefficient::GetTime()
    // defined in mfem/fem/coefficient.hpp:53:11
    t.method("GetTime", static_cast<double (mfem::Coefficient::*)() >(&mfem::Coefficient::GetTime));

    DEBUG_MSG("Adding wrapper for double mfem::Coefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Coefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:60:19
    t.method("Eval", static_cast<double (mfem::Coefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::Coefficient::Eval));

    DEBUG_MSG("Adding wrapper for double mfem::Coefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &, double) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Coefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &, double)
    // defined in mfem/fem/coefficient.hpp:68:11
    t.method("Eval", static_cast<double (mfem::Coefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &, double) >(&mfem::Coefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::Coefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Coefficient::Project(mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:77:17
    t.method("Project", static_cast<void (mfem::Coefficient::*)(mfem::QuadratureFunction &) >(&mfem::Coefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Coefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Coefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Coefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ElementTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ElementTransformation> : std::false_type { };
}

struct Jlmfem_ElementTransformation: public Wrapper {

  Jlmfem_ElementTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ElementTransformation (" __HERE__ ")");
    // defined in mfem/mesh/../fem/eltrans.hpp:23:7
    jlcxx::TypeWrapper<mfem::ElementTransformation>  t = jlModule.add_type<mfem::ElementTransformation>("mfem!ElementTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementTransformation>>(new jlcxx::TypeWrapper<mfem::ElementTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ElementTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ElementTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureFunction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureFunction> : std::false_type { };
template<> struct SuperType<mfem::QuadratureFunction> { typedef mfem::Vector type; };
}

struct Jlmfem_QuadratureFunction: public Wrapper {

  Jlmfem_QuadratureFunction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureFunction (" __HERE__ ")");
    // defined in mfem/mesh/../fem/qfunction.hpp:23:7
    jlcxx::TypeWrapper<mfem::QuadratureFunction>  t = jlModule.add_type<mfem::QuadratureFunction>("mfem!QuadratureFunction"    , jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunction>>(new jlcxx::TypeWrapper<mfem::QuadratureFunction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureFunction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ConstantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ConstantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ConstantCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_ConstantCoefficient: public Wrapper {

  Jlmfem_ConstantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ConstantCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:84:7
    jlcxx::TypeWrapper<mfem::ConstantCoefficient>  t = jlModule.add_type<mfem::ConstantCoefficient>("mfem!ConstantCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ConstantCoefficient>>(new jlcxx::TypeWrapper<mfem::ConstantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::ConstantCoefficient::ConstantCoefficient(double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:90:13
    t.constructor<double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for double mfem::ConstantCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ConstantCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:93:19
    t.method("Eval", static_cast<double (mfem::ConstantCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ConstantCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::ConstantCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConstantCoefficient::Project(mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:98:9
    t.method("Project", static_cast<void (mfem::ConstantCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::ConstantCoefficient::Project));

    DEBUG_MSG("Adding constant methods  to provide read access to the field constant (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:87:11
    // signature to use in the veto list: mfem::ConstantCoefficient::constant
    t.method("constant", [](const mfem::ConstantCoefficient& a) -> double { return a.constant; });
    t.method("constant", [](mfem::ConstantCoefficient& a) -> double { return a.constant; });
    t.method("constant", [](const mfem::ConstantCoefficient* a) -> double { return a->constant; });
    t.method("constant", [](mfem::ConstantCoefficient* a) -> double { return a->constant; });
    // defined in mfem/fem/coefficient.hpp:87:11
    // signature to use in the veto list: mfem::ConstantCoefficient::constant
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding constant! methods to provide write access to the field constant (" __HERE__ ")");
    t.method("constant!", [](mfem::ConstantCoefficient& a, double val) -> double { return a.constant = val; });

    DEBUG_MSG("Adding constant! methods to provide write access to the field constant (" __HERE__ ")");
    t.method("constant!", [](mfem::ConstantCoefficient* a, double val) -> double { return a->constant = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ConstantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ConstantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ConstantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PWConstCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PWConstCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PWConstCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_PWConstCoefficient: public Wrapper {

  Jlmfem_PWConstCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PWConstCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:103:7
    jlcxx::TypeWrapper<mfem::PWConstCoefficient>  t = jlModule.add_type<mfem::PWConstCoefficient>("mfem!PWConstCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PWConstCoefficient>>(new jlcxx::TypeWrapper<mfem::PWConstCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::PWConstCoefficient::PWConstCoefficient(int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:111:13
    t.constructor<int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::PWConstCoefficient::PWConstCoefficient(mfem::Vector &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:117:4
    t.constructor<mfem::Vector &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::PWConstCoefficient::UpdateConstants(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWConstCoefficient::UpdateConstants(mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:121:9
    t.method("UpdateConstants", static_cast<void (mfem::PWConstCoefficient::*)(mfem::Vector &) >(&mfem::PWConstCoefficient::UpdateConstants));

    DEBUG_MSG("Adding wrapper for double & mfem::PWConstCoefficient::operator()(int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::PWConstCoefficient::operator()(int)
    // defined in mfem/fem/coefficient.hpp:124:12
    t.method("paren", static_cast<double & (mfem::PWConstCoefficient::*)(int) >(&mfem::PWConstCoefficient::operator()));

    DEBUG_MSG("Adding wrapper for void mfem::PWConstCoefficient::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWConstCoefficient::operator=(double)
    // defined in mfem/fem/coefficient.hpp:127:9
    t.method("assign", static_cast<void (mfem::PWConstCoefficient::*)(double) >(&mfem::PWConstCoefficient::operator=));

    DEBUG_MSG("Adding wrapper for int mfem::PWConstCoefficient::GetNConst() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::PWConstCoefficient::GetNConst()
    // defined in mfem/fem/coefficient.hpp:130:8
    t.method("GetNConst", static_cast<int (mfem::PWConstCoefficient::*)() >(&mfem::PWConstCoefficient::GetNConst));

    DEBUG_MSG("Adding wrapper for double mfem::PWConstCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PWConstCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:133:19
    t.method("Eval", static_cast<double (mfem::PWConstCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PWConstCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PWConstCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PWConstCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PWConstCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PWCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PWCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PWCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_PWCoefficient: public Wrapper {

  Jlmfem_PWCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PWCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:153:7
    jlcxx::TypeWrapper<mfem::PWCoefficient>  t = jlModule.add_type<mfem::PWCoefficient>("mfem!PWCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PWCoefficient>>(new jlcxx::TypeWrapper<mfem::PWCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::PWCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:198:17
    t.method("SetTime", static_cast<void (mfem::PWCoefficient::*)(double) >(&mfem::PWCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::PWCoefficient::UpdateCoefficient(int, mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWCoefficient::UpdateCoefficient(int, mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:206:9
    t.method("UpdateCoefficient", static_cast<void (mfem::PWCoefficient::*)(int, mfem::Coefficient &) >(&mfem::PWCoefficient::UpdateCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWCoefficient::ZeroCoefficient(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWCoefficient::ZeroCoefficient(int)
    // defined in mfem/fem/coefficient.hpp:210:9
    t.method("ZeroCoefficient", static_cast<void (mfem::PWCoefficient::*)(int) >(&mfem::PWCoefficient::ZeroCoefficient));

    DEBUG_MSG("Adding wrapper for double mfem::PWCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PWCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:214:19
    t.method("Eval", static_cast<double (mfem::PWCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PWCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PWCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PWCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PWCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CartesianCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CartesianCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CartesianCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_CartesianCoefficient: public Wrapper {

  Jlmfem_CartesianCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CartesianCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:263:7
    jlcxx::TypeWrapper<mfem::CartesianCoefficient>  t = jlModule.add_type<mfem::CartesianCoefficient>("mfem!CartesianCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianCoefficient>>(new jlcxx::TypeWrapper<mfem::CartesianCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for double mfem::CartesianCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CartesianCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:274:19
    t.method("Eval", static_cast<double (mfem::CartesianCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CartesianCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CartesianCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CartesianCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CartesianXCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CartesianXCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CartesianXCoefficient> { typedef mfem::CartesianCoefficient type; };
}

struct Jlmfem_CartesianXCoefficient: public Wrapper {

  Jlmfem_CartesianXCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CartesianXCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:279:7
    jlcxx::TypeWrapper<mfem::CartesianXCoefficient>  t = jlModule.add_type<mfem::CartesianXCoefficient>("mfem!CartesianXCoefficient"    , jlcxx::julia_base_type<mfem::CartesianCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianXCoefficient>>(new jlcxx::TypeWrapper<mfem::CartesianXCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianXCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CartesianXCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CartesianXCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CartesianYCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CartesianYCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CartesianYCoefficient> { typedef mfem::CartesianCoefficient type; };
}

struct Jlmfem_CartesianYCoefficient: public Wrapper {

  Jlmfem_CartesianYCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CartesianYCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:286:7
    jlcxx::TypeWrapper<mfem::CartesianYCoefficient>  t = jlModule.add_type<mfem::CartesianYCoefficient>("mfem!CartesianYCoefficient"    , jlcxx::julia_base_type<mfem::CartesianCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianYCoefficient>>(new jlcxx::TypeWrapper<mfem::CartesianYCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianYCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CartesianYCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CartesianYCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CartesianZCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CartesianZCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CartesianZCoefficient> { typedef mfem::CartesianCoefficient type; };
}

struct Jlmfem_CartesianZCoefficient: public Wrapper {

  Jlmfem_CartesianZCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CartesianZCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:293:7
    jlcxx::TypeWrapper<mfem::CartesianZCoefficient>  t = jlModule.add_type<mfem::CartesianZCoefficient>("mfem!CartesianZCoefficient"    , jlcxx::julia_base_type<mfem::CartesianCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianZCoefficient>>(new jlcxx::TypeWrapper<mfem::CartesianZCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianZCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CartesianZCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CartesianZCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CylindricalRadialCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CylindricalRadialCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CylindricalRadialCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_CylindricalRadialCoefficient: public Wrapper {

  Jlmfem_CylindricalRadialCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CylindricalRadialCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:301:7
    jlcxx::TypeWrapper<mfem::CylindricalRadialCoefficient>  t = jlModule.add_type<mfem::CylindricalRadialCoefficient>("mfem!CylindricalRadialCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CylindricalRadialCoefficient>>(new jlcxx::TypeWrapper<mfem::CylindricalRadialCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for double mfem::CylindricalRadialCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CylindricalRadialCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:310:19
    t.method("Eval", static_cast<double (mfem::CylindricalRadialCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CylindricalRadialCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CylindricalRadialCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CylindricalRadialCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CylindricalRadialCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CylindricalAzimuthalCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CylindricalAzimuthalCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CylindricalAzimuthalCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_CylindricalAzimuthalCoefficient: public Wrapper {

  Jlmfem_CylindricalAzimuthalCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CylindricalAzimuthalCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:317:7
    jlcxx::TypeWrapper<mfem::CylindricalAzimuthalCoefficient>  t = jlModule.add_type<mfem::CylindricalAzimuthalCoefficient>("mfem!CylindricalAzimuthalCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CylindricalAzimuthalCoefficient>>(new jlcxx::TypeWrapper<mfem::CylindricalAzimuthalCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for double mfem::CylindricalAzimuthalCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CylindricalAzimuthalCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:326:19
    t.method("Eval", static_cast<double (mfem::CylindricalAzimuthalCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CylindricalAzimuthalCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CylindricalAzimuthalCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CylindricalAzimuthalCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CylindricalAzimuthalCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SphericalRadialCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SphericalRadialCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SphericalRadialCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_SphericalRadialCoefficient: public Wrapper {

  Jlmfem_SphericalRadialCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SphericalRadialCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:336:7
    jlcxx::TypeWrapper<mfem::SphericalRadialCoefficient>  t = jlModule.add_type<mfem::SphericalRadialCoefficient>("mfem!SphericalRadialCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalRadialCoefficient>>(new jlcxx::TypeWrapper<mfem::SphericalRadialCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for double mfem::SphericalRadialCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SphericalRadialCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:345:19
    t.method("Eval", static_cast<double (mfem::SphericalRadialCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SphericalRadialCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalRadialCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SphericalRadialCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SphericalRadialCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SphericalAzimuthalCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SphericalAzimuthalCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SphericalAzimuthalCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_SphericalAzimuthalCoefficient: public Wrapper {

  Jlmfem_SphericalAzimuthalCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SphericalAzimuthalCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:351:7
    jlcxx::TypeWrapper<mfem::SphericalAzimuthalCoefficient>  t = jlModule.add_type<mfem::SphericalAzimuthalCoefficient>("mfem!SphericalAzimuthalCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalAzimuthalCoefficient>>(new jlcxx::TypeWrapper<mfem::SphericalAzimuthalCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for double mfem::SphericalAzimuthalCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SphericalAzimuthalCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:360:19
    t.method("Eval", static_cast<double (mfem::SphericalAzimuthalCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SphericalAzimuthalCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalAzimuthalCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SphericalAzimuthalCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SphericalAzimuthalCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SphericalPolarCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SphericalPolarCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SphericalPolarCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_SphericalPolarCoefficient: public Wrapper {

  Jlmfem_SphericalPolarCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SphericalPolarCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:366:7
    jlcxx::TypeWrapper<mfem::SphericalPolarCoefficient>  t = jlModule.add_type<mfem::SphericalPolarCoefficient>("mfem!SphericalPolarCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalPolarCoefficient>>(new jlcxx::TypeWrapper<mfem::SphericalPolarCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for double mfem::SphericalPolarCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SphericalPolarCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:375:19
    t.method("Eval", static_cast<double (mfem::SphericalPolarCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SphericalPolarCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalPolarCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SphericalPolarCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SphericalPolarCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::GridFunctionCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_GridFunctionCoefficient: public Wrapper {

  Jlmfem_GridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GridFunctionCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:382:7
    jlcxx::TypeWrapper<mfem::GridFunctionCoefficient>  t = jlModule.add_type<mfem::GridFunctionCoefficient>("mfem!GridFunctionCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::GridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunctionCoefficient::GridFunctionCoefficient(const mfem::GridFunction *, int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:392:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/true);
    t.constructor<const mfem::GridFunction *, int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::GridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in mfem/fem/coefficient.hpp:396:9
    t.method("SetGridFunction", static_cast<void (mfem::GridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::GridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::GridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::GridFunctionCoefficient::GetGridFunction()
    // defined in mfem/fem/coefficient.hpp:399:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::GridFunctionCoefficient::*)()  const>(&mfem::GridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for double mfem::GridFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:402:19
    t.method("Eval", static_cast<double (mfem::GridFunctionCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::GridFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunctionCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunctionCoefficient::Project(mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:410:17
    t.method("Project", static_cast<void (mfem::GridFunctionCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::GridFunctionCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GridFunction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GridFunction> : std::false_type { };
template<> struct SuperType<mfem::GridFunction> { typedef mfem::Vector type; };
}

struct Jlmfem_GridFunction: public Wrapper {

  Jlmfem_GridFunction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GridFunction (" __HERE__ ")");
    // defined in mfem/mesh/../fem/gridfunc.hpp:30:7
    jlcxx::TypeWrapper<mfem::GridFunction>  t = jlModule.add_type<mfem::GridFunction>("mfem!GridFunction"    , jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunction>>(new jlcxx::TypeWrapper<mfem::GridFunction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GridFunction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GridFunction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TransformedCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TransformedCoefficient> : std::false_type { };
template<> struct SuperType<mfem::TransformedCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_TransformedCoefficient: public Wrapper {

  Jlmfem_TransformedCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TransformedCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:420:7
    jlcxx::TypeWrapper<mfem::TransformedCoefficient>  t = jlModule.add_type<mfem::TransformedCoefficient>("mfem!TransformedCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TransformedCoefficient>>(new jlcxx::TypeWrapper<mfem::TransformedCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::TransformedCoefficient::TransformedCoefficient(mfem::Coefficient *, double (*)(double)) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:429:4
    t.constructor<mfem::Coefficient *, double (*)(double)>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::TransformedCoefficient::TransformedCoefficient(mfem::Coefficient *, mfem::Coefficient *, double (*)(double, double)) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:431:4
    t.constructor<mfem::Coefficient *, mfem::Coefficient *, double (*)(double, double)>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::TransformedCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransformedCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:436:9
    t.method("SetTime", static_cast<void (mfem::TransformedCoefficient::*)(double) >(&mfem::TransformedCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::TransformedCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::TransformedCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:439:19
    t.method("Eval", static_cast<double (mfem::TransformedCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::TransformedCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TransformedCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TransformedCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TransformedCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DeltaCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DeltaCoefficient> : std::false_type { };
template<> struct SuperType<mfem::DeltaCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_DeltaCoefficient: public Wrapper {

  Jlmfem_DeltaCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DeltaCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:452:7
    jlcxx::TypeWrapper<mfem::DeltaCoefficient>  t = jlModule.add_type<mfem::DeltaCoefficient>("mfem!DeltaCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DeltaCoefficient>>(new jlcxx::TypeWrapper<mfem::DeltaCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::DeltaCoefficient(double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:470:4
    t.constructor<double, double>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::DeltaCoefficient(double, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:477:4
    t.constructor<double, double, double>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::DeltaCoefficient(double, double, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:484:4
    t.constructor<double, double, double, double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:491:9
    t.method("SetTime", static_cast<void (mfem::DeltaCoefficient::*)(double) >(&mfem::DeltaCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetDeltaCenter(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetDeltaCenter(const mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:494:9
    t.method("SetDeltaCenter", static_cast<void (mfem::DeltaCoefficient::*)(const mfem::Vector &) >(&mfem::DeltaCoefficient::SetDeltaCenter));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetScale(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetScale(double)
    // defined in mfem/fem/coefficient.hpp:497:9
    t.method("SetScale", static_cast<void (mfem::DeltaCoefficient::*)(double) >(&mfem::DeltaCoefficient::SetScale));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetFunction(double (*)(double)) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetFunction(double (*)(double))
    // defined in mfem/fem/coefficient.hpp:500:9
    t.method("SetFunction", static_cast<void (mfem::DeltaCoefficient::*)(double (*)(double)) >(&mfem::DeltaCoefficient::SetFunction));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetTol(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetTol(double)
    // defined in mfem/fem/coefficient.hpp:505:9
    t.method("SetTol", static_cast<void (mfem::DeltaCoefficient::*)(double) >(&mfem::DeltaCoefficient::SetTol));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetWeight(mfem::Coefficient *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetWeight(mfem::Coefficient *)
    // defined in mfem/fem/coefficient.hpp:513:9
    t.method("SetWeight", static_cast<void (mfem::DeltaCoefficient::*)(mfem::Coefficient *) >(&mfem::DeltaCoefficient::SetWeight));

    DEBUG_MSG("Adding wrapper for const double * mfem::DeltaCoefficient::Center() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::DeltaCoefficient::Center()
    // defined in mfem/fem/coefficient.hpp:517:18
    t.method("Center", static_cast<const double * (mfem::DeltaCoefficient::*)() >(&mfem::DeltaCoefficient::Center));

    DEBUG_MSG("Adding wrapper for double mfem::DeltaCoefficient::Scale() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeltaCoefficient::Scale()
    // defined in mfem/fem/coefficient.hpp:522:11
    t.method("Scale", static_cast<double (mfem::DeltaCoefficient::*)() >(&mfem::DeltaCoefficient::Scale));

    DEBUG_MSG("Adding wrapper for double mfem::DeltaCoefficient::Tol() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeltaCoefficient::Tol()
    // defined in mfem/fem/coefficient.hpp:525:11
    t.method("Tol", static_cast<double (mfem::DeltaCoefficient::*)() >(&mfem::DeltaCoefficient::Tol));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::DeltaCoefficient::Weight() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::DeltaCoefficient::Weight()
    // defined in mfem/fem/coefficient.hpp:528:17
    t.method("Weight", static_cast<mfem::Coefficient * (mfem::DeltaCoefficient::*)() >(&mfem::DeltaCoefficient::Weight));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::GetDeltaCenter(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::GetDeltaCenter(mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:531:9
    t.method("GetDeltaCenter", static_cast<void (mfem::DeltaCoefficient::*)(mfem::Vector &) >(&mfem::DeltaCoefficient::GetDeltaCenter));

    DEBUG_MSG("Adding wrapper for double mfem::DeltaCoefficient::EvalDelta(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeltaCoefficient::EvalDelta(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:534:19
    t.method("EvalDelta", static_cast<double (mfem::DeltaCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::DeltaCoefficient::EvalDelta));

    DEBUG_MSG("Adding wrapper for double mfem::DeltaCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeltaCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:537:19
    t.method("Eval", static_cast<double (mfem::DeltaCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::DeltaCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DeltaCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DeltaCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DeltaCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RestrictedCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RestrictedCoefficient> : std::false_type { };
template<> struct SuperType<mfem::RestrictedCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_RestrictedCoefficient: public Wrapper {

  Jlmfem_RestrictedCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RestrictedCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:544:7
    jlcxx::TypeWrapper<mfem::RestrictedCoefficient>  t = jlModule.add_type<mfem::RestrictedCoefficient>("mfem!RestrictedCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RestrictedCoefficient>>(new jlcxx::TypeWrapper<mfem::RestrictedCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::RestrictedCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RestrictedCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:558:9
    t.method("SetTime", static_cast<void (mfem::RestrictedCoefficient::*)(double) >(&mfem::RestrictedCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::RestrictedCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::RestrictedCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:561:19
    t.method("Eval", static_cast<double (mfem::RestrictedCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::RestrictedCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RestrictedCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RestrictedCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RestrictedCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorCoefficient> : std::false_type { };
}

struct Jlmfem_VectorCoefficient: public Wrapper {

  Jlmfem_VectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:566:7
    jlcxx::TypeWrapper<mfem::VectorCoefficient>  t = jlModule.add_type<mfem::VectorCoefficient>("mfem!VectorCoefficient");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:577:17
    t.method("SetTime", static_cast<void (mfem::VectorCoefficient::*)(double) >(&mfem::VectorCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::VectorCoefficient::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorCoefficient::GetTime()
    // defined in mfem/fem/coefficient.hpp:580:11
    t.method("GetTime", static_cast<double (mfem::VectorCoefficient::*)() >(&mfem::VectorCoefficient::GetTime));

    DEBUG_MSG("Adding wrapper for int mfem::VectorCoefficient::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::VectorCoefficient::GetVDim()
    // defined in mfem/fem/coefficient.hpp:583:8
    t.method("GetVDim", static_cast<int (mfem::VectorCoefficient::*)() >(&mfem::VectorCoefficient::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:590:17
    t.method("Eval", static_cast<void (mfem::VectorCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &)
    // defined in mfem/fem/coefficient.hpp:605:17
    t.method("Eval", static_cast<void (mfem::VectorCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) >(&mfem::VectorCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCoefficient::Project(mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:613:17
    t.method("Project", static_cast<void (mfem::VectorCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::VectorCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorConstantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorConstantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorConstantCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_VectorConstantCoefficient: public Wrapper {

  Jlmfem_VectorConstantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorConstantCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:620:7
    jlcxx::TypeWrapper<mfem::VectorConstantCoefficient>  t = jlModule.add_type<mfem::VectorConstantCoefficient>("mfem!VectorConstantCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorConstantCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorConstantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorConstantCoefficient::VectorConstantCoefficient(const mfem::Vector &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:626:4
    t.constructor<const mfem::Vector &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VectorConstantCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorConstantCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:631:17
    t.method("Eval", static_cast<void (mfem::VectorConstantCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorConstantCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::VectorConstantCoefficient::GetVec() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::VectorConstantCoefficient::GetVec()
    // defined in mfem/fem/coefficient.hpp:635:18
    t.method("GetVec", static_cast<const mfem::Vector & (mfem::VectorConstantCoefficient::*)()  const>(&mfem::VectorConstantCoefficient::GetVec));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorConstantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorConstantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorConstantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PWVectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PWVectorCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PWVectorCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_PWVectorCoefficient: public Wrapper {

  Jlmfem_PWVectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PWVectorCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:655:7
    jlcxx::TypeWrapper<mfem::PWVectorCoefficient>  t = jlModule.add_type<mfem::PWVectorCoefficient>("mfem!PWVectorCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PWVectorCoefficient>>(new jlcxx::TypeWrapper<mfem::PWVectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::PWVectorCoefficient(int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:684:13
    t.constructor<int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWVectorCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:701:17
    t.method("SetTime", static_cast<void (mfem::PWVectorCoefficient::*)(double) >(&mfem::PWVectorCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::UpdateCoefficient(int, mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWVectorCoefficient::UpdateCoefficient(int, mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:709:9
    t.method("UpdateCoefficient", static_cast<void (mfem::PWVectorCoefficient::*)(int, mfem::VectorCoefficient &) >(&mfem::PWVectorCoefficient::UpdateCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::ZeroCoefficient(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWVectorCoefficient::ZeroCoefficient(int)
    // defined in mfem/fem/coefficient.hpp:712:9
    t.method("ZeroCoefficient", static_cast<void (mfem::PWVectorCoefficient::*)(int) >(&mfem::PWVectorCoefficient::ZeroCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:716:17
    t.method("Eval", static_cast<void (mfem::PWVectorCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PWVectorCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PWVectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PWVectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PWVectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PositionVectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PositionVectorCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PositionVectorCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_PositionVectorCoefficient: public Wrapper {

  Jlmfem_PositionVectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PositionVectorCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:723:7
    jlcxx::TypeWrapper<mfem::PositionVectorCoefficient>  t = jlModule.add_type<mfem::PositionVectorCoefficient>("mfem!PositionVectorCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PositionVectorCoefficient>>(new jlcxx::TypeWrapper<mfem::PositionVectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::PositionVectorCoefficient::PositionVectorCoefficient(int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:727:4
    t.constructor<int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::PositionVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PositionVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:731:17
    t.method("Eval", static_cast<void (mfem::PositionVectorCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PositionVectorCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PositionVectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PositionVectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PositionVectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorArrayCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorArrayCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorArrayCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_VectorArrayCoefficient: public Wrapper {

  Jlmfem_VectorArrayCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorArrayCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:778:7
    jlcxx::TypeWrapper<mfem::VectorArrayCoefficient>  t = jlModule.add_type<mfem::VectorArrayCoefficient>("mfem!VectorArrayCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorArrayCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorArrayCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorArrayCoefficient::VectorArrayCoefficient(int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:787:13
    t.constructor<int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VectorArrayCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorArrayCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:790:9
    t.method("SetTime", static_cast<void (mfem::VectorArrayCoefficient::*)(double) >(&mfem::VectorArrayCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::VectorArrayCoefficient::GetCoeff(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::VectorArrayCoefficient::GetCoeff(int)
    // defined in mfem/fem/coefficient.hpp:793:17
    t.method("GetCoeff", static_cast<mfem::Coefficient * (mfem::VectorArrayCoefficient::*)(int) >(&mfem::VectorArrayCoefficient::GetCoeff));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient ** mfem::VectorArrayCoefficient::GetCoeffs() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient ** mfem::VectorArrayCoefficient::GetCoeffs()
    // defined in mfem/fem/coefficient.hpp:796:18
    t.method("GetCoeffs", static_cast<mfem::Coefficient ** (mfem::VectorArrayCoefficient::*)() >(&mfem::VectorArrayCoefficient::GetCoeffs));

    DEBUG_MSG("Adding wrapper for void mfem::VectorArrayCoefficient::Set(int, mfem::Coefficient *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorArrayCoefficient::Set(int, mfem::Coefficient *, bool)
    // defined in mfem/fem/coefficient.hpp:799:9
    t.method("Set", static_cast<void (mfem::VectorArrayCoefficient::*)(int, mfem::Coefficient *, bool) >(&mfem::VectorArrayCoefficient::Set));
    t.method("Set", [](mfem::VectorArrayCoefficient& a, int arg0, mfem::Coefficient * arg1)->void{ a.Set(arg0, arg1); });
    t.method("Set", [](mfem::VectorArrayCoefficient* a, int arg0, mfem::Coefficient * arg1)->void{ a->Set(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for double mfem::VectorArrayCoefficient::Eval(int, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorArrayCoefficient::Eval(int, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:803:11
    t.method("Eval", static_cast<double (mfem::VectorArrayCoefficient::*)(int, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorArrayCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorArrayCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorArrayCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:809:17
    t.method("Eval", static_cast<void (mfem::VectorArrayCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorArrayCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorArrayCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorArrayCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorArrayCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorGridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorGridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorGridFunctionCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_VectorGridFunctionCoefficient: public Wrapper {

  Jlmfem_VectorGridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorGridFunctionCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:817:7
    jlcxx::TypeWrapper<mfem::VectorGridFunctionCoefficient>  t = jlModule.add_type<mfem::VectorGridFunctionCoefficient>("mfem!VectorGridFunctionCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorGridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorGridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::VectorGridFunctionCoefficient(const mfem::GridFunction *) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:829:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in mfem/fem/coefficient.hpp:833:9
    t.method("SetGridFunction", static_cast<void (mfem::VectorGridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::VectorGridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::VectorGridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::VectorGridFunctionCoefficient::GetGridFunction()
    // defined in mfem/fem/coefficient.hpp:836:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::VectorGridFunctionCoefficient::*)()  const>(&mfem::VectorGridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:839:17
    t.method("Eval", static_cast<void (mfem::VectorGridFunctionCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorGridFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorGridFunctionCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &)
    // defined in mfem/fem/coefficient.hpp:845:17
    t.method("Eval", static_cast<void (mfem::VectorGridFunctionCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) >(&mfem::VectorGridFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorGridFunctionCoefficient::Project(mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:853:17
    t.method("Project", static_cast<void (mfem::VectorGridFunctionCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::VectorGridFunctionCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorGridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorGridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorGridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GradientGridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GradientGridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::GradientGridFunctionCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_GradientGridFunctionCoefficient: public Wrapper {

  Jlmfem_GradientGridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GradientGridFunctionCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:859:7
    jlcxx::TypeWrapper<mfem::GradientGridFunctionCoefficient>  t = jlModule.add_type<mfem::GradientGridFunctionCoefficient>("mfem!GradientGridFunctionCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GradientGridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::GradientGridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::GradientGridFunctionCoefficient::GradientGridFunctionCoefficient(const mfem::GridFunction *) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:868:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::GradientGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in mfem/fem/coefficient.hpp:871:9
    t.method("SetGridFunction", static_cast<void (mfem::GradientGridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::GradientGridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::GradientGridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::GradientGridFunctionCoefficient::GetGridFunction()
    // defined in mfem/fem/coefficient.hpp:874:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::GradientGridFunctionCoefficient::*)()  const>(&mfem::GradientGridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::GradientGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:877:17
    t.method("Eval", static_cast<void (mfem::GradientGridFunctionCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::GradientGridFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::GradientGridFunctionCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientGridFunctionCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &)
    // defined in mfem/fem/coefficient.hpp:883:17
    t.method("Eval", static_cast<void (mfem::GradientGridFunctionCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) >(&mfem::GradientGridFunctionCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GradientGridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GradientGridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GradientGridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CurlGridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CurlGridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CurlGridFunctionCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_CurlGridFunctionCoefficient: public Wrapper {

  Jlmfem_CurlGridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CurlGridFunctionCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:890:7
    jlcxx::TypeWrapper<mfem::CurlGridFunctionCoefficient>  t = jlModule.add_type<mfem::CurlGridFunctionCoefficient>("mfem!CurlGridFunctionCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CurlGridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::CurlGridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::CurlGridFunctionCoefficient::CurlGridFunctionCoefficient(const mfem::GridFunction *) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:898:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::CurlGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in mfem/fem/coefficient.hpp:901:9
    t.method("SetGridFunction", static_cast<void (mfem::CurlGridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::CurlGridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::CurlGridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::CurlGridFunctionCoefficient::GetGridFunction()
    // defined in mfem/fem/coefficient.hpp:904:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::CurlGridFunctionCoefficient::*)()  const>(&mfem::CurlGridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::CurlGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:908:17
    t.method("Eval", static_cast<void (mfem::CurlGridFunctionCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CurlGridFunctionCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CurlGridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CurlGridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CurlGridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DivergenceGridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DivergenceGridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::DivergenceGridFunctionCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_DivergenceGridFunctionCoefficient: public Wrapper {

  Jlmfem_DivergenceGridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DivergenceGridFunctionCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:915:7
    jlcxx::TypeWrapper<mfem::DivergenceGridFunctionCoefficient>  t = jlModule.add_type<mfem::DivergenceGridFunctionCoefficient>("mfem!DivergenceGridFunctionCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DivergenceGridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::DivergenceGridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DivergenceGridFunctionCoefficient::DivergenceGridFunctionCoefficient(const mfem::GridFunction *) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:923:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::DivergenceGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DivergenceGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in mfem/fem/coefficient.hpp:926:9
    t.method("SetGridFunction", static_cast<void (mfem::DivergenceGridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::DivergenceGridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::DivergenceGridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::DivergenceGridFunctionCoefficient::GetGridFunction()
    // defined in mfem/fem/coefficient.hpp:929:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::DivergenceGridFunctionCoefficient::*)()  const>(&mfem::DivergenceGridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for double mfem::DivergenceGridFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DivergenceGridFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:932:19
    t.method("Eval", static_cast<double (mfem::DivergenceGridFunctionCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::DivergenceGridFunctionCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DivergenceGridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DivergenceGridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DivergenceGridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorDeltaCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorDeltaCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorDeltaCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_VectorDeltaCoefficient: public Wrapper {

  Jlmfem_VectorDeltaCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorDeltaCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:943:7
    jlcxx::TypeWrapper<mfem::VectorDeltaCoefficient>  t = jlModule.add_type<mfem::VectorDeltaCoefficient>("mfem!VectorDeltaCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDeltaCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorDeltaCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:951:4
    t.constructor<int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(const mfem::Vector &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:956:4
    t.constructor<const mfem::Vector &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(const mfem::Vector &, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:961:4
    t.constructor<const mfem::Vector &, double, double>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(const mfem::Vector &, double, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:966:4
    t.constructor<const mfem::Vector &, double, double, double>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(const mfem::Vector &, double, double, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:971:4
    t.constructor<const mfem::Vector &, double, double, double, double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:976:9
    t.method("SetTime", static_cast<void (mfem::VectorDeltaCoefficient::*)(double) >(&mfem::VectorDeltaCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetDeltaCoefficient(const mfem::DeltaCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetDeltaCoefficient(const mfem::DeltaCoefficient &)
    // defined in mfem/fem/coefficient.hpp:981:9
    t.method("SetDeltaCoefficient", static_cast<void (mfem::VectorDeltaCoefficient::*)(const mfem::DeltaCoefficient &) >(&mfem::VectorDeltaCoefficient::SetDeltaCoefficient));

    DEBUG_MSG("Adding wrapper for mfem::DeltaCoefficient & mfem::VectorDeltaCoefficient::GetDeltaCoefficient() (" __HERE__ ")");
    // signature to use in the veto list: mfem::DeltaCoefficient & mfem::VectorDeltaCoefficient::GetDeltaCoefficient()
    // defined in mfem/fem/coefficient.hpp:984:22
    t.method("GetDeltaCoefficient", static_cast<mfem::DeltaCoefficient & (mfem::VectorDeltaCoefficient::*)() >(&mfem::VectorDeltaCoefficient::GetDeltaCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetScale(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetScale(double)
    // defined in mfem/fem/coefficient.hpp:986:9
    t.method("SetScale", static_cast<void (mfem::VectorDeltaCoefficient::*)(double) >(&mfem::VectorDeltaCoefficient::SetScale));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetDirection(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetDirection(const mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:987:9
    t.method("SetDirection", static_cast<void (mfem::VectorDeltaCoefficient::*)(const mfem::Vector &) >(&mfem::VectorDeltaCoefficient::SetDirection));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetDeltaCenter(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetDeltaCenter(const mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:989:9
    t.method("SetDeltaCenter", static_cast<void (mfem::VectorDeltaCoefficient::*)(const mfem::Vector &) >(&mfem::VectorDeltaCoefficient::SetDeltaCenter));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::GetDeltaCenter(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::GetDeltaCenter(mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:990:9
    t.method("GetDeltaCenter", static_cast<void (mfem::VectorDeltaCoefficient::*)(mfem::Vector &) >(&mfem::VectorDeltaCoefficient::GetDeltaCenter));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::EvalDelta(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::EvalDelta(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:995:17
    t.method("EvalDelta", static_cast<void (mfem::VectorDeltaCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorDeltaCoefficient::EvalDelta));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1001:17
    t.method("Eval", static_cast<void (mfem::VectorDeltaCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorDeltaCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDeltaCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorDeltaCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorDeltaCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorRestrictedCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorRestrictedCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorRestrictedCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_VectorRestrictedCoefficient: public Wrapper {

  Jlmfem_VectorRestrictedCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorRestrictedCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1009:7
    jlcxx::TypeWrapper<mfem::VectorRestrictedCoefficient>  t = jlModule.add_type<mfem::VectorRestrictedCoefficient>("mfem!VectorRestrictedCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorRestrictedCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorRestrictedCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::VectorRestrictedCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRestrictedCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1024:9
    t.method("SetTime", static_cast<void (mfem::VectorRestrictedCoefficient::*)(double) >(&mfem::VectorRestrictedCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorRestrictedCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRestrictedCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1027:17
    t.method("Eval", static_cast<void (mfem::VectorRestrictedCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorRestrictedCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorRestrictedCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRestrictedCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &)
    // defined in mfem/fem/coefficient.hpp:1033:17
    t.method("Eval", static_cast<void (mfem::VectorRestrictedCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) >(&mfem::VectorRestrictedCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorRestrictedCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorRestrictedCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorRestrictedCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixCoefficient> : std::false_type { };
}

struct Jlmfem_MatrixCoefficient: public Wrapper {

  Jlmfem_MatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1040:7
    jlcxx::TypeWrapper<mfem::MatrixCoefficient>  t = jlModule.add_type<mfem::MatrixCoefficient>("mfem!MatrixCoefficient");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;



    DEBUG_MSG("Adding wrapper for void mfem::MatrixCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1057:17
    t.method("SetTime", static_cast<void (mfem::MatrixCoefficient::*)(double) >(&mfem::MatrixCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::MatrixCoefficient::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::MatrixCoefficient::GetTime()
    // defined in mfem/fem/coefficient.hpp:1060:11
    t.method("GetTime", static_cast<double (mfem::MatrixCoefficient::*)() >(&mfem::MatrixCoefficient::GetTime));

    DEBUG_MSG("Adding wrapper for int mfem::MatrixCoefficient::GetHeight() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MatrixCoefficient::GetHeight()
    // defined in mfem/fem/coefficient.hpp:1063:8
    t.method("GetHeight", static_cast<int (mfem::MatrixCoefficient::*)()  const>(&mfem::MatrixCoefficient::GetHeight));

    DEBUG_MSG("Adding wrapper for int mfem::MatrixCoefficient::GetWidth() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MatrixCoefficient::GetWidth()
    // defined in mfem/fem/coefficient.hpp:1066:8
    t.method("GetWidth", static_cast<int (mfem::MatrixCoefficient::*)()  const>(&mfem::MatrixCoefficient::GetWidth));

    DEBUG_MSG("Adding wrapper for int mfem::MatrixCoefficient::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MatrixCoefficient::GetVDim()
    // defined in mfem/fem/coefficient.hpp:1069:8
    t.method("GetVDim", static_cast<int (mfem::MatrixCoefficient::*)()  const>(&mfem::MatrixCoefficient::GetVDim));

    DEBUG_MSG("Adding wrapper for bool mfem::MatrixCoefficient::IsSymmetric() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MatrixCoefficient::IsSymmetric()
    // defined in mfem/fem/coefficient.hpp:1072:9
    t.method("IsSymmetric", static_cast<bool (mfem::MatrixCoefficient::*)()  const>(&mfem::MatrixCoefficient::IsSymmetric));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1079:17
    t.method("Eval", static_cast<void (mfem::MatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixCoefficient::Project(mfem::QuadratureFunction &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixCoefficient::Project(mfem::QuadratureFunction &, bool)
    // defined in mfem/fem/coefficient.hpp:1088:17
    t.method("Project", static_cast<void (mfem::MatrixCoefficient::*)(mfem::QuadratureFunction &, bool) >(&mfem::MatrixCoefficient::Project));
    t.method("Project", [](mfem::MatrixCoefficient& a, mfem::QuadratureFunction & arg0)->void{ a.Project(arg0); });
    t.method("Project", [](mfem::MatrixCoefficient* a, mfem::QuadratureFunction & arg0)->void{ a->Project(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::MatrixCoefficient::EvalSymmetric(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixCoefficient::EvalSymmetric(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1097:17
    t.method("EvalSymmetric", static_cast<void (mfem::MatrixCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixCoefficient::EvalSymmetric));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixConstantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixConstantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixConstantCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_MatrixConstantCoefficient: public Wrapper {

  Jlmfem_MatrixConstantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixConstantCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1106:7
    jlcxx::TypeWrapper<mfem::MatrixConstantCoefficient>  t = jlModule.add_type<mfem::MatrixConstantCoefficient>("mfem!MatrixConstantCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixConstantCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixConstantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixConstantCoefficient::MatrixConstantCoefficient(const mfem::DenseMatrix &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1112:4
    t.constructor<const mfem::DenseMatrix &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixConstantCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixConstantCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1116:17
    t.method("Eval", static_cast<void (mfem::MatrixConstantCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixConstantCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for const mfem::DenseMatrix & mfem::MatrixConstantCoefficient::GetMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::DenseMatrix & mfem::MatrixConstantCoefficient::GetMatrix()
    // defined in mfem/fem/coefficient.hpp:1119:23
    t.method("GetMatrix", static_cast<const mfem::DenseMatrix & (mfem::MatrixConstantCoefficient::*)() >(&mfem::MatrixConstantCoefficient::GetMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixConstantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixConstantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixConstantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PWMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PWMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PWMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_PWMatrixCoefficient: public Wrapper {

  Jlmfem_PWMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PWMatrixCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1140:7
    jlcxx::TypeWrapper<mfem::PWMatrixCoefficient>  t = jlModule.add_type<mfem::PWMatrixCoefficient>("mfem!PWMatrixCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PWMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::PWMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::PWMatrixCoefficient(int, bool) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1169:13
    t.constructor<int>(/*finalize=*/true);
    t.constructor<int, bool>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::PWMatrixCoefficient(int, int, bool) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1173:13
    t.constructor<int, int>(/*finalize=*/true);
    t.constructor<int, int, bool>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWMatrixCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1210:17
    t.method("SetTime", static_cast<void (mfem::PWMatrixCoefficient::*)(double) >(&mfem::PWMatrixCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::UpdateCoefficient(int, mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWMatrixCoefficient::UpdateCoefficient(int, mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1218:9
    t.method("UpdateCoefficient", static_cast<void (mfem::PWMatrixCoefficient::*)(int, mfem::MatrixCoefficient &) >(&mfem::PWMatrixCoefficient::UpdateCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::ZeroCoefficient(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWMatrixCoefficient::ZeroCoefficient(int)
    // defined in mfem/fem/coefficient.hpp:1221:9
    t.method("ZeroCoefficient", static_cast<void (mfem::PWMatrixCoefficient::*)(int) >(&mfem::PWMatrixCoefficient::ZeroCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1225:17
    t.method("Eval", static_cast<void (mfem::PWMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PWMatrixCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PWMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PWMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PWMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixArrayCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixArrayCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixArrayCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_MatrixArrayCoefficient: public Wrapper {

  Jlmfem_MatrixArrayCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixArrayCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1301:7
    jlcxx::TypeWrapper<mfem::MatrixArrayCoefficient>  t = jlModule.add_type<mfem::MatrixArrayCoefficient>("mfem!MatrixArrayCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixArrayCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixArrayCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixArrayCoefficient::MatrixArrayCoefficient(int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1310:13
    t.constructor<int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixArrayCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixArrayCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1313:9
    t.method("SetTime", static_cast<void (mfem::MatrixArrayCoefficient::*)(double) >(&mfem::MatrixArrayCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::MatrixArrayCoefficient::GetCoeff(int, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::MatrixArrayCoefficient::GetCoeff(int, int)
    // defined in mfem/fem/coefficient.hpp:1316:17
    t.method("GetCoeff", static_cast<mfem::Coefficient * (mfem::MatrixArrayCoefficient::*)(int, int) >(&mfem::MatrixArrayCoefficient::GetCoeff));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixArrayCoefficient::Set(int, int, mfem::Coefficient *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixArrayCoefficient::Set(int, int, mfem::Coefficient *, bool)
    // defined in mfem/fem/coefficient.hpp:1321:9
    t.method("Set", static_cast<void (mfem::MatrixArrayCoefficient::*)(int, int, mfem::Coefficient *, bool) >(&mfem::MatrixArrayCoefficient::Set));
    t.method("Set", [](mfem::MatrixArrayCoefficient& a, int arg0, int arg1, mfem::Coefficient * arg2)->void{ a.Set(arg0, arg1, arg2); });
    t.method("Set", [](mfem::MatrixArrayCoefficient* a, int arg0, int arg1, mfem::Coefficient * arg2)->void{ a->Set(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for double mfem::MatrixArrayCoefficient::Eval(int, int, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::MatrixArrayCoefficient::Eval(int, int, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1327:11
    t.method("Eval", static_cast<double (mfem::MatrixArrayCoefficient::*)(int, int, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixArrayCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixArrayCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixArrayCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1331:17
    t.method("Eval", static_cast<void (mfem::MatrixArrayCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixArrayCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixArrayCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixArrayCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixArrayCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixRestrictedCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixRestrictedCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixRestrictedCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_MatrixRestrictedCoefficient: public Wrapper {

  Jlmfem_MatrixRestrictedCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixRestrictedCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1340:7
    jlcxx::TypeWrapper<mfem::MatrixRestrictedCoefficient>  t = jlModule.add_type<mfem::MatrixRestrictedCoefficient>("mfem!MatrixRestrictedCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixRestrictedCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixRestrictedCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::MatrixRestrictedCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixRestrictedCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1355:9
    t.method("SetTime", static_cast<void (mfem::MatrixRestrictedCoefficient::*)(double) >(&mfem::MatrixRestrictedCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixRestrictedCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixRestrictedCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1358:17
    t.method("Eval", static_cast<void (mfem::MatrixRestrictedCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixRestrictedCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixRestrictedCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixRestrictedCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixRestrictedCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SumCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SumCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SumCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_SumCoefficient: public Wrapper {

  Jlmfem_SumCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SumCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1366:7
    jlcxx::TypeWrapper<mfem::SumCoefficient>  t = jlModule.add_type<mfem::SumCoefficient>("mfem!SumCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SumCoefficient>>(new jlcxx::TypeWrapper<mfem::SumCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SumCoefficient(double, mfem::Coefficient &, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1378:4
    t.constructor<double, mfem::Coefficient &>(/*finalize=*/true);
    t.constructor<double, mfem::Coefficient &, double>(/*finalize=*/true);
    t.constructor<double, mfem::Coefficient &, double, double>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SumCoefficient(mfem::Coefficient &, mfem::Coefficient &, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1383:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/true);
    t.constructor<mfem::Coefficient &, mfem::Coefficient &, double>(/*finalize=*/true);
    t.constructor<mfem::Coefficient &, mfem::Coefficient &, double, double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1388:9
    t.method("SetTime", static_cast<void (mfem::SumCoefficient::*)(double) >(&mfem::SumCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetAConst(double)
    // defined in mfem/fem/coefficient.hpp:1391:9
    t.method("SetAConst", static_cast<void (mfem::SumCoefficient::*)(double) >(&mfem::SumCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::SumCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SumCoefficient::GetAConst()
    // defined in mfem/fem/coefficient.hpp:1393:11
    t.method("GetAConst", static_cast<double (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetACoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1396:9
    t.method("SetACoef", static_cast<void (mfem::SumCoefficient::*)(mfem::Coefficient &) >(&mfem::SumCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::SumCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::SumCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1398:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetBCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetBCoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1401:9
    t.method("SetBCoef", static_cast<void (mfem::SumCoefficient::*)(mfem::Coefficient &) >(&mfem::SumCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::SumCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::SumCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1403:18
    t.method("GetBCoef", static_cast<mfem::Coefficient * (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetAlpha(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetAlpha(double)
    // defined in mfem/fem/coefficient.hpp:1406:9
    t.method("SetAlpha", static_cast<void (mfem::SumCoefficient::*)(double) >(&mfem::SumCoefficient::SetAlpha));

    DEBUG_MSG("Adding wrapper for double mfem::SumCoefficient::GetAlpha() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SumCoefficient::GetAlpha()
    // defined in mfem/fem/coefficient.hpp:1408:11
    t.method("GetAlpha", static_cast<double (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetAlpha));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetBeta(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetBeta(double)
    // defined in mfem/fem/coefficient.hpp:1411:9
    t.method("SetBeta", static_cast<void (mfem::SumCoefficient::*)(double) >(&mfem::SumCoefficient::SetBeta));

    DEBUG_MSG("Adding wrapper for double mfem::SumCoefficient::GetBeta() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SumCoefficient::GetBeta()
    // defined in mfem/fem/coefficient.hpp:1413:11
    t.method("GetBeta", static_cast<double (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetBeta));

    DEBUG_MSG("Adding wrapper for double mfem::SumCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SumCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1416:19
    t.method("Eval", static_cast<double (mfem::SumCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SumCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SumCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SumCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SumCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SymmetricMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SymmetricMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SymmetricMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_SymmetricMatrixCoefficient: public Wrapper {

  Jlmfem_SymmetricMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SymmetricMatrixCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1426:7
    jlcxx::TypeWrapper<mfem::SymmetricMatrixCoefficient>  t = jlModule.add_type<mfem::SymmetricMatrixCoefficient>("mfem!SymmetricMatrixCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SymmetricMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::SymmetricMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for int mfem::SymmetricMatrixCoefficient::GetSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SymmetricMatrixCoefficient::GetSize()
    // defined in mfem/fem/coefficient.hpp:1437:8
    t.method("GetSize", static_cast<int (mfem::SymmetricMatrixCoefficient::*)()  const>(&mfem::SymmetricMatrixCoefficient::GetSize));

    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixCoefficient::ProjectSymmetric(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SymmetricMatrixCoefficient::ProjectSymmetric(mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:1446:17
    t.method("ProjectSymmetric", static_cast<void (mfem::SymmetricMatrixCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::SymmetricMatrixCoefficient::ProjectSymmetric));

    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixCoefficient::Eval(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SymmetricMatrixCoefficient::Eval(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1453:17
    t.method("Eval", static_cast<void (mfem::SymmetricMatrixCoefficient::*)(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SymmetricMatrixCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SymmetricMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1464:17
    t.method("Eval", static_cast<void (mfem::SymmetricMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SymmetricMatrixCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for const mfem::DenseSymmetricMatrix & mfem::SymmetricMatrixCoefficient::GetMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::DenseSymmetricMatrix & mfem::SymmetricMatrixCoefficient::GetMatrix()
    // defined in mfem/fem/coefficient.hpp:1468:32
    t.method("GetMatrix", static_cast<const mfem::DenseSymmetricMatrix & (mfem::SymmetricMatrixCoefficient::*)() >(&mfem::SymmetricMatrixCoefficient::GetMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SymmetricMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SymmetricMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SymmetricMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DenseSymmetricMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DenseSymmetricMatrix> : std::false_type { };
}

struct Jlmfem_DenseSymmetricMatrix: public Wrapper {

  Jlmfem_DenseSymmetricMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DenseSymmetricMatrix (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../linalg/symmat.hpp:24:7
    jlcxx::TypeWrapper<mfem::DenseSymmetricMatrix>  t = jlModule.add_type<mfem::DenseSymmetricMatrix>("mfem!DenseSymmetricMatrix");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseSymmetricMatrix>>(new jlcxx::TypeWrapper<mfem::DenseSymmetricMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseSymmetricMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DenseSymmetricMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DenseSymmetricMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SymmetricMatrixConstantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SymmetricMatrixConstantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SymmetricMatrixConstantCoefficient> { typedef mfem::SymmetricMatrixCoefficient type; };
}

struct Jlmfem_SymmetricMatrixConstantCoefficient: public Wrapper {

  Jlmfem_SymmetricMatrixConstantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SymmetricMatrixConstantCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1475:7
    jlcxx::TypeWrapper<mfem::SymmetricMatrixConstantCoefficient>  t = jlModule.add_type<mfem::SymmetricMatrixConstantCoefficient>("mfem!SymmetricMatrixConstantCoefficient"    , jlcxx::julia_base_type<mfem::SymmetricMatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SymmetricMatrixConstantCoefficient>>(new jlcxx::TypeWrapper<mfem::SymmetricMatrixConstantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixConstantCoefficient::SymmetricMatrixConstantCoefficient(const mfem::DenseSymmetricMatrix &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1482:4
    t.constructor<const mfem::DenseSymmetricMatrix &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixConstantCoefficient::Eval(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SymmetricMatrixConstantCoefficient::Eval(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1486:17
    t.method("Eval", static_cast<void (mfem::SymmetricMatrixConstantCoefficient::*)(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SymmetricMatrixConstantCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SymmetricMatrixConstantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SymmetricMatrixConstantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SymmetricMatrixConstantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ProductCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_ProductCoefficient: public Wrapper {

  Jlmfem_ProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1546:7
    jlcxx::TypeWrapper<mfem::ProductCoefficient>  t = jlModule.add_type<mfem::ProductCoefficient>("mfem!ProductCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductCoefficient>>(new jlcxx::TypeWrapper<mfem::ProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::ProductCoefficient(double, mfem::Coefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1555:4
    t.constructor<double, mfem::Coefficient &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::ProductCoefficient(mfem::Coefficient &, mfem::Coefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1559:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1563:9
    t.method("SetTime", static_cast<void (mfem::ProductCoefficient::*)(double) >(&mfem::ProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductCoefficient::SetAConst(double)
    // defined in mfem/fem/coefficient.hpp:1566:9
    t.method("SetAConst", static_cast<void (mfem::ProductCoefficient::*)(double) >(&mfem::ProductCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::ProductCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ProductCoefficient::GetAConst()
    // defined in mfem/fem/coefficient.hpp:1568:11
    t.method("GetAConst", static_cast<double (mfem::ProductCoefficient::*)()  const>(&mfem::ProductCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductCoefficient::SetACoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1571:9
    t.method("SetACoef", static_cast<void (mfem::ProductCoefficient::*)(mfem::Coefficient &) >(&mfem::ProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::ProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::ProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1573:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::ProductCoefficient::*)()  const>(&mfem::ProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::SetBCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductCoefficient::SetBCoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1576:9
    t.method("SetBCoef", static_cast<void (mfem::ProductCoefficient::*)(mfem::Coefficient &) >(&mfem::ProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::ProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::ProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1578:18
    t.method("GetBCoef", static_cast<mfem::Coefficient * (mfem::ProductCoefficient::*)()  const>(&mfem::ProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for double mfem::ProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1581:19
    t.method("Eval", static_cast<double (mfem::ProductCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RatioCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RatioCoefficient> : std::false_type { };
template<> struct SuperType<mfem::RatioCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_RatioCoefficient: public Wrapper {

  Jlmfem_RatioCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RatioCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1588:7
    jlcxx::TypeWrapper<mfem::RatioCoefficient>  t = jlModule.add_type<mfem::RatioCoefficient>("mfem!RatioCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RatioCoefficient>>(new jlcxx::TypeWrapper<mfem::RatioCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::RatioCoefficient(double, mfem::Coefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1599:4
    t.constructor<double, mfem::Coefficient &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::RatioCoefficient(mfem::Coefficient &, mfem::Coefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1603:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::RatioCoefficient(mfem::Coefficient &, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1607:4
    t.constructor<mfem::Coefficient &, double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1611:9
    t.method("SetTime", static_cast<void (mfem::RatioCoefficient::*)(double) >(&mfem::RatioCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetAConst(double)
    // defined in mfem/fem/coefficient.hpp:1614:9
    t.method("SetAConst", static_cast<void (mfem::RatioCoefficient::*)(double) >(&mfem::RatioCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::RatioCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::RatioCoefficient::GetAConst()
    // defined in mfem/fem/coefficient.hpp:1616:11
    t.method("GetAConst", static_cast<double (mfem::RatioCoefficient::*)()  const>(&mfem::RatioCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetBConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetBConst(double)
    // defined in mfem/fem/coefficient.hpp:1619:9
    t.method("SetBConst", static_cast<void (mfem::RatioCoefficient::*)(double) >(&mfem::RatioCoefficient::SetBConst));

    DEBUG_MSG("Adding wrapper for double mfem::RatioCoefficient::GetBConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::RatioCoefficient::GetBConst()
    // defined in mfem/fem/coefficient.hpp:1621:11
    t.method("GetBConst", static_cast<double (mfem::RatioCoefficient::*)()  const>(&mfem::RatioCoefficient::GetBConst));

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetACoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1624:9
    t.method("SetACoef", static_cast<void (mfem::RatioCoefficient::*)(mfem::Coefficient &) >(&mfem::RatioCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::RatioCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::RatioCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1626:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::RatioCoefficient::*)()  const>(&mfem::RatioCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetBCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetBCoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1629:9
    t.method("SetBCoef", static_cast<void (mfem::RatioCoefficient::*)(mfem::Coefficient &) >(&mfem::RatioCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::RatioCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::RatioCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1631:18
    t.method("GetBCoef", static_cast<mfem::Coefficient * (mfem::RatioCoefficient::*)()  const>(&mfem::RatioCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for double mfem::RatioCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::RatioCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1634:19
    t.method("Eval", static_cast<double (mfem::RatioCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::RatioCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RatioCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RatioCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RatioCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PowerCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PowerCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PowerCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_PowerCoefficient: public Wrapper {

  Jlmfem_PowerCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PowerCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1644:7
    jlcxx::TypeWrapper<mfem::PowerCoefficient>  t = jlModule.add_type<mfem::PowerCoefficient>("mfem!PowerCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PowerCoefficient>>(new jlcxx::TypeWrapper<mfem::PowerCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::PowerCoefficient::PowerCoefficient(mfem::Coefficient &, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1653:4
    t.constructor<mfem::Coefficient &, double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::PowerCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PowerCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1657:9
    t.method("SetTime", static_cast<void (mfem::PowerCoefficient::*)(double) >(&mfem::PowerCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::PowerCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PowerCoefficient::SetACoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1660:9
    t.method("SetACoef", static_cast<void (mfem::PowerCoefficient::*)(mfem::Coefficient &) >(&mfem::PowerCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::PowerCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::PowerCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1662:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::PowerCoefficient::*)()  const>(&mfem::PowerCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::PowerCoefficient::SetExponent(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PowerCoefficient::SetExponent(double)
    // defined in mfem/fem/coefficient.hpp:1665:9
    t.method("SetExponent", static_cast<void (mfem::PowerCoefficient::*)(double) >(&mfem::PowerCoefficient::SetExponent));

    DEBUG_MSG("Adding wrapper for double mfem::PowerCoefficient::GetExponent() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PowerCoefficient::GetExponent()
    // defined in mfem/fem/coefficient.hpp:1667:11
    t.method("GetExponent", static_cast<double (mfem::PowerCoefficient::*)()  const>(&mfem::PowerCoefficient::GetExponent));

    DEBUG_MSG("Adding wrapper for double mfem::PowerCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PowerCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1670:19
    t.method("Eval", static_cast<double (mfem::PowerCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PowerCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PowerCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PowerCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PowerCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InnerProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InnerProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::InnerProductCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_InnerProductCoefficient: public Wrapper {

  Jlmfem_InnerProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InnerProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1677:7
    jlcxx::TypeWrapper<mfem::InnerProductCoefficient>  t = jlModule.add_type<mfem::InnerProductCoefficient>("mfem!InnerProductCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InnerProductCoefficient>>(new jlcxx::TypeWrapper<mfem::InnerProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::InnerProductCoefficient::InnerProductCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1687:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::InnerProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InnerProductCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1690:9
    t.method("SetTime", static_cast<void (mfem::InnerProductCoefficient::*)(double) >(&mfem::InnerProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::InnerProductCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InnerProductCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1693:9
    t.method("SetACoef", static_cast<void (mfem::InnerProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::InnerProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::InnerProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::InnerProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1695:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::InnerProductCoefficient::*)()  const>(&mfem::InnerProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::InnerProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InnerProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1698:9
    t.method("SetBCoef", static_cast<void (mfem::InnerProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::InnerProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::InnerProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::InnerProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1700:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::InnerProductCoefficient::*)()  const>(&mfem::InnerProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for double mfem::InnerProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::InnerProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1703:19
    t.method("Eval", static_cast<double (mfem::InnerProductCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::InnerProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InnerProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InnerProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InnerProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorRotProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorRotProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorRotProductCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_VectorRotProductCoefficient: public Wrapper {

  Jlmfem_VectorRotProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorRotProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1708:7
    jlcxx::TypeWrapper<mfem::VectorRotProductCoefficient>  t = jlModule.add_type<mfem::VectorRotProductCoefficient>("mfem!VectorRotProductCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorRotProductCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorRotProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorRotProductCoefficient::VectorRotProductCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1719:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VectorRotProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRotProductCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1722:9
    t.method("SetTime", static_cast<void (mfem::VectorRotProductCoefficient::*)(double) >(&mfem::VectorRotProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorRotProductCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRotProductCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1725:9
    t.method("SetACoef", static_cast<void (mfem::VectorRotProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorRotProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorRotProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorRotProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1727:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::VectorRotProductCoefficient::*)()  const>(&mfem::VectorRotProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorRotProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRotProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1730:9
    t.method("SetBCoef", static_cast<void (mfem::VectorRotProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorRotProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorRotProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorRotProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1732:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::VectorRotProductCoefficient::*)()  const>(&mfem::VectorRotProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for double mfem::VectorRotProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorRotProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1735:19
    t.method("Eval", static_cast<double (mfem::VectorRotProductCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorRotProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorRotProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorRotProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorRotProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DeterminantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DeterminantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::DeterminantCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_DeterminantCoefficient: public Wrapper {

  Jlmfem_DeterminantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DeterminantCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1740:7
    jlcxx::TypeWrapper<mfem::DeterminantCoefficient>  t = jlModule.add_type<mfem::DeterminantCoefficient>("mfem!DeterminantCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DeterminantCoefficient>>(new jlcxx::TypeWrapper<mfem::DeterminantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DeterminantCoefficient::DeterminantCoefficient(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1749:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::DeterminantCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeterminantCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1752:9
    t.method("SetTime", static_cast<void (mfem::DeterminantCoefficient::*)(double) >(&mfem::DeterminantCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::DeterminantCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeterminantCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1755:9
    t.method("SetACoef", static_cast<void (mfem::DeterminantCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::DeterminantCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::DeterminantCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::DeterminantCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1757:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::DeterminantCoefficient::*)()  const>(&mfem::DeterminantCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for double mfem::DeterminantCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeterminantCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1760:19
    t.method("Eval", static_cast<double (mfem::DeterminantCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::DeterminantCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DeterminantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DeterminantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DeterminantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorSumCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorSumCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorSumCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_VectorSumCoefficient: public Wrapper {

  Jlmfem_VectorSumCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorSumCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1765:7
    jlcxx::TypeWrapper<mfem::VectorSumCoefficient>  t = jlModule.add_type<mfem::VectorSumCoefficient>("mfem!VectorSumCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorSumCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorSumCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::VectorSumCoefficient(int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1785:4
    t.constructor<int>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::VectorSumCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1789:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/true);
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &, double>(/*finalize=*/true);
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &, double, double>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::VectorSumCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &, mfem::Coefficient &, mfem::Coefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1794:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &, mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1798:9
    t.method("SetTime", static_cast<void (mfem::VectorSumCoefficient::*)(double) >(&mfem::VectorSumCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1801:9
    t.method("SetACoef", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorSumCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorSumCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorSumCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1803:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1806:9
    t.method("SetBCoef", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorSumCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorSumCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorSumCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1808:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetAlphaCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetAlphaCoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1811:9
    t.method("SetAlphaCoef", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::Coefficient &) >(&mfem::VectorSumCoefficient::SetAlphaCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::VectorSumCoefficient::GetAlphaCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::VectorSumCoefficient::GetAlphaCoef()
    // defined in mfem/fem/coefficient.hpp:1813:18
    t.method("GetAlphaCoef", static_cast<mfem::Coefficient * (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetAlphaCoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetBetaCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetBetaCoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1816:9
    t.method("SetBetaCoef", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::Coefficient &) >(&mfem::VectorSumCoefficient::SetBetaCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::VectorSumCoefficient::GetBetaCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::VectorSumCoefficient::GetBetaCoef()
    // defined in mfem/fem/coefficient.hpp:1818:18
    t.method("GetBetaCoef", static_cast<mfem::Coefficient * (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetBetaCoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetA(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetA(const mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:1821:9
    t.method("SetA", static_cast<void (mfem::VectorSumCoefficient::*)(const mfem::Vector &) >(&mfem::VectorSumCoefficient::SetA));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::VectorSumCoefficient::GetA() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::VectorSumCoefficient::GetA()
    // defined in mfem/fem/coefficient.hpp:1823:19
    t.method("GetA", static_cast<const mfem::Vector & (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetB(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetB(const mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:1826:9
    t.method("SetB", static_cast<void (mfem::VectorSumCoefficient::*)(const mfem::Vector &) >(&mfem::VectorSumCoefficient::SetB));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::VectorSumCoefficient::GetB() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::VectorSumCoefficient::GetB()
    // defined in mfem/fem/coefficient.hpp:1828:19
    t.method("GetB", static_cast<const mfem::Vector & (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetB));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetAlpha(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetAlpha(double)
    // defined in mfem/fem/coefficient.hpp:1831:9
    t.method("SetAlpha", static_cast<void (mfem::VectorSumCoefficient::*)(double) >(&mfem::VectorSumCoefficient::SetAlpha));

    DEBUG_MSG("Adding wrapper for double mfem::VectorSumCoefficient::GetAlpha() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorSumCoefficient::GetAlpha()
    // defined in mfem/fem/coefficient.hpp:1833:11
    t.method("GetAlpha", static_cast<double (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetAlpha));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetBeta(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetBeta(double)
    // defined in mfem/fem/coefficient.hpp:1836:9
    t.method("SetBeta", static_cast<void (mfem::VectorSumCoefficient::*)(double) >(&mfem::VectorSumCoefficient::SetBeta));

    DEBUG_MSG("Adding wrapper for double mfem::VectorSumCoefficient::GetBeta() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorSumCoefficient::GetBeta()
    // defined in mfem/fem/coefficient.hpp:1838:11
    t.method("GetBeta", static_cast<double (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetBeta));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1841:17
    t.method("Eval", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorSumCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorSumCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorSumCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorSumCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ScalarVectorProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ScalarVectorProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ScalarVectorProductCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_ScalarVectorProductCoefficient: public Wrapper {

  Jlmfem_ScalarVectorProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ScalarVectorProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1847:7
    jlcxx::TypeWrapper<mfem::ScalarVectorProductCoefficient>  t = jlModule.add_type<mfem::ScalarVectorProductCoefficient>("mfem!ScalarVectorProductCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarVectorProductCoefficient>>(new jlcxx::TypeWrapper<mfem::ScalarVectorProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::ScalarVectorProductCoefficient(double, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1856:4
    t.constructor<double, mfem::VectorCoefficient &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::ScalarVectorProductCoefficient(mfem::Coefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1859:4
    t.constructor<mfem::Coefficient &, mfem::VectorCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1862:9
    t.method("SetTime", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(double) >(&mfem::ScalarVectorProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::SetAConst(double)
    // defined in mfem/fem/coefficient.hpp:1865:9
    t.method("SetAConst", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(double) >(&mfem::ScalarVectorProductCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::ScalarVectorProductCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ScalarVectorProductCoefficient::GetAConst()
    // defined in mfem/fem/coefficient.hpp:1867:11
    t.method("GetAConst", static_cast<double (mfem::ScalarVectorProductCoefficient::*)()  const>(&mfem::ScalarVectorProductCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::SetACoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:1870:9
    t.method("SetACoef", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(mfem::Coefficient &) >(&mfem::ScalarVectorProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::ScalarVectorProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::ScalarVectorProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1872:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::ScalarVectorProductCoefficient::*)()  const>(&mfem::ScalarVectorProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1875:9
    t.method("SetBCoef", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::ScalarVectorProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::ScalarVectorProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::ScalarVectorProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1877:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::ScalarVectorProductCoefficient::*)()  const>(&mfem::ScalarVectorProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1880:17
    t.method("Eval", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ScalarVectorProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarVectorProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ScalarVectorProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ScalarVectorProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NormalizedVectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NormalizedVectorCoefficient> : std::false_type { };
template<> struct SuperType<mfem::NormalizedVectorCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_NormalizedVectorCoefficient: public Wrapper {

  Jlmfem_NormalizedVectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NormalizedVectorCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1886:7
    jlcxx::TypeWrapper<mfem::NormalizedVectorCoefficient>  t = jlModule.add_type<mfem::NormalizedVectorCoefficient>("mfem!NormalizedVectorCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalizedVectorCoefficient>>(new jlcxx::TypeWrapper<mfem::NormalizedVectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NormalizedVectorCoefficient::NormalizedVectorCoefficient(mfem::VectorCoefficient &, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1900:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/true);
    t.constructor<mfem::VectorCoefficient &, double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::NormalizedVectorCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalizedVectorCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1903:9
    t.method("SetTime", static_cast<void (mfem::NormalizedVectorCoefficient::*)(double) >(&mfem::NormalizedVectorCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::NormalizedVectorCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalizedVectorCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1906:9
    t.method("SetACoef", static_cast<void (mfem::NormalizedVectorCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::NormalizedVectorCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::NormalizedVectorCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::NormalizedVectorCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1908:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::NormalizedVectorCoefficient::*)()  const>(&mfem::NormalizedVectorCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::NormalizedVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalizedVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1911:17
    t.method("Eval", static_cast<void (mfem::NormalizedVectorCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::NormalizedVectorCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalizedVectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NormalizedVectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NormalizedVectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorCrossProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorCrossProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorCrossProductCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_VectorCrossProductCoefficient: public Wrapper {

  Jlmfem_VectorCrossProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorCrossProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1917:7
    jlcxx::TypeWrapper<mfem::VectorCrossProductCoefficient>  t = jlModule.add_type<mfem::VectorCrossProductCoefficient>("mfem!VectorCrossProductCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCrossProductCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorCrossProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::VectorCrossProductCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1928:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1931:9
    t.method("SetTime", static_cast<void (mfem::VectorCrossProductCoefficient::*)(double) >(&mfem::VectorCrossProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1934:9
    t.method("SetACoef", static_cast<void (mfem::VectorCrossProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorCrossProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorCrossProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorCrossProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1936:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::VectorCrossProductCoefficient::*)()  const>(&mfem::VectorCrossProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1939:9
    t.method("SetBCoef", static_cast<void (mfem::VectorCrossProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorCrossProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorCrossProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorCrossProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1941:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::VectorCrossProductCoefficient::*)()  const>(&mfem::VectorCrossProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1944:17
    t.method("Eval", static_cast<void (mfem::VectorCrossProductCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorCrossProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCrossProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorCrossProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorCrossProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixVectorProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixVectorProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixVectorProductCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_MatrixVectorProductCoefficient: public Wrapper {

  Jlmfem_MatrixVectorProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixVectorProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1951:7
    jlcxx::TypeWrapper<mfem::MatrixVectorProductCoefficient>  t = jlModule.add_type<mfem::MatrixVectorProductCoefficient>("mfem!MatrixVectorProductCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixVectorProductCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixVectorProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::MatrixVectorProductCoefficient(mfem::MatrixCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1962:4
    t.constructor<mfem::MatrixCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixVectorProductCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:1965:9
    t.method("SetTime", static_cast<void (mfem::MatrixVectorProductCoefficient::*)(double) >(&mfem::MatrixVectorProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixVectorProductCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1968:9
    t.method("SetACoef", static_cast<void (mfem::MatrixVectorProductCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixVectorProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixVectorProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixVectorProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:1970:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixVectorProductCoefficient::*)()  const>(&mfem::MatrixVectorProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixVectorProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:1973:9
    t.method("SetBCoef", static_cast<void (mfem::MatrixVectorProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::MatrixVectorProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::MatrixVectorProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::MatrixVectorProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:1975:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::MatrixVectorProductCoefficient::*)()  const>(&mfem::MatrixVectorProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixVectorProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1978:17
    t.method("Eval", static_cast<void (mfem::MatrixVectorProductCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixVectorProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixVectorProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixVectorProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixVectorProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IdentityMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IdentityMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::IdentityMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_IdentityMatrixCoefficient: public Wrapper {

  Jlmfem_IdentityMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IdentityMatrixCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1987:7
    jlcxx::TypeWrapper<mfem::IdentityMatrixCoefficient>  t = jlModule.add_type<mfem::IdentityMatrixCoefficient>("mfem!IdentityMatrixCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IdentityMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::IdentityMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::IdentityMatrixCoefficient::IdentityMatrixCoefficient(int) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:1994:4
    t.constructor<int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::IdentityMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IdentityMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:1998:17
    t.method("Eval", static_cast<void (mfem::IdentityMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::IdentityMatrixCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IdentityMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IdentityMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IdentityMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixSumCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixSumCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixSumCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_MatrixSumCoefficient: public Wrapper {

  Jlmfem_MatrixSumCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixSumCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2003:7
    jlcxx::TypeWrapper<mfem::MatrixSumCoefficient>  t = jlModule.add_type<mfem::MatrixSumCoefficient>("mfem!MatrixSumCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixSumCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixSumCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::MatrixSumCoefficient(mfem::MatrixCoefficient &, mfem::MatrixCoefficient &, double, double) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2016:4
    t.constructor<mfem::MatrixCoefficient &, mfem::MatrixCoefficient &>(/*finalize=*/true);
    t.constructor<mfem::MatrixCoefficient &, mfem::MatrixCoefficient &, double>(/*finalize=*/true);
    t.constructor<mfem::MatrixCoefficient &, mfem::MatrixCoefficient &, double, double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:2020:9
    t.method("SetTime", static_cast<void (mfem::MatrixSumCoefficient::*)(double) >(&mfem::MatrixSumCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2023:9
    t.method("SetACoef", static_cast<void (mfem::MatrixSumCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixSumCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixSumCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixSumCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:2025:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixSumCoefficient::*)()  const>(&mfem::MatrixSumCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetBCoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetBCoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2028:9
    t.method("SetBCoef", static_cast<void (mfem::MatrixSumCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixSumCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixSumCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixSumCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:2030:24
    t.method("GetBCoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixSumCoefficient::*)()  const>(&mfem::MatrixSumCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetAlpha(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetAlpha(double)
    // defined in mfem/fem/coefficient.hpp:2033:9
    t.method("SetAlpha", static_cast<void (mfem::MatrixSumCoefficient::*)(double) >(&mfem::MatrixSumCoefficient::SetAlpha));

    DEBUG_MSG("Adding wrapper for double mfem::MatrixSumCoefficient::GetAlpha() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::MatrixSumCoefficient::GetAlpha()
    // defined in mfem/fem/coefficient.hpp:2035:11
    t.method("GetAlpha", static_cast<double (mfem::MatrixSumCoefficient::*)()  const>(&mfem::MatrixSumCoefficient::GetAlpha));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetBeta(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetBeta(double)
    // defined in mfem/fem/coefficient.hpp:2038:9
    t.method("SetBeta", static_cast<void (mfem::MatrixSumCoefficient::*)(double) >(&mfem::MatrixSumCoefficient::SetBeta));

    DEBUG_MSG("Adding wrapper for double mfem::MatrixSumCoefficient::GetBeta() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::MatrixSumCoefficient::GetBeta()
    // defined in mfem/fem/coefficient.hpp:2040:11
    t.method("GetBeta", static_cast<double (mfem::MatrixSumCoefficient::*)()  const>(&mfem::MatrixSumCoefficient::GetBeta));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2043:17
    t.method("Eval", static_cast<void (mfem::MatrixSumCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixSumCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixSumCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixSumCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixSumCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixProductCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_MatrixProductCoefficient: public Wrapper {

  Jlmfem_MatrixProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2048:7
    jlcxx::TypeWrapper<mfem::MatrixProductCoefficient>  t = jlModule.add_type<mfem::MatrixProductCoefficient>("mfem!MatrixProductCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixProductCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixProductCoefficient::MatrixProductCoefficient(mfem::MatrixCoefficient &, mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2059:4
    t.constructor<mfem::MatrixCoefficient &, mfem::MatrixCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixProductCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixProductCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2062:9
    t.method("SetACoef", static_cast<void (mfem::MatrixProductCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:2064:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixProductCoefficient::*)()  const>(&mfem::MatrixProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixProductCoefficient::SetBCoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixProductCoefficient::SetBCoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2067:9
    t.method("SetBCoef", static_cast<void (mfem::MatrixProductCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:2069:24
    t.method("GetBCoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixProductCoefficient::*)()  const>(&mfem::MatrixProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2072:17
    t.method("Eval", static_cast<void (mfem::MatrixProductCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ScalarMatrixProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ScalarMatrixProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ScalarMatrixProductCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_ScalarMatrixProductCoefficient: public Wrapper {

  Jlmfem_ScalarMatrixProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ScalarMatrixProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2078:7
    jlcxx::TypeWrapper<mfem::ScalarMatrixProductCoefficient>  t = jlModule.add_type<mfem::ScalarMatrixProductCoefficient>("mfem!ScalarMatrixProductCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarMatrixProductCoefficient>>(new jlcxx::TypeWrapper<mfem::ScalarMatrixProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::ScalarMatrixProductCoefficient(double, mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2087:4
    t.constructor<double, mfem::MatrixCoefficient &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::ScalarMatrixProductCoefficient(mfem::Coefficient &, mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2090:4
    t.constructor<mfem::Coefficient &, mfem::MatrixCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:2093:9
    t.method("SetTime", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(double) >(&mfem::ScalarMatrixProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::SetAConst(double)
    // defined in mfem/fem/coefficient.hpp:2096:9
    t.method("SetAConst", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(double) >(&mfem::ScalarMatrixProductCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::ScalarMatrixProductCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ScalarMatrixProductCoefficient::GetAConst()
    // defined in mfem/fem/coefficient.hpp:2098:11
    t.method("GetAConst", static_cast<double (mfem::ScalarMatrixProductCoefficient::*)()  const>(&mfem::ScalarMatrixProductCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::SetACoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:2101:9
    t.method("SetACoef", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(mfem::Coefficient &) >(&mfem::ScalarMatrixProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::ScalarMatrixProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::ScalarMatrixProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:2103:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::ScalarMatrixProductCoefficient::*)()  const>(&mfem::ScalarMatrixProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::SetBCoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::SetBCoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2106:9
    t.method("SetBCoef", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::ScalarMatrixProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::ScalarMatrixProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::ScalarMatrixProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:2108:24
    t.method("GetBCoef", static_cast<mfem::MatrixCoefficient * (mfem::ScalarMatrixProductCoefficient::*)()  const>(&mfem::ScalarMatrixProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2111:17
    t.method("Eval", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ScalarMatrixProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarMatrixProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ScalarMatrixProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ScalarMatrixProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TransposeMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TransposeMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::TransposeMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_TransposeMatrixCoefficient: public Wrapper {

  Jlmfem_TransposeMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TransposeMatrixCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2116:7
    jlcxx::TypeWrapper<mfem::TransposeMatrixCoefficient>  t = jlModule.add_type<mfem::TransposeMatrixCoefficient>("mfem!TransposeMatrixCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TransposeMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::TransposeMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::TransposeMatrixCoefficient::TransposeMatrixCoefficient(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2123:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::TransposeMatrixCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeMatrixCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:2126:9
    t.method("SetTime", static_cast<void (mfem::TransposeMatrixCoefficient::*)(double) >(&mfem::TransposeMatrixCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeMatrixCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeMatrixCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2129:9
    t.method("SetACoef", static_cast<void (mfem::TransposeMatrixCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::TransposeMatrixCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::TransposeMatrixCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::TransposeMatrixCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:2131:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::TransposeMatrixCoefficient::*)()  const>(&mfem::TransposeMatrixCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2134:17
    t.method("Eval", static_cast<void (mfem::TransposeMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::TransposeMatrixCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TransposeMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TransposeMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TransposeMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InverseMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InverseMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::InverseMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_InverseMatrixCoefficient: public Wrapper {

  Jlmfem_InverseMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InverseMatrixCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2139:7
    jlcxx::TypeWrapper<mfem::InverseMatrixCoefficient>  t = jlModule.add_type<mfem::InverseMatrixCoefficient>("mfem!InverseMatrixCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::InverseMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::InverseMatrixCoefficient::InverseMatrixCoefficient(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2146:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::InverseMatrixCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseMatrixCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:2149:9
    t.method("SetTime", static_cast<void (mfem::InverseMatrixCoefficient::*)(double) >(&mfem::InverseMatrixCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::InverseMatrixCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseMatrixCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2152:9
    t.method("SetACoef", static_cast<void (mfem::InverseMatrixCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::InverseMatrixCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::InverseMatrixCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::InverseMatrixCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:2154:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::InverseMatrixCoefficient::*)()  const>(&mfem::InverseMatrixCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::InverseMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2157:17
    t.method("Eval", static_cast<void (mfem::InverseMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::InverseMatrixCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InverseMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InverseMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OuterProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OuterProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::OuterProductCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_OuterProductCoefficient: public Wrapper {

  Jlmfem_OuterProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OuterProductCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2162:7
    jlcxx::TypeWrapper<mfem::OuterProductCoefficient>  t = jlModule.add_type<mfem::OuterProductCoefficient>("mfem!OuterProductCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OuterProductCoefficient>>(new jlcxx::TypeWrapper<mfem::OuterProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::OuterProductCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2173:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OuterProductCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:2176:9
    t.method("SetTime", static_cast<void (mfem::OuterProductCoefficient::*)(double) >(&mfem::OuterProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OuterProductCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2179:9
    t.method("SetACoef", static_cast<void (mfem::OuterProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::OuterProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::OuterProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::OuterProductCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:2181:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::OuterProductCoefficient::*)()  const>(&mfem::OuterProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OuterProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2184:9
    t.method("SetBCoef", static_cast<void (mfem::OuterProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::OuterProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::OuterProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::OuterProductCoefficient::GetBCoef()
    // defined in mfem/fem/coefficient.hpp:2186:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::OuterProductCoefficient::*)()  const>(&mfem::OuterProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OuterProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2189:17
    t.method("Eval", static_cast<void (mfem::OuterProductCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::OuterProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OuterProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OuterProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OuterProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CrossCrossCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CrossCrossCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CrossCrossCoefficient> { typedef mfem::MatrixCoefficient type; };
}

struct Jlmfem_CrossCrossCoefficient: public Wrapper {

  Jlmfem_CrossCrossCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CrossCrossCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2200:7
    jlcxx::TypeWrapper<mfem::CrossCrossCoefficient>  t = jlModule.add_type<mfem::CrossCrossCoefficient>("mfem!CrossCrossCoefficient"    , jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CrossCrossCoefficient>>(new jlcxx::TypeWrapper<mfem::CrossCrossCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::CrossCrossCoefficient(double, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2210:4
    t.constructor<double, mfem::VectorCoefficient &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::CrossCrossCoefficient(mfem::Coefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2211:4
    t.constructor<mfem::Coefficient &, mfem::VectorCoefficient &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::SetTime(double)
    // defined in mfem/fem/coefficient.hpp:2214:9
    t.method("SetTime", static_cast<void (mfem::CrossCrossCoefficient::*)(double) >(&mfem::CrossCrossCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::SetAConst(double)
    // defined in mfem/fem/coefficient.hpp:2217:9
    t.method("SetAConst", static_cast<void (mfem::CrossCrossCoefficient::*)(double) >(&mfem::CrossCrossCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::CrossCrossCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CrossCrossCoefficient::GetAConst()
    // defined in mfem/fem/coefficient.hpp:2219:11
    t.method("GetAConst", static_cast<double (mfem::CrossCrossCoefficient::*)()  const>(&mfem::CrossCrossCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::SetACoef(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:2222:9
    t.method("SetACoef", static_cast<void (mfem::CrossCrossCoefficient::*)(mfem::Coefficient &) >(&mfem::CrossCrossCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::CrossCrossCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::CrossCrossCoefficient::GetACoef()
    // defined in mfem/fem/coefficient.hpp:2224:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::CrossCrossCoefficient::*)()  const>(&mfem::CrossCrossCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::SetKCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::SetKCoef(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2227:9
    t.method("SetKCoef", static_cast<void (mfem::CrossCrossCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::CrossCrossCoefficient::SetKCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::CrossCrossCoefficient::GetKCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::CrossCrossCoefficient::GetKCoef()
    // defined in mfem/fem/coefficient.hpp:2229:24
    t.method("GetKCoef", static_cast<mfem::VectorCoefficient * (mfem::CrossCrossCoefficient::*)()  const>(&mfem::CrossCrossCoefficient::GetKCoef));

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2232:17
    t.method("Eval", static_cast<void (mfem::CrossCrossCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CrossCrossCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CrossCrossCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CrossCrossCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CrossCrossCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorQuadratureFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorQuadratureFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorQuadratureFunctionCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_VectorQuadratureFunctionCoefficient: public Wrapper {

  Jlmfem_VectorQuadratureFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorQuadratureFunctionCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2240:7
    jlcxx::TypeWrapper<mfem::VectorQuadratureFunctionCoefficient>  t = jlModule.add_type<mfem::VectorQuadratureFunctionCoefficient>("mfem!VectorQuadratureFunctionCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorQuadratureFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorQuadratureFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureFunctionCoefficient::VectorQuadratureFunctionCoefficient(mfem::QuadratureFunction &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2248:4
    t.constructor<mfem::QuadratureFunction &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureFunctionCoefficient::SetComponent(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorQuadratureFunctionCoefficient::SetComponent(int, int)
    // defined in mfem/fem/coefficient.hpp:2253:9
    t.method("SetComponent", static_cast<void (mfem::VectorQuadratureFunctionCoefficient::*)(int, int) >(&mfem::VectorQuadratureFunctionCoefficient::SetComponent));

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureFunction & mfem::VectorQuadratureFunctionCoefficient::GetQuadFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureFunction & mfem::VectorQuadratureFunctionCoefficient::GetQuadFunction()
    // defined in mfem/fem/coefficient.hpp:2255:30
    t.method("GetQuadFunction", static_cast<const mfem::QuadratureFunction & (mfem::VectorQuadratureFunctionCoefficient::*)()  const>(&mfem::VectorQuadratureFunctionCoefficient::GetQuadFunction));

    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorQuadratureFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2258:17
    t.method("Eval", static_cast<void (mfem::VectorQuadratureFunctionCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorQuadratureFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureFunctionCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorQuadratureFunctionCoefficient::Project(mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:2261:17
    t.method("Project", static_cast<void (mfem::VectorQuadratureFunctionCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::VectorQuadratureFunctionCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorQuadratureFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorQuadratureFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorQuadratureFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::QuadratureFunctionCoefficient> { typedef mfem::Coefficient type; };
}

struct Jlmfem_QuadratureFunctionCoefficient: public Wrapper {

  Jlmfem_QuadratureFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureFunctionCoefficient (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2269:7
    jlcxx::TypeWrapper<mfem::QuadratureFunctionCoefficient>  t = jlModule.add_type<mfem::QuadratureFunctionCoefficient>("mfem!QuadratureFunctionCoefficient"    , jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::QuadratureFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctionCoefficient::QuadratureFunctionCoefficient(mfem::QuadratureFunction &) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2276:4
    t.constructor<mfem::QuadratureFunction &>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureFunction & mfem::QuadratureFunctionCoefficient::GetQuadFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureFunction & mfem::QuadratureFunctionCoefficient::GetQuadFunction()
    // defined in mfem/fem/coefficient.hpp:2278:30
    t.method("GetQuadFunction", static_cast<const mfem::QuadratureFunction & (mfem::QuadratureFunctionCoefficient::*)()  const>(&mfem::QuadratureFunctionCoefficient::GetQuadFunction));

    DEBUG_MSG("Adding wrapper for double mfem::QuadratureFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::QuadratureFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/fem/coefficient.hpp:2280:19
    t.method("Eval", static_cast<double (mfem::QuadratureFunctionCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::QuadratureFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctionCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctionCoefficient::Project(mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:2282:17
    t.method("Project", static_cast<void (mfem::QuadratureFunctionCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::QuadratureFunctionCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CoefficientVector> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CoefficientVector> : std::false_type { };
template<> struct SuperType<mfem::CoefficientVector> { typedef mfem::Vector type; };
}

struct Jlmfem_CoefficientVector: public Wrapper {

  Jlmfem_CoefficientVector(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CoefficientVector (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2316:7
    jlcxx::TypeWrapper<mfem::CoefficientVector>  t = jlModule.add_type<mfem::CoefficientVector>("mfem!CoefficientVector"    , jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CoefficientVector>>(new jlcxx::TypeWrapper<mfem::CoefficientVector>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2325:4
    t.constructor<mfem::QuadratureSpaceBase &>(/*finalize=*/true);
    t.constructor<mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::Coefficient *, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2333:4
    t.constructor<mfem::Coefficient *, mfem::QuadratureSpaceBase &>(/*finalize=*/true);
    t.constructor<mfem::Coefficient *, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::Coefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2340:4
    t.constructor<mfem::Coefficient &, mfem::QuadratureSpaceBase &>(/*finalize=*/true);
    t.constructor<mfem::Coefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::VectorCoefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2347:4
    t.constructor<mfem::VectorCoefficient &, mfem::QuadratureSpaceBase &>(/*finalize=*/true);
    t.constructor<mfem::VectorCoefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::MatrixCoefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in mfem/fem/coefficient.hpp:2354:4
    t.constructor<mfem::MatrixCoefficient &, mfem::QuadratureSpaceBase &>(/*finalize=*/true);
    t.constructor<mfem::MatrixCoefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::Project(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::Project(mfem::Coefficient &)
    // defined in mfem/fem/coefficient.hpp:2359:9
    t.method("Project", static_cast<void (mfem::CoefficientVector::*)(mfem::Coefficient &) >(&mfem::CoefficientVector::Project));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::Project(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::Project(mfem::VectorCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2365:9
    t.method("Project", static_cast<void (mfem::CoefficientVector::*)(mfem::VectorCoefficient &) >(&mfem::CoefficientVector::Project));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::Project(mfem::MatrixCoefficient &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::Project(mfem::MatrixCoefficient &, bool)
    // defined in mfem/fem/coefficient.hpp:2371:9
    t.method("Project", static_cast<void (mfem::CoefficientVector::*)(mfem::MatrixCoefficient &, bool) >(&mfem::CoefficientVector::Project));
    t.method("Project", [](mfem::CoefficientVector& a, mfem::MatrixCoefficient & arg0)->void{ a.Project(arg0); });
    t.method("Project", [](mfem::CoefficientVector* a, mfem::MatrixCoefficient & arg0)->void{ a->Project(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::ProjectTranspose(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::ProjectTranspose(mfem::MatrixCoefficient &)
    // defined in mfem/fem/coefficient.hpp:2376:9
    t.method("ProjectTranspose", static_cast<void (mfem::CoefficientVector::*)(mfem::MatrixCoefficient &) >(&mfem::CoefficientVector::ProjectTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::MakeRef(const mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::MakeRef(const mfem::QuadratureFunction &)
    // defined in mfem/fem/coefficient.hpp:2379:9
    t.method("MakeRef", static_cast<void (mfem::CoefficientVector::*)(const mfem::QuadratureFunction &) >(&mfem::CoefficientVector::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::SetConstant(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::SetConstant(double)
    // defined in mfem/fem/coefficient.hpp:2382:9
    t.method("SetConstant", static_cast<void (mfem::CoefficientVector::*)(double) >(&mfem::CoefficientVector::SetConstant));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::SetConstant(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::SetConstant(const mfem::Vector &)
    // defined in mfem/fem/coefficient.hpp:2385:9
    t.method("SetConstant", static_cast<void (mfem::CoefficientVector::*)(const mfem::Vector &) >(&mfem::CoefficientVector::SetConstant));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::SetConstant(const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::SetConstant(const mfem::DenseMatrix &)
    // defined in mfem/fem/coefficient.hpp:2388:9
    t.method("SetConstant", static_cast<void (mfem::CoefficientVector::*)(const mfem::DenseMatrix &) >(&mfem::CoefficientVector::SetConstant));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::SetConstant(const mfem::DenseSymmetricMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::SetConstant(const mfem::DenseSymmetricMatrix &)
    // defined in mfem/fem/coefficient.hpp:2391:9
    t.method("SetConstant", static_cast<void (mfem::CoefficientVector::*)(const mfem::DenseSymmetricMatrix &) >(&mfem::CoefficientVector::SetConstant));

    DEBUG_MSG("Adding wrapper for int mfem::CoefficientVector::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CoefficientVector::GetVDim()
    // defined in mfem/fem/coefficient.hpp:2394:8
    t.method("GetVDim", static_cast<int (mfem::CoefficientVector::*)()  const>(&mfem::CoefficientVector::GetVDim));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CoefficientVector>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CoefficientVector(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CoefficientVector(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureSpaceBase> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureSpaceBase> : std::false_type { };
}

struct Jlmfem_QuadratureSpaceBase: public Wrapper {

  Jlmfem_QuadratureSpaceBase(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureSpaceBase (" __HERE__ ")");
    // defined in mfem/mesh/../fem/qspace.hpp:24:7
    jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>  t = jlModule.add_type<mfem::QuadratureSpaceBase>("mfem!QuadratureSpaceBase");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>>(new jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpaceBase(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureSpaceBase(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NCMesh> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NCMesh> : std::false_type { };
}

struct Jlmfem_NCMesh: public Wrapper {

  Jlmfem_NCMesh(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NCMesh (" __HERE__ ")");
    // defined in mfem/mesh/ncmesh.hpp:121:7
    jlcxx::TypeWrapper<mfem::NCMesh>  t = jlModule.add_type<mfem::NCMesh>("mfem!NCMesh");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NCMesh>>(new jlcxx::TypeWrapper<mfem::NCMesh>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NCMesh>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NCMesh(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NCMesh(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Element> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Element> : std::false_type { };
}

struct Jlmfem_Element: public Wrapper {

  Jlmfem_Element(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Element (" __HERE__ ")");
    // defined in mfem/mesh/element.hpp:28:7
    jlcxx::TypeWrapper<mfem::Element>  t = jlModule.add_type<mfem::Element>("mfem!Element");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Element>>(new jlcxx::TypeWrapper<mfem::Element>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Element>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Element(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Element(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh::GeometryList> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh::GeometryList> : std::false_type { };
}

struct Jlmfem_Mesh_GeometryList: public Wrapper {

  Jlmfem_Mesh_GeometryList(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh::GeometryList (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1273:10
    jlcxx::TypeWrapper<mfem::Mesh::GeometryList>  t = jlModule.add_type<mfem::Mesh::GeometryList>("mfem!Mesh!GeometryList");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::GeometryList>>(new jlcxx::TypeWrapper<mfem::Mesh::GeometryList>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeometryList::GeometryList(mfem::Mesh &) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1279:7
    t.constructor<mfem::Mesh &>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeometryList::GeometryList(mfem::Mesh &, int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1284:7
    t.constructor<mfem::Mesh &, int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::GeometryList>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh_GeometryList(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh_GeometryList(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Table> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Table> : std::false_type { };
}

struct Jlmfem_Table: public Wrapper {

  Jlmfem_Table(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Table (" __HERE__ ")");
    // defined in mfem/mesh/../general/table.hpp:43:7
    jlcxx::TypeWrapper<mfem::Table>  t = jlModule.add_type<mfem::Table>("mfem!Table");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Table>>(new jlcxx::TypeWrapper<mfem::Table>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Table>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Table(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Table(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DSTable> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DSTable> : std::false_type { };
}

struct Jlmfem_DSTable: public Wrapper {

  Jlmfem_DSTable(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DSTable (" __HERE__ ")");
    // defined in mfem/mesh/../general/table.hpp:244:7
    jlcxx::TypeWrapper<mfem::DSTable>  t = jlModule.add_type<mfem::DSTable>("mfem!DSTable");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DSTable>>(new jlcxx::TypeWrapper<mfem::DSTable>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DSTable>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DSTable(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DSTable(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElement> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElement> : std::false_type { };
}

struct Jlmfem_FiniteElement: public Wrapper {

  Jlmfem_FiniteElement(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElement (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe/fe_base.hpp:233:7
    jlcxx::TypeWrapper<mfem::FiniteElement>  t = jlModule.add_type<mfem::FiniteElement>("mfem!FiniteElement");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElement>>(new jlcxx::TypeWrapper<mfem::FiniteElement>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElement>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElement(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElement(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IsoparametricTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IsoparametricTransformation> : std::false_type { };
template<> struct SuperType<mfem::IsoparametricTransformation> { typedef mfem::ElementTransformation type; };
}

struct Jlmfem_IsoparametricTransformation: public Wrapper {

  Jlmfem_IsoparametricTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IsoparametricTransformation (" __HERE__ ")");
    // defined in mfem/mesh/../fem/eltrans.hpp:361:7
    jlcxx::TypeWrapper<mfem::IsoparametricTransformation>  t = jlModule.add_type<mfem::IsoparametricTransformation>("mfem!IsoparametricTransformation"    , jlcxx::julia_base_type<mfem::ElementTransformation>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IsoparametricTransformation>>(new jlcxx::TypeWrapper<mfem::IsoparametricTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IsoparametricTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IsoparametricTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IsoparametricTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceElementTransformations> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceElementTransformations> : std::false_type { };
template<> struct SuperType<mfem::FaceElementTransformations> { typedef mfem::IsoparametricTransformation type; };
}

struct Jlmfem_FaceElementTransformations: public Wrapper {

  Jlmfem_FaceElementTransformations(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceElementTransformations (" __HERE__ ")");
    // defined in mfem/mesh/../fem/eltrans.hpp:480:7
    jlcxx::TypeWrapper<mfem::FaceElementTransformations>  t = jlModule.add_type<mfem::FaceElementTransformations>("mfem!FaceElementTransformations"    , jlcxx::julia_base_type<mfem::IsoparametricTransformation>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceElementTransformations>>(new jlcxx::TypeWrapper<mfem::FaceElementTransformations>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceElementTransformations>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceElementTransformations(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceElementTransformations(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GeometricFactors> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GeometricFactors> : std::false_type { };
}

struct Jlmfem_GeometricFactors: public Wrapper {

  Jlmfem_GeometricFactors(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GeometricFactors (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2183:7
    jlcxx::TypeWrapper<mfem::GeometricFactors>  t = jlModule.add_type<mfem::GeometricFactors>("mfem!GeometricFactors");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GeometricFactors>>(new jlcxx::TypeWrapper<mfem::GeometricFactors>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::GeometricFactors::GeometricFactors(const mfem::Mesh *, const mfem::IntegrationRule &, int, mfem::MemoryType) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2202:4
    t.constructor<const mfem::Mesh *, const mfem::IntegrationRule &, int>(/*finalize=*/true);
    t.constructor<const mfem::Mesh *, const mfem::IntegrationRule &, int, mfem::MemoryType>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::GeometricFactors::GeometricFactors(const mfem::GridFunction &, const mfem::IntegrationRule &, int, mfem::MemoryType) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2205:4
    t.constructor<const mfem::GridFunction &, const mfem::IntegrationRule &, int>(/*finalize=*/true);
    t.constructor<const mfem::GridFunction &, const mfem::IntegrationRule &, int, mfem::MemoryType>(/*finalize=*/true);

    DEBUG_MSG("Adding mesh methods  to provide read access to the field mesh (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2191:16
    // signature to use in the veto list: mfem::GeometricFactors::mesh
    t.method("mesh", [](const mfem::GeometricFactors& a) -> const mfem::Mesh * { return a.mesh; });
    t.method("mesh", [](const mfem::GeometricFactors* a) -> const mfem::Mesh * { return a->mesh; });

    DEBUG_MSG("Adding IntRule methods  to provide read access to the field IntRule (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2192:27
    // signature to use in the veto list: mfem::GeometricFactors::IntRule
    t.method("IntRule", [](const mfem::GeometricFactors& a) -> const mfem::IntegrationRule * { return a.IntRule; });
    t.method("IntRule", [](const mfem::GeometricFactors* a) -> const mfem::IntegrationRule * { return a->IntRule; });

    DEBUG_MSG("Adding computed_factors methods  to provide read access to the field computed_factors (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2193:8
    // signature to use in the veto list: mfem::GeometricFactors::computed_factors
    t.method("computed_factors", [](const mfem::GeometricFactors& a) -> int { return a.computed_factors; });
    t.method("computed_factors", [](mfem::GeometricFactors& a) -> int { return a.computed_factors; });
    t.method("computed_factors", [](const mfem::GeometricFactors* a) -> int { return a->computed_factors; });
    t.method("computed_factors", [](mfem::GeometricFactors* a) -> int { return a->computed_factors; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2193:8
    // signature to use in the veto list: mfem::GeometricFactors::computed_factors
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding computed_factors! methods to provide write access to the field computed_factors (" __HERE__ ")");
    t.method("computed_factors!", [](mfem::GeometricFactors& a, int val) -> int { return a.computed_factors = val; });

    DEBUG_MSG("Adding computed_factors! methods to provide write access to the field computed_factors (" __HERE__ ")");
    t.method("computed_factors!", [](mfem::GeometricFactors* a, int val) -> int { return a->computed_factors = val; });

    DEBUG_MSG("Adding X methods  to provide read access to the field X (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2215:11
    // signature to use in the veto list: mfem::GeometricFactors::X
    t.method("X", [](const mfem::GeometricFactors& a) -> const mfem::Vector& { return a.X; });
    t.method("X", [](mfem::GeometricFactors& a) -> mfem::Vector& { return a.X; });
    t.method("X", [](const mfem::GeometricFactors* a) -> const mfem::Vector& { return a->X; });
    t.method("X", [](mfem::GeometricFactors* a) -> mfem::Vector& { return a->X; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2215:11
    // signature to use in the veto list: mfem::GeometricFactors::X
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding X! methods to provide write access to the field X (" __HERE__ ")");
    t.method("X!", [](mfem::GeometricFactors& a, const mfem::Vector& val) -> mfem::Vector& { return a.X = val; });

    DEBUG_MSG("Adding X! methods to provide write access to the field X (" __HERE__ ")");
    t.method("X!", [](mfem::GeometricFactors* a, const mfem::Vector& val) -> mfem::Vector& { return a->X = val; });

    DEBUG_MSG("Adding J methods  to provide read access to the field J (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2224:11
    // signature to use in the veto list: mfem::GeometricFactors::J
    t.method("J", [](const mfem::GeometricFactors& a) -> const mfem::Vector& { return a.J; });
    t.method("J", [](mfem::GeometricFactors& a) -> mfem::Vector& { return a.J; });
    t.method("J", [](const mfem::GeometricFactors* a) -> const mfem::Vector& { return a->J; });
    t.method("J", [](mfem::GeometricFactors* a) -> mfem::Vector& { return a->J; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2224:11
    // signature to use in the veto list: mfem::GeometricFactors::J
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding J! methods to provide write access to the field J (" __HERE__ ")");
    t.method("J!", [](mfem::GeometricFactors& a, const mfem::Vector& val) -> mfem::Vector& { return a.J = val; });

    DEBUG_MSG("Adding J! methods to provide write access to the field J (" __HERE__ ")");
    t.method("J!", [](mfem::GeometricFactors* a, const mfem::Vector& val) -> mfem::Vector& { return a->J = val; });

    DEBUG_MSG("Adding detJ methods  to provide read access to the field detJ (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2230:11
    // signature to use in the veto list: mfem::GeometricFactors::detJ
    t.method("detJ", [](const mfem::GeometricFactors& a) -> const mfem::Vector& { return a.detJ; });
    t.method("detJ", [](mfem::GeometricFactors& a) -> mfem::Vector& { return a.detJ; });
    t.method("detJ", [](const mfem::GeometricFactors* a) -> const mfem::Vector& { return a->detJ; });
    t.method("detJ", [](mfem::GeometricFactors* a) -> mfem::Vector& { return a->detJ; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2230:11
    // signature to use in the veto list: mfem::GeometricFactors::detJ
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding detJ! methods to provide write access to the field detJ (" __HERE__ ")");
    t.method("detJ!", [](mfem::GeometricFactors& a, const mfem::Vector& val) -> mfem::Vector& { return a.detJ = val; });

    DEBUG_MSG("Adding detJ! methods to provide write access to the field detJ (" __HERE__ ")");
    t.method("detJ!", [](mfem::GeometricFactors* a, const mfem::Vector& val) -> mfem::Vector& { return a->detJ = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GeometricFactors>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GeometricFactors(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GeometricFactors(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceGeometricFactors> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceGeometricFactors> : std::false_type { };
}

struct Jlmfem_FaceGeometricFactors: public Wrapper {

  Jlmfem_FaceGeometricFactors(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceGeometricFactors (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2237:7
    jlcxx::TypeWrapper<mfem::FaceGeometricFactors>  t = jlModule.add_type<mfem::FaceGeometricFactors>("mfem!FaceGeometricFactors");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceGeometricFactors>>(new jlcxx::TypeWrapper<mfem::FaceGeometricFactors>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::FaceGeometricFactors::FaceGeometricFactors(const mfem::Mesh *, const mfem::IntegrationRule &, int, mfem::FaceType, mfem::MemoryType) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2253:4
    t.constructor<const mfem::Mesh *, const mfem::IntegrationRule &, int, mfem::FaceType>(/*finalize=*/true);
    t.constructor<const mfem::Mesh *, const mfem::IntegrationRule &, int, mfem::FaceType, mfem::MemoryType>(/*finalize=*/true);

    DEBUG_MSG("Adding mesh methods  to provide read access to the field mesh (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2240:16
    // signature to use in the veto list: mfem::FaceGeometricFactors::mesh
    t.method("mesh", [](const mfem::FaceGeometricFactors& a) -> const mfem::Mesh * { return a.mesh; });
    t.method("mesh", [](const mfem::FaceGeometricFactors* a) -> const mfem::Mesh * { return a->mesh; });

    DEBUG_MSG("Adding IntRule methods  to provide read access to the field IntRule (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2241:27
    // signature to use in the veto list: mfem::FaceGeometricFactors::IntRule
    t.method("IntRule", [](const mfem::FaceGeometricFactors& a) -> const mfem::IntegrationRule * { return a.IntRule; });
    t.method("IntRule", [](const mfem::FaceGeometricFactors* a) -> const mfem::IntegrationRule * { return a->IntRule; });

    DEBUG_MSG("Adding computed_factors methods  to provide read access to the field computed_factors (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2242:8
    // signature to use in the veto list: mfem::FaceGeometricFactors::computed_factors
    t.method("computed_factors", [](const mfem::FaceGeometricFactors& a) -> int { return a.computed_factors; });
    t.method("computed_factors", [](mfem::FaceGeometricFactors& a) -> int { return a.computed_factors; });
    t.method("computed_factors", [](const mfem::FaceGeometricFactors* a) -> int { return a->computed_factors; });
    t.method("computed_factors", [](mfem::FaceGeometricFactors* a) -> int { return a->computed_factors; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2242:8
    // signature to use in the veto list: mfem::FaceGeometricFactors::computed_factors
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding computed_factors! methods to provide write access to the field computed_factors (" __HERE__ ")");
    t.method("computed_factors!", [](mfem::FaceGeometricFactors& a, int val) -> int { return a.computed_factors = val; });

    DEBUG_MSG("Adding computed_factors! methods to provide write access to the field computed_factors (" __HERE__ ")");
    t.method("computed_factors!", [](mfem::FaceGeometricFactors* a, int val) -> int { return a->computed_factors = val; });

    DEBUG_MSG("Adding type methods  to provide read access to the field type (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2243:13
    // signature to use in the veto list: mfem::FaceGeometricFactors::type
    t.method("type", [](const mfem::FaceGeometricFactors& a) -> mfem::FaceType { return a.type; });
    t.method("type", [](mfem::FaceGeometricFactors& a) -> mfem::FaceType { return a.type; });
    t.method("type", [](const mfem::FaceGeometricFactors* a) -> mfem::FaceType { return a->type; });
    t.method("type", [](mfem::FaceGeometricFactors* a) -> mfem::FaceType { return a->type; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2243:13
    // signature to use in the veto list: mfem::FaceGeometricFactors::type
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding type! methods to provide write access to the field type (" __HERE__ ")");
    t.method("type!", [](mfem::FaceGeometricFactors& a, mfem::FaceType val) -> mfem::FaceType { return a.type = val; });

    DEBUG_MSG("Adding type! methods to provide write access to the field type (" __HERE__ ")");
    t.method("type!", [](mfem::FaceGeometricFactors* a, mfem::FaceType val) -> mfem::FaceType { return a->type = val; });

    DEBUG_MSG("Adding X methods  to provide read access to the field X (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2262:11
    // signature to use in the veto list: mfem::FaceGeometricFactors::X
    t.method("X", [](const mfem::FaceGeometricFactors& a) -> const mfem::Vector& { return a.X; });
    t.method("X", [](mfem::FaceGeometricFactors& a) -> mfem::Vector& { return a.X; });
    t.method("X", [](const mfem::FaceGeometricFactors* a) -> const mfem::Vector& { return a->X; });
    t.method("X", [](mfem::FaceGeometricFactors* a) -> mfem::Vector& { return a->X; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2262:11
    // signature to use in the veto list: mfem::FaceGeometricFactors::X
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding X! methods to provide write access to the field X (" __HERE__ ")");
    t.method("X!", [](mfem::FaceGeometricFactors& a, const mfem::Vector& val) -> mfem::Vector& { return a.X = val; });

    DEBUG_MSG("Adding X! methods to provide write access to the field X (" __HERE__ ")");
    t.method("X!", [](mfem::FaceGeometricFactors* a, const mfem::Vector& val) -> mfem::Vector& { return a->X = val; });

    DEBUG_MSG("Adding J methods  to provide read access to the field J (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2271:11
    // signature to use in the veto list: mfem::FaceGeometricFactors::J
    t.method("J", [](const mfem::FaceGeometricFactors& a) -> const mfem::Vector& { return a.J; });
    t.method("J", [](mfem::FaceGeometricFactors& a) -> mfem::Vector& { return a.J; });
    t.method("J", [](const mfem::FaceGeometricFactors* a) -> const mfem::Vector& { return a->J; });
    t.method("J", [](mfem::FaceGeometricFactors* a) -> mfem::Vector& { return a->J; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2271:11
    // signature to use in the veto list: mfem::FaceGeometricFactors::J
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding J! methods to provide write access to the field J (" __HERE__ ")");
    t.method("J!", [](mfem::FaceGeometricFactors& a, const mfem::Vector& val) -> mfem::Vector& { return a.J = val; });

    DEBUG_MSG("Adding J! methods to provide write access to the field J (" __HERE__ ")");
    t.method("J!", [](mfem::FaceGeometricFactors* a, const mfem::Vector& val) -> mfem::Vector& { return a->J = val; });

    DEBUG_MSG("Adding detJ methods  to provide read access to the field detJ (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2277:11
    // signature to use in the veto list: mfem::FaceGeometricFactors::detJ
    t.method("detJ", [](const mfem::FaceGeometricFactors& a) -> const mfem::Vector& { return a.detJ; });
    t.method("detJ", [](mfem::FaceGeometricFactors& a) -> mfem::Vector& { return a.detJ; });
    t.method("detJ", [](const mfem::FaceGeometricFactors* a) -> const mfem::Vector& { return a->detJ; });
    t.method("detJ", [](mfem::FaceGeometricFactors* a) -> mfem::Vector& { return a->detJ; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2277:11
    // signature to use in the veto list: mfem::FaceGeometricFactors::detJ
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding detJ! methods to provide write access to the field detJ (" __HERE__ ")");
    t.method("detJ!", [](mfem::FaceGeometricFactors& a, const mfem::Vector& val) -> mfem::Vector& { return a.detJ = val; });

    DEBUG_MSG("Adding detJ! methods to provide write access to the field detJ (" __HERE__ ")");
    t.method("detJ!", [](mfem::FaceGeometricFactors* a, const mfem::Vector& val) -> mfem::Vector& { return a->detJ = val; });

    DEBUG_MSG("Adding normal methods  to provide read access to the field normal (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2284:11
    // signature to use in the veto list: mfem::FaceGeometricFactors::normal
    t.method("normal", [](const mfem::FaceGeometricFactors& a) -> const mfem::Vector& { return a.normal; });
    t.method("normal", [](mfem::FaceGeometricFactors& a) -> mfem::Vector& { return a.normal; });
    t.method("normal", [](const mfem::FaceGeometricFactors* a) -> const mfem::Vector& { return a->normal; });
    t.method("normal", [](mfem::FaceGeometricFactors* a) -> mfem::Vector& { return a->normal; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2284:11
    // signature to use in the veto list: mfem::FaceGeometricFactors::normal
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding normal! methods to provide write access to the field normal (" __HERE__ ")");
    t.method("normal!", [](mfem::FaceGeometricFactors& a, const mfem::Vector& val) -> mfem::Vector& { return a.normal = val; });

    DEBUG_MSG("Adding normal! methods to provide write access to the field normal (" __HERE__ ")");
    t.method("normal!", [](mfem::FaceGeometricFactors* a, const mfem::Vector& val) -> mfem::Vector& { return a->normal = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceGeometricFactors>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceGeometricFactors(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceGeometricFactors(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh::FaceInformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh::FaceInformation> : std::false_type { };
}

struct Jlmfem_Mesh_FaceInformation: public Wrapper {

  Jlmfem_Mesh_FaceInformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh::FaceInformation (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1664:11
    jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>  t = jlModule.add_type<mfem::Mesh::FaceInformation>("mfem!Mesh!FaceInformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>>(new jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsLocal() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsLocal()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1683:12
    t.method("IsLocal", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsLocal));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsShared() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsShared()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1690:12
    t.method("IsShared", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsShared));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsInterior() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsInterior()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1699:12
    t.method("IsInterior", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsInterior));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsBoundary() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsBoundary()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1706:12
    t.method("IsBoundary", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsBoundary));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsOfFaceType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsOfFaceType(mfem::FaceType)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1712:12
    t.method("IsOfFaceType", static_cast<bool (mfem::Mesh::FaceInformation::*)(mfem::FaceType)  const>(&mfem::Mesh::FaceInformation::IsOfFaceType));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsConforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsConforming()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1726:12
    t.method("IsConforming", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsConforming));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsNonconformingFine() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsNonconformingFine()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1732:12
    t.method("IsNonconformingFine", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsNonconformingFine));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsNonconformingCoarse() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsNonconformingCoarse()
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1743:12
    t.method("IsNonconformingCoarse", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsNonconformingCoarse));

    DEBUG_MSG("Adding topology methods  to provide read access to the field topology (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1666:20
    // signature to use in the veto list: mfem::Mesh::FaceInformation::topology
    t.method("topology", [](const mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceTopology { return a.topology; });
    t.method("topology", [](mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceTopology { return a.topology; });
    t.method("topology", [](const mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceTopology { return a->topology; });
    t.method("topology", [](mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceTopology { return a->topology; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1666:20
    // signature to use in the veto list: mfem::Mesh::FaceInformation::topology
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding topology! methods to provide write access to the field topology (" __HERE__ ")");
    t.method("topology!", [](mfem::Mesh::FaceInformation& a, mfem::Mesh::FaceTopology val) -> mfem::Mesh::FaceTopology { return a.topology = val; });

    DEBUG_MSG("Adding topology! methods to provide write access to the field topology (" __HERE__ ")");
    t.method("topology!", [](mfem::Mesh::FaceInformation* a, mfem::Mesh::FaceTopology val) -> mfem::Mesh::FaceTopology { return a->topology = val; });

    DEBUG_MSG("Adding tag methods  to provide read access to the field tag (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1677:19
    // signature to use in the veto list: mfem::Mesh::FaceInformation::tag
    t.method("tag", [](const mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceInfoTag { return a.tag; });
    t.method("tag", [](mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceInfoTag { return a.tag; });
    t.method("tag", [](const mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceInfoTag { return a->tag; });
    t.method("tag", [](mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceInfoTag { return a->tag; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1677:19
    // signature to use in the veto list: mfem::Mesh::FaceInformation::tag
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding tag! methods to provide write access to the field tag (" __HERE__ ")");
    t.method("tag!", [](mfem::Mesh::FaceInformation& a, mfem::Mesh::FaceInfoTag val) -> mfem::Mesh::FaceInfoTag { return a.tag = val; });

    DEBUG_MSG("Adding tag! methods to provide write access to the field tag (" __HERE__ ")");
    t.method("tag!", [](mfem::Mesh::FaceInformation* a, mfem::Mesh::FaceInfoTag val) -> mfem::Mesh::FaceInfoTag { return a->tag = val; });

    DEBUG_MSG("Adding ncface methods  to provide read access to the field ncface (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1678:11
    // signature to use in the veto list: mfem::Mesh::FaceInformation::ncface
    t.method("ncface", [](const mfem::Mesh::FaceInformation& a) -> int { return a.ncface; });
    t.method("ncface", [](mfem::Mesh::FaceInformation& a) -> int { return a.ncface; });
    t.method("ncface", [](const mfem::Mesh::FaceInformation* a) -> int { return a->ncface; });
    t.method("ncface", [](mfem::Mesh::FaceInformation* a) -> int { return a->ncface; });
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1678:11
    // signature to use in the veto list: mfem::Mesh::FaceInformation::ncface
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding ncface! methods to provide write access to the field ncface (" __HERE__ ")");
    t.method("ncface!", [](mfem::Mesh::FaceInformation& a, int val) -> int { return a.ncface = val; });

    DEBUG_MSG("Adding ncface! methods to provide write access to the field ncface (" __HERE__ ")");
    t.method("ncface!", [](mfem::Mesh::FaceInformation* a, int val) -> int { return a->ncface = val; });

    DEBUG_MSG("Adding point_matrix methods  to provide read access to the field point_matrix (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1679:26
    // signature to use in the veto list: mfem::Mesh::FaceInformation::point_matrix
    t.method("point_matrix", [](const mfem::Mesh::FaceInformation& a) -> const mfem::DenseMatrix * { return a.point_matrix; });
    t.method("point_matrix", [](const mfem::Mesh::FaceInformation* a) -> const mfem::DenseMatrix * { return a->point_matrix; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh_FaceInformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh_FaceInformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElementSpace> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElementSpace> : std::false_type { };
}

struct Jlmfem_FiniteElementSpace: public Wrapper {

  Jlmfem_FiniteElementSpace(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElementSpace (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fespace.hpp:219:7
    jlcxx::TypeWrapper<mfem::FiniteElementSpace>  t = jlModule.add_type<mfem::FiniteElementSpace>("mfem!FiniteElementSpace");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementSpace>>(new jlcxx::TypeWrapper<mfem::FiniteElementSpace>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::FiniteElementSpace(const mfem::FiniteElementSpace &, mfem::Mesh *, const mfem::FiniteElementCollection *) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fespace.hpp:532:4
    t.constructor<const mfem::FiniteElementSpace &>(/*finalize=*/true);
    t.constructor<const mfem::FiniteElementSpace &, mfem::Mesh *>(/*finalize=*/true);
    t.constructor<const mfem::FiniteElementSpace &, mfem::Mesh *, const mfem::FiniteElementCollection *>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::FiniteElementSpace(mfem::Mesh *, const mfem::FiniteElementCollection *, int, int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fespace.hpp:535:4
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *>(/*finalize=*/true);
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *, int>(/*finalize=*/true);
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *, int, int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::FiniteElementSpace::GetMesh() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::FiniteElementSpace::GetMesh()
    // defined in mfem/mesh/../fem/fespace.hpp:553:17
    t.method("GetMesh", static_cast<mfem::Mesh * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetMesh));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::Conforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::Conforming()
    // defined in mfem/mesh/../fem/fespace.hpp:559:9
    t.method("Conforming", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::Conforming));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::Nonconforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::Nonconforming()
    // defined in mfem/mesh/../fem/fespace.hpp:560:9
    t.method("Nonconforming", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::Nonconforming));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetElementOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetElementOrder(int, int)
    // defined in mfem/mesh/../fem/fespace.hpp:565:9
    t.method("SetElementOrder", static_cast<void (mfem::FiniteElementSpace::*)(int, int) >(&mfem::FiniteElementSpace::SetElementOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementOrder(int)
    // defined in mfem/mesh/../fem/fespace.hpp:568:8
    t.method("GetElementOrder", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetMaxElementOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetMaxElementOrder()
    // defined in mfem/mesh/../fem/fespace.hpp:571:8
    t.method("GetMaxElementOrder", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetMaxElementOrder));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::IsVariableOrder() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::IsVariableOrder()
    // defined in mfem/mesh/../fem/fespace.hpp:575:9
    t.method("IsVariableOrder", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::IsVariableOrder));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingProlongation()
    // defined in mfem/mesh/../fem/fespace.hpp:578:24
    t.method("GetConformingProlongation", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingRestriction()
    // defined in mfem/mesh/../fem/fespace.hpp:581:24
    t.method("GetConformingRestriction", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpConformingRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpConformingRestriction()
    // defined in mfem/mesh/../fem/fespace.hpp:588:24
    t.method("GetHpConformingRestriction", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetHpConformingRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetProlongationMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetProlongationMatrix()
    // defined in mfem/mesh/../fem/fespace.hpp:591:28
    t.method("GetProlongationMatrix", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetProlongationMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionTransposeOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionTransposeOperator()
    // defined in mfem/mesh/../fem/fespace.hpp:597:28
    t.method("GetRestrictionTransposeOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionTransposeOperator));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionOperator()
    // defined in mfem/mesh/../fem/fespace.hpp:603:28
    t.method("GetRestrictionOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionOperator));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetRestrictionMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetRestrictionMatrix()
    // defined in mfem/mesh/../fem/fespace.hpp:607:32
    t.method("GetRestrictionMatrix", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpRestrictionMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpRestrictionMatrix()
    // defined in mfem/mesh/../fem/fespace.hpp:611:32
    t.method("GetHpRestrictionMatrix", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetHpRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::ElementRestrictionOperator * mfem::FiniteElementSpace::GetElementRestriction(mfem::ElementDofOrdering) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::ElementRestrictionOperator * mfem::FiniteElementSpace::GetElementRestriction(mfem::ElementDofOrdering)
    // defined in mfem/mesh/../fem/fespace.hpp:631:38
    t.method("GetElementRestriction", static_cast<const mfem::ElementRestrictionOperator * (mfem::FiniteElementSpace::*)(mfem::ElementDofOrdering)  const>(&mfem::FiniteElementSpace::GetElementRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::FaceRestriction * mfem::FiniteElementSpace::GetFaceRestriction(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FaceRestriction * mfem::FiniteElementSpace::GetFaceRestriction(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues)
    // defined in mfem/mesh/../fem/fespace.hpp:635:35
    t.method("GetFaceRestriction", static_cast<const mfem::FaceRestriction * (mfem::FiniteElementSpace::*)(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues)  const>(&mfem::FiniteElementSpace::GetFaceRestriction));
    t.method("GetFaceRestriction", [](mfem::FiniteElementSpace const& a, mfem::ElementDofOrdering arg0, mfem::FaceType arg1)->const mfem::FaceRestriction *{ return a.GetFaceRestriction(arg0, arg1); });
    t.method("GetFaceRestriction", [](mfem::FiniteElementSpace const* a, mfem::ElementDofOrdering arg0, mfem::FaceType arg1)->const mfem::FaceRestriction *{ return a->GetFaceRestriction(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetOrder(int)
    // defined in mfem/mesh/../fem/fespace.hpp:683:8
    t.method("GetOrder", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetEdgeOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetEdgeOrder(int, int)
    // defined in mfem/mesh/../fem/fespace.hpp:687:8
    t.method("GetEdgeOrder", static_cast<int (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetEdgeOrder));
    t.method("GetEdgeOrder", [](mfem::FiniteElementSpace const& a, int arg0)->int{ return a.GetEdgeOrder(arg0); });
    t.method("GetEdgeOrder", [](mfem::FiniteElementSpace const* a, int arg0)->int{ return a->GetEdgeOrder(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetFaceOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetFaceOrder(int, int)
    // defined in mfem/mesh/../fem/fespace.hpp:690:8
    t.method("GetFaceOrder", static_cast<int (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetFaceOrder));
    t.method("GetFaceOrder", [](mfem::FiniteElementSpace const& a, int arg0)->int{ return a.GetFaceOrder(arg0); });
    t.method("GetFaceOrder", [](mfem::FiniteElementSpace const* a, int arg0)->int{ return a->GetFaceOrder(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetVDim()
    // defined in mfem/mesh/../fem/fespace.hpp:693:15
    t.method("GetVDim", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetVDim));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNDofs()
    // defined in mfem/mesh/../fem/fespace.hpp:697:15
    t.method("GetNDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetVSize()
    // defined in mfem/mesh/../fem/fespace.hpp:700:15
    t.method("GetVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetVSize));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetTrueVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetTrueVSize()
    // defined in mfem/mesh/../fem/fespace.hpp:703:16
    t.method("GetTrueVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetTrueVSize));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNConformingDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNConformingDofs()
    // defined in mfem/mesh/../fem/fespace.hpp:707:8
    t.method("GetNConformingDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNConformingDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetConformingVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetConformingVSize()
    // defined in mfem/mesh/../fem/fespace.hpp:709:8
    t.method("GetConformingVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingVSize));

    DEBUG_MSG("Adding wrapper for mfem::Ordering::Type mfem::FiniteElementSpace::GetOrdering() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Ordering::Type mfem::FiniteElementSpace::GetOrdering()
    // defined in mfem/mesh/../fem/fespace.hpp:712:26
    t.method("GetOrdering", static_cast<mfem::Ordering::Type (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetOrdering));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementCollection * mfem::FiniteElementSpace::FEColl() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementCollection * mfem::FiniteElementSpace::FEColl()
    // defined in mfem/mesh/../fem/fespace.hpp:714:35
    t.method("FEColl", static_cast<const mfem::FiniteElementCollection * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::FEColl));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNVDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNVDofs()
    // defined in mfem/mesh/../fem/fespace.hpp:717:8
    t.method("GetNVDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNVDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNEDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNEDofs()
    // defined in mfem/mesh/../fem/fespace.hpp:719:8
    t.method("GetNEDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNEDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNFDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNFDofs()
    // defined in mfem/mesh/../fem/fespace.hpp:721:8
    t.method("GetNFDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNFDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNV()
    // defined in mfem/mesh/../fem/fespace.hpp:724:15
    t.method("GetNV", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNV));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNE()
    // defined in mfem/mesh/../fem/fespace.hpp:727:15
    t.method("GetNE", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNF() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNF()
    // defined in mfem/mesh/../fem/fespace.hpp:733:15
    t.method("GetNF", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNF));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNBE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNBE()
    // defined in mfem/mesh/../fem/fespace.hpp:736:15
    t.method("GetNBE", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNBE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNFbyType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNFbyType(mfem::FaceType)
    // defined in mfem/mesh/../fem/fespace.hpp:744:15
    t.method("GetNFbyType", static_cast<int (mfem::FiniteElementSpace::*)(mfem::FaceType)  const>(&mfem::FiniteElementSpace::GetNFbyType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementType(int)
    // defined in mfem/mesh/../fem/fespace.hpp:748:15
    t.method("GetElementType", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetBdrElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetBdrElementType(int)
    // defined in mfem/mesh/../fem/fespace.hpp:756:15
    t.method("GetBdrElementType", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrElementType));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::FiniteElementSpace::GetElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::FiniteElementSpace::GetElementTransformation(int)
    // defined in mfem/mesh/../fem/fespace.hpp:760:27
    t.method("GetElementTransformation", static_cast<mfem::ElementTransformation * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in mfem/mesh/../fem/fespace.hpp:765:9
    t.method("GetElementTransformation", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::IsoparametricTransformation *) >(&mfem::FiniteElementSpace::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::FiniteElementSpace::GetBdrElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::FiniteElementSpace::GetBdrElementTransformation(int)
    // defined in mfem/mesh/../fem/fespace.hpp:769:27
    t.method("GetBdrElementTransformation", static_cast<mfem::ElementTransformation * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetAttribute(int)
    // defined in mfem/mesh/../fem/fespace.hpp:772:8
    t.method("GetAttribute", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetBdrAttribute(int)
    // defined in mfem/mesh/../fem/fespace.hpp:774:8
    t.method("GetBdrAttribute", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNumElementInteriorDofs(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNumElementInteriorDofs(int)
    // defined in mfem/mesh/../fem/fespace.hpp:881:8
    t.method("GetNumElementInteriorDofs", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetNumElementInteriorDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DofToVDof(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DofToVDof(int, int, int)
    // defined in mfem/mesh/../fem/fespace.hpp:958:8
    t.method("DofToVDof", static_cast<int (mfem::FiniteElementSpace::*)(int, int, int)  const>(&mfem::FiniteElementSpace::DofToVDof));
    t.method("DofToVDof", [](mfem::FiniteElementSpace const& a, int arg0, int arg1)->int{ return a.DofToVDof(arg0, arg1); });
    t.method("DofToVDof", [](mfem::FiniteElementSpace const* a, int arg0, int arg1)->int{ return a->DofToVDof(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::VDofToDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::VDofToDof(int)
    // defined in mfem/mesh/../fem/fespace.hpp:965:8
    t.method("VDofToDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::VDofToDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::EncodeDof(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::EncodeDof(int, int)
    // defined in mfem/mesh/../fem/fespace.hpp:983:22
    t.method("mfem!FiniteElementSpace!EncodeDof", static_cast<int (*)(int, int) >(&mfem::FiniteElementSpace::EncodeDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DecodeDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DecodeDof(int)
    // defined in mfem/mesh/../fem/fespace.hpp:987:22
    t.method("mfem!FiniteElementSpace!DecodeDof", static_cast<int (*)(int) >(&mfem::FiniteElementSpace::DecodeDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DecodeDof(int, double &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DecodeDof(int, double &)
    // defined in mfem/mesh/../fem/fespace.hpp:991:22
    t.method("mfem!FiniteElementSpace!DecodeDof", static_cast<int (*)(int, double &) >(&mfem::FiniteElementSpace::DecodeDof));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::RebuildElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::RebuildElementToDofTable()
    // defined in mfem/mesh/../fem/fespace.hpp:1073:25
    t.method("RebuildElementToDofTable", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::RebuildElementToDofTable));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ReorderElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ReorderElementToDofTable()
    // defined in mfem/mesh/../fem/fespace.hpp:1082:9
    t.method("ReorderElementToDofTable", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::ReorderElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table * mfem::FiniteElementSpace::GetElementToFaceOrientationTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table * mfem::FiniteElementSpace::GetElementToFaceOrientationTable()
    // defined in mfem/mesh/../fem/fespace.hpp:1084:17
    t.method("GetElementToFaceOrientationTable", static_cast<const mfem::Table * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetElementToFaceOrientationTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetElementToDofTable()
    // defined in mfem/mesh/../fem/fespace.hpp:1088:17
    t.method("GetElementToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetBdrElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetBdrElementToDofTable()
    // defined in mfem/mesh/../fem/fespace.hpp:1093:17
    t.method("GetBdrElementToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetBdrElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetFaceToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetFaceToDofTable()
    // defined in mfem/mesh/../fem/fespace.hpp:1101:17
    t.method("GetFaceToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetFaceToDofTable));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::BuildDofToArrays() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::BuildDofToArrays()
    // defined in mfem/mesh/../fem/fespace.hpp:1106:9
    t.method("BuildDofToArrays", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::BuildDofToArrays));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementForDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementForDof(int)
    // defined in mfem/mesh/../fem/fespace.hpp:1111:8
    t.method("GetElementForDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementForDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetLocalDofForDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetLocalDofForDof(int)
    // defined in mfem/mesh/../fem/fespace.hpp:1115:8
    t.method("GetLocalDofForDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetLocalDofForDof));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetFE(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetFE(int)
    // defined in mfem/mesh/../fem/fespace.hpp:1121:33
    t.method("GetFE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetFE));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetBE(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetBE(int)
    // defined in mfem/mesh/../fem/fespace.hpp:1125:25
    t.method("GetBE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBE));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetFaceElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetFaceElement(int)
    // defined in mfem/mesh/../fem/fespace.hpp:1131:25
    t.method("GetFaceElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetFaceElement));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetEdgeElement(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetEdgeElement(int, int)
    // defined in mfem/mesh/../fem/fespace.hpp:1135:25
    t.method("GetEdgeElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetEdgeElement));
    t.method("GetEdgeElement", [](mfem::FiniteElementSpace const& a, int arg0)->const mfem::FiniteElement *{ return a.GetEdgeElement(arg0); });
    t.method("GetEdgeElement", [](mfem::FiniteElementSpace const* a, int arg0)->const mfem::FiniteElement *{ return a->GetEdgeElement(arg0); });

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetTraceElement(int, mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetTraceElement(int, mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fespace.hpp:1138:25
    t.method("GetTraceElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int, mfem::Geometry::Type)  const>(&mfem::FiniteElementSpace::GetTraceElement));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in mfem/mesh/../fem/fespace.hpp:1188:18
    t.method("D2C_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in mfem/mesh/../fem/fespace.hpp:1192:18
    t.method("D2Const_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in mfem/mesh/../fem/fespace.hpp:1197:18
    t.method("H2L_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)
    // defined in mfem/mesh/../fem/fespace.hpp:1211:9
    t.method("GetTransferOperator", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)  const>(&mfem::FiniteElementSpace::GetTransferOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetTrueTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetTrueTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)
    // defined in mfem/mesh/../fem/fespace.hpp:1228:17
    t.method("GetTrueTransferOperator", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)  const>(&mfem::FiniteElementSpace::GetTrueTransferOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::Update(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::Update(bool)
    // defined in mfem/mesh/../fem/fespace.hpp:1234:17
    t.method("Update", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::Update));
    t.method("Update", [](mfem::FiniteElementSpace& a)->void{ a.Update(); });
    t.method("Update", [](mfem::FiniteElementSpace* a)->void{ a->Update(); });

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetUpdateOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetUpdateOperator()
    // defined in mfem/mesh/../fem/fespace.hpp:1237:20
    t.method("GetUpdateOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::GetUpdateOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetUpdateOperator(mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetUpdateOperator(mfem::OperatorHandle &)
    // defined in mfem/mesh/../fem/fespace.hpp:1240:9
    t.method("GetUpdateOperator", static_cast<void (mfem::FiniteElementSpace::*)(mfem::OperatorHandle &) >(&mfem::FiniteElementSpace::GetUpdateOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetUpdateOperatorOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetUpdateOperatorOwner(bool)
    // defined in mfem/mesh/../fem/fespace.hpp:1247:9
    t.method("SetUpdateOperatorOwner", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::SetUpdateOperatorOwner));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetUpdateOperatorType(mfem::Operator::Type) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetUpdateOperatorType(mfem::Operator::Type)
    // defined in mfem/mesh/../fem/fespace.hpp:1255:9
    t.method("SetUpdateOperatorType", static_cast<void (mfem::FiniteElementSpace::*)(mfem::Operator::Type) >(&mfem::FiniteElementSpace::SetUpdateOperatorType));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::UpdatesFinished() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::UpdatesFinished()
    // defined in mfem/mesh/../fem/fespace.hpp:1258:17
    t.method("UpdatesFinished", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::UpdatesFinished));

    DEBUG_MSG("Adding wrapper for long mfem::FiniteElementSpace::GetSequence() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::FiniteElementSpace::GetSequence()
    // defined in mfem/mesh/../fem/fespace.hpp:1262:9
    t.method("GetSequence", static_cast<long (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetSequence));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::IsDGSpace() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::IsDGSpace()
    // defined in mfem/mesh/../fem/fespace.hpp:1265:9
    t.method("IsDGSpace", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::IsDGSpace));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetRelaxedHpConformity(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetRelaxedHpConformity(bool)
    // defined in mfem/mesh/../fem/fespace.hpp:1279:9
    t.method("SetRelaxedHpConformity", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::SetRelaxedHpConformity));
    t.method("SetRelaxedHpConformity", [](mfem::FiniteElementSpace& a)->void{ a.SetRelaxedHpConformity(); });
    t.method("SetRelaxedHpConformity", [](mfem::FiniteElementSpace* a)->void{ a->SetRelaxedHpConformity(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementSpace>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElementSpace(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElementSpace(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Vertex> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Vertex> : std::false_type { };
}

struct Jlmfem_Vertex: public Wrapper {

  Jlmfem_Vertex(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Vertex (" __HERE__ ")");
    // defined in mfem/mesh/vertex.hpp:22:7
    jlcxx::TypeWrapper<mfem::Vertex>  t = jlModule.add_type<mfem::Vertex>("mfem!Vertex");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Vertex>>(new jlcxx::TypeWrapper<mfem::Vertex>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Vertex>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Vertex(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Vertex(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CoarseFineTransformations> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CoarseFineTransformations> : std::false_type { };
}

struct Jlmfem_CoarseFineTransformations: public Wrapper {

  Jlmfem_CoarseFineTransformations(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CoarseFineTransformations (" __HERE__ ")");
    // defined in mfem/mesh/ncmesh.hpp:70:8
    jlcxx::TypeWrapper<mfem::CoarseFineTransformations>  t = jlModule.add_type<mfem::CoarseFineTransformations>("mfem!CoarseFineTransformations");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CoarseFineTransformations>>(new jlcxx::TypeWrapper<mfem::CoarseFineTransformations>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CoarseFineTransformations>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CoarseFineTransformations(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CoarseFineTransformations(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InverseElementTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InverseElementTransformation> : std::false_type { };
}

struct Jlmfem_InverseElementTransformation: public Wrapper {

  Jlmfem_InverseElementTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InverseElementTransformation (" __HERE__ ")");
    // defined in mfem/mesh/../fem/eltrans.hpp:185:7
    jlcxx::TypeWrapper<mfem::InverseElementTransformation>  t = jlModule.add_type<mfem::InverseElementTransformation>("mfem!InverseElementTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseElementTransformation>>(new jlcxx::TypeWrapper<mfem::InverseElementTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseElementTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InverseElementTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InverseElementTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NodeExtrudeCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NodeExtrudeCoefficient> : std::false_type { };
template<> struct SuperType<mfem::NodeExtrudeCoefficient> { typedef mfem::VectorCoefficient type; };
}

struct Jlmfem_NodeExtrudeCoefficient: public Wrapper {

  Jlmfem_NodeExtrudeCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NodeExtrudeCoefficient (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2288:7
    jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>  t = jlModule.add_type<mfem::NodeExtrudeCoefficient>("mfem!NodeExtrudeCoefficient"    , jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>>(new jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::NodeExtrudeCoefficient(const int, const int, const double) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2295:4
    t.constructor<const int, const int, const double>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::SetLayer(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NodeExtrudeCoefficient::SetLayer(const int)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2296:9
    t.method("SetLayer", static_cast<void (mfem::NodeExtrudeCoefficient::*)(const int) >(&mfem::NodeExtrudeCoefficient::SetLayer));

    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NodeExtrudeCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2298:17
    t.method("Eval", static_cast<void (mfem::NodeExtrudeCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::NodeExtrudeCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NodeExtrudeCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NodeExtrudeCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElementCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElementCollection> : std::false_type { };
}

struct Jlmfem_FiniteElementCollection: public Wrapper {

  Jlmfem_FiniteElementCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElementCollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:26:7
    jlcxx::TypeWrapper<mfem::FiniteElementCollection>  t = jlModule.add_type<mfem::FiniteElementCollection>("mfem!FiniteElementCollection");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementCollection>>(new jlcxx::TypeWrapper<mfem::FiniteElementCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:52:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForDim(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForDim(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:60:4
    t.method("FiniteElementForDim", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::FiniteElementForDim));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:62:16
    t.method("DofForGeometry", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for mfem::StatelessDofTransformation * mfem::FiniteElementCollection::DofTransformationForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: mfem::StatelessDofTransformation * mfem::FiniteElementCollection::DofTransformationForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:68:4
    t.method("DofTransformationForGeometry", static_cast<mfem::StatelessDofTransformation * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::DofTransformationForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::FiniteElementCollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::FiniteElementCollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:77:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::FiniteElementCollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::FiniteElementCollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:80:25
    t.method("Name", static_cast<const char * (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:82:16
    t.method("GetContType", static_cast<int (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetContType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetRangeType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetRangeType(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:88:16
    t.method("GetRangeType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetRangeType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivRangeType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivRangeType(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:89:16
    t.method("GetDerivRangeType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivRangeType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetMapType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetMapType(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:90:16
    t.method("GetMapType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetMapType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivType(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:91:16
    t.method("GetDerivType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivMapType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivMapType(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:92:16
    t.method("GetDerivMapType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivMapType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::HasFaceDofs(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::HasFaceDofs(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:95:8
    t.method("HasFaceDofs", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::HasFaceDofs));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::TraceFiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::TraceFiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:97:33
    t.method("TraceFiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::TraceFiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:103:37
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::New(const char *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::New(const char *)
    // defined in mfem/mesh/../fem/fe_coll.hpp:175:36
    t.method("mfem!FiniteElementCollection!New", static_cast<mfem::FiniteElementCollection * (*)(const char *) >(&mfem::FiniteElementCollection::New));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::GetFE(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::GetFE(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:191:25
    t.method("GetFE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::GetFE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetNumDof(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetNumDof(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:203:8
    t.method("GetNumDof", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::GetNumDof));

    DEBUG_MSG("Adding wrapper for const int * mfem::FiniteElementCollection::GetDofOrdering(mfem::Geometry::Type, int, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::FiniteElementCollection::GetDofOrdering(mfem::Geometry::Type, int, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:215:15
    t.method("GetDofOrdering", static_cast<const int * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int, int)  const>(&mfem::FiniteElementCollection::GetDofOrdering));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetOrder()
    // defined in mfem/mesh/../fem/fe_coll.hpp:225:8
    t.method("GetOrder", static_cast<int (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetOrder));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::Clone(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:232:37
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElementCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElementCollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::StatelessDofTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::StatelessDofTransformation> : std::false_type { };
}

struct Jlmfem_StatelessDofTransformation: public Wrapper {

  Jlmfem_StatelessDofTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::StatelessDofTransformation (" __HERE__ ")");
    // defined in mfem/mesh/../fem/doftrans.hpp:68:7
    jlcxx::TypeWrapper<mfem::StatelessDofTransformation>  t = jlModule.add_type<mfem::StatelessDofTransformation>("mfem!StatelessDofTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::StatelessDofTransformation>>(new jlcxx::TypeWrapper<mfem::StatelessDofTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::StatelessDofTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_StatelessDofTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_StatelessDofTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_H1_FECollection: public Wrapper {

  Jlmfem_H1_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:259:7
    jlcxx::TypeWrapper<mfem::H1_FECollection>  t = jlModule.add_type<mfem::H1_FECollection>("mfem!H1_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_FECollection>>(new jlcxx::TypeWrapper<mfem::H1_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1_FECollection::H1_FECollection(const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:270:13
    t.constructor<const int>(/*finalize=*/true);
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::H1_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::H1_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:273:33
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:275:16
    t.method("DofForGeometry", static_cast<int (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:277:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::H1_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::H1_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::H1_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:280:24
    t.method("Name", static_cast<const char * (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:281:16
    t.method("GetContType", static_cast<int (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::GetBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::GetBasisType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:282:8
    t.method("GetBasisType", static_cast<int (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::H1_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::H1_FECollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:284:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:287:15
    t.method("GetDofMap", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::GetDofMap));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:289:15
    t.method("GetDofMap", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::H1_FECollection::GetDofMap));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::H1_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::H1_FECollection::Clone(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:291:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::H1_FECollection::*)(int)  const>(&mfem::H1_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1Pos_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1Pos_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1Pos_FECollection> { typedef mfem::H1_FECollection type; };
}

struct Jlmfem_H1Pos_FECollection: public Wrapper {

  Jlmfem_H1Pos_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1Pos_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:299:7
    jlcxx::TypeWrapper<mfem::H1Pos_FECollection>  t = jlModule.add_type<mfem::H1Pos_FECollection>("mfem!H1Pos_FECollection"    , jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Pos_FECollection>>(new jlcxx::TypeWrapper<mfem::H1Pos_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1Pos_FECollection::H1Pos_FECollection(const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:302:13
    t.constructor<const int>(/*finalize=*/true);
    t.constructor<const int, const int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Pos_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1Pos_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1Pos_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1Ser_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1Ser_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1Ser_FECollection> { typedef mfem::H1_FECollection type; };
}

struct Jlmfem_H1Ser_FECollection: public Wrapper {

  Jlmfem_H1Ser_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1Ser_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:309:7
    jlcxx::TypeWrapper<mfem::H1Ser_FECollection>  t = jlModule.add_type<mfem::H1Ser_FECollection>("mfem!H1Ser_FECollection"    , jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Ser_FECollection>>(new jlcxx::TypeWrapper<mfem::H1Ser_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1Ser_FECollection::H1Ser_FECollection(const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:312:13
    t.constructor<const int>(/*finalize=*/true);
    t.constructor<const int, const int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Ser_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1Ser_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1Ser_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1_Trace_FECollection> { typedef mfem::H1_FECollection type; };
}

struct Jlmfem_H1_Trace_FECollection: public Wrapper {

  Jlmfem_H1_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1_Trace_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:319:7
    jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>  t = jlModule.add_type<mfem::H1_Trace_FECollection>("mfem!H1_Trace_FECollection"    , jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1_Trace_FECollection::H1_Trace_FECollection(const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:322:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::L2_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::L2_FECollection> : std::false_type { };
template<> struct SuperType<mfem::L2_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_L2_FECollection: public Wrapper {

  Jlmfem_L2_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::L2_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:327:7
    jlcxx::TypeWrapper<mfem::L2_FECollection>  t = jlModule.add_type<mfem::L2_FECollection>("mfem!L2_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::L2_FECollection>>(new jlcxx::TypeWrapper<mfem::L2_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::L2_FECollection::L2_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:342:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::L2_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::L2_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:346:33
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:348:16
    t.method("DofForGeometry", static_cast<int (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::L2_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::L2_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:356:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::L2_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::L2_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::L2_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::L2_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:358:24
    t.method("Name", static_cast<const char * (mfem::L2_FECollection::*)()  const>(&mfem::L2_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:360:16
    t.method("GetContType", static_cast<int (mfem::L2_FECollection::*)()  const>(&mfem::L2_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::L2_FECollection::TraceFiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::L2_FECollection::TraceFiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:362:33
    t.method("TraceFiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::TraceFiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::GetBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::GetBasisType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:368:8
    t.method("GetBasisType", static_cast<int (mfem::L2_FECollection::*)()  const>(&mfem::L2_FECollection::GetBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::L2_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::L2_FECollection::Clone(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:370:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::L2_FECollection::*)(int)  const>(&mfem::L2_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::L2_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_L2_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_L2_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RT_FECollection: public Wrapper {

  Jlmfem_RT_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:380:7
    jlcxx::TypeWrapper<mfem::RT_FECollection>  t = jlModule.add_type<mfem::RT_FECollection>("mfem!RT_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_FECollection::RT_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:408:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:412:33
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:414:16
    t.method("DofForGeometry", static_cast<int (mfem::RT_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:416:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:418:24
    t.method("Name", static_cast<const char * (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:419:16
    t.method("GetContType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_FECollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:420:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetClosedBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetClosedBasisType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:422:8
    t.method("GetClosedBasisType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetClosedBasisType));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetOpenBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetOpenBasisType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:423:8
    t.method("GetOpenBasisType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetOpenBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_FECollection::Clone(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:425:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::RT_FECollection::*)(int)  const>(&mfem::RT_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_Trace_FECollection> { typedef mfem::RT_FECollection type; };
}

struct Jlmfem_RT_Trace_FECollection: public Wrapper {

  Jlmfem_RT_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_Trace_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:434:7
    jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>  t = jlModule.add_type<mfem::RT_Trace_FECollection>("mfem!RT_Trace_FECollection"    , jlcxx::julia_base_type<mfem::RT_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_Trace_FECollection::RT_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:437:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DG_Interface_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DG_Interface_FECollection> : std::false_type { };
template<> struct SuperType<mfem::DG_Interface_FECollection> { typedef mfem::RT_FECollection type; };
}

struct Jlmfem_DG_Interface_FECollection: public Wrapper {

  Jlmfem_DG_Interface_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DG_Interface_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:445:7
    jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>  t = jlModule.add_type<mfem::DG_Interface_FECollection>("mfem!DG_Interface_FECollection"    , jlcxx::julia_base_type<mfem::RT_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>>(new jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DG_Interface_FECollection::DG_Interface_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:448:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DG_Interface_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DG_Interface_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_ND_FECollection: public Wrapper {

  Jlmfem_ND_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:454:7
    jlcxx::TypeWrapper<mfem::ND_FECollection>  t = jlModule.add_type<mfem::ND_FECollection>("mfem!ND_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_FECollection::ND_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:466:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:471:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:473:16
    t.method("DofForGeometry", static_cast<int (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for mfem::StatelessDofTransformation * mfem::ND_FECollection::DofTransformationForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: mfem::StatelessDofTransformation * mfem::ND_FECollection::DofTransformationForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:477:4
    t.method("DofTransformationForGeometry", static_cast<mfem::StatelessDofTransformation * (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::DofTransformationForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:479:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:482:24
    t.method("Name", static_cast<const char * (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:483:16
    t.method("GetContType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_FECollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:484:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetClosedBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetClosedBasisType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:486:8
    t.method("GetClosedBasisType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetClosedBasisType));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetOpenBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetOpenBasisType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:487:8
    t.method("GetOpenBasisType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetOpenBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_FECollection::Clone(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:489:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::ND_FECollection::*)(int)  const>(&mfem::ND_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_Trace_FECollection> { typedef mfem::ND_FECollection type; };
}

struct Jlmfem_ND_Trace_FECollection: public Wrapper {

  Jlmfem_ND_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_Trace_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:498:7
    jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>  t = jlModule.add_type<mfem::ND_Trace_FECollection>("mfem!ND_Trace_FECollection"    , jlcxx::julia_base_type<mfem::ND_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_Trace_FECollection::ND_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:501:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R1D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R1D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R1D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_ND_R1D_FECollection: public Wrapper {

  Jlmfem_ND_R1D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R1D_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:507:7
    jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>  t = jlModule.add_type<mfem::ND_R1D_FECollection>("mfem!ND_R1D_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R1D_FECollection::ND_R1D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:515:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:519:33
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R1D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_R1D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R1D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:522:16
    t.method("DofForGeometry", static_cast<int (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R1D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:524:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_R1D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_R1D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_R1D_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:526:24
    t.method("Name", static_cast<const char * (mfem::ND_R1D_FECollection::*)()  const>(&mfem::ND_R1D_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::ND_R1D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R1D_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:527:16
    t.method("GetContType", static_cast<int (mfem::ND_R1D_FECollection::*)()  const>(&mfem::ND_R1D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_R1D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_R1D_FECollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:528:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_R1D_FECollection::*)()  const>(&mfem::ND_R1D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R1D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R1D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R1D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R1D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R1D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RT_R1D_FECollection: public Wrapper {

  Jlmfem_RT_R1D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R1D_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:534:7
    jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>  t = jlModule.add_type<mfem::RT_R1D_FECollection>("mfem!RT_R1D_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R1D_FECollection::RT_R1D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:542:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:546:33
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R1D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_R1D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R1D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:549:16
    t.method("DofForGeometry", static_cast<int (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R1D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:551:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_R1D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_R1D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_R1D_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:553:24
    t.method("Name", static_cast<const char * (mfem::RT_R1D_FECollection::*)()  const>(&mfem::RT_R1D_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RT_R1D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R1D_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:554:16
    t.method("GetContType", static_cast<int (mfem::RT_R1D_FECollection::*)()  const>(&mfem::RT_R1D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_R1D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_R1D_FECollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:555:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_R1D_FECollection::*)()  const>(&mfem::RT_R1D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R1D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R1D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R2D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R2D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R2D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_ND_R2D_FECollection: public Wrapper {

  Jlmfem_ND_R2D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R2D_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:561:7
    jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>  t = jlModule.add_type<mfem::ND_R2D_FECollection>("mfem!ND_R2D_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R2D_FECollection::ND_R2D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:570:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:574:33
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R2D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_R2D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R2D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:577:16
    t.method("DofForGeometry", static_cast<int (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R2D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:579:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_R2D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_R2D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_R2D_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:581:24
    t.method("Name", static_cast<const char * (mfem::ND_R2D_FECollection::*)()  const>(&mfem::ND_R2D_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::ND_R2D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R2D_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:582:16
    t.method("GetContType", static_cast<int (mfem::ND_R2D_FECollection::*)()  const>(&mfem::ND_R2D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_R2D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_R2D_FECollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:583:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_R2D_FECollection::*)()  const>(&mfem::ND_R2D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R2D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R2D_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R2D_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R2D_Trace_FECollection> { typedef mfem::ND_R2D_FECollection type; };
}

struct Jlmfem_ND_R2D_Trace_FECollection: public Wrapper {

  Jlmfem_ND_R2D_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R2D_Trace_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:591:7
    jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>  t = jlModule.add_type<mfem::ND_R2D_Trace_FECollection>("mfem!ND_R2D_Trace_FECollection"    , jlcxx::julia_base_type<mfem::ND_R2D_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R2D_Trace_FECollection::ND_R2D_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:594:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R2D_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R2D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R2D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R2D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RT_R2D_FECollection: public Wrapper {

  Jlmfem_RT_R2D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R2D_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:600:7
    jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>  t = jlModule.add_type<mfem::RT_R2D_FECollection>("mfem!RT_R2D_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R2D_FECollection::RT_R2D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:619:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:623:33
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R2D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_R2D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R2D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:626:16
    t.method("DofForGeometry", static_cast<int (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R2D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:628:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_R2D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_R2D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_R2D_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:630:24
    t.method("Name", static_cast<const char * (mfem::RT_R2D_FECollection::*)()  const>(&mfem::RT_R2D_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RT_R2D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R2D_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:631:16
    t.method("GetContType", static_cast<int (mfem::RT_R2D_FECollection::*)()  const>(&mfem::RT_R2D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_R2D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_R2D_FECollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:632:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_R2D_FECollection::*)()  const>(&mfem::RT_R2D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R2D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R2D_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R2D_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R2D_Trace_FECollection> { typedef mfem::RT_R2D_FECollection type; };
}

struct Jlmfem_RT_R2D_Trace_FECollection: public Wrapper {

  Jlmfem_RT_R2D_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R2D_Trace_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:640:7
    jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>  t = jlModule.add_type<mfem::RT_R2D_Trace_FECollection>("mfem!RT_R2D_Trace_FECollection"    , jlcxx::julia_base_type<mfem::RT_R2D_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R2D_Trace_FECollection::RT_R2D_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:643:4
    t.constructor<const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int>(/*finalize=*/true);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R2D_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSFECollection> : std::false_type { };
template<> struct SuperType<mfem::NURBSFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_NURBSFECollection: public Wrapper {

  Jlmfem_NURBSFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:649:7
    jlcxx::TypeWrapper<mfem::NURBSFECollection>  t = jlModule.add_type<mfem::NURBSFECollection>("mfem!NURBSFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSFECollection>>(new jlcxx::TypeWrapper<mfem::NURBSFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::NURBSFECollection(int) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:670:13
    t.constructor<int>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::Reset() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSFECollection::Reset()
    // defined in mfem/mesh/../fem/fe_coll.hpp:672:9
    t.method("Reset", static_cast<void (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::Reset));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::GetOrder()
    // defined in mfem/mesh/../fem/fe_coll.hpp:682:8
    t.method("GetOrder", static_cast<int (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetOrder));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::SetOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSFECollection::SetOrder(int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:686:9
    t.method("SetOrder", static_cast<void (mfem::NURBSFECollection::*)(int)  const>(&mfem::NURBSFECollection::SetOrder));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::NURBSFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::NURBSFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:689:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::NURBSFECollection::*)(mfem::Geometry::Type)  const>(&mfem::NURBSFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:691:16
    t.method("DofForGeometry", static_cast<int (mfem::NURBSFECollection::*)(mfem::Geometry::Type)  const>(&mfem::NURBSFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::NURBSFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::NURBSFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:693:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::NURBSFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::NURBSFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::NURBSFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::NURBSFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:696:24
    t.method("Name", static_cast<const char * (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:698:16
    t.method("GetContType", static_cast<int (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::NURBSFECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::NURBSFECollection::GetTraceCollection()
    // defined in mfem/mesh/../fem/fe_coll.hpp:700:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_LinearFECollection: public Wrapper {

  Jlmfem_LinearFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:707:7
    jlcxx::TypeWrapper<mfem::LinearFECollection>  t = jlModule.add_type<mfem::LinearFECollection>("mfem!LinearFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFECollection>>(new jlcxx::TypeWrapper<mfem::LinearFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:722:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:724:16
    t.method("DofForGeometry", static_cast<int (mfem::LinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:726:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:729:25
    t.method("Name", static_cast<const char * (mfem::LinearFECollection::*)()  const>(&mfem::LinearFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::LinearFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:731:16
    t.method("GetContType", static_cast<int (mfem::LinearFECollection::*)()  const>(&mfem::LinearFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_QuadraticFECollection: public Wrapper {

  Jlmfem_QuadraticFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:735:7
    jlcxx::TypeWrapper<mfem::QuadraticFECollection>  t = jlModule.add_type<mfem::QuadraticFECollection>("mfem!QuadraticFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:751:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:753:16
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:755:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:758:25
    t.method("Name", static_cast<const char * (mfem::QuadraticFECollection::*)()  const>(&mfem::QuadraticFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:760:16
    t.method("GetContType", static_cast<int (mfem::QuadraticFECollection::*)()  const>(&mfem::QuadraticFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticPosFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticPosFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticPosFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_QuadraticPosFECollection: public Wrapper {

  Jlmfem_QuadraticPosFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticPosFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:764:7
    jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>  t = jlModule.add_type<mfem::QuadraticPosFECollection>("mfem!QuadraticPosFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticPosFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticPosFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:774:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:776:16
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticPosFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticPosFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:778:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticPosFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticPosFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticPosFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:781:25
    t.method("Name", static_cast<const char * (mfem::QuadraticPosFECollection::*)()  const>(&mfem::QuadraticPosFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:783:16
    t.method("GetContType", static_cast<int (mfem::QuadraticPosFECollection::*)()  const>(&mfem::QuadraticPosFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticPosFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CubicFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CubicFECollection> : std::false_type { };
template<> struct SuperType<mfem::CubicFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_CubicFECollection: public Wrapper {

  Jlmfem_CubicFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CubicFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:787:7
    jlcxx::TypeWrapper<mfem::CubicFECollection>  t = jlModule.add_type<mfem::CubicFECollection>("mfem!CubicFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicFECollection>>(new jlcxx::TypeWrapper<mfem::CubicFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CubicFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CubicFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:805:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CubicFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CubicFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:807:16
    t.method("DofForGeometry", static_cast<int (mfem::CubicFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CubicFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CubicFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:809:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CubicFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CubicFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CubicFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CubicFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:812:25
    t.method("Name", static_cast<const char * (mfem::CubicFECollection::*)()  const>(&mfem::CubicFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::CubicFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:814:16
    t.method("GetContType", static_cast<int (mfem::CubicFECollection::*)()  const>(&mfem::CubicFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CubicFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CubicFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CrouzeixRaviartFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CrouzeixRaviartFECollection> : std::false_type { };
template<> struct SuperType<mfem::CrouzeixRaviartFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_CrouzeixRaviartFECollection: public Wrapper {

  Jlmfem_CrouzeixRaviartFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CrouzeixRaviartFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:818:7
    jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>  t = jlModule.add_type<mfem::CrouzeixRaviartFECollection>("mfem!CrouzeixRaviartFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>>(new jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:828:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CrouzeixRaviartFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CrouzeixRaviartFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:830:16
    t.method("DofForGeometry", static_cast<int (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CrouzeixRaviartFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CrouzeixRaviartFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CrouzeixRaviartFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:832:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CrouzeixRaviartFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CrouzeixRaviartFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CrouzeixRaviartFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:835:25
    t.method("Name", static_cast<const char * (mfem::CrouzeixRaviartFECollection::*)()  const>(&mfem::CrouzeixRaviartFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::CrouzeixRaviartFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CrouzeixRaviartFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:837:16
    t.method("GetContType", static_cast<int (mfem::CrouzeixRaviartFECollection::*)()  const>(&mfem::CrouzeixRaviartFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CrouzeixRaviartFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CrouzeixRaviartFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearNonConf3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearNonConf3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearNonConf3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_LinearNonConf3DFECollection: public Wrapper {

  Jlmfem_LinearNonConf3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearNonConf3DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:841:7
    jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>  t = jlModule.add_type<mfem::LinearNonConf3DFECollection>("mfem!LinearNonConf3DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearNonConf3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearNonConf3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:853:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearNonConf3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearNonConf3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearNonConf3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:855:16
    t.method("DofForGeometry", static_cast<int (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearNonConf3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearNonConf3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearNonConf3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:857:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearNonConf3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearNonConf3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearNonConf3DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:860:25
    t.method("Name", static_cast<const char * (mfem::LinearNonConf3DFECollection::*)()  const>(&mfem::LinearNonConf3DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::LinearNonConf3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearNonConf3DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:862:16
    t.method("GetContType", static_cast<int (mfem::LinearNonConf3DFECollection::*)()  const>(&mfem::LinearNonConf3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearNonConf3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearNonConf3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT0_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT0_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT0_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RT0_2DFECollection: public Wrapper {

  Jlmfem_RT0_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT0_2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:868:7
    jlcxx::TypeWrapper<mfem::RT0_2DFECollection>  t = jlModule.add_type<mfem::RT0_2DFECollection>("mfem!RT0_2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT0_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT0_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT0_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:878:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT0_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:880:16
    t.method("DofForGeometry", static_cast<int (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT0_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT0_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:882:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT0_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT0_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT0_2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:885:25
    t.method("Name", static_cast<const char * (mfem::RT0_2DFECollection::*)()  const>(&mfem::RT0_2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RT0_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:887:16
    t.method("GetContType", static_cast<int (mfem::RT0_2DFECollection::*)()  const>(&mfem::RT0_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT0_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT0_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT1_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT1_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT1_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RT1_2DFECollection: public Wrapper {

  Jlmfem_RT1_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT1_2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:892:7
    jlcxx::TypeWrapper<mfem::RT1_2DFECollection>  t = jlModule.add_type<mfem::RT1_2DFECollection>("mfem!RT1_2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT1_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT1_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT1_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:902:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT1_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:904:16
    t.method("DofForGeometry", static_cast<int (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT1_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT1_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:906:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT1_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT1_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT1_2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:909:25
    t.method("Name", static_cast<const char * (mfem::RT1_2DFECollection::*)()  const>(&mfem::RT1_2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RT1_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:911:16
    t.method("GetContType", static_cast<int (mfem::RT1_2DFECollection::*)()  const>(&mfem::RT1_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT1_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT1_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT2_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT2_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT2_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RT2_2DFECollection: public Wrapper {

  Jlmfem_RT2_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT2_2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:916:7
    jlcxx::TypeWrapper<mfem::RT2_2DFECollection>  t = jlModule.add_type<mfem::RT2_2DFECollection>("mfem!RT2_2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT2_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT2_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT2_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT2_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:926:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT2_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT2_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT2_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:928:16
    t.method("DofForGeometry", static_cast<int (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT2_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT2_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT2_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:930:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT2_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT2_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT2_2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:933:25
    t.method("Name", static_cast<const char * (mfem::RT2_2DFECollection::*)()  const>(&mfem::RT2_2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RT2_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT2_2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:935:16
    t.method("GetContType", static_cast<int (mfem::RT2_2DFECollection::*)()  const>(&mfem::RT2_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT2_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT2_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT2_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Const2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Const2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::Const2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_Const2DFECollection: public Wrapper {

  Jlmfem_Const2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Const2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:941:7
    jlcxx::TypeWrapper<mfem::Const2DFECollection>  t = jlModule.add_type<mfem::Const2DFECollection>("mfem!Const2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Const2DFECollection>>(new jlcxx::TypeWrapper<mfem::Const2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Const2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Const2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:950:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Const2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Const2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:952:16
    t.method("DofForGeometry", static_cast<int (mfem::Const2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Const2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Const2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:954:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Const2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Const2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Const2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Const2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:957:25
    t.method("Name", static_cast<const char * (mfem::Const2DFECollection::*)()  const>(&mfem::Const2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::Const2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:959:16
    t.method("GetContType", static_cast<int (mfem::Const2DFECollection::*)()  const>(&mfem::Const2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Const2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Const2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Const2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_LinearDiscont2DFECollection: public Wrapper {

  Jlmfem_LinearDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearDiscont2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:965:7
    jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>  t = jlModule.add_type<mfem::LinearDiscont2DFECollection>("mfem!LinearDiscont2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:975:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:977:16
    t.method("DofForGeometry", static_cast<int (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:979:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearDiscont2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:982:25
    t.method("Name", static_cast<const char * (mfem::LinearDiscont2DFECollection::*)()  const>(&mfem::LinearDiscont2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:984:16
    t.method("GetContType", static_cast<int (mfem::LinearDiscont2DFECollection::*)()  const>(&mfem::LinearDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GaussLinearDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GaussLinearDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::GaussLinearDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_GaussLinearDiscont2DFECollection: public Wrapper {

  Jlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GaussLinearDiscont2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:988:7
    jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>  t = jlModule.add_type<mfem::GaussLinearDiscont2DFECollection>("mfem!GaussLinearDiscont2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:999:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::GaussLinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussLinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1001:16
    t.method("DofForGeometry", static_cast<int (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussLinearDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1003:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::GaussLinearDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::GaussLinearDiscont2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1006:25
    t.method("Name", static_cast<const char * (mfem::GaussLinearDiscont2DFECollection::*)()  const>(&mfem::GaussLinearDiscont2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::GaussLinearDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussLinearDiscont2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1008:16
    t.method("GetContType", static_cast<int (mfem::GaussLinearDiscont2DFECollection::*)()  const>(&mfem::GaussLinearDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GaussLinearDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::P1OnQuadFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::P1OnQuadFECollection> : std::false_type { };
template<> struct SuperType<mfem::P1OnQuadFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_P1OnQuadFECollection: public Wrapper {

  Jlmfem_P1OnQuadFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::P1OnQuadFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1012:7
    jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>  t = jlModule.add_type<mfem::P1OnQuadFECollection>("mfem!P1OnQuadFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>>(new jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::P1OnQuadFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::P1OnQuadFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1019:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type)  const>(&mfem::P1OnQuadFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::P1OnQuadFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::P1OnQuadFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1020:16
    t.method("DofForGeometry", static_cast<int (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type)  const>(&mfem::P1OnQuadFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::P1OnQuadFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::P1OnQuadFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1021:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::P1OnQuadFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::P1OnQuadFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::P1OnQuadFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1023:25
    t.method("Name", static_cast<const char * (mfem::P1OnQuadFECollection::*)()  const>(&mfem::P1OnQuadFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::P1OnQuadFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::P1OnQuadFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1024:16
    t.method("GetContType", static_cast<int (mfem::P1OnQuadFECollection::*)()  const>(&mfem::P1OnQuadFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_P1OnQuadFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_P1OnQuadFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_QuadraticDiscont2DFECollection: public Wrapper {

  Jlmfem_QuadraticDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticDiscont2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1030:7
    jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>  t = jlModule.add_type<mfem::QuadraticDiscont2DFECollection>("mfem!QuadraticDiscont2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1040:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1042:16
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1044:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticDiscont2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1047:25
    t.method("Name", static_cast<const char * (mfem::QuadraticDiscont2DFECollection::*)()  const>(&mfem::QuadraticDiscont2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1048:16
    t.method("GetContType", static_cast<int (mfem::QuadraticDiscont2DFECollection::*)()  const>(&mfem::QuadraticDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticPosDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticPosDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticPosDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_QuadraticPosDiscont2DFECollection: public Wrapper {

  Jlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticPosDiscont2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1052:7
    jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>  t = jlModule.add_type<mfem::QuadraticPosDiscont2DFECollection>("mfem!QuadraticPosDiscont2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1060:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1061:16
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1062:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticPosDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticPosDiscont2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1065:25
    t.method("Name", static_cast<const char * (mfem::QuadraticPosDiscont2DFECollection::*)()  const>(&mfem::QuadraticPosDiscont2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosDiscont2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1066:16
    t.method("GetContType", static_cast<int (mfem::QuadraticPosDiscont2DFECollection::*)()  const>(&mfem::QuadraticPosDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticPosDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GaussQuadraticDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GaussQuadraticDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::GaussQuadraticDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_GaussQuadraticDiscont2DFECollection: public Wrapper {

  Jlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GaussQuadraticDiscont2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1070:7
    jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>  t = jlModule.add_type<mfem::GaussQuadraticDiscont2DFECollection>("mfem!GaussQuadraticDiscont2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1081:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1083:16
    t.method("DofForGeometry", static_cast<int (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1085:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::GaussQuadraticDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::GaussQuadraticDiscont2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1088:25
    t.method("Name", static_cast<const char * (mfem::GaussQuadraticDiscont2DFECollection::*)()  const>(&mfem::GaussQuadraticDiscont2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::GaussQuadraticDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussQuadraticDiscont2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1089:16
    t.method("GetContType", static_cast<int (mfem::GaussQuadraticDiscont2DFECollection::*)()  const>(&mfem::GaussQuadraticDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GaussQuadraticDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CubicDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CubicDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::CubicDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_CubicDiscont2DFECollection: public Wrapper {

  Jlmfem_CubicDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CubicDiscont2DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1095:7
    jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>  t = jlModule.add_type<mfem::CubicDiscont2DFECollection>("mfem!CubicDiscont2DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CubicDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CubicDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1105:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CubicDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1107:16
    t.method("DofForGeometry", static_cast<int (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CubicDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CubicDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1109:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CubicDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CubicDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CubicDiscont2DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1112:25
    t.method("Name", static_cast<const char * (mfem::CubicDiscont2DFECollection::*)()  const>(&mfem::CubicDiscont2DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::CubicDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicDiscont2DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1113:16
    t.method("GetContType", static_cast<int (mfem::CubicDiscont2DFECollection::*)()  const>(&mfem::CubicDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CubicDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CubicDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Const3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Const3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::Const3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_Const3DFECollection: public Wrapper {

  Jlmfem_Const3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Const3DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1119:7
    jlcxx::TypeWrapper<mfem::Const3DFECollection>  t = jlModule.add_type<mfem::Const3DFECollection>("mfem!Const3DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Const3DFECollection>>(new jlcxx::TypeWrapper<mfem::Const3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Const3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Const3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1131:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Const3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Const3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1133:16
    t.method("DofForGeometry", static_cast<int (mfem::Const3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Const3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Const3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1135:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Const3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Const3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Const3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Const3DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1138:25
    t.method("Name", static_cast<const char * (mfem::Const3DFECollection::*)()  const>(&mfem::Const3DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::Const3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const3DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1139:16
    t.method("GetContType", static_cast<int (mfem::Const3DFECollection::*)()  const>(&mfem::Const3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Const3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Const3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Const3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearDiscont3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearDiscont3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearDiscont3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_LinearDiscont3DFECollection: public Wrapper {

  Jlmfem_LinearDiscont3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearDiscont3DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1145:7
    jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>  t = jlModule.add_type<mfem::LinearDiscont3DFECollection>("mfem!LinearDiscont3DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1157:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1159:16
    t.method("DofForGeometry", static_cast<int (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1161:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearDiscont3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearDiscont3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearDiscont3DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1164:25
    t.method("Name", static_cast<const char * (mfem::LinearDiscont3DFECollection::*)()  const>(&mfem::LinearDiscont3DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont3DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1165:16
    t.method("GetContType", static_cast<int (mfem::LinearDiscont3DFECollection::*)()  const>(&mfem::LinearDiscont3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearDiscont3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticDiscont3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticDiscont3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticDiscont3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_QuadraticDiscont3DFECollection: public Wrapper {

  Jlmfem_QuadraticDiscont3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticDiscont3DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1171:7
    jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>  t = jlModule.add_type<mfem::QuadraticDiscont3DFECollection>("mfem!QuadraticDiscont3DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1182:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1184:16
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1186:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticDiscont3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticDiscont3DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1189:25
    t.method("Name", static_cast<const char * (mfem::QuadraticDiscont3DFECollection::*)()  const>(&mfem::QuadraticDiscont3DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont3DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1190:16
    t.method("GetContType", static_cast<int (mfem::QuadraticDiscont3DFECollection::*)()  const>(&mfem::QuadraticDiscont3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticDiscont3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RefinedLinearFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RefinedLinearFECollection> : std::false_type { };
template<> struct SuperType<mfem::RefinedLinearFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RefinedLinearFECollection: public Wrapper {

  Jlmfem_RefinedLinearFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RefinedLinearFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1194:7
    jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>  t = jlModule.add_type<mfem::RefinedLinearFECollection>("mfem!RefinedLinearFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>>(new jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RefinedLinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RefinedLinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1208:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RefinedLinearFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RefinedLinearFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RefinedLinearFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1210:16
    t.method("DofForGeometry", static_cast<int (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RefinedLinearFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RefinedLinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RefinedLinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1212:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RefinedLinearFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RefinedLinearFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RefinedLinearFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1215:25
    t.method("Name", static_cast<const char * (mfem::RefinedLinearFECollection::*)()  const>(&mfem::RefinedLinearFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RefinedLinearFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RefinedLinearFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1216:16
    t.method("GetContType", static_cast<int (mfem::RefinedLinearFECollection::*)()  const>(&mfem::RefinedLinearFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RefinedLinearFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RefinedLinearFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND1_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND1_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::ND1_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_ND1_3DFECollection: public Wrapper {

  Jlmfem_ND1_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND1_3DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1222:7
    jlcxx::TypeWrapper<mfem::ND1_3DFECollection>  t = jlModule.add_type<mfem::ND1_3DFECollection>("mfem!ND1_3DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND1_3DFECollection>>(new jlcxx::TypeWrapper<mfem::ND1_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1234:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND1_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND1_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND1_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1236:16
    t.method("DofForGeometry", static_cast<int (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND1_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1238:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND1_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND1_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND1_3DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1241:25
    t.method("Name", static_cast<const char * (mfem::ND1_3DFECollection::*)()  const>(&mfem::ND1_3DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::ND1_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND1_3DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1242:16
    t.method("GetContType", static_cast<int (mfem::ND1_3DFECollection::*)()  const>(&mfem::ND1_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND1_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND1_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND1_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT0_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT0_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT0_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RT0_3DFECollection: public Wrapper {

  Jlmfem_RT0_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT0_3DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1247:7
    jlcxx::TypeWrapper<mfem::RT0_3DFECollection>  t = jlModule.add_type<mfem::RT0_3DFECollection>("mfem!RT0_3DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_3DFECollection>>(new jlcxx::TypeWrapper<mfem::RT0_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT0_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT0_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1260:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT0_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1262:16
    t.method("DofForGeometry", static_cast<int (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT0_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT0_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1264:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT0_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT0_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT0_3DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1267:25
    t.method("Name", static_cast<const char * (mfem::RT0_3DFECollection::*)()  const>(&mfem::RT0_3DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RT0_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_3DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1268:16
    t.method("GetContType", static_cast<int (mfem::RT0_3DFECollection::*)()  const>(&mfem::RT0_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT0_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT0_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT1_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT1_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT1_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_RT1_3DFECollection: public Wrapper {

  Jlmfem_RT1_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT1_3DFECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1273:7
    jlcxx::TypeWrapper<mfem::RT1_3DFECollection>  t = jlModule.add_type<mfem::RT1_3DFECollection>("mfem!RT1_3DFECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_3DFECollection>>(new jlcxx::TypeWrapper<mfem::RT1_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1283:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT1_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1285:16
    t.method("DofForGeometry", static_cast<int (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1287:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT1_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT1_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT1_3DFECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1290:25
    t.method("Name", static_cast<const char * (mfem::RT1_3DFECollection::*)()  const>(&mfem::RT1_3DFECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::RT1_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_3DFECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1291:16
    t.method("GetContType", static_cast<int (mfem::RT1_3DFECollection::*)()  const>(&mfem::RT1_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT1_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT1_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Local_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Local_FECollection> : std::false_type { };
template<> struct SuperType<mfem::Local_FECollection> { typedef mfem::FiniteElementCollection type; };
}

struct Jlmfem_Local_FECollection: public Wrapper {

  Jlmfem_Local_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Local_FECollection (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1295:7
    jlcxx::TypeWrapper<mfem::Local_FECollection>  t = jlModule.add_type<mfem::Local_FECollection>("mfem!Local_FECollection"    , jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Local_FECollection>>(new jlcxx::TypeWrapper<mfem::Local_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::Local_FECollection::Local_FECollection(const char *) (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fe_coll.hpp:1303:4
    t.constructor<const char *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Local_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Local_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1305:33
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Local_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::Local_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Local_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Local_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1308:16
    t.method("DofForGeometry", static_cast<int (mfem::Local_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::Local_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Local_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Local_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in mfem/mesh/../fem/fe_coll.hpp:1310:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Local_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Local_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Local_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Local_FECollection::Name()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1313:24
    t.method("Name", static_cast<const char * (mfem::Local_FECollection::*)()  const>(&mfem::Local_FECollection::Name));

    DEBUG_MSG("Adding wrapper for int mfem::Local_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Local_FECollection::GetContType()
    // defined in mfem/mesh/../fem/fe_coll.hpp:1316:16
    t.method("GetContType", static_cast<int (mfem::Local_FECollection::*)()  const>(&mfem::Local_FECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Local_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Local_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Local_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Ordering> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Ordering> : std::false_type { };
}

struct Jlmfem_Ordering: public Wrapper {

  Jlmfem_Ordering(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Ordering (" __HERE__ ")");
    // defined in mfem/mesh/../fem/fespace.hpp:29:7
    jlcxx::TypeWrapper<mfem::Ordering>  t = jlModule.add_type<mfem::Ordering>("mfem!Ordering");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Ordering>>(new jlcxx::TypeWrapper<mfem::Ordering>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Ordering>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Ordering(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Ordering(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ElementRestrictionOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ElementRestrictionOperator> : std::false_type { };
template<> struct SuperType<mfem::ElementRestrictionOperator> { typedef mfem::Operator type; };
}

struct Jlmfem_ElementRestrictionOperator: public Wrapper {

  Jlmfem_ElementRestrictionOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ElementRestrictionOperator (" __HERE__ ")");
    // defined in mfem/mesh/../fem/restriction.hpp:25:7
    jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>  t = jlModule.add_type<mfem::ElementRestrictionOperator>("mfem!ElementRestrictionOperator"    , jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>>(new jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ElementRestrictionOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ElementRestrictionOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceRestriction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceRestriction> : std::false_type { };
template<> struct SuperType<mfem::FaceRestriction> { typedef mfem::Operator type; };
}

struct Jlmfem_FaceRestriction: public Wrapper {

  Jlmfem_FaceRestriction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceRestriction (" __HERE__ ")");
    // defined in mfem/mesh/../fem/restriction.hpp:159:7
    jlcxx::TypeWrapper<mfem::FaceRestriction>  t = jlModule.add_type<mfem::FaceRestriction>("mfem!FaceRestriction"    , jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceRestriction>>(new jlcxx::TypeWrapper<mfem::FaceRestriction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceRestriction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceRestriction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceRestriction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureSpace> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureSpace> : std::false_type { };
template<> struct SuperType<mfem::QuadratureSpace> { typedef mfem::QuadratureSpaceBase type; };
}

struct Jlmfem_QuadratureSpace: public Wrapper {

  Jlmfem_QuadratureSpace(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureSpace (" __HERE__ ")");
    // defined in mfem/mesh/../fem/qspace.hpp:92:7
    jlcxx::TypeWrapper<mfem::QuadratureSpace>  t = jlModule.add_type<mfem::QuadratureSpace>("mfem!QuadratureSpace"    , jlcxx::julia_base_type<mfem::QuadratureSpaceBase>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpace>>(new jlcxx::TypeWrapper<mfem::QuadratureSpace>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpace>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpace(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureSpace(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DofTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DofTransformation> : std::false_type { };
template<> struct SuperType<mfem::DofTransformation> { typedef mfem::StatelessDofTransformation type; };
}

struct Jlmfem_DofTransformation: public Wrapper {

  Jlmfem_DofTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DofTransformation (" __HERE__ ")");
    // defined in mfem/mesh/../fem/doftrans.hpp:136:7
    jlcxx::TypeWrapper<mfem::DofTransformation>  t = jlModule.add_type<mfem::DofTransformation>("mfem!DofTransformation"    , jlcxx::julia_base_type<mfem::StatelessDofTransformation>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DofTransformation>>(new jlcxx::TypeWrapper<mfem::DofTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DofTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DofTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DofTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OperatorHandle> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OperatorHandle> : std::false_type { };
}

struct Jlmfem_OperatorHandle: public Wrapper {

  Jlmfem_OperatorHandle(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OperatorHandle (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../linalg/handle.hpp:33:7
    jlcxx::TypeWrapper<mfem::OperatorHandle>  t = jlModule.add_type<mfem::OperatorHandle>("mfem!OperatorHandle");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorHandle>>(new jlcxx::TypeWrapper<mfem::OperatorHandle>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorHandle>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OperatorHandle(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OperatorHandle(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearForm> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearForm> : std::false_type { };
template<> struct SuperType<mfem::LinearForm> { typedef mfem::Vector type; };
}

struct Jlmfem_LinearForm: public Wrapper {

  Jlmfem_LinearForm(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearForm (" __HERE__ ")");
    // defined in mfem/fem/linearform.hpp:24:7
    jlcxx::TypeWrapper<mfem::LinearForm>  t = jlModule.add_type<mfem::LinearForm>("mfem!LinearForm"    , jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearForm>>(new jlcxx::TypeWrapper<mfem::LinearForm>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::LinearForm(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in mfem/fem/linearform.hpp:88:4
    t.constructor<mfem::FiniteElementSpace *>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::LinearForm(mfem::FiniteElementSpace *, mfem::LinearForm *) (" __HERE__ ")");
    // defined in mfem/fem/linearform.hpp:98:4
    t.constructor<mfem::FiniteElementSpace *, mfem::LinearForm *>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::LinearForm(mfem::FiniteElementSpace *, double *) (" __HERE__ ")");
    // defined in mfem/fem/linearform.hpp:112:4
    t.constructor<mfem::FiniteElementSpace *, double *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for mfem::LinearForm & mfem::LinearForm::operator=(const mfem::LinearForm &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::LinearForm & mfem::LinearForm::operator=(const mfem::LinearForm &)
    // defined in mfem/fem/linearform.hpp:121:16
    t.method("assign", static_cast<mfem::LinearForm & (mfem::LinearForm::*)(const mfem::LinearForm &) >(&mfem::LinearForm::operator=));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::LinearForm::GetFES() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::LinearForm::GetFES()
    // defined in mfem/fem/linearform.hpp:126:40
    t.method("GetFES", static_cast<mfem::FiniteElementSpace * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetFES));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::LinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::LinearForm::FESpace()
    // defined in mfem/fem/linearform.hpp:129:24
    t.method("FESpace", static_cast<mfem::FiniteElementSpace * (mfem::LinearForm::*)() >(&mfem::LinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::LinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::LinearForm::FESpace()
    // defined in mfem/fem/linearform.hpp:131:30
    t.method("FESpace", static_cast<const mfem::FiniteElementSpace * (mfem::LinearForm::*)()  const>(&mfem::LinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddDomainIntegrator(mfem::LinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddDomainIntegrator(mfem::LinearFormIntegrator *)
    // defined in mfem/fem/linearform.hpp:134:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *) >(&mfem::LinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddBoundaryIntegrator(mfem::LinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddBoundaryIntegrator(mfem::LinearFormIntegrator *)
    // defined in mfem/fem/linearform.hpp:141:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *) >(&mfem::LinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddBdrFaceIntegrator(mfem::LinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddBdrFaceIntegrator(mfem::LinearFormIntegrator *)
    // defined in mfem/fem/linearform.hpp:152:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *) >(&mfem::LinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddInteriorFaceIntegrator(mfem::LinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddInteriorFaceIntegrator(mfem::LinearFormIntegrator *)
    // defined in mfem/fem/linearform.hpp:163:9
    t.method("AddInteriorFaceIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *) >(&mfem::LinearForm::AddInteriorFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::UseFastAssembly(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::UseFastAssembly(bool)
    // defined in mfem/fem/linearform.hpp:197:9
    t.method("UseFastAssembly", static_cast<void (mfem::LinearForm::*)(bool) >(&mfem::LinearForm::UseFastAssembly));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::Assemble() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::Assemble()
    // defined in mfem/fem/linearform.hpp:203:9
    t.method("Assemble", static_cast<void (mfem::LinearForm::*)() >(&mfem::LinearForm::Assemble));

    DEBUG_MSG("Adding wrapper for bool mfem::LinearForm::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::LinearForm::SupportsDevice()
    // defined in mfem/fem/linearform.hpp:206:17
    t.method("SupportsDevice", static_cast<bool (mfem::LinearForm::*)()  const>(&mfem::LinearForm::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AssembleDelta() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AssembleDelta()
    // defined in mfem/fem/linearform.hpp:209:9
    t.method("AssembleDelta", static_cast<void (mfem::LinearForm::*)() >(&mfem::LinearForm::AssembleDelta));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::Update() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::Update()
    // defined in mfem/fem/linearform.hpp:216:9
    t.method("Update", static_cast<void (mfem::LinearForm::*)() >(&mfem::LinearForm::Update));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::Update(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::Update(mfem::FiniteElementSpace *)
    // defined in mfem/fem/linearform.hpp:219:9
    t.method("Update", static_cast<void (mfem::LinearForm::*)(mfem::FiniteElementSpace *) >(&mfem::LinearForm::Update));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::Update(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::Update(mfem::FiniteElementSpace *, mfem::Vector &, int)
    // defined in mfem/fem/linearform.hpp:225:9
    t.method("Update", static_cast<void (mfem::LinearForm::*)(mfem::FiniteElementSpace *, mfem::Vector &, int) >(&mfem::LinearForm::Update));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::MakeRef(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::MakeRef(mfem::FiniteElementSpace *, mfem::Vector &, int)
    // defined in mfem/fem/linearform.hpp:235:17
    t.method("MakeRef", static_cast<void (mfem::LinearForm::*)(mfem::FiniteElementSpace *, mfem::Vector &, int) >(&mfem::LinearForm::MakeRef));

    DEBUG_MSG("Adding wrapper for double mfem::LinearForm::operator()(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::LinearForm::operator()(const mfem::GridFunction &)
    // defined in mfem/fem/linearform.hpp:242:11
    t.method("paren", static_cast<double (mfem::LinearForm::*)(const mfem::GridFunction &)  const>(&mfem::LinearForm::operator()));

    DEBUG_MSG("Adding wrapper for mfem::LinearForm & mfem::LinearForm::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::LinearForm & mfem::LinearForm::operator=(double)
    // defined in mfem/fem/linearform.hpp:245:16
    t.method("assign", static_cast<mfem::LinearForm & (mfem::LinearForm::*)(double) >(&mfem::LinearForm::operator=));

    DEBUG_MSG("Adding wrapper for mfem::LinearForm & mfem::LinearForm::operator=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::LinearForm & mfem::LinearForm::operator=(const mfem::Vector &)
    // defined in mfem/fem/linearform.hpp:250:16
    t.method("assign", static_cast<mfem::LinearForm & (mfem::LinearForm::*)(const mfem::Vector &) >(&mfem::LinearForm::operator=));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearForm>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearForm(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearForm(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearFormIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearFormIntegrator> : std::false_type { };
}

struct Jlmfem_LinearFormIntegrator: public Wrapper {

  Jlmfem_LinearFormIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearFormIntegrator (" __HERE__ ")");
    // defined in mfem/mesh/../fem/lininteg.hpp:24:7
    jlcxx::TypeWrapper<mfem::LinearFormIntegrator>  t = jlModule.add_type<mfem::LinearFormIntegrator>("mfem!LinearFormIntegrator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFormIntegrator>>(new jlcxx::TypeWrapper<mfem::LinearFormIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFormIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearFormIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearFormIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Hybridization> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Hybridization> : std::false_type { };
}

struct Jlmfem_Hybridization: public Wrapper {

  Jlmfem_Hybridization(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Hybridization (" __HERE__ ")");
    // defined in mfem/mesh/../fem/hybridization.hpp:60:7
    jlcxx::TypeWrapper<mfem::Hybridization>  t = jlModule.add_type<mfem::Hybridization>("mfem!Hybridization");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Hybridization>>(new jlcxx::TypeWrapper<mfem::Hybridization>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Hybridization>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Hybridization(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Hybridization(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BilinearFormIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BilinearFormIntegrator> : std::false_type { };
}

struct Jlmfem_BilinearFormIntegrator: public Wrapper {

  Jlmfem_BilinearFormIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BilinearFormIntegrator (" __HERE__ ")");
    // defined in mfem/mesh/../fem/bilininteg.hpp:35:7
    jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>  t = jlModule.add_type<mfem::BilinearFormIntegrator>("mfem!BilinearFormIntegrator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>>(new jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BilinearFormIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BilinearFormIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedBilinearForm> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedBilinearForm> : std::false_type { };
}

struct Jlmfem_MixedBilinearForm: public Wrapper {

  Jlmfem_MixedBilinearForm(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedBilinearForm (" __HERE__ ")");
    // defined in mfem/fem/bilinearform.hpp:696:7
    jlcxx::TypeWrapper<mfem::MixedBilinearForm>  t = jlModule.add_type<mfem::MixedBilinearForm>("mfem!MixedBilinearForm");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedBilinearForm>>(new jlcxx::TypeWrapper<mfem::MixedBilinearForm>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::MixedBilinearForm(mfem::FiniteElementSpace *, mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in mfem/fem/bilinearform.hpp:747:4
    t.constructor<mfem::FiniteElementSpace *, mfem::FiniteElementSpace *>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::MixedBilinearForm(mfem::FiniteElementSpace *, mfem::FiniteElementSpace *, mfem::MixedBilinearForm *) (" __HERE__ ")");
    // defined in mfem/fem/bilinearform.hpp:759:4
    t.constructor<mfem::FiniteElementSpace *, mfem::FiniteElementSpace *, mfem::MixedBilinearForm *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for double & mfem::MixedBilinearForm::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::MixedBilinearForm::Elem(int, int)
    // defined in mfem/fem/bilinearform.hpp:764:20
    t.method("Elem", static_cast<double & (mfem::MixedBilinearForm::*)(int, int) >(&mfem::MixedBilinearForm::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::MixedBilinearForm::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::MixedBilinearForm::Elem(int, int)
    // defined in mfem/fem/bilinearform.hpp:767:26
    t.method("Elem", static_cast<const double & (mfem::MixedBilinearForm::*)(int, int)  const>(&mfem::MixedBilinearForm::Elem));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:770:17
    t.method("Mult", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MixedBilinearForm::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddMult(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddMult(const mfem::Vector &, mfem::Vector &, const double)
    // defined in mfem/fem/bilinearform.hpp:772:17
    t.method("AddMult", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::MixedBilinearForm::AddMult));
    t.method("AddMult", [](mfem::MixedBilinearForm const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a.AddMult(arg0, arg1); });
    t.method("AddMult", [](mfem::MixedBilinearForm const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a->AddMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:775:17
    t.method("MultTranspose", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MixedBilinearForm::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double)
    // defined in mfem/fem/bilinearform.hpp:776:17
    t.method("AddMultTranspose", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::MixedBilinearForm::AddMultTranspose));
    t.method("AddMultTranspose", [](mfem::MixedBilinearForm const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a.AddMultTranspose(arg0, arg1); });
    t.method("AddMultTranspose", [](mfem::MixedBilinearForm const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void{ a->AddMultTranspose(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::MatrixInverse * mfem::MixedBilinearForm::Inverse() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixInverse * mfem::MixedBilinearForm::Inverse()
    // defined in mfem/fem/bilinearform.hpp:779:27
    t.method("Inverse", static_cast<mfem::MatrixInverse * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::Inverse));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::Finalize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::Finalize(int)
    // defined in mfem/fem/bilinearform.hpp:782:17
    t.method("Finalize", static_cast<void (mfem::MixedBilinearForm::*)(int) >(&mfem::MixedBilinearForm::Finalize));
    t.method("Finalize", [](mfem::MixedBilinearForm& a)->void{ a.Finalize(); });
    t.method("Finalize", [](mfem::MixedBilinearForm* a)->void{ a->Finalize(); });

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix & mfem::MixedBilinearForm::SpMat() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix & mfem::MixedBilinearForm::SpMat()
    // defined in mfem/fem/bilinearform.hpp:790:24
    t.method("SpMat", static_cast<const mfem::SparseMatrix & (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::SpMat));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::MixedBilinearForm::SpMat() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::MixedBilinearForm::SpMat()
    // defined in mfem/fem/bilinearform.hpp:793:18
    t.method("SpMat", static_cast<mfem::SparseMatrix & (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::SpMat));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::MixedBilinearForm::LoseMat() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::MixedBilinearForm::LoseMat()
    // defined in mfem/fem/bilinearform.hpp:797:18
    t.method("LoseMat", static_cast<mfem::SparseMatrix * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::LoseMat));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *)
    // defined in mfem/fem/bilinearform.hpp:800:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::MixedBilinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *)
    // defined in mfem/fem/bilinearform.hpp:803:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::MixedBilinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddTraceFaceIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddTraceFaceIntegrator(mfem::BilinearFormIntegrator *)
    // defined in mfem/fem/bilinearform.hpp:814:9
    t.method("AddTraceFaceIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::MixedBilinearForm::AddTraceFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator(mfem::BilinearFormIntegrator *)
    // defined in mfem/fem/bilinearform.hpp:817:9
    t.method("AddBdrTraceFaceIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::operator=(const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::operator=(const double)
    // defined in mfem/fem/bilinearform.hpp:846:9
    t.method("assign", static_cast<void (mfem::MixedBilinearForm::*)(const double) >(&mfem::MixedBilinearForm::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::SetAssemblyLevel(mfem::AssemblyLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::SetAssemblyLevel(mfem::AssemblyLevel)
    // defined in mfem/fem/bilinearform.hpp:850:9
    t.method("SetAssemblyLevel", static_cast<void (mfem::MixedBilinearForm::*)(mfem::AssemblyLevel) >(&mfem::MixedBilinearForm::SetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::Assemble(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::Assemble(int)
    // defined in mfem/fem/bilinearform.hpp:852:9
    t.method("Assemble", static_cast<void (mfem::MixedBilinearForm::*)(int) >(&mfem::MixedBilinearForm::Assemble));
    t.method("Assemble", [](mfem::MixedBilinearForm& a)->void{ a.Assemble(); });
    t.method("Assemble", [](mfem::MixedBilinearForm* a)->void{ a->Assemble(); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AssembleDiagonal_ADAt(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AssembleDiagonal_ADAt(const mfem::Vector &, mfem::Vector &)
    // defined in mfem/fem/bilinearform.hpp:856:9
    t.method("AssembleDiagonal_ADAt", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MixedBilinearForm::AssembleDiagonal_ADAt));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::MixedBilinearForm::GetProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::MixedBilinearForm::GetProlongation()
    // defined in mfem/fem/bilinearform.hpp:859:28
    t.method("GetProlongation", static_cast<const mfem::Operator * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::GetProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::MixedBilinearForm::GetRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::MixedBilinearForm::GetRestriction()
    // defined in mfem/fem/bilinearform.hpp:863:28
    t.method("GetRestriction", static_cast<const mfem::Operator * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::GetRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::MixedBilinearForm::GetOutputProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::MixedBilinearForm::GetOutputProlongation()
    // defined in mfem/fem/bilinearform.hpp:867:28
    t.method("GetOutputProlongation", static_cast<const mfem::Operator * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::GetOutputProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::MixedBilinearForm::GetOutputRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::MixedBilinearForm::GetOutputRestriction()
    // defined in mfem/fem/bilinearform.hpp:871:28
    t.method("GetOutputRestriction", static_cast<const mfem::Operator * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::GetOutputRestriction));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::ConformingAssemble() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::ConformingAssemble()
    // defined in mfem/fem/bilinearform.hpp:879:9
    t.method("ConformingAssemble", static_cast<void (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::ConformingAssemble));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::ComputeElementMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::ComputeElementMatrix(int, mfem::DenseMatrix &)
    // defined in mfem/fem/bilinearform.hpp:882:9
    t.method("ComputeElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, mfem::DenseMatrix &) >(&mfem::MixedBilinearForm::ComputeElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::ComputeBdrElementMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::ComputeBdrElementMatrix(int, mfem::DenseMatrix &)
    // defined in mfem/fem/bilinearform.hpp:885:9
    t.method("ComputeBdrElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, mfem::DenseMatrix &) >(&mfem::MixedBilinearForm::ComputeBdrElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, int)
    // defined in mfem/fem/bilinearform.hpp:893:9
    t.method("AssembleElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, const mfem::DenseMatrix &, int) >(&mfem::MixedBilinearForm::AssembleElementMatrix));
    t.method("AssembleElementMatrix", [](mfem::MixedBilinearForm& a, int arg0, const mfem::DenseMatrix & arg1)->void{ a.AssembleElementMatrix(arg0, arg1); });
    t.method("AssembleElementMatrix", [](mfem::MixedBilinearForm* a, int arg0, const mfem::DenseMatrix & arg1)->void{ a->AssembleElementMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, int)
    // defined in mfem/fem/bilinearform.hpp:913:9
    t.method("AssembleBdrElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, const mfem::DenseMatrix &, int) >(&mfem::MixedBilinearForm::AssembleBdrElementMatrix));
    t.method("AssembleBdrElementMatrix", [](mfem::MixedBilinearForm& a, int arg0, const mfem::DenseMatrix & arg1)->void{ a.AssembleBdrElementMatrix(arg0, arg1); });
    t.method("AssembleBdrElementMatrix", [](mfem::MixedBilinearForm* a, int arg0, const mfem::DenseMatrix & arg1)->void{ a->AssembleBdrElementMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::Update() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::Update()
    // defined in mfem/fem/bilinearform.hpp:995:9
    t.method("Update", static_cast<void (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::Update));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::MixedBilinearForm::TrialFESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::MixedBilinearForm::TrialFESpace()
    // defined in mfem/fem/bilinearform.hpp:998:24
    t.method("TrialFESpace", static_cast<mfem::FiniteElementSpace * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::TrialFESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::MixedBilinearForm::TrialFESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::MixedBilinearForm::TrialFESpace()
    // defined in mfem/fem/bilinearform.hpp:1000:30
    t.method("TrialFESpace", static_cast<const mfem::FiniteElementSpace * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::TrialFESpace));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::MixedBilinearForm::TestFESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::MixedBilinearForm::TestFESpace()
    // defined in mfem/fem/bilinearform.hpp:1003:24
    t.method("TestFESpace", static_cast<mfem::FiniteElementSpace * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::TestFESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::MixedBilinearForm::TestFESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::MixedBilinearForm::TestFESpace()
    // defined in mfem/fem/bilinearform.hpp:1005:30
    t.method("TestFESpace", static_cast<const mfem::FiniteElementSpace * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::TestFESpace));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedBilinearForm>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedBilinearForm(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedBilinearForm(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DiscreteLinearOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DiscreteLinearOperator> : std::false_type { };
template<> struct SuperType<mfem::DiscreteLinearOperator> { typedef mfem::MixedBilinearForm type; };
}

struct Jlmfem_DiscreteLinearOperator: public Wrapper {

  Jlmfem_DiscreteLinearOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DiscreteLinearOperator (" __HERE__ ")");
    // defined in mfem/fem/bilinearform.hpp:1041:7
    jlcxx::TypeWrapper<mfem::DiscreteLinearOperator>  t = jlModule.add_type<mfem::DiscreteLinearOperator>("mfem!DiscreteLinearOperator"    , jlcxx::julia_base_type<mfem::MixedBilinearForm>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DiscreteLinearOperator>>(new jlcxx::TypeWrapper<mfem::DiscreteLinearOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::DiscreteLinearOperator(mfem::FiniteElementSpace *, mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in mfem/fem/bilinearform.hpp:1055:4
    t.constructor<mfem::FiniteElementSpace *, mfem::FiniteElementSpace *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::AddDomainInterpolator(mfem::DiscreteInterpolator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::AddDomainInterpolator(mfem::DiscreteInterpolator *)
    // defined in mfem/fem/bilinearform.hpp:1060:9
    t.method("AddDomainInterpolator", static_cast<void (mfem::DiscreteLinearOperator::*)(mfem::DiscreteInterpolator *) >(&mfem::DiscreteLinearOperator::AddDomainInterpolator));

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::AddTraceFaceInterpolator(mfem::DiscreteInterpolator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::AddTraceFaceInterpolator(mfem::DiscreteInterpolator *)
    // defined in mfem/fem/bilinearform.hpp:1064:9
    t.method("AddTraceFaceInterpolator", static_cast<void (mfem::DiscreteLinearOperator::*)(mfem::DiscreteInterpolator *) >(&mfem::DiscreteLinearOperator::AddTraceFaceInterpolator));

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::SetAssemblyLevel(mfem::AssemblyLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::SetAssemblyLevel(mfem::AssemblyLevel)
    // defined in mfem/fem/bilinearform.hpp:1072:9
    t.method("SetAssemblyLevel", static_cast<void (mfem::DiscreteLinearOperator::*)(mfem::AssemblyLevel) >(&mfem::DiscreteLinearOperator::SetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::Assemble(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::Assemble(int)
    // defined in mfem/fem/bilinearform.hpp:1076:17
    t.method("Assemble", static_cast<void (mfem::DiscreteLinearOperator::*)(int) >(&mfem::DiscreteLinearOperator::Assemble));
    t.method("Assemble", [](mfem::DiscreteLinearOperator& a)->void{ a.Assemble(); });
    t.method("Assemble", [](mfem::DiscreteLinearOperator* a)->void{ a->Assemble(); });

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::DiscreteLinearOperator::GetOutputRestrictionTranspose() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::DiscreteLinearOperator::GetOutputRestrictionTranspose()
    // defined in mfem/fem/bilinearform.hpp:1080:28
    t.method("GetOutputRestrictionTranspose", static_cast<const mfem::Operator * (mfem::DiscreteLinearOperator::*)()  const>(&mfem::DiscreteLinearOperator::GetOutputRestrictionTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DiscreteLinearOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DiscreteLinearOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DiscreteLinearOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DiscreteInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DiscreteInterpolator> : std::false_type { };
template<> struct SuperType<mfem::DiscreteInterpolator> { typedef mfem::BilinearFormIntegrator type; };
}

struct Jlmfem_DiscreteInterpolator: public Wrapper {

  Jlmfem_DiscreteInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DiscreteInterpolator (" __HERE__ ")");
    // defined in mfem/mesh/../fem/bilininteg.hpp:3487:7
    jlcxx::TypeWrapper<mfem::DiscreteInterpolator>  t = jlModule.add_type<mfem::DiscreteInterpolator>("mfem!DiscreteInterpolator"    , jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DiscreteInterpolator>>(new jlcxx::TypeWrapper<mfem::DiscreteInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DiscreteInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DiscreteInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DiscreteInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DataCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DataCollection> : std::false_type { };
}

struct Jlmfem_DataCollection: public Wrapper {

  Jlmfem_DataCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DataCollection (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:128:7
    jlcxx::TypeWrapper<mfem::DataCollection>  t = jlModule.add_type<mfem::DataCollection>("mfem!DataCollection");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DataCollection>>(new jlcxx::TypeWrapper<mfem::DataCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::DataCollection(const std::string &, mfem::Mesh *) (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:240:13
    t.constructor<const std::string &>(/*finalize=*/true);
    t.constructor<const std::string &, mfem::Mesh *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::RegisterField(const std::string &, mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::RegisterField(const std::string &, mfem::GridFunction *)
    // defined in mfem/fem/datacollection.hpp:244:17
    t.method("RegisterField", static_cast<void (mfem::DataCollection::*)(const std::string &, mfem::GridFunction *) >(&mfem::DataCollection::RegisterField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::DeregisterField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::DeregisterField(const std::string &)
    // defined in mfem/fem/datacollection.hpp:248:17
    t.method("DeregisterField", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::DeregisterField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::RegisterQField(const std::string &, mfem::QuadratureFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::RegisterQField(const std::string &, mfem::QuadratureFunction *)
    // defined in mfem/fem/datacollection.hpp:252:17
    t.method("RegisterQField", static_cast<void (mfem::DataCollection::*)(const std::string &, mfem::QuadratureFunction *) >(&mfem::DataCollection::RegisterQField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::DeregisterQField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::DeregisterQField(const std::string &)
    // defined in mfem/fem/datacollection.hpp:258:17
    t.method("DeregisterQField", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::DeregisterQField));

    DEBUG_MSG("Adding wrapper for bool mfem::DataCollection::HasField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::DataCollection::HasField(const std::string &)
    // defined in mfem/fem/datacollection.hpp:262:9
    t.method("HasField", static_cast<bool (mfem::DataCollection::*)(const std::string &)  const>(&mfem::DataCollection::HasField));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction * mfem::DataCollection::GetField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction * mfem::DataCollection::GetField(const std::string &)
    // defined in mfem/fem/datacollection.hpp:267:18
    t.method("GetField", static_cast<mfem::GridFunction * (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::GetField));

    DEBUG_MSG("Adding wrapper for bool mfem::DataCollection::HasQField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::DataCollection::HasQField(const std::string &)
    // defined in mfem/fem/datacollection.hpp:283:9
    t.method("HasQField", static_cast<bool (mfem::DataCollection::*)(const std::string &)  const>(&mfem::DataCollection::HasQField));

    DEBUG_MSG("Adding wrapper for mfem::QuadratureFunction * mfem::DataCollection::GetQField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::QuadratureFunction * mfem::DataCollection::GetQField(const std::string &)
    // defined in mfem/fem/datacollection.hpp:288:24
    t.method("GetQField", static_cast<mfem::QuadratureFunction * (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::GetQField));

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::DataCollection::GetMesh() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::DataCollection::GetMesh()
    // defined in mfem/fem/datacollection.hpp:304:10
    t.method("GetMesh", static_cast<mfem::Mesh * (mfem::DataCollection::*)() >(&mfem::DataCollection::GetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetMesh(mfem::Mesh *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetMesh(mfem::Mesh *)
    // defined in mfem/fem/datacollection.hpp:309:17
    t.method("SetMesh", static_cast<void (mfem::DataCollection::*)(mfem::Mesh *) >(&mfem::DataCollection::SetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetCycle(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetCycle(int)
    // defined in mfem/fem/datacollection.hpp:319:9
    t.method("SetCycle", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetCycle));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetTime(double)
    // defined in mfem/fem/datacollection.hpp:321:9
    t.method("SetTime", static_cast<void (mfem::DataCollection::*)(double) >(&mfem::DataCollection::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetTimeStep(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetTimeStep(double)
    // defined in mfem/fem/datacollection.hpp:324:9
    t.method("SetTimeStep", static_cast<void (mfem::DataCollection::*)(double) >(&mfem::DataCollection::SetTimeStep));

    DEBUG_MSG("Adding wrapper for int mfem::DataCollection::GetCycle() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::DataCollection::GetCycle()
    // defined in mfem/fem/datacollection.hpp:327:8
    t.method("GetCycle", static_cast<int (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetCycle));

    DEBUG_MSG("Adding wrapper for double mfem::DataCollection::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DataCollection::GetTime()
    // defined in mfem/fem/datacollection.hpp:329:11
    t.method("GetTime", static_cast<double (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetTime));

    DEBUG_MSG("Adding wrapper for double mfem::DataCollection::GetTimeStep() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DataCollection::GetTimeStep()
    // defined in mfem/fem/datacollection.hpp:331:11
    t.method("GetTimeStep", static_cast<double (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetTimeStep));

    DEBUG_MSG("Adding wrapper for const std::string & mfem::DataCollection::GetCollectionName() (" __HERE__ ")");
    // signature to use in the veto list: const std::string & mfem::DataCollection::GetCollectionName()
    // defined in mfem/fem/datacollection.hpp:334:23
    t.method("GetCollectionName", static_cast<const std::string & (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetCollectionName));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetOwnData(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetOwnData(bool)
    // defined in mfem/fem/datacollection.hpp:336:9
    t.method("SetOwnData", static_cast<void (mfem::DataCollection::*)(bool) >(&mfem::DataCollection::SetOwnData));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPrecision(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPrecision(int)
    // defined in mfem/fem/datacollection.hpp:339:9
    t.method("SetPrecision", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetPrecision));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPadDigits(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPadDigits(int)
    // defined in mfem/fem/datacollection.hpp:341:17
    t.method("SetPadDigits", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetPadDigits));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPadDigitsCycle(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPadDigitsCycle(int)
    // defined in mfem/fem/datacollection.hpp:344:17
    t.method("SetPadDigitsCycle", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetPadDigitsCycle));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPadDigitsRank(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPadDigitsRank(int)
    // defined in mfem/fem/datacollection.hpp:346:17
    t.method("SetPadDigitsRank", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetPadDigitsRank));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetFormat(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetFormat(int)
    // defined in mfem/fem/datacollection.hpp:351:17
    t.method("SetFormat", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetFormat));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetCompression(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetCompression(bool)
    // defined in mfem/fem/datacollection.hpp:354:17
    t.method("SetCompression", static_cast<void (mfem::DataCollection::*)(bool) >(&mfem::DataCollection::SetCompression));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPrefixPath(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPrefixPath(const std::string &)
    // defined in mfem/fem/datacollection.hpp:357:9
    t.method("SetPrefixPath", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::SetPrefixPath));

    DEBUG_MSG("Adding wrapper for const std::string & mfem::DataCollection::GetPrefixPath() (" __HERE__ ")");
    // signature to use in the veto list: const std::string & mfem::DataCollection::GetPrefixPath()
    // defined in mfem/fem/datacollection.hpp:360:23
    t.method("GetPrefixPath", static_cast<const std::string & (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetPrefixPath));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::Save() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::Save()
    // defined in mfem/fem/datacollection.hpp:366:17
    t.method("Save", static_cast<void (mfem::DataCollection::*)() >(&mfem::DataCollection::Save));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SaveMesh() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SaveMesh()
    // defined in mfem/fem/datacollection.hpp:368:17
    t.method("SaveMesh", static_cast<void (mfem::DataCollection::*)() >(&mfem::DataCollection::SaveMesh));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SaveField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SaveField(const std::string &)
    // defined in mfem/fem/datacollection.hpp:370:17
    t.method("SaveField", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::SaveField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SaveQField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SaveQField(const std::string &)
    // defined in mfem/fem/datacollection.hpp:372:17
    t.method("SaveQField", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::SaveQField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::Load(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::Load(int)
    // defined in mfem/fem/datacollection.hpp:375:17
    t.method("Load", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::Load));
    t.method("Load", [](mfem::DataCollection& a)->void{ a.Load(); });
    t.method("Load", [](mfem::DataCollection* a)->void{ a->Load(); });

    DEBUG_MSG("Adding wrapper for int mfem::DataCollection::Error() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::DataCollection::Error()
    // defined in mfem/fem/datacollection.hpp:396:8
    t.method("Error", static_cast<int (mfem::DataCollection::*)()  const>(&mfem::DataCollection::Error));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::ResetError(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::ResetError(int)
    // defined in mfem/fem/datacollection.hpp:398:9
    t.method("ResetError", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::ResetError));
    t.method("ResetError", [](mfem::DataCollection& a)->void{ a.ResetError(); });
    t.method("ResetError", [](mfem::DataCollection* a)->void{ a->ResetError(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DataCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DataCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DataCollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VisItFieldInfo> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VisItFieldInfo> : std::false_type { };
}

struct Jlmfem_VisItFieldInfo: public Wrapper {

  Jlmfem_VisItFieldInfo(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VisItFieldInfo (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:407:7
    jlcxx::TypeWrapper<mfem::VisItFieldInfo>  t = jlModule.add_type<mfem::VisItFieldInfo>("mfem!VisItFieldInfo");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VisItFieldInfo>>(new jlcxx::TypeWrapper<mfem::VisItFieldInfo>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/true);


    DEBUG_MSG("Adding wrapper for void mfem::VisItFieldInfo::VisItFieldInfo(std::string, int, int) (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:414:4
    t.constructor<std::string, int>(/*finalize=*/true);
    t.constructor<std::string, int, int>(/*finalize=*/true);

    DEBUG_MSG("Adding association methods  to provide read access to the field association (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:410:16
    // signature to use in the veto list: mfem::VisItFieldInfo::association
    t.method("association", [](const mfem::VisItFieldInfo& a) -> const std::string& { return a.association; });
    t.method("association", [](mfem::VisItFieldInfo& a) -> std::string& { return a.association; });
    t.method("association", [](const mfem::VisItFieldInfo* a) -> const std::string& { return a->association; });
    t.method("association", [](mfem::VisItFieldInfo* a) -> std::string& { return a->association; });
    // defined in mfem/fem/datacollection.hpp:410:16
    // signature to use in the veto list: mfem::VisItFieldInfo::association
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding association! methods to provide write access to the field association (" __HERE__ ")");
    t.method("association!", [](mfem::VisItFieldInfo& a, const std::string& val) -> std::string& { return a.association = val; });

    DEBUG_MSG("Adding association! methods to provide write access to the field association (" __HERE__ ")");
    t.method("association!", [](mfem::VisItFieldInfo* a, const std::string& val) -> std::string& { return a->association = val; });

    DEBUG_MSG("Adding num_components methods  to provide read access to the field num_components (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:411:8
    // signature to use in the veto list: mfem::VisItFieldInfo::num_components
    t.method("num_components", [](const mfem::VisItFieldInfo& a) -> int { return a.num_components; });
    t.method("num_components", [](mfem::VisItFieldInfo& a) -> int { return a.num_components; });
    t.method("num_components", [](const mfem::VisItFieldInfo* a) -> int { return a->num_components; });
    t.method("num_components", [](mfem::VisItFieldInfo* a) -> int { return a->num_components; });
    // defined in mfem/fem/datacollection.hpp:411:8
    // signature to use in the veto list: mfem::VisItFieldInfo::num_components
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding num_components! methods to provide write access to the field num_components (" __HERE__ ")");
    t.method("num_components!", [](mfem::VisItFieldInfo& a, int val) -> int { return a.num_components = val; });

    DEBUG_MSG("Adding num_components! methods to provide write access to the field num_components (" __HERE__ ")");
    t.method("num_components!", [](mfem::VisItFieldInfo* a, int val) -> int { return a->num_components = val; });

    DEBUG_MSG("Adding lod methods  to provide read access to the field lod (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:412:8
    // signature to use in the veto list: mfem::VisItFieldInfo::lod
    t.method("lod", [](const mfem::VisItFieldInfo& a) -> int { return a.lod; });
    t.method("lod", [](mfem::VisItFieldInfo& a) -> int { return a.lod; });
    t.method("lod", [](const mfem::VisItFieldInfo* a) -> int { return a->lod; });
    t.method("lod", [](mfem::VisItFieldInfo* a) -> int { return a->lod; });
    // defined in mfem/fem/datacollection.hpp:412:8
    // signature to use in the veto list: mfem::VisItFieldInfo::lod
    // with ! suffix to veto the setter only

    DEBUG_MSG("Adding lod! methods to provide write access to the field lod (" __HERE__ ")");
    t.method("lod!", [](mfem::VisItFieldInfo& a, int val) -> int { return a.lod = val; });

    DEBUG_MSG("Adding lod! methods to provide write access to the field lod (" __HERE__ ")");
    t.method("lod!", [](mfem::VisItFieldInfo* a, int val) -> int { return a->lod = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VisItFieldInfo>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VisItFieldInfo(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VisItFieldInfo(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VisItDataCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VisItDataCollection> : std::false_type { };
template<> struct SuperType<mfem::VisItDataCollection> { typedef mfem::DataCollection type; };
}

struct Jlmfem_VisItDataCollection: public Wrapper {

  Jlmfem_VisItDataCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VisItDataCollection (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:419:7
    jlcxx::TypeWrapper<mfem::VisItDataCollection>  t = jlModule.add_type<mfem::VisItDataCollection>("mfem!VisItDataCollection"    , jlcxx::julia_base_type<mfem::DataCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VisItDataCollection>>(new jlcxx::TypeWrapper<mfem::VisItDataCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::VisItDataCollection(const std::string &, mfem::Mesh *) (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:446:4
    t.constructor<const std::string &>(/*finalize=*/true);
    t.constructor<const std::string &, mfem::Mesh *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SetMesh(mfem::Mesh *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SetMesh(mfem::Mesh *)
    // defined in mfem/fem/datacollection.hpp:457:17
    t.method("SetMesh", static_cast<void (mfem::VisItDataCollection::*)(mfem::Mesh *) >(&mfem::VisItDataCollection::SetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::RegisterField(const std::string &, mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::RegisterField(const std::string &, mfem::GridFunction *)
    // defined in mfem/fem/datacollection.hpp:465:17
    t.method("RegisterField", static_cast<void (mfem::VisItDataCollection::*)(const std::string &, mfem::GridFunction *) >(&mfem::VisItDataCollection::RegisterField));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::RegisterQField(const std::string &, mfem::QuadratureFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::RegisterQField(const std::string &, mfem::QuadratureFunction *)
    // defined in mfem/fem/datacollection.hpp:471:17
    t.method("RegisterQField", static_cast<void (mfem::VisItDataCollection::*)(const std::string &, mfem::QuadratureFunction *) >(&mfem::VisItDataCollection::RegisterQField));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SetPadDigits(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SetPadDigits(int)
    // defined in mfem/fem/datacollection.hpp:478:17
    t.method("SetPadDigits", static_cast<void (mfem::VisItDataCollection::*)(int) >(&mfem::VisItDataCollection::SetPadDigits));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SetLevelsOfDetail(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SetLevelsOfDetail(int)
    // defined in mfem/fem/datacollection.hpp:482:9
    t.method("SetLevelsOfDetail", static_cast<void (mfem::VisItDataCollection::*)(int) >(&mfem::VisItDataCollection::SetLevelsOfDetail));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SetMaxLevelsOfDetail(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SetMaxLevelsOfDetail(int)
    // defined in mfem/fem/datacollection.hpp:485:9
    t.method("SetMaxLevelsOfDetail", static_cast<void (mfem::VisItDataCollection::*)(int) >(&mfem::VisItDataCollection::SetMaxLevelsOfDetail));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::DeleteAll() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::DeleteAll()
    // defined in mfem/fem/datacollection.hpp:489:9
    t.method("DeleteAll", static_cast<void (mfem::VisItDataCollection::*)() >(&mfem::VisItDataCollection::DeleteAll));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::Save() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::Save()
    // defined in mfem/fem/datacollection.hpp:492:17
    t.method("Save", static_cast<void (mfem::VisItDataCollection::*)() >(&mfem::VisItDataCollection::Save));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SaveRootFile() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SaveRootFile()
    // defined in mfem/fem/datacollection.hpp:495:9
    t.method("SaveRootFile", static_cast<void (mfem::VisItDataCollection::*)() >(&mfem::VisItDataCollection::SaveRootFile));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::Load(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::Load(int)
    // defined in mfem/fem/datacollection.hpp:498:17
    t.method("Load", static_cast<void (mfem::VisItDataCollection::*)(int) >(&mfem::VisItDataCollection::Load));
    t.method("Load", [](mfem::VisItDataCollection& a)->void{ a.Load(); });
    t.method("Load", [](mfem::VisItDataCollection* a)->void{ a->Load(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VisItDataCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VisItDataCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VisItDataCollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ParaViewDataCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ParaViewDataCollection> : std::false_type { };
template<> struct SuperType<mfem::ParaViewDataCollection> { typedef mfem::DataCollection type; };
}

struct Jlmfem_ParaViewDataCollection: public Wrapper {

  Jlmfem_ParaViewDataCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ParaViewDataCollection (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:506:7
    jlcxx::TypeWrapper<mfem::ParaViewDataCollection>  t = jlModule.add_type<mfem::ParaViewDataCollection>("mfem!ParaViewDataCollection"    , jlcxx::julia_base_type<mfem::DataCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ParaViewDataCollection>>(new jlcxx::TypeWrapper<mfem::ParaViewDataCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::ParaViewDataCollection(const std::string &, mfem::Mesh *) (" __HERE__ ")");
    // defined in mfem/fem/datacollection.hpp:540:4
    t.constructor<const std::string &>(/*finalize=*/true);
    t.constructor<const std::string &, mfem::Mesh *>(/*finalize=*/true);

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetLevelsOfDetail(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetLevelsOfDetail(int)
    // defined in mfem/fem/datacollection.hpp:545:9
    t.method("SetLevelsOfDetail", static_cast<void (mfem::ParaViewDataCollection::*)(int) >(&mfem::ParaViewDataCollection::SetLevelsOfDetail));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::Save() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::Save()
    // defined in mfem/fem/datacollection.hpp:549:17
    t.method("Save", static_cast<void (mfem::ParaViewDataCollection::*)() >(&mfem::ParaViewDataCollection::Save));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetDataFormat(mfem::VTKFormat) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetDataFormat(mfem::VTKFormat)
    // defined in mfem/fem/datacollection.hpp:557:9
    t.method("SetDataFormat", static_cast<void (mfem::ParaViewDataCollection::*)(mfem::VTKFormat) >(&mfem::ParaViewDataCollection::SetDataFormat));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetCompressionLevel(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetCompressionLevel(int)
    // defined in mfem/fem/datacollection.hpp:571:9
    t.method("SetCompressionLevel", static_cast<void (mfem::ParaViewDataCollection::*)(int) >(&mfem::ParaViewDataCollection::SetCompressionLevel));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetCompression(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetCompression(bool)
    // defined in mfem/fem/datacollection.hpp:576:9
    t.method("SetCompression", static_cast<void (mfem::ParaViewDataCollection::*)(bool) >(&mfem::ParaViewDataCollection::SetCompression));

    DEBUG_MSG("Adding wrapper for bool mfem::ParaViewDataCollection::IsBinaryFormat() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::ParaViewDataCollection::IsBinaryFormat()
    // defined in mfem/fem/datacollection.hpp:579:9
    t.method("IsBinaryFormat", static_cast<bool (mfem::ParaViewDataCollection::*)()  const>(&mfem::ParaViewDataCollection::IsBinaryFormat));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetHighOrderOutput(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetHighOrderOutput(bool)
    // defined in mfem/fem/datacollection.hpp:583:9
    t.method("SetHighOrderOutput", static_cast<void (mfem::ParaViewDataCollection::*)(bool) >(&mfem::ParaViewDataCollection::SetHighOrderOutput));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::UseRestartMode(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::UseRestartMode(bool)
    // defined in mfem/fem/datacollection.hpp:590:9
    t.method("UseRestartMode", static_cast<void (mfem::ParaViewDataCollection::*)(bool) >(&mfem::ParaViewDataCollection::UseRestartMode));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::Load(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::Load(int)
    // defined in mfem/fem/datacollection.hpp:593:17
    t.method("Load", static_cast<void (mfem::ParaViewDataCollection::*)(int) >(&mfem::ParaViewDataCollection::Load));
    t.method("Load", [](mfem::ParaViewDataCollection& a)->void{ a.Load(); });
    t.method("Load", [](mfem::ParaViewDataCollection* a)->void{ a->Load(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ParaViewDataCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ParaViewDataCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ParaViewDataCollection(module));
}
struct JlGlobal: public Wrapper {

  JlGlobal(jlcxx::Module& jlModule): Wrapper(jlModule){
  }

  void add_methods() const{
    auto& t = module_;

    DEBUG_MSG("Adding wrapper for double mfem::infinity() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::infinity()
    // defined in mfem/linalg/vector.hpp:44:15
    t.method("mfem!infinity", static_cast<double (*)() >(&mfem::infinity));

    DEBUG_MSG("Adding wrapper for bool mfem::IsFinite(const double &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::IsFinite(const double &)
    // defined in mfem/linalg/vector.hpp:486:13
    t.method("mfem!IsFinite", static_cast<bool (*)(const double &) >(&mfem::IsFinite));

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::Vector &, mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:626:24
    t.method("mfem!Swap", static_cast<void (*)(mfem::Vector &, mfem::Vector &) >(&mfem::Swap));

    DEBUG_MSG("Adding wrapper for double mfem::DistanceSquared(const double *, const double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DistanceSquared(const double *, const double *, const int)
    // defined in mfem/linalg/vector.hpp:636:15
    t.method("mfem!DistanceSquared", static_cast<double (*)(const double *, const double *, const int) >(&mfem::DistanceSquared));

    DEBUG_MSG("Adding wrapper for double mfem::Distance(const double *, const double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Distance(const double *, const double *, const int)
    // defined in mfem/linalg/vector.hpp:648:15
    t.method("mfem!Distance", static_cast<double (*)(const double *, const double *, const int) >(&mfem::Distance));

    DEBUG_MSG("Adding wrapper for double mfem::Distance(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Distance(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:653:15
    t.method("mfem!Distance", static_cast<double (*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::Distance));

    DEBUG_MSG("Adding wrapper for double mfem::InnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::InnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in mfem/linalg/vector.hpp:684:15
    t.method("mfem!InnerProduct", static_cast<double (*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::InnerProduct));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrixFunction(mfem::SparseMatrix &, double (*)(double)) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrixFunction(mfem::SparseMatrix &, double (*)(double))
    // defined in mfem/linalg/sparsemat.hpp:718:6
    t.method("mfem!SparseMatrixFunction", static_cast<void (*)(mfem::SparseMatrix &, double (*)(double)) >(&mfem::SparseMatrixFunction));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Transpose(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Transpose(const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:722:15
    t.method("mfem!Transpose", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &) >(&mfem::Transpose));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::TransposeAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::TransposeAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, int)
    // defined in mfem/linalg/sparsemat.hpp:724:15
    t.method("mfem!TransposeAbstractSparseMatrix", static_cast<mfem::SparseMatrix * (*)(const mfem::AbstractSparseMatrix &, int) >(&mfem::TransposeAbstractSparseMatrix));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Mult(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Mult(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *)
    // defined in mfem/linalg/sparsemat.hpp:733:15
    t.method("mfem!Mult", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) >(&mfem::Mult));
    t.method("mfem!Mult", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix *{ return mfem::Mult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::TransposeMult(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::TransposeMult(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:737:15
    t.method("mfem!TransposeMult", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &) >(&mfem::TransposeMult));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::MultAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, const mfem::AbstractSparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::MultAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, const mfem::AbstractSparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:740:15
    t.method("mfem!MultAbstractSparseMatrix", static_cast<mfem::SparseMatrix * (*)(const mfem::AbstractSparseMatrix &, const mfem::AbstractSparseMatrix &) >(&mfem::MultAbstractSparseMatrix));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::Mult(const mfem::SparseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::Mult(const mfem::SparseMatrix &, mfem::DenseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:744:14
    t.method("mfem!Mult", static_cast<mfem::DenseMatrix * (*)(const mfem::SparseMatrix &, mfem::DenseMatrix &) >(&mfem::Mult));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::RAP(const mfem::SparseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::RAP(const mfem::SparseMatrix &, mfem::DenseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:747:14
    t.method("mfem!RAP", static_cast<mfem::DenseMatrix * (*)(const mfem::SparseMatrix &, mfem::DenseMatrix &) >(&mfem::RAP));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::RAP(mfem::DenseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::RAP(mfem::DenseMatrix &, const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:750:14
    t.method("mfem!RAP", static_cast<mfem::DenseMatrix * (*)(mfem::DenseMatrix &, const mfem::SparseMatrix &) >(&mfem::RAP));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *)
    // defined in mfem/linalg/sparsemat.hpp:754:15
    t.method("mfem!RAP", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) >(&mfem::RAP));
    t.method("mfem!RAP", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix *{ return mfem::RAP(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:758:15
    t.method("mfem!RAP", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &, const mfem::SparseMatrix &) >(&mfem::RAP));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Mult_AtDA(const mfem::SparseMatrix &, const mfem::Vector &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Mult_AtDA(const mfem::SparseMatrix &, const mfem::Vector &, mfem::SparseMatrix *)
    // defined in mfem/linalg/sparsemat.hpp:762:15
    t.method("mfem!Mult_AtDA", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::Vector &, mfem::SparseMatrix *) >(&mfem::Mult_AtDA));
    t.method("mfem!Mult_AtDA", [](const mfem::SparseMatrix & arg0, const mfem::Vector & arg1)->mfem::SparseMatrix *{ return mfem::Mult_AtDA(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Add(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Add(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:767:16
    t.method("mfem!Add", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &) >(&mfem::Add));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Add(double, const mfem::SparseMatrix &, double, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Add(double, const mfem::SparseMatrix &, double, const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:769:16
    t.method("mfem!Add", static_cast<mfem::SparseMatrix * (*)(double, const mfem::SparseMatrix &, double, const mfem::SparseMatrix &) >(&mfem::Add));

    DEBUG_MSG("Adding wrapper for void mfem::Add(const mfem::SparseMatrix &, double, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Add(const mfem::SparseMatrix &, double, mfem::DenseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:775:6
    t.method("mfem!Add", static_cast<void (*)(const mfem::SparseMatrix &, double, mfem::DenseMatrix &) >(&mfem::Add));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::DenseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:778:14
    t.method("mfem!OuterProduct", static_cast<mfem::DenseMatrix * (*)(const mfem::DenseMatrix &, const mfem::DenseMatrix &) >(&mfem::OuterProduct));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:781:15
    t.method("mfem!OuterProduct", static_cast<mfem::SparseMatrix * (*)(const mfem::DenseMatrix &, const mfem::SparseMatrix &) >(&mfem::OuterProduct));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::DenseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:784:15
    t.method("mfem!OuterProduct", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::DenseMatrix &) >(&mfem::OuterProduct));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:787:15
    t.method("mfem!OuterProduct", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &) >(&mfem::OuterProduct));

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::SparseMatrix &, mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::SparseMatrix &, mfem::SparseMatrix &)
    // defined in mfem/linalg/sparsemat.hpp:931:24
    t.method("mfem!Swap", static_cast<void (*)(mfem::SparseMatrix &, mfem::SparseMatrix &) >(&mfem::Swap));

    DEBUG_MSG("Adding wrapper for void mfem::SLI(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLI(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in mfem/linalg/solvers.hpp:482:6
    t.method("mfem!SLI", static_cast<void (*)(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::SLI));
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void{ mfem::SLI(arg0, arg1, arg2); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void{ mfem::SLI(arg0, arg1, arg2, arg3); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void{ mfem::SLI(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void{ mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::SLI(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLI(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in mfem/linalg/solvers.hpp:487:6
    t.method("mfem!SLI", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::SLI));
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void{ mfem::SLI(arg0, arg1, arg2, arg3); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void{ mfem::SLI(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void{ mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void{ mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::CG(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CG(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in mfem/linalg/solvers.hpp:514:6
    t.method("mfem!CG", static_cast<void (*)(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::CG));
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void{ mfem::CG(arg0, arg1, arg2); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void{ mfem::CG(arg0, arg1, arg2, arg3); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void{ mfem::CG(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void{ mfem::CG(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::PCG(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PCG(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in mfem/linalg/solvers.hpp:519:6
    t.method("mfem!PCG", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::PCG));
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void{ mfem::PCG(arg0, arg1, arg2, arg3); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void{ mfem::PCG(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void{ mfem::PCG(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void{ mfem::PCG(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for int mfem::GMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, int, double &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, int, double &, double, int)
    // defined in mfem/linalg/solvers.hpp:562:5
    t.method("mfem!GMRES", static_cast<int (*)(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, int, double &, double, int) >(&mfem::GMRES));

    DEBUG_MSG("Adding wrapper for void mfem::GMRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GMRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, int, double, double)
    // defined in mfem/linalg/solvers.hpp:566:6
    t.method("mfem!GMRES", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, int, double, double) >(&mfem::GMRES));
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void{ mfem::GMRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void{ mfem::GMRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void{ mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, int arg6)->void{ mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, int arg6, double arg7)->void{ mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for int mfem::BiCGSTAB(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, double &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::BiCGSTAB(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, double &, double, int)
    // defined in mfem/linalg/solvers.hpp:593:5
    t.method("mfem!BiCGSTAB", static_cast<int (*)(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, double &, double, int) >(&mfem::BiCGSTAB));

    DEBUG_MSG("Adding wrapper for void mfem::BiCGSTAB(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BiCGSTAB(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in mfem/linalg/solvers.hpp:597:6
    t.method("mfem!BiCGSTAB", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::BiCGSTAB));
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void{ mfem::BiCGSTAB(arg0, arg1, arg2, arg3); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void{ mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void{ mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void{ mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::MINRES(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRES(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in mfem/linalg/solvers.hpp:628:6
    t.method("mfem!MINRES", static_cast<void (*)(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::MINRES));
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void{ mfem::MINRES(arg0, arg1, arg2); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void{ mfem::MINRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void{ mfem::MINRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void{ mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::MINRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in mfem/linalg/solvers.hpp:632:6
    t.method("mfem!MINRES", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::MINRES));
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void{ mfem::MINRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void{ mfem::MINRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void{ mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void{ mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for int mfem::aGMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, const mfem::Operator &, int &, int, int, int, double, double &, double &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::aGMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, const mfem::Operator &, int &, int, int, int, double, double &, double &, int)
    // defined in mfem/linalg/solvers.hpp:791:5
    t.method("mfem!aGMRES", static_cast<int (*)(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, const mfem::Operator &, int &, int, int, int, double, double &, double &, int) >(&mfem::aGMRES));

    DEBUG_MSG("Adding wrapper for double mfem::ComputeLpNorm(double, mfem::Coefficient &, mfem::Mesh &, const mfem::IntegrationRule *[]) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ComputeLpNorm(double, mfem::Coefficient &, mfem::Mesh &, const mfem::IntegrationRule *[])
    // defined in mfem/fem/coefficient.hpp:2401:8
    t.method("mfem!ComputeLpNorm", static_cast<double (*)(double, mfem::Coefficient &, mfem::Mesh &, const mfem::IntegrationRule *[]) >(&mfem::ComputeLpNorm));

    DEBUG_MSG("Adding wrapper for double mfem::ComputeLpNorm(double, mfem::VectorCoefficient &, mfem::Mesh &, const mfem::IntegrationRule *[]) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ComputeLpNorm(double, mfem::VectorCoefficient &, mfem::Mesh &, const mfem::IntegrationRule *[])
    // defined in mfem/fem/coefficient.hpp:2406:8
    t.method("mfem!ComputeLpNorm", static_cast<double (*)(double, mfem::VectorCoefficient &, mfem::Mesh &, const mfem::IntegrationRule *[]) >(&mfem::ComputeLpNorm));

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::Extrude1D(mfem::Mesh *, const int, const double, const bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::Extrude1D(mfem::Mesh *, const int, const double, const bool)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2305:7
    t.method("mfem!Extrude1D", static_cast<mfem::Mesh * (*)(mfem::Mesh *, const int, const double, const bool) >(&mfem::Extrude1D));
    t.method("mfem!Extrude1D", [](mfem::Mesh * arg0, const int arg1, const double arg2)->mfem::Mesh *{ return mfem::Extrude1D(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::Extrude2D(mfem::Mesh *, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::Extrude2D(mfem::Mesh *, const int, const double)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2309:7
    t.method("mfem!Extrude2D", static_cast<mfem::Mesh * (*)(mfem::Mesh *, const int, const double) >(&mfem::Extrude2D));

    DEBUG_MSG("Adding wrapper for void mfem::ShiftRight(int &, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ShiftRight(int &, int &, int &)
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2312:13
    t.method("mfem!ShiftRight", static_cast<void (*)(int &, int &, int &) >(&mfem::ShiftRight));

    DEBUG_MSG("Adding wrapper for bool mfem::UsesTensorBasis(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::UsesTensorBasis(const mfem::FiniteElementSpace &)
    // defined in mfem/mesh/../fem/fespace.hpp:1297:13
    t.method("mfem!UsesTensorBasis", static_cast<bool (*)(const mfem::FiniteElementSpace &) >(&mfem::UsesTensorBasis));

    DEBUG_MSG("Adding mfem!IntRules methods to provide access to the global variable mfem::IntRules (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:480:37
    t.method("mfem!IntRules", []()-> mfem::IntegrationRules& { return mfem::IntRules; });
    // t.method("mfem!IntRules!", [](const mfem::IntegrationRules& val)-> mfem::IntegrationRules& { return mfem::IntRules = val; });

    DEBUG_MSG("Adding mfem!RefinedIntRules methods to provide access to the global variable mfem::RefinedIntRules (" __HERE__ ")");
    // defined in mfem/fem/intrules.hpp:483:37
    t.method("mfem!RefinedIntRules", []()-> mfem::IntegrationRules& { return mfem::RefinedIntRules; });
    // t.method("mfem!RefinedIntRules!", [](const mfem::IntegrationRules& val)-> mfem::IntegrationRules& { return mfem::RefinedIntRules = val; });

    DEBUG_MSG("Adding mfem!Mesh!remove_unused_vertices methods to provide access to the global variable mfem::Mesh::remove_unused_vertices (" __HERE__ ")");
    // defined in mfem/mesh/../fem/../mesh/mesh.hpp:286:16
    t.method("mfem!Mesh!remove_unused_vertices", []()-> bool { return mfem::Mesh::remove_unused_vertices; });
    t.method("mfem!Mesh!remove_unused_vertices!", [](bool val)-> bool { return mfem::Mesh::remove_unused_vertices = val; });
  }
};
std::shared_ptr<Wrapper> newJlGlobal(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlGlobal(module));
}

class Jlmfem_Vector;
class Jlmfem_RowNode;
class Jlmfem_AbstractSparseMatrix;
class Jlmfem_DenseMatrix;
class Jlmfem_Operator;
class Jlmfem_SparseMatrix;
class Jlmfem_IterativeSolverMonitor;
class Jlmfem_Solver;
class Jlmfem_IterativeSolver_PrintLevel;
class Jlmfem_MatrixInverse;
class Jlmfem_IterativeSolver;
class Jlmfem_OperatorJacobiSmoother;
class Jlmfem_BilinearForm;
class Jlmfem_OperatorChebyshevSmoother;
class Jlmfem_SLISolver;
class Jlmfem_CGSolver;
class Jlmfem_GMRESSolver;
class Jlmfem_FGMRESSolver;
class Jlmfem_BiCGSTABSolver;
class Jlmfem_MINRESSolver;
class Jlmfem_NewtonSolver;
class Jlmfem_LBFGSSolver;
class Jlmfem_OptimizationProblem;
class Jlmfem_OptimizationSolver;
class Jlmfem_SLBQPOptimizer;
class Jlmfem_BlockILU;
class Jlmfem_ResidualBCMonitor;
class Jlmfem_DirectSubBlockSolver;
class Jlmfem_ProductSolver;
class Jlmfem_OrthoSolver;
class Jlmfem_IntegrationPoint;
class Jlmfem_IntegrationRule;
class Jlmfem_NURBSMeshRules;
class Jlmfem_Mesh;
class Jlmfem_QuadratureFunctions1D;
class Jlmfem_Quadrature1D;
class Jlmfem_IntegrationRules;
class Jlmfem_Coefficient;
class Jlmfem_ElementTransformation;
class Jlmfem_QuadratureFunction;
class Jlmfem_ConstantCoefficient;
class Jlmfem_PWConstCoefficient;
class Jlmfem_PWCoefficient;
class Jlmfem_CartesianCoefficient;
class Jlmfem_CartesianXCoefficient;
class Jlmfem_CartesianYCoefficient;
class Jlmfem_CartesianZCoefficient;
class Jlmfem_CylindricalRadialCoefficient;
class Jlmfem_CylindricalAzimuthalCoefficient;
class Jlmfem_SphericalRadialCoefficient;
class Jlmfem_SphericalAzimuthalCoefficient;
class Jlmfem_SphericalPolarCoefficient;
class Jlmfem_GridFunctionCoefficient;
class Jlmfem_GridFunction;
class Jlmfem_TransformedCoefficient;
class Jlmfem_DeltaCoefficient;
class Jlmfem_RestrictedCoefficient;
class Jlmfem_VectorCoefficient;
class Jlmfem_VectorConstantCoefficient;
class Jlmfem_PWVectorCoefficient;
class Jlmfem_PositionVectorCoefficient;
class Jlmfem_VectorArrayCoefficient;
class Jlmfem_VectorGridFunctionCoefficient;
class Jlmfem_GradientGridFunctionCoefficient;
class Jlmfem_CurlGridFunctionCoefficient;
class Jlmfem_DivergenceGridFunctionCoefficient;
class Jlmfem_VectorDeltaCoefficient;
class Jlmfem_VectorRestrictedCoefficient;
class Jlmfem_MatrixCoefficient;
class Jlmfem_MatrixConstantCoefficient;
class Jlmfem_PWMatrixCoefficient;
class Jlmfem_MatrixArrayCoefficient;
class Jlmfem_MatrixRestrictedCoefficient;
class Jlmfem_SumCoefficient;
class Jlmfem_SymmetricMatrixCoefficient;
class Jlmfem_DenseSymmetricMatrix;
class Jlmfem_SymmetricMatrixConstantCoefficient;
class Jlmfem_ProductCoefficient;
class Jlmfem_RatioCoefficient;
class Jlmfem_PowerCoefficient;
class Jlmfem_InnerProductCoefficient;
class Jlmfem_VectorRotProductCoefficient;
class Jlmfem_DeterminantCoefficient;
class Jlmfem_VectorSumCoefficient;
class Jlmfem_ScalarVectorProductCoefficient;
class Jlmfem_NormalizedVectorCoefficient;
class Jlmfem_VectorCrossProductCoefficient;
class Jlmfem_MatrixVectorProductCoefficient;
class Jlmfem_IdentityMatrixCoefficient;
class Jlmfem_MatrixSumCoefficient;
class Jlmfem_MatrixProductCoefficient;
class Jlmfem_ScalarMatrixProductCoefficient;
class Jlmfem_TransposeMatrixCoefficient;
class Jlmfem_InverseMatrixCoefficient;
class Jlmfem_OuterProductCoefficient;
class Jlmfem_CrossCrossCoefficient;
class Jlmfem_VectorQuadratureFunctionCoefficient;
class Jlmfem_QuadratureFunctionCoefficient;
class Jlmfem_CoefficientVector;
class Jlmfem_QuadratureSpaceBase;
class Jlmfem_NCMesh;
class Jlmfem_Element;
class Jlmfem_Mesh_GeometryList;
class Jlmfem_Table;
class Jlmfem_DSTable;
class Jlmfem_FiniteElement;
class Jlmfem_IsoparametricTransformation;
class Jlmfem_FaceElementTransformations;
class Jlmfem_GeometricFactors;
class Jlmfem_FaceGeometricFactors;
class Jlmfem_Mesh_FaceInformation;
class Jlmfem_FiniteElementSpace;
class Jlmfem_Vertex;
class Jlmfem_CoarseFineTransformations;
class Jlmfem_InverseElementTransformation;
class Jlmfem_NodeExtrudeCoefficient;
class Jlmfem_FiniteElementCollection;
class Jlmfem_StatelessDofTransformation;
class Jlmfem_H1_FECollection;
class Jlmfem_H1Pos_FECollection;
class Jlmfem_H1Ser_FECollection;
class Jlmfem_H1_Trace_FECollection;
class Jlmfem_L2_FECollection;
class Jlmfem_RT_FECollection;
class Jlmfem_RT_Trace_FECollection;
class Jlmfem_DG_Interface_FECollection;
class Jlmfem_ND_FECollection;
class Jlmfem_ND_Trace_FECollection;
class Jlmfem_ND_R1D_FECollection;
class Jlmfem_RT_R1D_FECollection;
class Jlmfem_ND_R2D_FECollection;
class Jlmfem_ND_R2D_Trace_FECollection;
class Jlmfem_RT_R2D_FECollection;
class Jlmfem_RT_R2D_Trace_FECollection;
class Jlmfem_NURBSFECollection;
class Jlmfem_LinearFECollection;
class Jlmfem_QuadraticFECollection;
class Jlmfem_QuadraticPosFECollection;
class Jlmfem_CubicFECollection;
class Jlmfem_CrouzeixRaviartFECollection;
class Jlmfem_LinearNonConf3DFECollection;
class Jlmfem_RT0_2DFECollection;
class Jlmfem_RT1_2DFECollection;
class Jlmfem_RT2_2DFECollection;
class Jlmfem_Const2DFECollection;
class Jlmfem_LinearDiscont2DFECollection;
class Jlmfem_GaussLinearDiscont2DFECollection;
class Jlmfem_P1OnQuadFECollection;
class Jlmfem_QuadraticDiscont2DFECollection;
class Jlmfem_QuadraticPosDiscont2DFECollection;
class Jlmfem_GaussQuadraticDiscont2DFECollection;
class Jlmfem_CubicDiscont2DFECollection;
class Jlmfem_Const3DFECollection;
class Jlmfem_LinearDiscont3DFECollection;
class Jlmfem_QuadraticDiscont3DFECollection;
class Jlmfem_RefinedLinearFECollection;
class Jlmfem_ND1_3DFECollection;
class Jlmfem_RT0_3DFECollection;
class Jlmfem_RT1_3DFECollection;
class Jlmfem_Local_FECollection;
class Jlmfem_Ordering;
class Jlmfem_ElementRestrictionOperator;
class Jlmfem_FaceRestriction;
class Jlmfem_QuadratureSpace;
class Jlmfem_DofTransformation;
class Jlmfem_OperatorHandle;
class Jlmfem_LinearForm;
class Jlmfem_LinearFormIntegrator;
class Jlmfem_Hybridization;
class Jlmfem_BilinearFormIntegrator;
class Jlmfem_MixedBilinearForm;
class Jlmfem_DiscreteLinearOperator;
class Jlmfem_DiscreteInterpolator;
class Jlmfem_DataCollection;
class Jlmfem_VisItFieldInfo;
class Jlmfem_VisItDataCollection;
class Jlmfem_ParaViewDataCollection;
class JlGlobal;

std::shared_ptr<Wrapper> newJlmfem_Vector(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RowNode(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_AbstractSparseMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DenseMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Operator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SparseMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IterativeSolverMonitor(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Solver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IterativeSolver_PrintLevel(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixInverse(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IterativeSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OperatorJacobiSmoother(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BilinearForm(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OperatorChebyshevSmoother(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SLISolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CGSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GMRESSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FGMRESSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BiCGSTABSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MINRESSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NewtonSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LBFGSSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OptimizationProblem(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OptimizationSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SLBQPOptimizer(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BlockILU(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ResidualBCMonitor(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DirectSubBlockSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ProductSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OrthoSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IntegrationPoint(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IntegrationRule(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSMeshRules(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunctions1D(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Quadrature1D(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IntegrationRules(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Coefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ElementTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ConstantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PWConstCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PWCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CartesianCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CartesianXCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CartesianYCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CartesianZCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CylindricalRadialCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CylindricalAzimuthalCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SphericalRadialCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SphericalAzimuthalCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SphericalPolarCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GridFunction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TransformedCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DeltaCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RestrictedCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorConstantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PWVectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PositionVectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorArrayCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorGridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GradientGridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CurlGridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DivergenceGridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorDeltaCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorRestrictedCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixConstantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PWMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixArrayCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixRestrictedCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SumCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SymmetricMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DenseSymmetricMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SymmetricMatrixConstantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RatioCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PowerCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InnerProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorRotProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DeterminantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorSumCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ScalarVectorProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NormalizedVectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorCrossProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixVectorProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IdentityMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixSumCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ScalarMatrixProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TransposeMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InverseMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OuterProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CrossCrossCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorQuadratureFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CoefficientVector(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpaceBase(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NCMesh(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Element(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh_GeometryList(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Table(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DSTable(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElement(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IsoparametricTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceElementTransformations(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GeometricFactors(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceGeometricFactors(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh_FaceInformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElementSpace(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Vertex(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CoarseFineTransformations(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InverseElementTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NodeExtrudeCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElementCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_StatelessDofTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1Pos_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1Ser_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_L2_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DG_Interface_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R1D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R1D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CubicFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CrouzeixRaviartFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearNonConf3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT0_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT1_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT2_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Const2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_P1OnQuadFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CubicDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Const3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RefinedLinearFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND1_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT0_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT1_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Local_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Ordering(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ElementRestrictionOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceRestriction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpace(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DofTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OperatorHandle(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearForm(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearFormIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Hybridization(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BilinearFormIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedBilinearForm(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DiscreteLinearOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DiscreteInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DataCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VisItFieldInfo(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VisItDataCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ParaViewDataCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlGlobal(jlcxx::Module&);


JLCXX_MODULE define_julia_module(jlcxx::Module& jlModule){
  std::vector<std::shared_ptr<Wrapper>> wrappers = {
    std::shared_ptr<Wrapper>(newJlmfem_Vector(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RowNode(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_AbstractSparseMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DenseMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Operator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SparseMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IterativeSolverMonitor(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Solver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IterativeSolver_PrintLevel(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixInverse(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IterativeSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OperatorJacobiSmoother(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BilinearForm(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OperatorChebyshevSmoother(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SLISolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CGSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GMRESSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FGMRESSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BiCGSTABSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MINRESSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NewtonSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LBFGSSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OptimizationProblem(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OptimizationSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SLBQPOptimizer(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BlockILU(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ResidualBCMonitor(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DirectSubBlockSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ProductSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OrthoSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IntegrationPoint(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IntegrationRule(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSMeshRules(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureFunctions1D(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Quadrature1D(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IntegrationRules(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Coefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ElementTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureFunction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ConstantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PWConstCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PWCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CartesianCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CartesianXCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CartesianYCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CartesianZCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CylindricalRadialCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CylindricalAzimuthalCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SphericalRadialCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SphericalAzimuthalCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SphericalPolarCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GridFunction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TransformedCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DeltaCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RestrictedCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorConstantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PWVectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PositionVectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorArrayCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorGridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GradientGridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CurlGridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DivergenceGridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorDeltaCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorRestrictedCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixConstantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PWMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixArrayCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixRestrictedCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SumCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SymmetricMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DenseSymmetricMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SymmetricMatrixConstantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RatioCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PowerCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InnerProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorRotProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DeterminantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorSumCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ScalarVectorProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NormalizedVectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorCrossProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixVectorProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IdentityMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixSumCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ScalarMatrixProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TransposeMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InverseMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OuterProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CrossCrossCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorQuadratureFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CoefficientVector(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureSpaceBase(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NCMesh(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Element(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh_GeometryList(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Table(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DSTable(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElement(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IsoparametricTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceElementTransformations(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GeometricFactors(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceGeometricFactors(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh_FaceInformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElementSpace(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Vertex(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CoarseFineTransformations(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InverseElementTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NodeExtrudeCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElementCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_StatelessDofTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1Pos_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1Ser_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_L2_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DG_Interface_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R1D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R1D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R2D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R2D_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R2D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R2D_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticPosFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CubicFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CrouzeixRaviartFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearNonConf3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT0_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT1_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT2_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Const2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GaussLinearDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_P1OnQuadFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticPosDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GaussQuadraticDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CubicDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Const3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearDiscont3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticDiscont3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RefinedLinearFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND1_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT0_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT1_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Local_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Ordering(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ElementRestrictionOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceRestriction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureSpace(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DofTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OperatorHandle(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearForm(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearFormIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Hybridization(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BilinearFormIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedBilinearForm(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DiscreteLinearOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DiscreteInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DataCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VisItFieldInfo(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VisItDataCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ParaViewDataCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlGlobal(jlModule))
  };

  DEBUG_MSG("Adding wrapper for enum mfem::MemoryType (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../linalg/../general/mem_manager.hpp:31:12
  jlModule.add_bits<mfem::MemoryType>("mfem!MemoryType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!MemoryType!HOST", mfem::MemoryType::HOST);
  jlModule.set_const("mfem!MemoryType!HOST_32", mfem::MemoryType::HOST_32);
  jlModule.set_const("mfem!MemoryType!HOST_64", mfem::MemoryType::HOST_64);
  jlModule.set_const("mfem!MemoryType!HOST_DEBUG", mfem::MemoryType::HOST_DEBUG);
  jlModule.set_const("mfem!MemoryType!HOST_UMPIRE", mfem::MemoryType::HOST_UMPIRE);
  jlModule.set_const("mfem!MemoryType!HOST_PINNED", mfem::MemoryType::HOST_PINNED);
  jlModule.set_const("mfem!MemoryType!MANAGED", mfem::MemoryType::MANAGED);
  jlModule.set_const("mfem!MemoryType!DEVICE", mfem::MemoryType::DEVICE);
  jlModule.set_const("mfem!MemoryType!DEVICE_DEBUG", mfem::MemoryType::DEVICE_DEBUG);
  jlModule.set_const("mfem!MemoryType!DEVICE_UMPIRE", mfem::MemoryType::DEVICE_UMPIRE);
  jlModule.set_const("mfem!MemoryType!DEVICE_UMPIRE_2", mfem::MemoryType::DEVICE_UMPIRE_2);
  jlModule.set_const("mfem!MemoryType!SIZE", mfem::MemoryType::SIZE);
  jlModule.set_const("mfem!MemoryType!PRESERVE", mfem::MemoryType::PRESERVE);
  jlModule.set_const("mfem!MemoryType!DEFAULT", mfem::MemoryType::DEFAULT);

  DEBUG_MSG("Adding wrapper for enum mfem::MemoryClass (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../linalg/../general/mem_manager.hpp:73:12
  jlModule.add_bits<mfem::MemoryClass>("mfem!MemoryClass", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!MemoryClass!HOST", mfem::MemoryClass::HOST);
  jlModule.set_const("mfem!MemoryClass!HOST_32", mfem::MemoryClass::HOST_32);
  jlModule.set_const("mfem!MemoryClass!HOST_64", mfem::MemoryClass::HOST_64);
  jlModule.set_const("mfem!MemoryClass!DEVICE", mfem::MemoryClass::DEVICE);
  jlModule.set_const("mfem!MemoryClass!MANAGED", mfem::MemoryClass::MANAGED);

  DEBUG_MSG("Adding wrapper for enum mfem::Operator::DiagonalPolicy (" __HERE__ ")");
  // defined in mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:47:9
  jlModule.add_bits<mfem::Operator::DiagonalPolicy>("mfem!Operator!DiagonalPolicy", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Operator!DIAG_ZERO", mfem::Operator::DIAG_ZERO);
  jlModule.set_const("mfem!Operator!DIAG_ONE", mfem::Operator::DIAG_ONE);
  jlModule.set_const("mfem!Operator!DIAG_KEEP", mfem::Operator::DIAG_KEEP);

  DEBUG_MSG("Adding wrapper for enum mfem::Operator::Type (" __HERE__ ")");
  // defined in mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:283:9
  jlModule.add_bits<mfem::Operator::Type>("mfem!Operator!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Operator!ANY_TYPE", mfem::Operator::ANY_TYPE);
  jlModule.set_const("mfem!Operator!MFEM_SPARSEMAT", mfem::Operator::MFEM_SPARSEMAT);
  jlModule.set_const("mfem!Operator!Hypre_ParCSR", mfem::Operator::Hypre_ParCSR);
  jlModule.set_const("mfem!Operator!PETSC_MATAIJ", mfem::Operator::PETSC_MATAIJ);
  jlModule.set_const("mfem!Operator!PETSC_MATIS", mfem::Operator::PETSC_MATIS);
  jlModule.set_const("mfem!Operator!PETSC_MATSHELL", mfem::Operator::PETSC_MATSHELL);
  jlModule.set_const("mfem!Operator!PETSC_MATNEST", mfem::Operator::PETSC_MATNEST);
  jlModule.set_const("mfem!Operator!PETSC_MATHYPRE", mfem::Operator::PETSC_MATHYPRE);
  jlModule.set_const("mfem!Operator!PETSC_MATGENERIC", mfem::Operator::PETSC_MATGENERIC);
  jlModule.set_const("mfem!Operator!Complex_Operator", mfem::Operator::Complex_Operator);
  jlModule.set_const("mfem!Operator!MFEM_ComplexSparseMat", mfem::Operator::MFEM_ComplexSparseMat);
  jlModule.set_const("mfem!Operator!Complex_Hypre_ParCSR", mfem::Operator::Complex_Hypre_ParCSR);
  jlModule.set_const("mfem!Operator!Complex_DenseMat", mfem::Operator::Complex_DenseMat);
  jlModule.set_const("mfem!Operator!MFEM_Block_Matrix", mfem::Operator::MFEM_Block_Matrix);
  jlModule.set_const("mfem!Operator!MFEM_Block_Operator", mfem::Operator::MFEM_Block_Operator);

  DEBUG_MSG("Adding wrapper for enum mfem::BlockILU::Reordering (" __HERE__ ")");
  // defined in mfem/linalg/solvers.hpp:968:15
  jlModule.add_bits<mfem::BlockILU::Reordering>("mfem!BlockILU!Reordering", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!BlockILU!Reordering!MINIMUM_DISCARDED_FILL", mfem::BlockILU::Reordering::MINIMUM_DISCARDED_FILL);
  jlModule.set_const("mfem!BlockILU!Reordering!NONE", mfem::BlockILU::Reordering::NONE);

  DEBUG_MSG("Adding anonymous enum defined in mfem/fem/intrules.hpp:393:4 (" __HERE__ ")");
  // defined in mfem/fem/intrules.hpp:393:4
  jlModule.set_const("mfem!Quadrature1D!Invalid", static_cast<int>(mfem::Quadrature1D::Invalid));
  jlModule.set_const("mfem!Quadrature1D!GaussLegendre", static_cast<int>(mfem::Quadrature1D::GaussLegendre));
  jlModule.set_const("mfem!Quadrature1D!GaussLobatto", static_cast<int>(mfem::Quadrature1D::GaussLobatto));
  jlModule.set_const("mfem!Quadrature1D!OpenUniform", static_cast<int>(mfem::Quadrature1D::OpenUniform));
  jlModule.set_const("mfem!Quadrature1D!ClosedUniform", static_cast<int>(mfem::Quadrature1D::ClosedUniform));
  jlModule.set_const("mfem!Quadrature1D!OpenHalfUniform", static_cast<int>(mfem::Quadrature1D::OpenHalfUniform));
  jlModule.set_const("mfem!Quadrature1D!ClosedGL", static_cast<int>(mfem::Quadrature1D::ClosedGL));

  DEBUG_MSG("Adding wrapper for enum mfem::CoefficientStorage (" __HERE__ ")");
  // defined in mfem/fem/coefficient.hpp:2288:12
  jlModule.add_bits<mfem::CoefficientStorage>("mfem!CoefficientStorage", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!CoefficientStorage!FULL", mfem::CoefficientStorage::FULL);
  jlModule.set_const("mfem!CoefficientStorage!CONSTANTS", mfem::CoefficientStorage::CONSTANTS);
  jlModule.set_const("mfem!CoefficientStorage!SYMMETRIC", mfem::CoefficientStorage::SYMMETRIC);
  jlModule.set_const("mfem!CoefficientStorage!COMPRESSED", mfem::CoefficientStorage::COMPRESSED);

  DEBUG_MSG("Adding wrapper for enum mfem::FaceType (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../mesh/mesh.hpp:45:12
  jlModule.add_bits<mfem::FaceType>("mfem!FaceType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!FaceType!Interior", mfem::FaceType::Interior);
  jlModule.set_const("mfem!FaceType!Boundary", mfem::FaceType::Boundary);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::Operation (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../mesh/mesh.hpp:270:9
  jlModule.add_bits<mfem::Mesh::Operation>("mfem!Mesh!Operation", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!NONE", mfem::Mesh::NONE);
  jlModule.set_const("mfem!Mesh!REFINE", mfem::Mesh::REFINE);
  jlModule.set_const("mfem!Mesh!DEREFINE", mfem::Mesh::DEREFINE);
  jlModule.set_const("mfem!Mesh!REBALANCE", mfem::Mesh::REBALANCE);

  DEBUG_MSG("Adding wrapper for enum mfem::Geometry::Type (" __HERE__ ")");
  // defined in mfem/mesh/../fem/geom.hpp:35:9
  jlModule.add_bits<mfem::Geometry::Type>("mfem!Geometry!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Geometry!INVALID", mfem::Geometry::INVALID);
  jlModule.set_const("mfem!Geometry!POINT", mfem::Geometry::POINT);
  jlModule.set_const("mfem!Geometry!SEGMENT", mfem::Geometry::SEGMENT);
  jlModule.set_const("mfem!Geometry!TRIANGLE", mfem::Geometry::TRIANGLE);
  jlModule.set_const("mfem!Geometry!SQUARE", mfem::Geometry::SQUARE);
  jlModule.set_const("mfem!Geometry!TETRAHEDRON", mfem::Geometry::TETRAHEDRON);
  jlModule.set_const("mfem!Geometry!CUBE", mfem::Geometry::CUBE);
  jlModule.set_const("mfem!Geometry!PRISM", mfem::Geometry::PRISM);
  jlModule.set_const("mfem!Geometry!PYRAMID", mfem::Geometry::PYRAMID);
  jlModule.set_const("mfem!Geometry!NUM_GEOMETRIES", mfem::Geometry::NUM_GEOMETRIES);

  DEBUG_MSG("Adding wrapper for enum mfem::Element::Type (" __HERE__ ")");
  // defined in mfem/mesh/element.hpp:41:9
  jlModule.add_bits<mfem::Element::Type>("mfem!Element!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Element!POINT", mfem::Element::POINT);
  jlModule.set_const("mfem!Element!SEGMENT", mfem::Element::SEGMENT);
  jlModule.set_const("mfem!Element!TRIANGLE", mfem::Element::TRIANGLE);
  jlModule.set_const("mfem!Element!QUADRILATERAL", mfem::Element::QUADRILATERAL);
  jlModule.set_const("mfem!Element!TETRAHEDRON", mfem::Element::TETRAHEDRON);
  jlModule.set_const("mfem!Element!HEXAHEDRON", mfem::Element::HEXAHEDRON);
  jlModule.set_const("mfem!Element!WEDGE", mfem::Element::WEDGE);
  jlModule.set_const("mfem!Element!PYRAMID", mfem::Element::PYRAMID);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::FaceTopology (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1598:15
  jlModule.add_bits<mfem::Mesh::FaceTopology>("mfem!Mesh!FaceTopology", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!FaceTopology!Boundary", mfem::Mesh::FaceTopology::Boundary);
  jlModule.set_const("mfem!Mesh!FaceTopology!Conforming", mfem::Mesh::FaceTopology::Conforming);
  jlModule.set_const("mfem!Mesh!FaceTopology!Nonconforming", mfem::Mesh::FaceTopology::Nonconforming);
  jlModule.set_const("mfem!Mesh!FaceTopology!NA", mfem::Mesh::FaceTopology::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::ElementLocation (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1610:15
  jlModule.add_bits<mfem::Mesh::ElementLocation>("mfem!Mesh!ElementLocation", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!ElementLocation!Local", mfem::Mesh::ElementLocation::Local);
  jlModule.set_const("mfem!Mesh!ElementLocation!FaceNbr", mfem::Mesh::ElementLocation::FaceNbr);
  jlModule.set_const("mfem!Mesh!ElementLocation!NA", mfem::Mesh::ElementLocation::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::ElementConformity (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1625:15
  jlModule.add_bits<mfem::Mesh::ElementConformity>("mfem!Mesh!ElementConformity", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!ElementConformity!Coincident", mfem::Mesh::ElementConformity::Coincident);
  jlModule.set_const("mfem!Mesh!ElementConformity!Superset", mfem::Mesh::ElementConformity::Superset);
  jlModule.set_const("mfem!Mesh!ElementConformity!Subset", mfem::Mesh::ElementConformity::Subset);
  jlModule.set_const("mfem!Mesh!ElementConformity!NA", mfem::Mesh::ElementConformity::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::FaceInfoTag (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../mesh/mesh.hpp:1644:15
  jlModule.add_bits<mfem::Mesh::FaceInfoTag>("mfem!Mesh!FaceInfoTag", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!FaceInfoTag!Boundary", mfem::Mesh::FaceInfoTag::Boundary);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!LocalConforming", mfem::Mesh::FaceInfoTag::LocalConforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!LocalSlaveNonconforming", mfem::Mesh::FaceInfoTag::LocalSlaveNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!SharedConforming", mfem::Mesh::FaceInfoTag::SharedConforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!SharedSlaveNonconforming", mfem::Mesh::FaceInfoTag::SharedSlaveNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!MasterNonconforming", mfem::Mesh::FaceInfoTag::MasterNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!GhostSlave", mfem::Mesh::FaceInfoTag::GhostSlave);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!GhostMaster", mfem::Mesh::FaceInfoTag::GhostMaster);

  DEBUG_MSG("Adding wrapper for enum mfem::VTKFormat (" __HERE__ ")");
  // defined in mfem/mesh/vtk.hpp:98:12
  jlModule.add_bits<mfem::VTKFormat>("mfem!VTKFormat", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!ASCII", mfem::VTKFormat::ASCII);
  jlModule.set_const("mfem!BINARY", mfem::VTKFormat::BINARY);
  jlModule.set_const("mfem!BINARY32", mfem::VTKFormat::BINARY32);

  DEBUG_MSG("Adding wrapper for enum mfem::GeometricFactors::FactorFlags (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2195:9
  jlModule.add_bits<mfem::GeometricFactors::FactorFlags>("mfem!GeometricFactors!FactorFlags", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!GeometricFactors!COORDINATES", mfem::GeometricFactors::COORDINATES);
  jlModule.set_const("mfem!GeometricFactors!JACOBIANS", mfem::GeometricFactors::JACOBIANS);
  jlModule.set_const("mfem!GeometricFactors!DETERMINANTS", mfem::GeometricFactors::DETERMINANTS);

  DEBUG_MSG("Adding wrapper for enum mfem::FaceGeometricFactors::FactorFlags (" __HERE__ ")");
  // defined in mfem/mesh/../fem/../mesh/mesh.hpp:2245:9
  jlModule.add_bits<mfem::FaceGeometricFactors::FactorFlags>("mfem!FaceGeometricFactors!FactorFlags", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!FaceGeometricFactors!COORDINATES", mfem::FaceGeometricFactors::COORDINATES);
  jlModule.set_const("mfem!FaceGeometricFactors!JACOBIANS", mfem::FaceGeometricFactors::JACOBIANS);
  jlModule.set_const("mfem!FaceGeometricFactors!DETERMINANTS", mfem::FaceGeometricFactors::DETERMINANTS);
  jlModule.set_const("mfem!FaceGeometricFactors!NORMALS", mfem::FaceGeometricFactors::NORMALS);

  DEBUG_MSG("Adding anonymous enum defined in mfem/mesh/../fem/fe_coll.hpp:45:4 (" __HERE__ ")");
  // defined in mfem/mesh/../fem/fe_coll.hpp:45:4
  jlModule.set_const("mfem!FiniteElementCollection!CONTINUOUS", static_cast<int>(mfem::FiniteElementCollection::CONTINUOUS));
  jlModule.set_const("mfem!FiniteElementCollection!TANGENTIAL", static_cast<int>(mfem::FiniteElementCollection::TANGENTIAL));
  jlModule.set_const("mfem!FiniteElementCollection!NORMAL", static_cast<int>(mfem::FiniteElementCollection::NORMAL));
  jlModule.set_const("mfem!FiniteElementCollection!DISCONTINUOUS", static_cast<int>(mfem::FiniteElementCollection::DISCONTINUOUS));

  DEBUG_MSG("Adding anonymous enum defined in mfem/mesh/../fem/fe_coll.hpp:666:4 (" __HERE__ ")");
  // defined in mfem/mesh/../fem/fe_coll.hpp:666:4
  jlModule.set_const("mfem!NURBSFECollection!VariableOrder", static_cast<int>(mfem::NURBSFECollection::VariableOrder));

  DEBUG_MSG("Adding wrapper for enum mfem::Ordering::Type (" __HERE__ ")");
  // defined in mfem/mesh/../fem/fespace.hpp:33:9
  jlModule.add_bits<mfem::Ordering::Type>("mfem!Ordering!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Ordering!byNODES", mfem::Ordering::byNODES);
  jlModule.set_const("mfem!Ordering!byVDIM", mfem::Ordering::byVDIM);

  DEBUG_MSG("Adding wrapper for enum mfem::QVectorLayout (" __HERE__ ")");
  // defined in mfem/mesh/../fem/fespace.hpp:52:12
  jlModule.add_bits<mfem::QVectorLayout>("mfem!QVectorLayout", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!QVectorLayout!byNODES", mfem::QVectorLayout::byNODES);
  jlModule.set_const("mfem!QVectorLayout!byVDIM", mfem::QVectorLayout::byVDIM);

  DEBUG_MSG("Adding wrapper for enum mfem::ElementDofOrdering (" __HERE__ ")");
  // defined in mfem/mesh/../fem/fespace.hpp:74:12
  jlModule.add_bits<mfem::ElementDofOrdering>("mfem!ElementDofOrdering", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!ElementDofOrdering!NATIVE", mfem::ElementDofOrdering::NATIVE);
  jlModule.set_const("mfem!ElementDofOrdering!LEXICOGRAPHIC", mfem::ElementDofOrdering::LEXICOGRAPHIC);

  DEBUG_MSG("Adding wrapper for enum mfem::L2FaceValues (" __HERE__ ")");
  // defined in mfem/mesh/../fem/restriction.hpp:136:12
  jlModule.add_bits<mfem::L2FaceValues>("mfem!L2FaceValues", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!L2FaceValues!SingleValued", mfem::L2FaceValues::SingleValued);
  jlModule.set_const("mfem!L2FaceValues!DoubleValued", mfem::L2FaceValues::DoubleValued);

  DEBUG_MSG("Adding wrapper for enum mfem::AssemblyLevel (" __HERE__ ")");
  // defined in mfem/fem/bilinearform.hpp:31:12
  jlModule.add_bits<mfem::AssemblyLevel>("mfem!AssemblyLevel", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!AssemblyLevel!LEGACY", mfem::AssemblyLevel::LEGACY);
  jlModule.set_const("mfem!AssemblyLevel!LEGACYFULL", mfem::AssemblyLevel::LEGACYFULL);
  jlModule.set_const("mfem!AssemblyLevel!FULL", mfem::AssemblyLevel::FULL);
  jlModule.set_const("mfem!AssemblyLevel!ELEMENT", mfem::AssemblyLevel::ELEMENT);
  jlModule.set_const("mfem!AssemblyLevel!PARTIAL", mfem::AssemblyLevel::PARTIAL);
  jlModule.set_const("mfem!AssemblyLevel!NONE", mfem::AssemblyLevel::NONE);

  DEBUG_MSG("Adding wrapper for enum mfem::DataCollection::Format (" __HERE__ ")");
  // defined in mfem/fem/datacollection.hpp:148:9
  jlModule.add_bits<mfem::DataCollection::Format>("mfem!DataCollection!Format", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!DataCollection!SERIAL_FORMAT", mfem::DataCollection::SERIAL_FORMAT);
  jlModule.set_const("mfem!DataCollection!PARALLEL_FORMAT", mfem::DataCollection::PARALLEL_FORMAT);

  DEBUG_MSG("Adding anonymous enum defined in mfem/fem/datacollection.hpp:381:4 (" __HERE__ ")");
  // defined in mfem/fem/datacollection.hpp:381:4
  jlModule.set_const("mfem!DataCollection!NO_ERROR", static_cast<int>(mfem::DataCollection::NO_ERROR));
  jlModule.set_const("mfem!DataCollection!No_Error", static_cast<int>(mfem::DataCollection::No_Error));
  jlModule.set_const("mfem!DataCollection!READ_ERROR", static_cast<int>(mfem::DataCollection::READ_ERROR));
  jlModule.set_const("mfem!DataCollection!WRITE_ERROR", static_cast<int>(mfem::DataCollection::WRITE_ERROR));
  for(const auto& w: wrappers) w->add_methods();

}
