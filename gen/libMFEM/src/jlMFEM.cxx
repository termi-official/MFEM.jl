// this file was auto-generated by wrapit v1.4.0
#include "jlcxx/jlcxx.hpp"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

#include "jlMFEM.h"

#include <regex>

#include "dbg_msg.h"
#include "Wrapper.h"

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Embedding> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Embedding> : std::false_type { };
}

// Class generating the wrapper for type mfem::Embedding
// signature to use in the veto file: mfem::Embedding
struct Jlmfem_Embedding: public Wrapper {

  Jlmfem_Embedding(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Embedding (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:50:8
    jlcxx::TypeWrapper<mfem::Embedding>  t = jlModule.add_type<mfem::Embedding>("mfem!Embedding");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Embedding>>(new jlcxx::TypeWrapper<mfem::Embedding>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Embedding::Embedding(int, mfem::Geometry::Type, int, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:65:4
    t.constructor<int, mfem::Geometry::Type>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, mfem::Geometry::Type, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, mfem::Geometry::Type, int, bool>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding parent methods  to provide read access to the field parent (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:53:8
    // signature to use in the veto list: mfem::Embedding::parent
    t.method("parent", [](const mfem::Embedding& a) -> int { return a.parent; });
    t.method("parent", [](mfem::Embedding& a) -> int { return a.parent; });
    t.method("parent", [](const mfem::Embedding* a) -> int { return a->parent; });
    t.method("parent", [](mfem::Embedding* a) -> int { return a->parent; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:53:8
    // signature to use in the veto list: mfem::Embedding::parent
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding parent! methods to provide write access to the field parent (" __HERE__ ")");
    t.method("parent!", [](mfem::Embedding& a, int val) -> int { return a.parent = val; });

    DEBUG_MSG("Adding parent! methods to provide write access to the field parent (" __HERE__ ")");
    t.method("parent!", [](mfem::Embedding* a, int val) -> int { return a->parent = val; });

    DEBUG_MSG("Adding geom methods  to provide read access to the field geom (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:58:13
    // signature to use in the veto list: mfem::Embedding::geom
    t.method("geom", [](const mfem::Embedding& a) -> unsigned int { return a.geom; });
    t.method("geom", [](mfem::Embedding& a) -> unsigned int { return a.geom; });
    t.method("geom", [](const mfem::Embedding* a) -> unsigned int { return a->geom; });
    t.method("geom", [](mfem::Embedding* a) -> unsigned int { return a->geom; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:58:13
    // signature to use in the veto list: mfem::Embedding::geom
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding geom! methods to provide write access to the field geom (" __HERE__ ")");
    t.method("geom!", [](mfem::Embedding& a, unsigned int val) -> unsigned int { return a.geom = val; });

    DEBUG_MSG("Adding geom! methods to provide write access to the field geom (" __HERE__ ")");
    t.method("geom!", [](mfem::Embedding* a, unsigned int val) -> unsigned int { return a->geom = val; });

    DEBUG_MSG("Adding matrix methods  to provide read access to the field matrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:59:13
    // signature to use in the veto list: mfem::Embedding::matrix
    t.method("matrix", [](const mfem::Embedding& a) -> unsigned int { return a.matrix; });
    t.method("matrix", [](mfem::Embedding& a) -> unsigned int { return a.matrix; });
    t.method("matrix", [](const mfem::Embedding* a) -> unsigned int { return a->matrix; });
    t.method("matrix", [](mfem::Embedding* a) -> unsigned int { return a->matrix; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:59:13
    // signature to use in the veto list: mfem::Embedding::matrix
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding matrix! methods to provide write access to the field matrix (" __HERE__ ")");
    t.method("matrix!", [](mfem::Embedding& a, unsigned int val) -> unsigned int { return a.matrix = val; });

    DEBUG_MSG("Adding matrix! methods to provide write access to the field matrix (" __HERE__ ")");
    t.method("matrix!", [](mfem::Embedding* a, unsigned int val) -> unsigned int { return a->matrix = val; });

    DEBUG_MSG("Adding ghost methods  to provide read access to the field ghost (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:62:13
    // signature to use in the veto list: mfem::Embedding::ghost
    t.method("ghost", [](const mfem::Embedding& a) -> unsigned int { return a.ghost; });
    t.method("ghost", [](mfem::Embedding& a) -> unsigned int { return a.ghost; });
    t.method("ghost", [](const mfem::Embedding* a) -> unsigned int { return a->ghost; });
    t.method("ghost", [](mfem::Embedding* a) -> unsigned int { return a->ghost; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:62:13
    // signature to use in the veto list: mfem::Embedding::ghost
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding ghost! methods to provide write access to the field ghost (" __HERE__ ")");
    t.method("ghost!", [](mfem::Embedding& a, unsigned int val) -> unsigned int { return a.ghost = val; });

    DEBUG_MSG("Adding ghost! methods to provide write access to the field ghost (" __HERE__ ")");
    t.method("ghost!", [](mfem::Embedding* a, unsigned int val) -> unsigned int { return a->ghost = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Embedding>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Embedding(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Embedding(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Refinement> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Refinement> : std::false_type { };
}

// Class generating the wrapper for type mfem::Refinement
// signature to use in the veto file: mfem::Refinement
struct Jlmfem_Refinement: public Wrapper {

  Jlmfem_Refinement(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Refinement (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:36:8
    jlcxx::TypeWrapper<mfem::Refinement>  t = jlModule.add_type<mfem::Refinement>("mfem!Refinement");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Refinement>>(new jlcxx::TypeWrapper<mfem::Refinement>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Refinement::Refinement(int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:44:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding index methods  to provide read access to the field index (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:39:8
    // signature to use in the veto list: mfem::Refinement::index
    t.method("index", [](const mfem::Refinement& a) -> int { return a.index; });
    t.method("index", [](mfem::Refinement& a) -> int { return a.index; });
    t.method("index", [](const mfem::Refinement* a) -> int { return a->index; });
    t.method("index", [](mfem::Refinement* a) -> int { return a->index; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:39:8
    // signature to use in the veto list: mfem::Refinement::index
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding index! methods to provide write access to the field index (" __HERE__ ")");
    t.method("index!", [](mfem::Refinement& a, int val) -> int { return a.index = val; });

    DEBUG_MSG("Adding index! methods to provide write access to the field index (" __HERE__ ")");
    t.method("index!", [](mfem::Refinement* a, int val) -> int { return a->index = val; });

    DEBUG_MSG("Adding ref_type methods  to provide read access to the field ref_type (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:40:9
    // signature to use in the veto list: mfem::Refinement::ref_type
    t.method("ref_type", [](const mfem::Refinement& a) -> char { return a.ref_type; });
    t.method("ref_type", [](mfem::Refinement& a) -> char { return a.ref_type; });
    t.method("ref_type", [](const mfem::Refinement* a) -> char { return a->ref_type; });
    t.method("ref_type", [](mfem::Refinement* a) -> char { return a->ref_type; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:40:9
    // signature to use in the veto list: mfem::Refinement::ref_type
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding ref_type! methods to provide write access to the field ref_type (" __HERE__ ")");
    t.method("ref_type!", [](mfem::Refinement& a, char val) -> char { return a.ref_type = val; });

    DEBUG_MSG("Adding ref_type! methods to provide write access to the field ref_type (" __HERE__ ")");
    t.method("ref_type!", [](mfem::Refinement* a, char val) -> char { return a->ref_type = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Refinement>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Refinement(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Refinement(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IntegrationPoint> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IntegrationPoint> : std::false_type { };
}

// Class generating the wrapper for type mfem::IntegrationPoint
// signature to use in the veto file: mfem::IntegrationPoint
struct Jlmfem_IntegrationPoint: public Wrapper {

  Jlmfem_IntegrationPoint(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IntegrationPoint (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:34:7
    jlcxx::TypeWrapper<mfem::IntegrationPoint>  t = jlModule.add_type<mfem::IntegrationPoint>("mfem!IntegrationPoint");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationPoint>>(new jlcxx::TypeWrapper<mfem::IntegrationPoint>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Init(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Init(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:40:9
    t.method("Init", static_cast<void (mfem::IntegrationPoint::*)(const int) >(&mfem::IntegrationPoint::Init));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set(const double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set(const double *, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:46:9
    t.method("Set", static_cast<void (mfem::IntegrationPoint::*)(const double *, const int) >(&mfem::IntegrationPoint::Set));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Get(double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Get(double *, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:60:9
    t.method("Get", static_cast<void (mfem::IntegrationPoint::*)(double *, const int)  const>(&mfem::IntegrationPoint::Get));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set(const double, const double, const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set(const double, const double, const double, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:74:9
    t.method("Set", static_cast<void (mfem::IntegrationPoint::*)(const double, const double, const double, const double) >(&mfem::IntegrationPoint::Set));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set3w(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set3w(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:77:9
    t.method("Set3w", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set3w));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set3(const double, const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set3(const double, const double, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:79:9
    t.method("Set3", static_cast<void (mfem::IntegrationPoint::*)(const double, const double, const double) >(&mfem::IntegrationPoint::Set3));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set3(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set3(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:82:9
    t.method("Set3", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set3));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set2w(const double, const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set2w(const double, const double, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:84:9
    t.method("Set2w", static_cast<void (mfem::IntegrationPoint::*)(const double, const double, const double) >(&mfem::IntegrationPoint::Set2w));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set2w(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set2w(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:87:9
    t.method("Set2w", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set2w));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set2(const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set2(const double, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:89:9
    t.method("Set2", static_cast<void (mfem::IntegrationPoint::*)(const double, const double) >(&mfem::IntegrationPoint::Set2));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set2(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set2(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:91:9
    t.method("Set2", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set2));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set1w(const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set1w(const double, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:93:9
    t.method("Set1w", static_cast<void (mfem::IntegrationPoint::*)(const double, const double) >(&mfem::IntegrationPoint::Set1w));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationPoint::Set1w(const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationPoint::Set1w(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:95:9
    t.method("Set1w", static_cast<void (mfem::IntegrationPoint::*)(const double *) >(&mfem::IntegrationPoint::Set1w));

    DEBUG_MSG("Adding x methods  to provide read access to the field x (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:37:11
    // signature to use in the veto list: mfem::IntegrationPoint::x
    t.method("x", [](const mfem::IntegrationPoint& a) -> double { return a.x; });
    t.method("x", [](mfem::IntegrationPoint& a) -> double { return a.x; });
    t.method("x", [](const mfem::IntegrationPoint* a) -> double { return a->x; });
    t.method("x", [](mfem::IntegrationPoint* a) -> double { return a->x; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:37:11
    // signature to use in the veto list: mfem::IntegrationPoint::x
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding x! methods to provide write access to the field x (" __HERE__ ")");
    t.method("x!", [](mfem::IntegrationPoint& a, double val) -> double { return a.x = val; });

    DEBUG_MSG("Adding x! methods to provide write access to the field x (" __HERE__ ")");
    t.method("x!", [](mfem::IntegrationPoint* a, double val) -> double { return a->x = val; });

    DEBUG_MSG("Adding y methods  to provide read access to the field y (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:37:14
    // signature to use in the veto list: mfem::IntegrationPoint::y
    t.method("y", [](const mfem::IntegrationPoint& a) -> double { return a.y; });
    t.method("y", [](mfem::IntegrationPoint& a) -> double { return a.y; });
    t.method("y", [](const mfem::IntegrationPoint* a) -> double { return a->y; });
    t.method("y", [](mfem::IntegrationPoint* a) -> double { return a->y; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:37:14
    // signature to use in the veto list: mfem::IntegrationPoint::y
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding y! methods to provide write access to the field y (" __HERE__ ")");
    t.method("y!", [](mfem::IntegrationPoint& a, double val) -> double { return a.y = val; });

    DEBUG_MSG("Adding y! methods to provide write access to the field y (" __HERE__ ")");
    t.method("y!", [](mfem::IntegrationPoint* a, double val) -> double { return a->y = val; });

    DEBUG_MSG("Adding z methods  to provide read access to the field z (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:37:17
    // signature to use in the veto list: mfem::IntegrationPoint::z
    t.method("z", [](const mfem::IntegrationPoint& a) -> double { return a.z; });
    t.method("z", [](mfem::IntegrationPoint& a) -> double { return a.z; });
    t.method("z", [](const mfem::IntegrationPoint* a) -> double { return a->z; });
    t.method("z", [](mfem::IntegrationPoint* a) -> double { return a->z; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:37:17
    // signature to use in the veto list: mfem::IntegrationPoint::z
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding z! methods to provide write access to the field z (" __HERE__ ")");
    t.method("z!", [](mfem::IntegrationPoint& a, double val) -> double { return a.z = val; });

    DEBUG_MSG("Adding z! methods to provide write access to the field z (" __HERE__ ")");
    t.method("z!", [](mfem::IntegrationPoint* a, double val) -> double { return a->z = val; });

    DEBUG_MSG("Adding weight methods  to provide read access to the field weight (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:37:20
    // signature to use in the veto list: mfem::IntegrationPoint::weight
    t.method("weight", [](const mfem::IntegrationPoint& a) -> double { return a.weight; });
    t.method("weight", [](mfem::IntegrationPoint& a) -> double { return a.weight; });
    t.method("weight", [](const mfem::IntegrationPoint* a) -> double { return a->weight; });
    t.method("weight", [](mfem::IntegrationPoint* a) -> double { return a->weight; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:37:20
    // signature to use in the veto list: mfem::IntegrationPoint::weight
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding weight! methods to provide write access to the field weight (" __HERE__ ")");
    t.method("weight!", [](mfem::IntegrationPoint& a, double val) -> double { return a.weight = val; });

    DEBUG_MSG("Adding weight! methods to provide write access to the field weight (" __HERE__ ")");
    t.method("weight!", [](mfem::IntegrationPoint* a, double val) -> double { return a->weight = val; });

    DEBUG_MSG("Adding index methods  to provide read access to the field index (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:38:8
    // signature to use in the veto list: mfem::IntegrationPoint::index
    t.method("index", [](const mfem::IntegrationPoint& a) -> int { return a.index; });
    t.method("index", [](mfem::IntegrationPoint& a) -> int { return a.index; });
    t.method("index", [](const mfem::IntegrationPoint* a) -> int { return a->index; });
    t.method("index", [](mfem::IntegrationPoint* a) -> int { return a->index; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:38:8
    // signature to use in the veto list: mfem::IntegrationPoint::index
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding index! methods to provide write access to the field index (" __HERE__ ")");
    t.method("index!", [](mfem::IntegrationPoint& a, int val) -> int { return a.index = val; });

    DEBUG_MSG("Adding index! methods to provide write access to the field index (" __HERE__ ")");
    t.method("index!", [](mfem::IntegrationPoint* a, int val) -> int { return a->index = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationPoint>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IntegrationPoint(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IntegrationPoint(module));
}

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<mfem::Array<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<mfem::Array<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<mfem::Array<T>> : std::false_type { };
}

// Class generating the wrapper for type mfem::Array
// signature to use in the veto file: mfem::Array
struct Jlmfem_Array: public Wrapper {

  Jlmfem_Array(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Array (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:45:7
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("mfem!Array");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
    auto t1_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<mfem::Array<T>> wrapped){
      auto module_ = this->module_;
      typedef mfem::Array<T> WrappedType;
      wrapped.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(mfem::MemoryType) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:67:11
      wrapped.template constructor<mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(int) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:70:20
      wrapped.template constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(int, mfem::MemoryType) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:74:11
      wrapped.template constructor<int, mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(T *, int) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:79:11
      wrapped.template constructor<T *, int>(/*finalize=*/jlcxx::finalize_policy::yes);

      DEBUG_MSG("Adding wrapper for T * mfem::Array::GetData() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::GetData()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:114:14
      wrapped.method("GetData", static_cast<T * (WrappedType::*)() >(&WrappedType::GetData));

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::GetData() (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::GetData()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:116:20
      wrapped.method("GetData", static_cast<const T * (WrappedType::*)()  const>(&WrappedType::GetData));

      DEBUG_MSG("Adding wrapper for bool mfem::Array::UseDevice() (" __HERE__ ")");
      // signature to use in the veto list: bool mfem::Array::UseDevice()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:125:9
      wrapped.method("UseDevice", static_cast<bool (WrappedType::*)()  const>(&WrappedType::UseDevice));

      DEBUG_MSG("Adding wrapper for bool mfem::Array::OwnsData() (" __HERE__ ")");
      // signature to use in the veto list: bool mfem::Array::OwnsData()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:128:16
      wrapped.method("OwnsData", static_cast<bool (WrappedType::*)()  const>(&WrappedType::OwnsData));

      DEBUG_MSG("Adding wrapper for void mfem::Array::StealData(T **) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::StealData(T **)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:131:16
      wrapped.method("StealData", static_cast<void (WrappedType::*)(T **) >(&WrappedType::StealData));

      DEBUG_MSG("Adding wrapper for void mfem::Array::LoseData() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::LoseData()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:134:16
      wrapped.method("LoseData", static_cast<void (WrappedType::*)() >(&WrappedType::LoseData));

      DEBUG_MSG("Adding wrapper for void mfem::Array::MakeDataOwner() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::MakeDataOwner()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:137:9
      wrapped.method("MakeDataOwner", static_cast<void (WrappedType::*)()  const>(&WrappedType::MakeDataOwner));

      DEBUG_MSG("Adding wrapper for int mfem::Array::Size() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Size()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:140:15
      wrapped.method("Size", static_cast<int (WrappedType::*)()  const>(&WrappedType::Size));

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:143:16
      wrapped.method("SetSize", static_cast<void (WrappedType::*)(int) >(&WrappedType::SetSize));

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int, const T &) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int, const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:146:16
      wrapped.method("SetSize", static_cast<void (WrappedType::*)(int, const T &) >(&WrappedType::SetSize));

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int, mfem::MemoryType) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int, mfem::MemoryType)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:151:16
      wrapped.method("SetSize", static_cast<void (WrappedType::*)(int, mfem::MemoryType) >(&WrappedType::SetSize));

      DEBUG_MSG("Adding wrapper for int mfem::Array::Capacity() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Capacity()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:155:15
      wrapped.method("Capacity", static_cast<int (WrappedType::*)()  const>(&WrappedType::Capacity));

      DEBUG_MSG("Adding wrapper for void mfem::Array::Reserve(int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::Reserve(int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:158:16
      wrapped.method("Reserve", static_cast<void (WrappedType::*)(int) >(&WrappedType::Reserve));
      module_.set_override_module(jl_base_module);


      DEBUG_MSG("Adding setindex! method  to wrap T & mfem::Array::operator[](int) (" __HERE__ ")");
// defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:162:15
      wrapped.method("setindex!",
        [](WrappedType& a, int i, T const & val){
        return a[i] = val;
      });

      DEBUG_MSG("Adding getindex method to wrap T & mfem::Array::operator[](int) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:162:15
      wrapped.method("getindex",
        [](WrappedType& a, int i){
        return a[i];
      });


      module_.unset_override_module();

      DEBUG_MSG("Adding wrapper for int mfem::Array::Append(const T &) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Append(const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:168:15
      wrapped.method("Append", static_cast<int (WrappedType::*)(const T &) >(&WrappedType::Append));

      DEBUG_MSG("Adding wrapper for int mfem::Array::Append(const T *, int) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Append(const T *, int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:171:15
      wrapped.method("Append", static_cast<int (WrappedType::*)(const T *, int) >(&WrappedType::Append));

      DEBUG_MSG("Adding wrapper for int mfem::Array::Prepend(const T &) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Prepend(const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:177:15
      wrapped.method("Prepend", static_cast<int (WrappedType::*)(const T &) >(&WrappedType::Prepend));

      DEBUG_MSG("Adding wrapper for T & mfem::Array::Last() (" __HERE__ ")");
      // signature to use in the veto list: T & mfem::Array::Last()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:180:14
      wrapped.method("Last", static_cast<T & (WrappedType::*)() >(&WrappedType::Last));

      DEBUG_MSG("Adding wrapper for const T & mfem::Array::Last() (" __HERE__ ")");
      // signature to use in the veto list: const T & mfem::Array::Last()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:183:20
      wrapped.method("Last", static_cast<const T & (WrappedType::*)()  const>(&WrappedType::Last));

      DEBUG_MSG("Adding wrapper for void mfem::Array::DeleteLast() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::DeleteLast()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:195:16
      wrapped.method("DeleteLast", static_cast<void (WrappedType::*)() >(&WrappedType::DeleteLast));

      DEBUG_MSG("Adding wrapper for void mfem::Array::DeleteAll() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::DeleteAll()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:201:16
      wrapped.method("DeleteAll", static_cast<void (WrappedType::*)() >(&WrappedType::DeleteAll));

      DEBUG_MSG("Adding wrapper for void mfem::Array::MakeRef(T *, int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::MakeRef(T *, int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:208:16
      wrapped.method("MakeRef", static_cast<void (WrappedType::*)(T *, int) >(&WrappedType::MakeRef));

      DEBUG_MSG("Adding wrapper for void mfem::Array::operator=(const T &) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::operator=(const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:274:16
      wrapped.method("assign", static_cast<void (WrappedType::*)(const T &) >(&WrappedType::operator=));

      DEBUG_MSG("Adding wrapper for void mfem::Array::Assign(const T *) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::Assign(const T *)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:277:16
      wrapped.method("Assign", static_cast<void (WrappedType::*)(const T *) >(&WrappedType::Assign));

      DEBUG_MSG("Adding wrapper for std::size_t mfem::Array::MemoryUsage() (" __HERE__ ")");
      // signature to use in the veto list: std::size_t mfem::Array::MemoryUsage()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:303:16
      wrapped.method("MemoryUsage", static_cast<std::size_t (WrappedType::*)()  const>(&WrappedType::MemoryUsage));

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::Read(bool) (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::Read(bool)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:306:13
      wrapped.method("Read", static_cast<const T * (WrappedType::*)(bool)  const>(&WrappedType::Read));
      wrapped.method("Read", [](WrappedType const& a)->const T * { return a.Read(); });
      wrapped.method("Read", [](WrappedType const* a)->const T * { return a->Read(); });

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::HostRead() (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::HostRead()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:310:13
      wrapped.method("HostRead", static_cast<const T * (WrappedType::*)()  const>(&WrappedType::HostRead));

      DEBUG_MSG("Adding wrapper for T * mfem::Array::Write(bool) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::Write(bool)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:314:7
      wrapped.method("Write", static_cast<T * (WrappedType::*)(bool) >(&WrappedType::Write));
      wrapped.method("Write", [](WrappedType& a)->T * { return a.Write(); });
      wrapped.method("Write", [](WrappedType* a)->T * { return a->Write(); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array::HostWrite() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::HostWrite()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:318:7
      wrapped.method("HostWrite", static_cast<T * (WrappedType::*)() >(&WrappedType::HostWrite));

      DEBUG_MSG("Adding wrapper for T * mfem::Array::ReadWrite(bool) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::ReadWrite(bool)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:322:7
      wrapped.method("ReadWrite", static_cast<T * (WrappedType::*)(bool) >(&WrappedType::ReadWrite));
      wrapped.method("ReadWrite", [](WrappedType& a)->T * { return a.ReadWrite(); });
      wrapped.method("ReadWrite", [](WrappedType* a)->T * { return a->ReadWrite(); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array::HostReadWrite() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::HostReadWrite()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:326:7
      wrapped.method("HostReadWrite", static_cast<T * (WrappedType::*)() >(&WrappedType::HostReadWrite));
    };
    t.apply<mfem::Array<int>, mfem::Array<float>, mfem::Array<double>, mfem::Array<mfem::FiniteElementSpace *>, mfem::Array<mfem::NonlinearFormIntegrator *>, mfem::Array<mfem::BilinearFormIntegrator *>, mfem::Array<mfem::DeltaLFIntegrator *>, mfem::Array<mfem::Array<int> *>, mfem::Array<mfem::LinearFormIntegrator *>, mfem::Array<mfem::IntegrationPoint>, mfem::Array<mfem::Vector *>, mfem::Array<mfem::KnotVector *>, mfem::Array<mfem::Refinement>, mfem::Array<mfem::Embedding>, mfem::Array<mfem::Geometry::Type>, mfem::Array<mfem::Coefficient *>, mfem::Array<const mfem::KnotVector *>, mfem::Array<mfem::SparseMatrix *>>(t1_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Array(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Array(module));
}

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<mfem::Array2D<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<mfem::Array2D<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<mfem::Array2D<T>> : std::false_type { };
}

// Class generating the wrapper for type mfem::Array2D
// signature to use in the veto file: mfem::Array2D
struct Jlmfem_Array2D: public Wrapper {

  Jlmfem_Array2D(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Array2D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:360:7
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("mfem!Array2D");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
    auto t4_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<mfem::Array2D<T>> wrapped){
      auto module_ = this->module_;
      typedef mfem::Array2D<T> WrappedType;
      wrapped.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array2D::Array2D<T>(int, int) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:370:4
      wrapped.template constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

      DEBUG_MSG("Adding wrapper for void mfem::Array2D::SetSize(int, int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array2D::SetSize(int, int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:374:9
      wrapped.method("SetSize", static_cast<void (WrappedType::*)(int, int) >(&WrappedType::SetSize));

      DEBUG_MSG("Adding wrapper for int mfem::Array2D::NumRows() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array2D::NumRows()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:376:8
      wrapped.method("NumRows", static_cast<int (WrappedType::*)()  const>(&WrappedType::NumRows));

      DEBUG_MSG("Adding wrapper for int mfem::Array2D::NumCols() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array2D::NumCols()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:377:8
      wrapped.method("NumCols", static_cast<int (WrappedType::*)()  const>(&WrappedType::NumCols));

      DEBUG_MSG("Adding wrapper for const T & mfem::Array2D::operator()(int, int) (" __HERE__ ")");
      // signature to use in the veto list: const T & mfem::Array2D::operator()(int, int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:379:20
      wrapped.method("paren", static_cast<const T & (WrappedType::*)(int, int)  const>(&WrappedType::operator()));

      DEBUG_MSG("Adding wrapper for T & mfem::Array2D::operator()(int, int) (" __HERE__ ")");
      // signature to use in the veto list: T & mfem::Array2D::operator()(int, int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:380:20
      wrapped.method("paren", static_cast<T & (WrappedType::*)(int, int) >(&WrappedType::operator()));
      module_.set_override_module(jl_base_module);



      module_.unset_override_module();

      DEBUG_MSG("Adding wrapper for const T * mfem::Array2D::operator()(int) (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array2D::operator()(int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:385:13
      wrapped.method("paren", static_cast<const T * (WrappedType::*)(int)  const>(&WrappedType::operator()));

      DEBUG_MSG("Adding wrapper for T * mfem::Array2D::operator()(int) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array2D::operator()(int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:386:13
      wrapped.method("paren", static_cast<T * (WrappedType::*)(int) >(&WrappedType::operator()));

      DEBUG_MSG("Adding wrapper for const T * mfem::Array2D::GetRow(int) (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array2D::GetRow(int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:388:13
      wrapped.method("GetRow", static_cast<const T * (WrappedType::*)(int)  const>(&WrappedType::GetRow));

      DEBUG_MSG("Adding wrapper for T * mfem::Array2D::GetRow(int) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array2D::GetRow(int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:389:13
      wrapped.method("GetRow", static_cast<T * (WrappedType::*)(int) >(&WrappedType::GetRow));

      DEBUG_MSG("Adding wrapper for void mfem::Array2D::operator=(const T &) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array2D::operator=(const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:433:16
      wrapped.method("assign", static_cast<void (WrappedType::*)(const T &) >(&WrappedType::operator=));

      DEBUG_MSG("Adding wrapper for void mfem::Array2D::DeleteAll() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array2D::DeleteAll()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:443:16
      wrapped.method("DeleteAll", static_cast<void (WrappedType::*)() >(&WrappedType::DeleteAll));
    };
    t.apply<mfem::Array2D<mfem::SparseMatrix *>>(t4_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Array2D(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Array2D(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Vector> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Vector> : std::false_type { };
}

// Class generating the wrapper for type mfem::Vector
// signature to use in the veto file: mfem::Vector
struct Jlmfem_Vector: public Wrapper {

  Jlmfem_Vector(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Vector (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:58:7
    jlcxx::TypeWrapper<mfem::Vector>  t = jlModule.add_type<mfem::Vector>("mfem!Vector");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Vector>>(new jlcxx::TypeWrapper<mfem::Vector>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(const mfem::Vector &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:72:4
    t.constructor<const mfem::Vector &>(/*finalize=*/jlcxx::finalize_policy::yes);



    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:79:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(double *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:84:4
    t.constructor<double *, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(mfem::Vector &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:89:4
    t.constructor<mfem::Vector &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(int, mfem::MemoryType) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:93:4
    t.constructor<int, mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Vector::Vector(int, mfem::MemoryType, mfem::MemoryType) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:98:4
    t.constructor<int, mfem::MemoryType, mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::Vector::UseDevice(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::UseDevice(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:115:17
    t.method("UseDevice", static_cast<void (mfem::Vector::*)(bool)  const>(&mfem::Vector::UseDevice));

    DEBUG_MSG("Adding wrapper for bool mfem::Vector::UseDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Vector::UseDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:118:17
    t.method("UseDevice", static_cast<bool (mfem::Vector::*)()  const>(&mfem::Vector::UseDevice));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSize(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:137:9
    t.method("SetSize", static_cast<void (mfem::Vector::*)(int) >(&mfem::Vector::SetSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSize(int, mfem::MemoryType) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSize(int, mfem::MemoryType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:140:9
    t.method("SetSize", static_cast<void (mfem::Vector::*)(int, mfem::MemoryType) >(&mfem::Vector::SetSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSize(int, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSize(int, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:143:9
    t.method("SetSize", static_cast<void (mfem::Vector::*)(int, const mfem::Vector &) >(&mfem::Vector::SetSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetData(double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetData(double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:147:9
    t.method("SetData", static_cast<void (mfem::Vector::*)(double *) >(&mfem::Vector::SetData));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetDataAndSize(double *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetDataAndSize(double *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:154:9
    t.method("SetDataAndSize", static_cast<void (mfem::Vector::*)(double *, int) >(&mfem::Vector::SetDataAndSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::NewDataAndSize(double *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::NewDataAndSize(double *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:160:9
    t.method("NewDataAndSize", static_cast<void (mfem::Vector::*)(double *, int) >(&mfem::Vector::NewDataAndSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::NewMemoryAndSize(const mfem::Memory<double> &, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::NewMemoryAndSize(const mfem::Memory<double> &, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:175:16
    t.method("NewMemoryAndSize", static_cast<void (mfem::Vector::*)(const mfem::Memory<double> &, int, bool) >(&mfem::Vector::NewMemoryAndSize));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::MakeRef(mfem::Vector &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::MakeRef(mfem::Vector &, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:178:16
    t.method("MakeRef", static_cast<void (mfem::Vector::*)(mfem::Vector &, int, int) >(&mfem::Vector::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::MakeRef(mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::MakeRef(mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:182:16
    t.method("MakeRef", static_cast<void (mfem::Vector::*)(mfem::Vector &, int) >(&mfem::Vector::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::MakeDataOwner() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::MakeDataOwner()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:185:9
    t.method("MakeDataOwner", static_cast<void (mfem::Vector::*)()  const>(&mfem::Vector::MakeDataOwner));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Destroy() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Destroy()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:188:9
    t.method("Destroy", static_cast<void (mfem::Vector::*)() >(&mfem::Vector::Destroy));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::DeleteDevice(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::DeleteDevice(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:193:9
    t.method("DeleteDevice", static_cast<void (mfem::Vector::*)(bool) >(&mfem::Vector::DeleteDevice));
    t.method("DeleteDevice", [](mfem::Vector& a)->void { a.DeleteDevice(); });
    t.method("DeleteDevice", [](mfem::Vector* a)->void { a->DeleteDevice(); });

    DEBUG_MSG("Adding wrapper for int mfem::Vector::Size() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Vector::Size()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:197:15
    t.method("Size", static_cast<int (mfem::Vector::*)()  const>(&mfem::Vector::Size));

    DEBUG_MSG("Adding wrapper for int mfem::Vector::Capacity() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Vector::Capacity()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:201:15
    t.method("Capacity", static_cast<int (mfem::Vector::*)()  const>(&mfem::Vector::Capacity));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::GetData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::GetData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:206:19
    t.method("GetData", static_cast<double * (mfem::Vector::*)()  const>(&mfem::Vector::GetData));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::begin() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::begin()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:216:19
    t.method("begin", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::begin));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::end() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::end()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:219:19
    t.method("end", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::end));

    DEBUG_MSG("Adding wrapper for const double * mfem::Vector::begin() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Vector::begin()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:222:25
    t.method("begin", static_cast<const double * (mfem::Vector::*)()  const>(&mfem::Vector::begin));

    DEBUG_MSG("Adding wrapper for const double * mfem::Vector::end() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Vector::end()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:225:25
    t.method("end", static_cast<const double * (mfem::Vector::*)()  const>(&mfem::Vector::end));

    DEBUG_MSG("Adding wrapper for mfem::Memory<double> & mfem::Vector::GetMemory() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Memory<double> & mfem::Vector::GetMemory()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:228:20
    t.method("GetMemory", static_cast<mfem::Memory<double> & (mfem::Vector::*)() >(&mfem::Vector::GetMemory));

    DEBUG_MSG("Adding wrapper for const mfem::Memory<double> & mfem::Vector::GetMemory() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Memory<double> & mfem::Vector::GetMemory()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:232:26
    t.method("GetMemory", static_cast<const mfem::Memory<double> & (mfem::Vector::*)()  const>(&mfem::Vector::GetMemory));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SyncMemory(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SyncMemory(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:235:9
    t.method("SyncMemory", static_cast<void (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::SyncMemory));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SyncAliasMemory(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SyncAliasMemory(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:238:9
    t.method("SyncAliasMemory", static_cast<void (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::SyncAliasMemory));

    DEBUG_MSG("Adding wrapper for bool mfem::Vector::OwnsData() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Vector::OwnsData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:242:16
    t.method("OwnsData", static_cast<bool (mfem::Vector::*)()  const>(&mfem::Vector::OwnsData));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::StealData(double **) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::StealData(double **)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:245:16
    t.method("StealData", static_cast<void (mfem::Vector::*)(double **) >(&mfem::Vector::StealData));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::StealData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::StealData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:249:19
    t.method("StealData", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::StealData));

    DEBUG_MSG("Adding wrapper for double & mfem::Vector::Elem(int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::Vector::Elem(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:252:12
    t.method("Elem", static_cast<double & (mfem::Vector::*)(int) >(&mfem::Vector::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::Vector::Elem(int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::Vector::Elem(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:255:18
    t.method("Elem", static_cast<const double & (mfem::Vector::*)(int)  const>(&mfem::Vector::Elem));

    DEBUG_MSG("Adding wrapper for double & mfem::Vector::operator()(int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::Vector::operator()(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:259:19
    t.method("paren", static_cast<double & (mfem::Vector::*)(int) >(&mfem::Vector::operator()));

    DEBUG_MSG("Adding wrapper for const double & mfem::Vector::operator()(int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::Vector::operator()(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:263:25
    t.method("paren", static_cast<const double & (mfem::Vector::*)(int)  const>(&mfem::Vector::operator()));
    module_.set_override_module(jl_base_module);


    DEBUG_MSG("Adding setindex! method  to wrap double & mfem::Vector::operator[](int) (" __HERE__ ")");
// defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:267:19
    t.method("setindex!",
      [](mfem::Vector& a, int i, double const & val){
      return a[i] = val;
    });

    DEBUG_MSG("Adding getindex method to wrap double & mfem::Vector::operator[](int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:267:19
    t.method("getindex",
      [](mfem::Vector& a, int i){
      return a[i];
    });


    DEBUG_MSG("Adding wrapper for double mfem::Vector::operator*(const double *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::operator*(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:274:11
    t.method("*", static_cast<double (mfem::Vector::*)(const double *)  const>(&mfem::Vector::operator*));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::operator*(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::operator*(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:277:11
    t.method("*", static_cast<double (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::operator*));

    module_.unset_override_module();

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator=(const double *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator=(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:280:12
    t.method("assign", static_cast<mfem::Vector & (mfem::Vector::*)(const double *) >(&mfem::Vector::operator=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:285:12
    t.method("assign", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator=));


    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:291:12
    t.method("assign", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator*=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator*=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:293:12
    t.method("mult!", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator*=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator*=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator*=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:296:12
    t.method("mult!", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator*=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator/=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator/=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:298:12
    t.method("fdiv!", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator/=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator/=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator/=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:301:12
    t.method("fdiv!", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator/=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator-=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator-=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:303:12
    t.method("sub!", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator-=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator-=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator-=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:305:12
    t.method("sub!", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator-=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator+=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator+=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:307:12
    t.method("add!", static_cast<mfem::Vector & (mfem::Vector::*)(double) >(&mfem::Vector::operator+=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::operator+=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::operator+=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:309:12
    t.method("add!", static_cast<mfem::Vector & (mfem::Vector::*)(const mfem::Vector &) >(&mfem::Vector::operator+=));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::Add(const double, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::Add(const double, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:312:12
    t.method("Add", static_cast<mfem::Vector & (mfem::Vector::*)(const double, const mfem::Vector &) >(&mfem::Vector::Add));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::Vector::Set(const double, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::Vector::Set(const double, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:315:12
    t.method("Set", static_cast<mfem::Vector & (mfem::Vector::*)(const double, const mfem::Vector &) >(&mfem::Vector::Set));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetVector(const mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetVector(const mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:317:9
    t.method("SetVector", static_cast<void (mfem::Vector::*)(const mfem::Vector &, int) >(&mfem::Vector::SetVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::AddSubVector(const mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::AddSubVector(const mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:319:9
    t.method("AddSubVector", static_cast<void (mfem::Vector::*)(const mfem::Vector &, int) >(&mfem::Vector::AddSubVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Neg() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Neg()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:322:9
    t.method("Neg", static_cast<void (mfem::Vector::*)() >(&mfem::Vector::Neg));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Reciprocal() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Reciprocal()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:325:9
    t.method("Reciprocal", static_cast<void (mfem::Vector::*)() >(&mfem::Vector::Reciprocal));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Swap(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Swap(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:328:16
    t.method("Swap", static_cast<void (mfem::Vector::*)(mfem::Vector &) >(&mfem::Vector::Swap));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::cross3D(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::cross3D(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:352:9
    t.method("cross3D", static_cast<void (mfem::Vector::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::Vector::cross3D));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::median(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::median(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:355:9
    t.method("median", static_cast<void (mfem::Vector::*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::Vector::median));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::GetSubVector(const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::GetSubVector(const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:360:9
    t.method("GetSubVector", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, mfem::Vector &)  const>(&mfem::Vector::GetSubVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::GetSubVector(const mfem::Array<int> &, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::GetSubVector(const mfem::Array<int> &, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:365:9
    t.method("GetSubVector", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, double *)  const>(&mfem::Vector::GetSubVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSubVector(const mfem::Array<int> &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSubVector(const mfem::Array<int> &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:370:9
    t.method("SetSubVector", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, const double) >(&mfem::Vector::SetSubVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSubVector(const mfem::Array<int> &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSubVector(const mfem::Array<int> &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:375:9
    t.method("SetSubVector", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, const mfem::Vector &) >(&mfem::Vector::SetSubVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSubVector(const mfem::Array<int> &, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSubVector(const mfem::Array<int> &, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:380:9
    t.method("SetSubVector", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, double *) >(&mfem::Vector::SetSubVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::AddElementVector(const mfem::Array<int> &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::AddElementVector(const mfem::Array<int> &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:385:9
    t.method("AddElementVector", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, const mfem::Vector &) >(&mfem::Vector::AddElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::AddElementVector(const mfem::Array<int> &, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::AddElementVector(const mfem::Array<int> &, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:390:9
    t.method("AddElementVector", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, double *) >(&mfem::Vector::AddElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::AddElementVector(const mfem::Array<int> &, const double, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::AddElementVector(const mfem::Array<int> &, const double, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:395:9
    t.method("AddElementVector", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, const double, const mfem::Vector &) >(&mfem::Vector::AddElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::SetSubVectorComplement(const mfem::Array<int> &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::SetSubVectorComplement(const mfem::Array<int> &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:399:9
    t.method("SetSubVectorComplement", static_cast<void (mfem::Vector::*)(const mfem::Array<int> &, const double) >(&mfem::Vector::SetSubVectorComplement));

    DEBUG_MSG("Adding wrapper for void mfem::Vector::Randomize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Vector::Randomize(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:421:9
    t.method("Randomize", static_cast<void (mfem::Vector::*)(int) >(&mfem::Vector::Randomize));
    t.method("Randomize", [](mfem::Vector& a)->void { a.Randomize(); });
    t.method("Randomize", [](mfem::Vector* a)->void { a->Randomize(); });

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Norml2() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Norml2()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:423:11
    t.method("Norml2", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Norml2));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Normlinf() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Normlinf()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:425:11
    t.method("Normlinf", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Normlinf));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Norml1() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Norml1()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:427:11
    t.method("Norml1", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Norml1));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Normlp(double) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Normlp(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:429:11
    t.method("Normlp", static_cast<double (mfem::Vector::*)(double)  const>(&mfem::Vector::Normlp));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Max() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Max()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:431:11
    t.method("Max", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Max));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Min() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Min()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:433:11
    t.method("Min", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Min));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::Sum() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::Sum()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:435:11
    t.method("Sum", static_cast<double (mfem::Vector::*)()  const>(&mfem::Vector::Sum));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::DistanceSquaredTo(const double *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::DistanceSquaredTo(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:437:18
    t.method("DistanceSquaredTo", static_cast<double (mfem::Vector::*)(const double *)  const>(&mfem::Vector::DistanceSquaredTo));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::DistanceSquaredTo(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::DistanceSquaredTo(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:439:18
    t.method("DistanceSquaredTo", static_cast<double (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::DistanceSquaredTo));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::DistanceTo(const double *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::DistanceTo(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:441:18
    t.method("DistanceTo", static_cast<double (mfem::Vector::*)(const double *)  const>(&mfem::Vector::DistanceTo));

    DEBUG_MSG("Adding wrapper for double mfem::Vector::DistanceTo(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Vector::DistanceTo(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:443:18
    t.method("DistanceTo", static_cast<double (mfem::Vector::*)(const mfem::Vector &)  const>(&mfem::Vector::DistanceTo));

    DEBUG_MSG("Adding wrapper for int mfem::Vector::CheckFinite() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Vector::CheckFinite()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:447:8
    t.method("CheckFinite", static_cast<int (mfem::Vector::*)()  const>(&mfem::Vector::CheckFinite));

    DEBUG_MSG("Adding wrapper for const double * mfem::Vector::Read(bool) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Vector::Read(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:453:26
    t.method("Read", static_cast<const double * (mfem::Vector::*)(bool)  const>(&mfem::Vector::Read));
    t.method("Read", [](mfem::Vector const& a)->const double * { return a.Read(); });
    t.method("Read", [](mfem::Vector const* a)->const double * { return a->Read(); });

    DEBUG_MSG("Adding wrapper for const double * mfem::Vector::HostRead() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Vector::HostRead()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:457:26
    t.method("HostRead", static_cast<const double * (mfem::Vector::*)()  const>(&mfem::Vector::HostRead));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::Write(bool) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::Write(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:461:20
    t.method("Write", static_cast<double * (mfem::Vector::*)(bool) >(&mfem::Vector::Write));
    t.method("Write", [](mfem::Vector& a)->double * { return a.Write(); });
    t.method("Write", [](mfem::Vector* a)->double * { return a->Write(); });

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::HostWrite() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::HostWrite()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:465:20
    t.method("HostWrite", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::HostWrite));

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::ReadWrite(bool) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::ReadWrite(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:469:20
    t.method("ReadWrite", static_cast<double * (mfem::Vector::*)(bool) >(&mfem::Vector::ReadWrite));
    t.method("ReadWrite", [](mfem::Vector& a)->double * { return a.ReadWrite(); });
    t.method("ReadWrite", [](mfem::Vector* a)->double * { return a->ReadWrite(); });

    DEBUG_MSG("Adding wrapper for double * mfem::Vector::HostReadWrite() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Vector::HostReadWrite()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:473:20
    t.method("HostReadWrite", static_cast<double * (mfem::Vector::*)() >(&mfem::Vector::HostReadWrite));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Vector>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Vector(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Vector(module));
}

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<mfem::Memory<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<mfem::Memory<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<mfem::Memory<T>> : std::false_type { };
}

// Class generating the wrapper for type mfem::Memory
// signature to use in the veto file: mfem::Memory
struct Jlmfem_Memory: public Wrapper {

  Jlmfem_Memory(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Memory (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/../general/mem_manager.hpp:160:7
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("mfem!Memory");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
    auto t8_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<mfem::Memory<T>> wrapped){
      auto module_ = this->module_;
      wrapped.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
    };
    t.apply<mfem::Memory<int>, mfem::Memory<double>>(t8_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Memory(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Memory(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Operator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Operator> : std::false_type { };
}

// Class generating the wrapper for type mfem::Operator
// signature to use in the veto file: mfem::Operator
struct Jlmfem_Operator: public Wrapper {

  Jlmfem_Operator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Operator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:24:7
    jlcxx::TypeWrapper<mfem::Operator>  t = jlModule.add_type<mfem::Operator>("mfem!Operator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Operator>>(new jlcxx::TypeWrapper<mfem::Operator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::Operator::InitTVectors(const mfem::Operator *, const mfem::Operator *, const mfem::Operator *, mfem::Vector &, mfem::Vector &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::InitTVectors(const mfem::Operator *, const mfem::Operator *, const mfem::Operator *, mfem::Vector &, mfem::Vector &, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:55:9
    t.method("InitTVectors", static_cast<void (mfem::Operator::*)(const mfem::Operator *, const mfem::Operator *, const mfem::Operator *, mfem::Vector &, mfem::Vector &, mfem::Vector &, mfem::Vector &)  const>(&mfem::Operator::InitTVectors));



    DEBUG_MSG("Adding wrapper for int mfem::Operator::Height() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Operator::Height()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:66:15
    t.method("Height", static_cast<int (mfem::Operator::*)()  const>(&mfem::Operator::Height));

    DEBUG_MSG("Adding wrapper for int mfem::Operator::NumRows() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Operator::NumRows()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:69:15
    t.method("NumRows", static_cast<int (mfem::Operator::*)()  const>(&mfem::Operator::NumRows));

    DEBUG_MSG("Adding wrapper for int mfem::Operator::Width() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Operator::Width()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:72:15
    t.method("Width", static_cast<int (mfem::Operator::*)()  const>(&mfem::Operator::Width));

    DEBUG_MSG("Adding wrapper for int mfem::Operator::NumCols() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Operator::NumCols()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:75:15
    t.method("NumCols", static_cast<int (mfem::Operator::*)()  const>(&mfem::Operator::NumCols));

    DEBUG_MSG("Adding wrapper for mfem::MemoryClass mfem::Operator::GetMemoryClass() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MemoryClass mfem::Operator::GetMemoryClass()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:86:24
    t.method("GetMemoryClass", static_cast<mfem::MemoryClass (mfem::Operator::*)()  const>(&mfem::Operator::GetMemoryClass));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:89:17
    t.method("Mult", static_cast<void (mfem::Operator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::Operator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:93:17
    t.method("MultTranspose", static_cast<void (mfem::Operator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::Operator::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::AddMult(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::AddMult(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:97:17
    t.method("AddMult", static_cast<void (mfem::Operator::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::Operator::AddMult));
    t.method("AddMult", [](mfem::Operator const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMult(arg0, arg1); });
    t.method("AddMult", [](mfem::Operator const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Operator::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:100:17
    t.method("AddMultTranspose", static_cast<void (mfem::Operator::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::Operator::AddMultTranspose));
    t.method("AddMultTranspose", [](mfem::Operator const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMultTranspose(arg0, arg1); });
    t.method("AddMultTranspose", [](mfem::Operator const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMultTranspose(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::Operator & mfem::Operator::GetGradient(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator & mfem::Operator::GetGradient(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:122:22
    t.method("GetGradient", static_cast<mfem::Operator & (mfem::Operator::*)(const mfem::Vector &)  const>(&mfem::Operator::GetGradient));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::AssembleDiagonal(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::AssembleDiagonal(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:131:17
    t.method("AssembleDiagonal", static_cast<void (mfem::Operator::*)(mfem::Vector &)  const>(&mfem::Operator::AssembleDiagonal));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::Operator::GetProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::Operator::GetProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:139:28
    t.method("GetProlongation", static_cast<const mfem::Operator * (mfem::Operator::*)()  const>(&mfem::Operator::GetProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::Operator::GetRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::Operator::GetRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:143:28
    t.method("GetRestriction", static_cast<const mfem::Operator * (mfem::Operator::*)()  const>(&mfem::Operator::GetRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::Operator::GetOutputProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::Operator::GetOutputProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:147:28
    t.method("GetOutputProlongation", static_cast<const mfem::Operator * (mfem::Operator::*)()  const>(&mfem::Operator::GetOutputProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::Operator::GetOutputRestrictionTranspose() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::Operator::GetOutputRestrictionTranspose()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:156:28
    t.method("GetOutputRestrictionTranspose", static_cast<const mfem::Operator * (mfem::Operator::*)()  const>(&mfem::Operator::GetOutputRestrictionTranspose));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::Operator::GetOutputRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::Operator::GetOutputRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:160:28
    t.method("GetOutputRestriction", static_cast<const mfem::Operator * (mfem::Operator::*)()  const>(&mfem::Operator::GetOutputRestriction));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::FormLinearSystem(const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::Operator *&, mfem::Vector &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::FormLinearSystem(const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::Operator *&, mfem::Vector &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:195:9
    t.method("FormLinearSystem", static_cast<void (mfem::Operator::*)(const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::Operator *&, mfem::Vector &, mfem::Vector &, int) >(&mfem::Operator::FormLinearSystem));
    t.method("FormLinearSystem", [](mfem::Operator& a, const mfem::Array<int> & arg0, mfem::Vector & arg1, mfem::Vector & arg2, mfem::Operator *& arg3, mfem::Vector & arg4, mfem::Vector & arg5)->void { a.FormLinearSystem(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("FormLinearSystem", [](mfem::Operator* a, const mfem::Array<int> & arg0, mfem::Vector & arg1, mfem::Vector & arg2, mfem::Operator *& arg3, mfem::Vector & arg4, mfem::Vector & arg5)->void { a->FormLinearSystem(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::Operator::FormRectangularLinearSystem(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::Operator *&, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::FormRectangularLinearSystem(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::Operator *&, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:226:9
    t.method("FormRectangularLinearSystem", static_cast<void (mfem::Operator::*)(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::Operator *&, mfem::Vector &, mfem::Vector &) >(&mfem::Operator::FormRectangularLinearSystem));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::RecoverFEMSolution(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::RecoverFEMSolution(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:240:17
    t.method("RecoverFEMSolution", static_cast<void (mfem::Operator::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) >(&mfem::Operator::RecoverFEMSolution));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::FormSystemOperator(const mfem::Array<int> &, mfem::Operator *&) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::FormSystemOperator(const mfem::Array<int> &, mfem::Operator *&)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:247:9
    t.method("FormSystemOperator", static_cast<void (mfem::Operator::*)(const mfem::Array<int> &, mfem::Operator *&) >(&mfem::Operator::FormSystemOperator));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::FormRectangularSystemOperator(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Operator *&) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::FormRectangularSystemOperator(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Operator *&)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:255:9
    t.method("FormRectangularSystemOperator", static_cast<void (mfem::Operator::*)(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Operator *&) >(&mfem::Operator::FormRectangularSystemOperator));

    DEBUG_MSG("Adding wrapper for void mfem::Operator::FormDiscreteOperator(mfem::Operator *&) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Operator::FormDiscreteOperator(mfem::Operator *&)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:270:9
    t.method("FormDiscreteOperator", static_cast<void (mfem::Operator::*)(mfem::Operator *&) >(&mfem::Operator::FormDiscreteOperator));

    DEBUG_MSG("Adding wrapper for mfem::Operator::Type mfem::Operator::GetType() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator::Type mfem::Operator::GetType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:307:9
    t.method("GetType", static_cast<mfem::Operator::Type (mfem::Operator::*)()  const>(&mfem::Operator::GetType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Operator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Operator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Operator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TimeDependentOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TimeDependentOperator> : std::false_type { };
template<> struct SuperType<mfem::TimeDependentOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::TimeDependentOperator
// signature to use in the veto file: mfem::TimeDependentOperator
struct Jlmfem_TimeDependentOperator: public Wrapper {

  Jlmfem_TimeDependentOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TimeDependentOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:316:7
    jlcxx::TypeWrapper<mfem::TimeDependentOperator>  t = jlModule.add_type<mfem::TimeDependentOperator>("mfem!TimeDependentOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TimeDependentOperator>>(new jlcxx::TypeWrapper<mfem::TimeDependentOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentOperator::TimeDependentOperator(int, double, mfem::TimeDependentOperator::Type) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:347:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, double, mfem::TimeDependentOperator::Type>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentOperator::TimeDependentOperator(int, int, double, mfem::TimeDependentOperator::Type) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:353:4
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, double, mfem::TimeDependentOperator::Type>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::TimeDependentOperator::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::TimeDependentOperator::GetTime()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:357:19
    t.method("GetTime", static_cast<double (mfem::TimeDependentOperator::*)()  const>(&mfem::TimeDependentOperator::GetTime));

    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentOperator::SetTime(const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentOperator::SetTime(const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:360:17
    t.method("SetTime", static_cast<void (mfem::TimeDependentOperator::*)(const double) >(&mfem::TimeDependentOperator::SetTime));

    DEBUG_MSG("Adding wrapper for bool mfem::TimeDependentOperator::isExplicit() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::TimeDependentOperator::isExplicit()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:363:9
    t.method("isExplicit", static_cast<bool (mfem::TimeDependentOperator::*)()  const>(&mfem::TimeDependentOperator::isExplicit));

    DEBUG_MSG("Adding wrapper for bool mfem::TimeDependentOperator::isImplicit() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::TimeDependentOperator::isImplicit()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:365:9
    t.method("isImplicit", static_cast<bool (mfem::TimeDependentOperator::*)()  const>(&mfem::TimeDependentOperator::isImplicit));

    DEBUG_MSG("Adding wrapper for bool mfem::TimeDependentOperator::isHomogeneous() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::TimeDependentOperator::isHomogeneous()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:367:9
    t.method("isHomogeneous", static_cast<bool (mfem::TimeDependentOperator::*)()  const>(&mfem::TimeDependentOperator::isHomogeneous));

    DEBUG_MSG("Adding wrapper for mfem::TimeDependentOperator::EvalMode mfem::TimeDependentOperator::GetEvalMode() (" __HERE__ ")");
    // signature to use in the veto list: mfem::TimeDependentOperator::EvalMode mfem::TimeDependentOperator::GetEvalMode()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:370:13
    t.method("GetEvalMode", static_cast<mfem::TimeDependentOperator::EvalMode (mfem::TimeDependentOperator::*)()  const>(&mfem::TimeDependentOperator::GetEvalMode));

    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentOperator::SetEvalMode(const mfem::TimeDependentOperator::EvalMode) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentOperator::SetEvalMode(const mfem::TimeDependentOperator::EvalMode)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:383:17
    t.method("SetEvalMode", static_cast<void (mfem::TimeDependentOperator::*)(const mfem::TimeDependentOperator::EvalMode) >(&mfem::TimeDependentOperator::SetEvalMode));

    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentOperator::ExplicitMult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentOperator::ExplicitMult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:391:17
    t.method("ExplicitMult", static_cast<void (mfem::TimeDependentOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TimeDependentOperator::ExplicitMult));

    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentOperator::ImplicitMult(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentOperator::ImplicitMult(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:398:17
    t.method("ImplicitMult", static_cast<void (mfem::TimeDependentOperator::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)  const>(&mfem::TimeDependentOperator::ImplicitMult));

    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:403:17
    t.method("Mult", static_cast<void (mfem::TimeDependentOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TimeDependentOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentOperator::ImplicitSolve(const double, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentOperator::ImplicitSolve(const double, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:421:17
    t.method("ImplicitSolve", static_cast<void (mfem::TimeDependentOperator::*)(const double, const mfem::Vector &, mfem::Vector &) >(&mfem::TimeDependentOperator::ImplicitSolve));

    DEBUG_MSG("Adding wrapper for mfem::Operator & mfem::TimeDependentOperator::GetImplicitGradient(const mfem::Vector &, const mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator & mfem::TimeDependentOperator::GetImplicitGradient(const mfem::Vector &, const mfem::Vector &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:428:22
    t.method("GetImplicitGradient", static_cast<mfem::Operator & (mfem::TimeDependentOperator::*)(const mfem::Vector &, const mfem::Vector &, double)  const>(&mfem::TimeDependentOperator::GetImplicitGradient));

    DEBUG_MSG("Adding wrapper for mfem::Operator & mfem::TimeDependentOperator::GetExplicitGradient(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator & mfem::TimeDependentOperator::GetExplicitGradient(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:436:22
    t.method("GetExplicitGradient", static_cast<mfem::Operator & (mfem::TimeDependentOperator::*)(const mfem::Vector &)  const>(&mfem::TimeDependentOperator::GetExplicitGradient));

    DEBUG_MSG("Adding wrapper for int mfem::TimeDependentOperator::SUNImplicitSetup(const mfem::Vector &, const mfem::Vector &, int, int *, double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::TimeDependentOperator::SUNImplicitSetup(const mfem::Vector &, const mfem::Vector &, int, int *, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:451:16
    t.method("SUNImplicitSetup", static_cast<int (mfem::TimeDependentOperator::*)(const mfem::Vector &, const mfem::Vector &, int, int *, double) >(&mfem::TimeDependentOperator::SUNImplicitSetup));

    DEBUG_MSG("Adding wrapper for int mfem::TimeDependentOperator::SUNImplicitSolve(const mfem::Vector &, mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::TimeDependentOperator::SUNImplicitSolve(const mfem::Vector &, mfem::Vector &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:465:16
    t.method("SUNImplicitSolve", static_cast<int (mfem::TimeDependentOperator::*)(const mfem::Vector &, mfem::Vector &, double) >(&mfem::TimeDependentOperator::SUNImplicitSolve));

    DEBUG_MSG("Adding wrapper for int mfem::TimeDependentOperator::SUNMassSetup() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::TimeDependentOperator::SUNMassSetup()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:473:16
    t.method("SUNMassSetup", static_cast<int (mfem::TimeDependentOperator::*)() >(&mfem::TimeDependentOperator::SUNMassSetup));

    DEBUG_MSG("Adding wrapper for int mfem::TimeDependentOperator::SUNMassSolve(const mfem::Vector &, mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::TimeDependentOperator::SUNMassSolve(const mfem::Vector &, mfem::Vector &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:486:16
    t.method("SUNMassSolve", static_cast<int (mfem::TimeDependentOperator::*)(const mfem::Vector &, mfem::Vector &, double) >(&mfem::TimeDependentOperator::SUNMassSolve));

    DEBUG_MSG("Adding wrapper for int mfem::TimeDependentOperator::SUNMassMult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::TimeDependentOperator::SUNMassMult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:497:16
    t.method("SUNMassMult", static_cast<int (mfem::TimeDependentOperator::*)(const mfem::Vector &, mfem::Vector &) >(&mfem::TimeDependentOperator::SUNMassMult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TimeDependentOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TimeDependentOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TimeDependentOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TimeDependentAdjointOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TimeDependentAdjointOperator> : std::false_type { };
template<> struct SuperType<mfem::TimeDependentAdjointOperator> { typedef mfem::TimeDependentOperator type; };
}

// Class generating the wrapper for type mfem::TimeDependentAdjointOperator
// signature to use in the veto file: mfem::TimeDependentAdjointOperator
struct Jlmfem_TimeDependentAdjointOperator: public Wrapper {

  Jlmfem_TimeDependentAdjointOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TimeDependentAdjointOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:505:7
    jlcxx::TypeWrapper<mfem::TimeDependentAdjointOperator>  t = jlModule.add_type<mfem::TimeDependentAdjointOperator>("mfem!TimeDependentAdjointOperator",
      jlcxx::julia_base_type<mfem::TimeDependentOperator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TimeDependentAdjointOperator>>(new jlcxx::TypeWrapper<mfem::TimeDependentAdjointOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentAdjointOperator::QuadratureIntegration(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentAdjointOperator::QuadratureIntegration(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:553:17
    t.method("QuadratureIntegration", static_cast<void (mfem::TimeDependentAdjointOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TimeDependentAdjointOperator::QuadratureIntegration));

    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentAdjointOperator::AdjointRateMult(const mfem::Vector &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentAdjointOperator::AdjointRateMult(const mfem::Vector &, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:562:17
    t.method("AdjointRateMult", static_cast<void (mfem::TimeDependentAdjointOperator::*)(const mfem::Vector &, mfem::Vector &, mfem::Vector &)  const>(&mfem::TimeDependentAdjointOperator::AdjointRateMult));

    DEBUG_MSG("Adding wrapper for void mfem::TimeDependentAdjointOperator::QuadratureSensitivityMult(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TimeDependentAdjointOperator::QuadratureSensitivityMult(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:574:17
    t.method("QuadratureSensitivityMult", static_cast<void (mfem::TimeDependentAdjointOperator::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)  const>(&mfem::TimeDependentAdjointOperator::QuadratureSensitivityMult));

    DEBUG_MSG("Adding wrapper for int mfem::TimeDependentAdjointOperator::SUNImplicitSetupB(const double, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, int, int *, double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::TimeDependentAdjointOperator::SUNImplicitSetupB(const double, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, int, int *, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:593:16
    t.method("SUNImplicitSetupB", static_cast<int (mfem::TimeDependentAdjointOperator::*)(const double, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, int, int *, double) >(&mfem::TimeDependentAdjointOperator::SUNImplicitSetupB));

    DEBUG_MSG("Adding wrapper for int mfem::TimeDependentAdjointOperator::SUNImplicitSolveB(mfem::Vector &, const mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::TimeDependentAdjointOperator::SUNImplicitSolveB(mfem::Vector &, const mfem::Vector &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:613:16
    t.method("SUNImplicitSolveB", static_cast<int (mfem::TimeDependentAdjointOperator::*)(mfem::Vector &, const mfem::Vector &, double) >(&mfem::TimeDependentAdjointOperator::SUNImplicitSolveB));

    DEBUG_MSG("Adding wrapper for int mfem::TimeDependentAdjointOperator::GetAdjointHeight() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::TimeDependentAdjointOperator::GetAdjointHeight()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:621:8
    t.method("GetAdjointHeight", static_cast<int (mfem::TimeDependentAdjointOperator::*)() >(&mfem::TimeDependentAdjointOperator::GetAdjointHeight));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TimeDependentAdjointOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TimeDependentAdjointOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TimeDependentAdjointOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SecondOrderTimeDependentOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SecondOrderTimeDependentOperator> : std::false_type { };
template<> struct SuperType<mfem::SecondOrderTimeDependentOperator> { typedef mfem::TimeDependentOperator type; };
}

// Class generating the wrapper for type mfem::SecondOrderTimeDependentOperator
// signature to use in the veto file: mfem::SecondOrderTimeDependentOperator
struct Jlmfem_SecondOrderTimeDependentOperator: public Wrapper {

  Jlmfem_SecondOrderTimeDependentOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SecondOrderTimeDependentOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:634:7
    jlcxx::TypeWrapper<mfem::SecondOrderTimeDependentOperator>  t = jlModule.add_type<mfem::SecondOrderTimeDependentOperator>("mfem!SecondOrderTimeDependentOperator",
      jlcxx::julia_base_type<mfem::TimeDependentOperator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SecondOrderTimeDependentOperator>>(new jlcxx::TypeWrapper<mfem::SecondOrderTimeDependentOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SecondOrderTimeDependentOperator::SecondOrderTimeDependentOperator(int, double, mfem::TimeDependentOperator::Type) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:639:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, double, mfem::TimeDependentOperator::Type>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SecondOrderTimeDependentOperator::SecondOrderTimeDependentOperator(int, int, double, mfem::TimeDependentOperator::Type) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:645:4
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, double, mfem::TimeDependentOperator::Type>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::SecondOrderTimeDependentOperator::Mult(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SecondOrderTimeDependentOperator::Mult(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:654:17
    t.method("Mult", static_cast<void (mfem::SecondOrderTimeDependentOperator::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)  const>(&mfem::SecondOrderTimeDependentOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::SecondOrderTimeDependentOperator::ImplicitSolve(const double, const double, const mfem::Vector &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SecondOrderTimeDependentOperator::ImplicitSolve(const double, const double, const mfem::Vector &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:673:17
    t.method("ImplicitSolve", static_cast<void (mfem::SecondOrderTimeDependentOperator::*)(const double, const double, const mfem::Vector &, const mfem::Vector &, mfem::Vector &) >(&mfem::SecondOrderTimeDependentOperator::ImplicitSolve));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SecondOrderTimeDependentOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SecondOrderTimeDependentOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SecondOrderTimeDependentOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Solver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Solver> : std::false_type { };
template<> struct SuperType<mfem::Solver> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::Solver
// signature to use in the veto file: mfem::Solver
struct Jlmfem_Solver: public Wrapper {

  Jlmfem_Solver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Solver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:682:7
    jlcxx::TypeWrapper<mfem::Solver>  t = jlModule.add_type<mfem::Solver>("mfem!Solver",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Solver>>(new jlcxx::TypeWrapper<mfem::Solver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;



    DEBUG_MSG("Adding wrapper for void mfem::Solver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Solver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:700:17
    t.method("SetOperator", static_cast<void (mfem::Solver::*)(const mfem::Operator &) >(&mfem::Solver::SetOperator));

    DEBUG_MSG("Adding iterative_mode methods  to provide read access to the field iterative_mode (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:686:9
    // signature to use in the veto list: mfem::Solver::iterative_mode
    t.method("iterative_mode", [](const mfem::Solver& a) -> bool { return a.iterative_mode; });
    t.method("iterative_mode", [](mfem::Solver& a) -> bool { return a.iterative_mode; });
    t.method("iterative_mode", [](const mfem::Solver* a) -> bool { return a->iterative_mode; });
    t.method("iterative_mode", [](mfem::Solver* a) -> bool { return a->iterative_mode; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:686:9
    // signature to use in the veto list: mfem::Solver::iterative_mode
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding iterative_mode! methods to provide write access to the field iterative_mode (" __HERE__ ")");
    t.method("iterative_mode!", [](mfem::Solver& a, bool val) -> bool { return a.iterative_mode = val; });

    DEBUG_MSG("Adding iterative_mode! methods to provide write access to the field iterative_mode (" __HERE__ ")");
    t.method("iterative_mode!", [](mfem::Solver* a, bool val) -> bool { return a->iterative_mode = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Solver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Solver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Solver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IdentityOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IdentityOperator> : std::false_type { };
template<> struct SuperType<mfem::IdentityOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::IdentityOperator
// signature to use in the veto file: mfem::IdentityOperator
struct Jlmfem_IdentityOperator: public Wrapper {

  Jlmfem_IdentityOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IdentityOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:705:7
    jlcxx::TypeWrapper<mfem::IdentityOperator>  t = jlModule.add_type<mfem::IdentityOperator>("mfem!IdentityOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IdentityOperator>>(new jlcxx::TypeWrapper<mfem::IdentityOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::IdentityOperator::IdentityOperator(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:709:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::IdentityOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IdentityOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:712:17
    t.method("Mult", static_cast<void (mfem::IdentityOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::IdentityOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::IdentityOperator::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IdentityOperator::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:715:17
    t.method("MultTranspose", static_cast<void (mfem::IdentityOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::IdentityOperator::MultTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IdentityOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IdentityOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IdentityOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ScaledOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ScaledOperator> : std::false_type { };
template<> struct SuperType<mfem::ScaledOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::ScaledOperator
// signature to use in the veto file: mfem::ScaledOperator
struct Jlmfem_ScaledOperator: public Wrapper {

  Jlmfem_ScaledOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ScaledOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:726:7
    jlcxx::TypeWrapper<mfem::ScaledOperator>  t = jlModule.add_type<mfem::ScaledOperator>("mfem!ScaledOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ScaledOperator>>(new jlcxx::TypeWrapper<mfem::ScaledOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ScaledOperator::ScaledOperator(const mfem::Operator *, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:734:13
    t.constructor<const mfem::Operator *, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ScaledOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScaledOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:738:17
    t.method("Mult", static_cast<void (mfem::ScaledOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ScaledOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::ScaledOperator::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScaledOperator::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:742:17
    t.method("MultTranspose", static_cast<void (mfem::ScaledOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ScaledOperator::MultTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ScaledOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ScaledOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ScaledOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TransposeOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TransposeOperator> : std::false_type { };
template<> struct SuperType<mfem::TransposeOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::TransposeOperator
// signature to use in the veto file: mfem::TransposeOperator
struct Jlmfem_TransposeOperator: public Wrapper {

  Jlmfem_TransposeOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TransposeOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:749:7
    jlcxx::TypeWrapper<mfem::TransposeOperator>  t = jlModule.add_type<mfem::TransposeOperator>("mfem!TransposeOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TransposeOperator>>(new jlcxx::TypeWrapper<mfem::TransposeOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::TransposeOperator::TransposeOperator(const mfem::Operator *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:756:4
    t.constructor<const mfem::Operator *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::TransposeOperator::TransposeOperator(const mfem::Operator &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:760:4
    t.constructor<const mfem::Operator &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::TransposeOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:764:17
    t.method("Mult", static_cast<void (mfem::TransposeOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TransposeOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeOperator::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeOperator::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:768:17
    t.method("MultTranspose", static_cast<void (mfem::TransposeOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TransposeOperator::MultTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TransposeOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TransposeOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TransposeOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ProductOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ProductOperator> : std::false_type { };
template<> struct SuperType<mfem::ProductOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::ProductOperator
// signature to use in the veto file: mfem::ProductOperator
struct Jlmfem_ProductOperator: public Wrapper {

  Jlmfem_ProductOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ProductOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:774:7
    jlcxx::TypeWrapper<mfem::ProductOperator>  t = jlModule.add_type<mfem::ProductOperator>("mfem!ProductOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductOperator>>(new jlcxx::TypeWrapper<mfem::ProductOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ProductOperator::ProductOperator(const mfem::Operator *, const mfem::Operator *, bool, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:781:4
    t.constructor<const mfem::Operator *, const mfem::Operator *, bool, bool>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ProductOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:783:17
    t.method("Mult", static_cast<void (mfem::ProductOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ProductOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::ProductOperator::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductOperator::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:786:17
    t.method("MultTranspose", static_cast<void (mfem::ProductOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ProductOperator::MultTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ProductOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ProductOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RAPOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RAPOperator> : std::false_type { };
template<> struct SuperType<mfem::RAPOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::RAPOperator
// signature to use in the veto file: mfem::RAPOperator
struct Jlmfem_RAPOperator: public Wrapper {

  Jlmfem_RAPOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RAPOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:794:7
    jlcxx::TypeWrapper<mfem::RAPOperator>  t = jlModule.add_type<mfem::RAPOperator>("mfem!RAPOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RAPOperator>>(new jlcxx::TypeWrapper<mfem::RAPOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RAPOperator::RAPOperator(const mfem::Operator &, const mfem::Operator &, const mfem::Operator &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:806:4
    t.constructor<const mfem::Operator &, const mfem::Operator &, const mfem::Operator &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::MemoryClass mfem::RAPOperator::GetMemoryClass() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MemoryClass mfem::RAPOperator::GetMemoryClass()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:808:24
    t.method("GetMemoryClass", static_cast<mfem::MemoryClass (mfem::RAPOperator::*)()  const>(&mfem::RAPOperator::GetMemoryClass));

    DEBUG_MSG("Adding wrapper for void mfem::RAPOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RAPOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:811:17
    t.method("Mult", static_cast<void (mfem::RAPOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::RAPOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::RAPOperator::AssembleDiagonal(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RAPOperator::AssembleDiagonal(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:821:17
    t.method("AssembleDiagonal", static_cast<void (mfem::RAPOperator::*)(mfem::Vector &)  const>(&mfem::RAPOperator::AssembleDiagonal));

    DEBUG_MSG("Adding wrapper for void mfem::RAPOperator::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RAPOperator::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:832:17
    t.method("MultTranspose", static_cast<void (mfem::RAPOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::RAPOperator::MultTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RAPOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RAPOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RAPOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TripleProductOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TripleProductOperator> : std::false_type { };
template<> struct SuperType<mfem::TripleProductOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::TripleProductOperator
// signature to use in the veto file: mfem::TripleProductOperator
struct Jlmfem_TripleProductOperator: public Wrapper {

  Jlmfem_TripleProductOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TripleProductOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:838:7
    jlcxx::TypeWrapper<mfem::TripleProductOperator>  t = jlModule.add_type<mfem::TripleProductOperator>("mfem!TripleProductOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TripleProductOperator>>(new jlcxx::TypeWrapper<mfem::TripleProductOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::TripleProductOperator::TripleProductOperator(const mfem::Operator *, const mfem::Operator *, const mfem::Operator *, bool, bool, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:848:4
    t.constructor<const mfem::Operator *, const mfem::Operator *, const mfem::Operator *, bool, bool, bool>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::MemoryClass mfem::TripleProductOperator::GetMemoryClass() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MemoryClass mfem::TripleProductOperator::GetMemoryClass()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:851:24
    t.method("GetMemoryClass", static_cast<mfem::MemoryClass (mfem::TripleProductOperator::*)()  const>(&mfem::TripleProductOperator::GetMemoryClass));

    DEBUG_MSG("Adding wrapper for void mfem::TripleProductOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TripleProductOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:853:17
    t.method("Mult", static_cast<void (mfem::TripleProductOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TripleProductOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::TripleProductOperator::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TripleProductOperator::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:856:17
    t.method("MultTranspose", static_cast<void (mfem::TripleProductOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TripleProductOperator::MultTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TripleProductOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TripleProductOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TripleProductOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ConstrainedOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ConstrainedOperator> : std::false_type { };
template<> struct SuperType<mfem::ConstrainedOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::ConstrainedOperator
// signature to use in the veto file: mfem::ConstrainedOperator
struct Jlmfem_ConstrainedOperator: public Wrapper {

  Jlmfem_ConstrainedOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ConstrainedOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:872:7
    jlcxx::TypeWrapper<mfem::ConstrainedOperator>  t = jlModule.add_type<mfem::ConstrainedOperator>("mfem!ConstrainedOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ConstrainedOperator>>(new jlcxx::TypeWrapper<mfem::ConstrainedOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ConstrainedOperator::ConstrainedOperator(mfem::Operator *, const mfem::Array<int> &, bool, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:891:4
    t.constructor<mfem::Operator *, const mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Operator *, const mfem::Array<int> &, bool>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Operator *, const mfem::Array<int> &, bool, mfem::Operator::DiagonalPolicy>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::MemoryClass mfem::ConstrainedOperator::GetMemoryClass() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MemoryClass mfem::ConstrainedOperator::GetMemoryClass()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:895:24
    t.method("GetMemoryClass", static_cast<mfem::MemoryClass (mfem::ConstrainedOperator::*)()  const>(&mfem::ConstrainedOperator::GetMemoryClass));

    DEBUG_MSG("Adding wrapper for void mfem::ConstrainedOperator::SetDiagonalPolicy(const mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConstrainedOperator::SetDiagonalPolicy(const mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:898:9
    t.method("SetDiagonalPolicy", static_cast<void (mfem::ConstrainedOperator::*)(const mfem::Operator::DiagonalPolicy) >(&mfem::ConstrainedOperator::SetDiagonalPolicy));

    DEBUG_MSG("Adding wrapper for void mfem::ConstrainedOperator::AssembleDiagonal(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConstrainedOperator::AssembleDiagonal(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:902:17
    t.method("AssembleDiagonal", static_cast<void (mfem::ConstrainedOperator::*)(mfem::Vector &)  const>(&mfem::ConstrainedOperator::AssembleDiagonal));

    DEBUG_MSG("Adding wrapper for void mfem::ConstrainedOperator::EliminateRHS(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConstrainedOperator::EliminateRHS(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:915:9
    t.method("EliminateRHS", static_cast<void (mfem::ConstrainedOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ConstrainedOperator::EliminateRHS));

    DEBUG_MSG("Adding wrapper for void mfem::ConstrainedOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConstrainedOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:925:17
    t.method("Mult", static_cast<void (mfem::ConstrainedOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ConstrainedOperator::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ConstrainedOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ConstrainedOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ConstrainedOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RectangularConstrainedOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RectangularConstrainedOperator> : std::false_type { };
template<> struct SuperType<mfem::RectangularConstrainedOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::RectangularConstrainedOperator
// signature to use in the veto file: mfem::RectangularConstrainedOperator
struct Jlmfem_RectangularConstrainedOperator: public Wrapper {

  Jlmfem_RectangularConstrainedOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RectangularConstrainedOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:938:7
    jlcxx::TypeWrapper<mfem::RectangularConstrainedOperator>  t = jlModule.add_type<mfem::RectangularConstrainedOperator>("mfem!RectangularConstrainedOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RectangularConstrainedOperator>>(new jlcxx::TypeWrapper<mfem::RectangularConstrainedOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RectangularConstrainedOperator::RectangularConstrainedOperator(mfem::Operator *, const mfem::Array<int> &, const mfem::Array<int> &, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:955:4
    t.constructor<mfem::Operator *, const mfem::Array<int> &, const mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Operator *, const mfem::Array<int> &, const mfem::Array<int> &, bool>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::MemoryClass mfem::RectangularConstrainedOperator::GetMemoryClass() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MemoryClass mfem::RectangularConstrainedOperator::GetMemoryClass()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:958:24
    t.method("GetMemoryClass", static_cast<mfem::MemoryClass (mfem::RectangularConstrainedOperator::*)()  const>(&mfem::RectangularConstrainedOperator::GetMemoryClass));

    DEBUG_MSG("Adding wrapper for void mfem::RectangularConstrainedOperator::EliminateRHS(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RectangularConstrainedOperator::EliminateRHS(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:969:9
    t.method("EliminateRHS", static_cast<void (mfem::RectangularConstrainedOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::RectangularConstrainedOperator::EliminateRHS));

    DEBUG_MSG("Adding wrapper for void mfem::RectangularConstrainedOperator::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RectangularConstrainedOperator::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:979:17
    t.method("Mult", static_cast<void (mfem::RectangularConstrainedOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::RectangularConstrainedOperator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::RectangularConstrainedOperator::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RectangularConstrainedOperator::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:980:17
    t.method("MultTranspose", static_cast<void (mfem::RectangularConstrainedOperator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::RectangularConstrainedOperator::MultTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RectangularConstrainedOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RectangularConstrainedOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RectangularConstrainedOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PowerMethod> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PowerMethod> : std::false_type { };
}

// Class generating the wrapper for type mfem::PowerMethod
// signature to use in the veto file: mfem::PowerMethod
struct Jlmfem_PowerMethod: public Wrapper {

  Jlmfem_PowerMethod(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PowerMethod (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:986:7
    jlcxx::TypeWrapper<mfem::PowerMethod>  t = jlModule.add_type<mfem::PowerMethod>("mfem!PowerMethod");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PowerMethod>>(new jlcxx::TypeWrapper<mfem::PowerMethod>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::PowerMethod::EstimateLargestEigenvalue(mfem::Operator &, mfem::Vector &, int, double, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PowerMethod::EstimateLargestEigenvalue(mfem::Operator &, mfem::Vector &, int, double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:1012:11
    t.method("EstimateLargestEigenvalue", static_cast<double (mfem::PowerMethod::*)(mfem::Operator &, mfem::Vector &, int, double, int) >(&mfem::PowerMethod::EstimateLargestEigenvalue));
    t.method("EstimateLargestEigenvalue", [](mfem::PowerMethod& a, mfem::Operator & arg0, mfem::Vector & arg1)->double { return a.EstimateLargestEigenvalue(arg0, arg1); });
    t.method("EstimateLargestEigenvalue", [](mfem::PowerMethod& a, mfem::Operator & arg0, mfem::Vector & arg1, int arg2)->double { return a.EstimateLargestEigenvalue(arg0, arg1, arg2); });
    t.method("EstimateLargestEigenvalue", [](mfem::PowerMethod& a, mfem::Operator & arg0, mfem::Vector & arg1, int arg2, double arg3)->double { return a.EstimateLargestEigenvalue(arg0, arg1, arg2, arg3); });
    t.method("EstimateLargestEigenvalue", [](mfem::PowerMethod* a, mfem::Operator & arg0, mfem::Vector & arg1)->double { return a->EstimateLargestEigenvalue(arg0, arg1); });
    t.method("EstimateLargestEigenvalue", [](mfem::PowerMethod* a, mfem::Operator & arg0, mfem::Vector & arg1, int arg2)->double { return a->EstimateLargestEigenvalue(arg0, arg1, arg2); });
    t.method("EstimateLargestEigenvalue", [](mfem::PowerMethod* a, mfem::Operator & arg0, mfem::Vector & arg1, int arg2, double arg3)->double { return a->EstimateLargestEigenvalue(arg0, arg1, arg2, arg3); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PowerMethod>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PowerMethod(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PowerMethod(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Matrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Matrix> : std::false_type { };
template<> struct SuperType<mfem::Matrix> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::Matrix
// signature to use in the veto file: mfem::Matrix
struct Jlmfem_Matrix: public Wrapper {

  Jlmfem_Matrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Matrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:27:7
    jlcxx::TypeWrapper<mfem::Matrix>  t = jlModule.add_type<mfem::Matrix>("mfem!Matrix",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Matrix>>(new jlcxx::TypeWrapper<mfem::Matrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;



    DEBUG_MSG("Adding wrapper for bool mfem::Matrix::IsSquare() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Matrix::IsSquare()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:39:9
    t.method("IsSquare", static_cast<bool (mfem::Matrix::*)()  const>(&mfem::Matrix::IsSquare));

    DEBUG_MSG("Adding wrapper for double & mfem::Matrix::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::Matrix::Elem(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:42:20
    t.method("Elem", static_cast<double & (mfem::Matrix::*)(int, int) >(&mfem::Matrix::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::Matrix::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::Matrix::Elem(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:45:26
    t.method("Elem", static_cast<const double & (mfem::Matrix::*)(int, int)  const>(&mfem::Matrix::Elem));

    DEBUG_MSG("Adding wrapper for mfem::MatrixInverse * mfem::Matrix::Inverse() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixInverse * mfem::Matrix::Inverse()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:48:27
    t.method("Inverse", static_cast<mfem::MatrixInverse * (mfem::Matrix::*)()  const>(&mfem::Matrix::Inverse));

    DEBUG_MSG("Adding wrapper for void mfem::Matrix::Finalize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Matrix::Finalize(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:51:17
    t.method("Finalize", static_cast<void (mfem::Matrix::*)(int) >(&mfem::Matrix::Finalize));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Matrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Matrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Matrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixInverse> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixInverse> : std::false_type { };
template<> struct SuperType<mfem::MatrixInverse> { typedef mfem::Solver type; };
}

// Class generating the wrapper for type mfem::MatrixInverse
// signature to use in the veto file: mfem::MatrixInverse
struct Jlmfem_MatrixInverse: public Wrapper {

  Jlmfem_MatrixInverse(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixInverse (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:62:7
    jlcxx::TypeWrapper<mfem::MatrixInverse>  t = jlModule.add_type<mfem::MatrixInverse>("mfem!MatrixInverse",
      jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixInverse>>(new jlcxx::TypeWrapper<mfem::MatrixInverse>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixInverse>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixInverse(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixInverse(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::AbstractSparseMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::AbstractSparseMatrix> : std::false_type { };
template<> struct SuperType<mfem::AbstractSparseMatrix> { typedef mfem::Matrix type; };
}

// Class generating the wrapper for type mfem::AbstractSparseMatrix
// signature to use in the veto file: mfem::AbstractSparseMatrix
struct Jlmfem_AbstractSparseMatrix: public Wrapper {

  Jlmfem_AbstractSparseMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::AbstractSparseMatrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:73:7
    jlcxx::TypeWrapper<mfem::AbstractSparseMatrix>  t = jlModule.add_type<mfem::AbstractSparseMatrix>("mfem!AbstractSparseMatrix",
      jlcxx::julia_base_type<mfem::Matrix>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::AbstractSparseMatrix>>(new jlcxx::TypeWrapper<mfem::AbstractSparseMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;



    DEBUG_MSG("Adding wrapper for int mfem::AbstractSparseMatrix::NumNonZeroElems() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::AbstractSparseMatrix::NumNonZeroElems()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:83:16
    t.method("NumNonZeroElems", static_cast<int (mfem::AbstractSparseMatrix::*)()  const>(&mfem::AbstractSparseMatrix::NumNonZeroElems));

    DEBUG_MSG("Adding wrapper for int mfem::AbstractSparseMatrix::GetRow(const int, mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::AbstractSparseMatrix::GetRow(const int, mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:89:16
    t.method("GetRow", static_cast<int (mfem::AbstractSparseMatrix::*)(const int, mfem::Array<int> &, mfem::Vector &)  const>(&mfem::AbstractSparseMatrix::GetRow));

    DEBUG_MSG("Adding wrapper for void mfem::AbstractSparseMatrix::EliminateZeroRows(const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::AbstractSparseMatrix::EliminateZeroRows(const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:96:17
    t.method("EliminateZeroRows", static_cast<void (mfem::AbstractSparseMatrix::*)(const double) >(&mfem::AbstractSparseMatrix::EliminateZeroRows));
    t.method("EliminateZeroRows", [](mfem::AbstractSparseMatrix& a)->void { a.EliminateZeroRows(); });
    t.method("EliminateZeroRows", [](mfem::AbstractSparseMatrix* a)->void { a->EliminateZeroRows(); });

    DEBUG_MSG("Adding wrapper for void mfem::AbstractSparseMatrix::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::AbstractSparseMatrix::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:99:17
    t.method("Mult", static_cast<void (mfem::AbstractSparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::AbstractSparseMatrix::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::AbstractSparseMatrix::AddMult(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::AbstractSparseMatrix::AddMult(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:101:17
    t.method("AddMult", static_cast<void (mfem::AbstractSparseMatrix::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::AbstractSparseMatrix::AddMult));
    t.method("AddMult", [](mfem::AbstractSparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMult(arg0, arg1); });
    t.method("AddMult", [](mfem::AbstractSparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::AbstractSparseMatrix::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::AbstractSparseMatrix::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:104:17
    t.method("MultTranspose", static_cast<void (mfem::AbstractSparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::AbstractSparseMatrix::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::AbstractSparseMatrix::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::AbstractSparseMatrix::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/matrix.hpp:106:17
    t.method("AddMultTranspose", static_cast<void (mfem::AbstractSparseMatrix::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::AbstractSparseMatrix::AddMultTranspose));
    t.method("AddMultTranspose", [](mfem::AbstractSparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMultTranspose(arg0, arg1); });
    t.method("AddMultTranspose", [](mfem::AbstractSparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMultTranspose(arg0, arg1); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::AbstractSparseMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_AbstractSparseMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_AbstractSparseMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RowNode> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RowNode> : std::false_type { };
}

// Class generating the wrapper for type mfem::RowNode
// signature to use in the veto file: mfem::RowNode
struct Jlmfem_RowNode: public Wrapper {

  Jlmfem_RowNode(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RowNode (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:41:4
    jlcxx::TypeWrapper<mfem::RowNode>  t = jlModule.add_type<mfem::RowNode>("mfem!RowNode");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RowNode>>(new jlcxx::TypeWrapper<mfem::RowNode>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding Value methods  to provide read access to the field Value (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:44:11
    // signature to use in the veto list: mfem::RowNode::Value
    t.method("Value", [](const mfem::RowNode& a) -> double { return a.Value; });
    t.method("Value", [](mfem::RowNode& a) -> double { return a.Value; });
    t.method("Value", [](const mfem::RowNode* a) -> double { return a->Value; });
    t.method("Value", [](mfem::RowNode* a) -> double { return a->Value; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:44:11
    // signature to use in the veto list: mfem::RowNode::Value
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Value! methods to provide write access to the field Value (" __HERE__ ")");
    t.method("Value!", [](mfem::RowNode& a, double val) -> double { return a.Value = val; });

    DEBUG_MSG("Adding Value! methods to provide write access to the field Value (" __HERE__ ")");
    t.method("Value!", [](mfem::RowNode* a, double val) -> double { return a->Value = val; });

    DEBUG_MSG("Adding Prev methods  to provide read access to the field Prev (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:45:13
    // signature to use in the veto list: mfem::RowNode::Prev
    t.method("Prev", [](const mfem::RowNode& a) -> mfem::RowNode * { return a.Prev; });
    t.method("Prev", [](mfem::RowNode& a) -> mfem::RowNode * { return a.Prev; });
    t.method("Prev", [](const mfem::RowNode* a) -> mfem::RowNode * { return a->Prev; });
    t.method("Prev", [](mfem::RowNode* a) -> mfem::RowNode * { return a->Prev; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:45:13
    // signature to use in the veto list: mfem::RowNode::Prev
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Prev! methods to provide write access to the field Prev (" __HERE__ ")");
    t.method("Prev!", [](mfem::RowNode& a, mfem::RowNode * val) -> mfem::RowNode * { return a.Prev = val; });

    DEBUG_MSG("Adding Prev! methods to provide write access to the field Prev (" __HERE__ ")");
    t.method("Prev!", [](mfem::RowNode* a, mfem::RowNode * val) -> mfem::RowNode * { return a->Prev = val; });

    DEBUG_MSG("Adding Column methods  to provide read access to the field Column (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:46:8
    // signature to use in the veto list: mfem::RowNode::Column
    t.method("Column", [](const mfem::RowNode& a) -> int { return a.Column; });
    t.method("Column", [](mfem::RowNode& a) -> int { return a.Column; });
    t.method("Column", [](const mfem::RowNode* a) -> int { return a->Column; });
    t.method("Column", [](mfem::RowNode* a) -> int { return a->Column; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:46:8
    // signature to use in the veto list: mfem::RowNode::Column
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding Column! methods to provide write access to the field Column (" __HERE__ ")");
    t.method("Column!", [](mfem::RowNode& a, int val) -> int { return a.Column = val; });

    DEBUG_MSG("Adding Column! methods to provide write access to the field Column (" __HERE__ ")");
    t.method("Column!", [](mfem::RowNode* a, int val) -> int { return a->Column = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RowNode>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RowNode(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RowNode(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SparseMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SparseMatrix> : std::false_type { };
template<> struct SuperType<mfem::SparseMatrix> { typedef mfem::AbstractSparseMatrix type; };
}

// Class generating the wrapper for type mfem::SparseMatrix
// signature to use in the veto file: mfem::SparseMatrix
struct Jlmfem_SparseMatrix: public Wrapper {

  Jlmfem_SparseMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SparseMatrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:50:7
    jlcxx::TypeWrapper<mfem::SparseMatrix>  t = jlModule.add_type<mfem::SparseMatrix>("mfem!SparseMatrix",
      jlcxx::julia_base_type<mfem::AbstractSparseMatrix>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SparseMatrix>>(new jlcxx::TypeWrapper<mfem::SparseMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:143:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(int *, int *, double *, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:147:4
    t.constructor<int *, int *, double *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(int *, int *, double *, int, int, bool, bool, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:154:4
    t.constructor<int *, int *, double *, int, int, bool, bool, bool>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(int, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:161:4
    t.constructor<int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(const mfem::SparseMatrix &, bool, mfem::MemoryType) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:171:4
    t.constructor<const mfem::SparseMatrix &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::SparseMatrix &, bool>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::SparseMatrix &, bool, mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SparseMatrix(const mfem::Vector &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:175:4
    t.constructor<const mfem::Vector &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::OverrideSize(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::OverrideSize(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:184:9
    t.method("OverrideSize", static_cast<void (mfem::SparseMatrix::*)(int, int) >(&mfem::SparseMatrix::OverrideSize));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::UseGPUSparse(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::UseGPUSparse(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:191:9
    t.method("UseGPUSparse", static_cast<void (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::UseGPUSparse));
    t.method("UseGPUSparse", [](mfem::SparseMatrix& a)->void { a.UseGPUSparse(); });
    t.method("UseGPUSparse", [](mfem::SparseMatrix* a)->void { a->UseGPUSparse(); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::UseCuSparse(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::UseCuSparse(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:194:9
    t.method("UseCuSparse", static_cast<void (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::UseCuSparse));
    t.method("UseCuSparse", [](mfem::SparseMatrix& a)->void { a.UseCuSparse(); });
    t.method("UseCuSparse", [](mfem::SparseMatrix* a)->void { a->UseCuSparse(); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::SparseMatrix::operator=(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::SparseMatrix::operator=(const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:197:18
    t.method("assign", static_cast<mfem::SparseMatrix & (mfem::SparseMatrix::*)(const mfem::SparseMatrix &) >(&mfem::SparseMatrix::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::MakeRef(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::MakeRef(const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:203:9
    t.method("MakeRef", static_cast<void (mfem::SparseMatrix::*)(const mfem::SparseMatrix &) >(&mfem::SparseMatrix::MakeRef));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::Size() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::Size()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:206:8
    t.method("Size", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::Size));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Clear()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:209:9
    t.method("Clear", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::Clear));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ClearGPUSparse() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ClearGPUSparse()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:213:9
    t.method("ClearGPUSparse", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::ClearGPUSparse));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ClearCuSparse() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ClearCuSparse()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:216:9
    t.method("ClearCuSparse", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::ClearCuSparse));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::Empty() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::Empty()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:219:9
    t.method("Empty", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::Empty));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::GetI() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::GetI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:222:16
    t.method("GetI", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetI));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::GetI() (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::GetI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:224:22
    t.method("GetI", static_cast<const int * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetI));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::GetJ() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::GetJ()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:227:16
    t.method("GetJ", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetJ));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::GetJ() (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::GetJ()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:229:22
    t.method("GetJ", static_cast<const int * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetJ));

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::GetData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::GetData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:232:19
    t.method("GetData", static_cast<double * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetData));

    DEBUG_MSG("Adding wrapper for const double * mfem::SparseMatrix::GetData() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::SparseMatrix::GetData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:234:25
    t.method("GetData", static_cast<const double * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetData));

    DEBUG_MSG("Adding wrapper for mfem::Memory<int> & mfem::SparseMatrix::GetMemoryI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Memory<int> & mfem::SparseMatrix::GetMemoryI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:237:17
    t.method("GetMemoryI", static_cast<mfem::Memory<int> & (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetMemoryI));

    DEBUG_MSG("Adding wrapper for const mfem::Memory<int> & mfem::SparseMatrix::GetMemoryI() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Memory<int> & mfem::SparseMatrix::GetMemoryI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:238:23
    t.method("GetMemoryI", static_cast<const mfem::Memory<int> & (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetMemoryI));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::ReadI(bool) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::ReadI(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:239:15
    t.method("ReadI", static_cast<const int * (mfem::SparseMatrix::*)(bool)  const>(&mfem::SparseMatrix::ReadI));
    t.method("ReadI", [](mfem::SparseMatrix const& a)->const int * { return a.ReadI(); });
    t.method("ReadI", [](mfem::SparseMatrix const* a)->const int * { return a->ReadI(); });

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::WriteI(bool) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::WriteI(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:241:9
    t.method("WriteI", static_cast<int * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::WriteI));
    t.method("WriteI", [](mfem::SparseMatrix& a)->int * { return a.WriteI(); });
    t.method("WriteI", [](mfem::SparseMatrix* a)->int * { return a->WriteI(); });

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::ReadWriteI(bool) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::ReadWriteI(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:243:9
    t.method("ReadWriteI", static_cast<int * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::ReadWriteI));
    t.method("ReadWriteI", [](mfem::SparseMatrix& a)->int * { return a.ReadWriteI(); });
    t.method("ReadWriteI", [](mfem::SparseMatrix* a)->int * { return a->ReadWriteI(); });

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::HostReadI() (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::HostReadI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:245:15
    t.method("HostReadI", static_cast<const int * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::HostReadI));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::HostWriteI() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::HostWriteI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:247:9
    t.method("HostWriteI", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostWriteI));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::HostReadWriteI() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::HostReadWriteI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:249:9
    t.method("HostReadWriteI", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostReadWriteI));

    DEBUG_MSG("Adding wrapper for mfem::Memory<int> & mfem::SparseMatrix::GetMemoryJ() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Memory<int> & mfem::SparseMatrix::GetMemoryJ()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:253:17
    t.method("GetMemoryJ", static_cast<mfem::Memory<int> & (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetMemoryJ));

    DEBUG_MSG("Adding wrapper for const mfem::Memory<int> & mfem::SparseMatrix::GetMemoryJ() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Memory<int> & mfem::SparseMatrix::GetMemoryJ()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:254:23
    t.method("GetMemoryJ", static_cast<const mfem::Memory<int> & (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetMemoryJ));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::ReadJ(bool) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::ReadJ(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:255:15
    t.method("ReadJ", static_cast<const int * (mfem::SparseMatrix::*)(bool)  const>(&mfem::SparseMatrix::ReadJ));
    t.method("ReadJ", [](mfem::SparseMatrix const& a)->const int * { return a.ReadJ(); });
    t.method("ReadJ", [](mfem::SparseMatrix const* a)->const int * { return a->ReadJ(); });

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::WriteJ(bool) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::WriteJ(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:257:9
    t.method("WriteJ", static_cast<int * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::WriteJ));
    t.method("WriteJ", [](mfem::SparseMatrix& a)->int * { return a.WriteJ(); });
    t.method("WriteJ", [](mfem::SparseMatrix* a)->int * { return a->WriteJ(); });

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::ReadWriteJ(bool) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::ReadWriteJ(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:259:9
    t.method("ReadWriteJ", static_cast<int * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::ReadWriteJ));
    t.method("ReadWriteJ", [](mfem::SparseMatrix& a)->int * { return a.ReadWriteJ(); });
    t.method("ReadWriteJ", [](mfem::SparseMatrix* a)->int * { return a->ReadWriteJ(); });

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::HostReadJ() (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::HostReadJ()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:261:15
    t.method("HostReadJ", static_cast<const int * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::HostReadJ));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::HostWriteJ() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::HostWriteJ()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:263:9
    t.method("HostWriteJ", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostWriteJ));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::HostReadWriteJ() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::HostReadWriteJ()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:265:9
    t.method("HostReadWriteJ", static_cast<int * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostReadWriteJ));

    DEBUG_MSG("Adding wrapper for mfem::Memory<double> & mfem::SparseMatrix::GetMemoryData() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Memory<double> & mfem::SparseMatrix::GetMemoryData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:269:20
    t.method("GetMemoryData", static_cast<mfem::Memory<double> & (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::GetMemoryData));

    DEBUG_MSG("Adding wrapper for const mfem::Memory<double> & mfem::SparseMatrix::GetMemoryData() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Memory<double> & mfem::SparseMatrix::GetMemoryData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:270:26
    t.method("GetMemoryData", static_cast<const mfem::Memory<double> & (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetMemoryData));

    DEBUG_MSG("Adding wrapper for const double * mfem::SparseMatrix::ReadData(bool) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::SparseMatrix::ReadData(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:271:18
    t.method("ReadData", static_cast<const double * (mfem::SparseMatrix::*)(bool)  const>(&mfem::SparseMatrix::ReadData));
    t.method("ReadData", [](mfem::SparseMatrix const& a)->const double * { return a.ReadData(); });
    t.method("ReadData", [](mfem::SparseMatrix const* a)->const double * { return a->ReadData(); });

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::WriteData(bool) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::WriteData(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:273:12
    t.method("WriteData", static_cast<double * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::WriteData));
    t.method("WriteData", [](mfem::SparseMatrix& a)->double * { return a.WriteData(); });
    t.method("WriteData", [](mfem::SparseMatrix* a)->double * { return a->WriteData(); });

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::ReadWriteData(bool) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::ReadWriteData(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:275:12
    t.method("ReadWriteData", static_cast<double * (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::ReadWriteData));
    t.method("ReadWriteData", [](mfem::SparseMatrix& a)->double * { return a.ReadWriteData(); });
    t.method("ReadWriteData", [](mfem::SparseMatrix* a)->double * { return a->ReadWriteData(); });

    DEBUG_MSG("Adding wrapper for const double * mfem::SparseMatrix::HostReadData() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::SparseMatrix::HostReadData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:277:18
    t.method("HostReadData", static_cast<const double * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::HostReadData));

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::HostWriteData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::HostWriteData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:279:12
    t.method("HostWriteData", static_cast<double * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostWriteData));

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::HostReadWriteData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::HostReadWriteData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:281:12
    t.method("HostReadWriteData", static_cast<double * (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::HostReadWriteData));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::RowSize(const int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::RowSize(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:285:8
    t.method("RowSize", static_cast<int (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::RowSize));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::MaxRowSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::MaxRowSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:288:8
    t.method("MaxRowSize", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::MaxRowSize));

    DEBUG_MSG("Adding wrapper for int * mfem::SparseMatrix::GetRowColumns(const int) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::SparseMatrix::GetRowColumns(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:291:9
    t.method("GetRowColumns", static_cast<int * (mfem::SparseMatrix::*)(const int) >(&mfem::SparseMatrix::GetRowColumns));

    DEBUG_MSG("Adding wrapper for const int * mfem::SparseMatrix::GetRowColumns(const int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::SparseMatrix::GetRowColumns(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:293:15
    t.method("GetRowColumns", static_cast<const int * (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::GetRowColumns));

    DEBUG_MSG("Adding wrapper for double * mfem::SparseMatrix::GetRowEntries(const int) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::SparseMatrix::GetRowEntries(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:296:12
    t.method("GetRowEntries", static_cast<double * (mfem::SparseMatrix::*)(const int) >(&mfem::SparseMatrix::GetRowEntries));

    DEBUG_MSG("Adding wrapper for const double * mfem::SparseMatrix::GetRowEntries(const int) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::SparseMatrix::GetRowEntries(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:298:18
    t.method("GetRowEntries", static_cast<const double * (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::GetRowEntries));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetWidth(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetWidth(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:308:9
    t.method("SetWidth", static_cast<void (mfem::SparseMatrix::*)(int) >(&mfem::SparseMatrix::SetWidth));
    t.method("SetWidth", [](mfem::SparseMatrix& a)->void { a.SetWidth(); });
    t.method("SetWidth", [](mfem::SparseMatrix* a)->void { a->SetWidth(); });

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::ActualWidth() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::ActualWidth()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:312:8
    t.method("ActualWidth", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ActualWidth));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SortColumnIndices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SortColumnIndices()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:315:9
    t.method("SortColumnIndices", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::SortColumnIndices));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::MoveDiagonalFirst() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::MoveDiagonalFirst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:319:9
    t.method("MoveDiagonalFirst", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::MoveDiagonalFirst));

    DEBUG_MSG("Adding wrapper for double & mfem::SparseMatrix::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::SparseMatrix::Elem(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:322:20
    t.method("Elem", static_cast<double & (mfem::SparseMatrix::*)(int, int) >(&mfem::SparseMatrix::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::SparseMatrix::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::SparseMatrix::Elem(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:325:26
    t.method("Elem", static_cast<const double & (mfem::SparseMatrix::*)(int, int)  const>(&mfem::SparseMatrix::Elem));

    DEBUG_MSG("Adding wrapper for double & mfem::SparseMatrix::operator()(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::SparseMatrix::operator()(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:328:12
    t.method("paren", static_cast<double & (mfem::SparseMatrix::*)(int, int) >(&mfem::SparseMatrix::operator()));

    DEBUG_MSG("Adding wrapper for const double & mfem::SparseMatrix::operator()(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::SparseMatrix::operator()(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:331:18
    t.method("paren", static_cast<const double & (mfem::SparseMatrix::*)(int, int)  const>(&mfem::SparseMatrix::operator()));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::GetDiag(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::GetDiag(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:334:9
    t.method("GetDiag", static_cast<void (mfem::SparseMatrix::*)(mfem::Vector &)  const>(&mfem::SparseMatrix::GetDiag));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::SparseMatrix::ToDenseMatrix() (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::SparseMatrix::ToDenseMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:337:17
    t.method("ToDenseMatrix", static_cast<mfem::DenseMatrix * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ToDenseMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ToDenseMatrix(mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ToDenseMatrix(mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:340:9
    t.method("ToDenseMatrix", static_cast<void (mfem::SparseMatrix::*)(mfem::DenseMatrix &)  const>(&mfem::SparseMatrix::ToDenseMatrix));

    DEBUG_MSG("Adding wrapper for mfem::MemoryClass mfem::SparseMatrix::GetMemoryClass() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MemoryClass mfem::SparseMatrix::GetMemoryClass()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:342:24
    t.method("GetMemoryClass", static_cast<mfem::MemoryClass (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetMemoryClass));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:349:17
    t.method("Mult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AddMult(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AddMult(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:352:17
    t.method("AddMult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::SparseMatrix::AddMult));
    t.method("AddMult", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMult(arg0, arg1); });
    t.method("AddMult", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:359:17
    t.method("MultTranspose", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:365:17
    t.method("AddMultTranspose", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::SparseMatrix::AddMultTranspose));
    t.method("AddMultTranspose", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMultTranspose(arg0, arg1); });
    t.method("AddMultTranspose", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMultTranspose(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::BuildTranspose() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::BuildTranspose()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:390:9
    t.method("BuildTranspose", static_cast<void (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::BuildTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ResetTranspose() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ResetTranspose()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:394:9
    t.method("ResetTranspose", static_cast<void (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ResetTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EnsureMultTranspose() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EnsureMultTranspose()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:406:9
    t.method("EnsureMultTranspose", static_cast<void (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::EnsureMultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::PartMult(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::PartMult(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:408:9
    t.method("PartMult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::PartMult));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::PartAddMult(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::PartAddMult(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:409:9
    t.method("PartAddMult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::SparseMatrix::PartAddMult));
    t.method("PartAddMult", [](mfem::SparseMatrix const& a, const mfem::Array<int> & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a.PartAddMult(arg0, arg1, arg2); });
    t.method("PartAddMult", [](mfem::SparseMatrix const* a, const mfem::Array<int> & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a->PartAddMult(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::BooleanMult(const mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::BooleanMult(const mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:416:9
    t.method("BooleanMult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::SparseMatrix::BooleanMult));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::BooleanMultTranspose(const mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::BooleanMultTranspose(const mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:422:9
    t.method("BooleanMultTranspose", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::SparseMatrix::BooleanMultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AbsMult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AbsMult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:425:9
    t.method("AbsMult", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::AbsMult));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AbsMultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AbsMultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:431:9
    t.method("AbsMultTranspose", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::AbsMultTranspose));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::InnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::InnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:434:11
    t.method("InnerProduct", static_cast<double (mfem::SparseMatrix::*)(const mfem::Vector &, const mfem::Vector &)  const>(&mfem::SparseMatrix::InnerProduct));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::GetRowSums(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::GetRowSums(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:437:9
    t.method("GetRowSums", static_cast<void (mfem::SparseMatrix::*)(mfem::Vector &)  const>(&mfem::SparseMatrix::GetRowSums));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::GetRowNorml1(int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::GetRowNorml1(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:439:11
    t.method("GetRowNorml1", static_cast<double (mfem::SparseMatrix::*)(int)  const>(&mfem::SparseMatrix::GetRowNorml1));

    DEBUG_MSG("Adding wrapper for mfem::MatrixInverse * mfem::SparseMatrix::Inverse() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixInverse * mfem::SparseMatrix::Inverse()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:442:27
    t.method("Inverse", static_cast<mfem::MatrixInverse * (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::Inverse));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRow(int, const double, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRow(int, const double, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:445:9
    t.method("EliminateRow", static_cast<void (mfem::SparseMatrix::*)(int, const double, mfem::Vector &) >(&mfem::SparseMatrix::EliminateRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRow(int, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRow(int, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:454:9
    t.method("EliminateRow", static_cast<void (mfem::SparseMatrix::*)(int, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRow));
    t.method("EliminateRow", [](mfem::SparseMatrix& a, int arg0)->void { a.EliminateRow(arg0); });
    t.method("EliminateRow", [](mfem::SparseMatrix* a, int arg0)->void { a->EliminateRow(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateCol(int, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateCol(int, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:461:9
    t.method("EliminateCol", static_cast<void (mfem::SparseMatrix::*)(int, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateCol));
    t.method("EliminateCol", [](mfem::SparseMatrix& a, int arg0)->void { a.EliminateCol(arg0); });
    t.method("EliminateCol", [](mfem::SparseMatrix* a, int arg0)->void { a->EliminateCol(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateCols(const mfem::Array<int> &, const mfem::Vector *, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateCols(const mfem::Array<int> &, const mfem::Vector *, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:468:9
    t.method("EliminateCols", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, const mfem::Vector *, mfem::Vector *) >(&mfem::SparseMatrix::EliminateCols));
    t.method("EliminateCols", [](mfem::SparseMatrix& a, const mfem::Array<int> & arg0)->void { a.EliminateCols(arg0); });
    t.method("EliminateCols", [](mfem::SparseMatrix& a, const mfem::Array<int> & arg0, const mfem::Vector * arg1)->void { a.EliminateCols(arg0, arg1); });
    t.method("EliminateCols", [](mfem::SparseMatrix* a, const mfem::Array<int> & arg0)->void { a->EliminateCols(arg0); });
    t.method("EliminateCols", [](mfem::SparseMatrix* a, const mfem::Array<int> & arg0, const mfem::Vector * arg1)->void { a->EliminateCols(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateCols(const mfem::Array<int> &, mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateCols(const mfem::Array<int> &, mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:473:9
    t.method("EliminateCols", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, mfem::SparseMatrix &) >(&mfem::SparseMatrix::EliminateCols));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowCol(int, const double, mfem::Vector &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowCol(int, const double, mfem::Vector &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:481:9
    t.method("EliminateRowCol", static_cast<void (mfem::SparseMatrix::*)(int, const double, mfem::Vector &, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRowCol));
    t.method("EliminateRowCol", [](mfem::SparseMatrix& a, int arg0, const double arg1, mfem::Vector & arg2)->void { a.EliminateRowCol(arg0, arg1, arg2); });
    t.method("EliminateRowCol", [](mfem::SparseMatrix* a, int arg0, const double arg1, mfem::Vector & arg2)->void { a->EliminateRowCol(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowColMultipleRHS(int, const mfem::Vector &, mfem::DenseMatrix &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowColMultipleRHS(int, const mfem::Vector &, mfem::DenseMatrix &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:488:9
    t.method("EliminateRowColMultipleRHS", static_cast<void (mfem::SparseMatrix::*)(int, const mfem::Vector &, mfem::DenseMatrix &, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRowColMultipleRHS));
    t.method("EliminateRowColMultipleRHS", [](mfem::SparseMatrix& a, int arg0, const mfem::Vector & arg1, mfem::DenseMatrix & arg2)->void { a.EliminateRowColMultipleRHS(arg0, arg1, arg2); });
    t.method("EliminateRowColMultipleRHS", [](mfem::SparseMatrix* a, int arg0, const mfem::Vector & arg1, mfem::DenseMatrix & arg2)->void { a->EliminateRowColMultipleRHS(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowColDiag(int, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowColDiag(int, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:493:9
    t.method("EliminateRowColDiag", static_cast<void (mfem::SparseMatrix::*)(int, double) >(&mfem::SparseMatrix::EliminateRowColDiag));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowCol(int, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowCol(int, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:496:9
    t.method("EliminateRowCol", static_cast<void (mfem::SparseMatrix::*)(int, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRowCol));
    t.method("EliminateRowCol", [](mfem::SparseMatrix& a, int arg0)->void { a.EliminateRowCol(arg0); });
    t.method("EliminateRowCol", [](mfem::SparseMatrix* a, int arg0)->void { a->EliminateRowCol(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateRowCol(int, mfem::SparseMatrix &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateRowCol(int, mfem::SparseMatrix &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:501:9
    t.method("EliminateRowCol", static_cast<void (mfem::SparseMatrix::*)(int, mfem::SparseMatrix &, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateRowCol));
    t.method("EliminateRowCol", [](mfem::SparseMatrix& a, int arg0, mfem::SparseMatrix & arg1)->void { a.EliminateRowCol(arg0, arg1); });
    t.method("EliminateRowCol", [](mfem::SparseMatrix* a, int arg0, mfem::SparseMatrix & arg1)->void { a->EliminateRowCol(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateBC(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateBC(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:509:9
    t.method("EliminateBC", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy) >(&mfem::SparseMatrix::EliminateBC));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetDiagIdentity() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetDiagIdentity()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:513:9
    t.method("SetDiagIdentity", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::SetDiagIdentity));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::EliminateZeroRows(const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::EliminateZeroRows(const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:515:17
    t.method("EliminateZeroRows", static_cast<void (mfem::SparseMatrix::*)(const double) >(&mfem::SparseMatrix::EliminateZeroRows));
    t.method("EliminateZeroRows", [](mfem::SparseMatrix& a)->void { a.EliminateZeroRows(); });
    t.method("EliminateZeroRows", [](mfem::SparseMatrix* a)->void { a->EliminateZeroRows(); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Gauss_Seidel_forw(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Gauss_Seidel_forw(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:518:9
    t.method("Gauss_Seidel_forw", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::Gauss_Seidel_forw));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Gauss_Seidel_back(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Gauss_Seidel_back(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:519:9
    t.method("Gauss_Seidel_back", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SparseMatrix::Gauss_Seidel_back));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::GetJacobiScaling() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::GetJacobiScaling()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:522:11
    t.method("GetJacobiScaling", static_cast<double (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetJacobiScaling));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Jacobi(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Jacobi(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:526:9
    t.method("Jacobi", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, bool)  const>(&mfem::SparseMatrix::Jacobi));
    t.method("Jacobi", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, double arg3)->void { a.Jacobi(arg0, arg1, arg2, arg3); });
    t.method("Jacobi", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, double arg3)->void { a->Jacobi(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::DiagScale(const mfem::Vector &, mfem::Vector &, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::DiagScale(const mfem::Vector &, mfem::Vector &, double, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:530:9
    t.method("DiagScale", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, mfem::Vector &, double, bool)  const>(&mfem::SparseMatrix::DiagScale));
    t.method("DiagScale", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.DiagScale(arg0, arg1); });
    t.method("DiagScale", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, mfem::Vector & arg1, double arg2)->void { a.DiagScale(arg0, arg1, arg2); });
    t.method("DiagScale", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->DiagScale(arg0, arg1); });
    t.method("DiagScale", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, mfem::Vector & arg1, double arg2)->void { a->DiagScale(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Jacobi2(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Jacobi2(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:534:9
    t.method("Jacobi2", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double)  const>(&mfem::SparseMatrix::Jacobi2));
    t.method("Jacobi2", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a.Jacobi2(arg0, arg1, arg2); });
    t.method("Jacobi2", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a->Jacobi2(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Jacobi3(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Jacobi3(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:538:9
    t.method("Jacobi3", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double)  const>(&mfem::SparseMatrix::Jacobi3));
    t.method("Jacobi3", [](mfem::SparseMatrix const& a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a.Jacobi3(arg0, arg1, arg2); });
    t.method("Jacobi3", [](mfem::SparseMatrix const* a, const mfem::Vector & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a->Jacobi3(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Finalize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Finalize(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:546:17
    t.method("Finalize", static_cast<void (mfem::SparseMatrix::*)(int) >(&mfem::SparseMatrix::Finalize));
    t.method("Finalize", [](mfem::SparseMatrix& a)->void { a.Finalize(); });
    t.method("Finalize", [](mfem::SparseMatrix* a)->void { a->Finalize(); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Finalize(int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Finalize(int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:549:9
    t.method("Finalize", static_cast<void (mfem::SparseMatrix::*)(int, bool) >(&mfem::SparseMatrix::Finalize));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::Finalized() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::Finalized()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:552:9
    t.method("Finalized", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::Finalized));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::ColumnsAreSorted() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::ColumnsAreSorted()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:554:9
    t.method("ColumnsAreSorted", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ColumnsAreSorted));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Threshold(double, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Threshold(double, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:559:9
    t.method("Threshold", static_cast<void (mfem::SparseMatrix::*)(double, bool) >(&mfem::SparseMatrix::Threshold));
    t.method("Threshold", [](mfem::SparseMatrix& a, double arg0)->void { a.Threshold(arg0); });
    t.method("Threshold", [](mfem::SparseMatrix* a, double arg0)->void { a->Threshold(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::GetBlocks(mfem::Array2D<mfem::SparseMatrix *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::GetBlocks(mfem::Array2D<mfem::SparseMatrix *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:564:9
    t.method("GetBlocks", static_cast<void (mfem::SparseMatrix::*)(mfem::Array2D<mfem::SparseMatrix *> &)  const>(&mfem::SparseMatrix::GetBlocks));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::GetSubMatrix(const mfem::Array<int> &, const mfem::Array<int> &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::GetSubMatrix(const mfem::Array<int> &, const mfem::Array<int> &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:566:9
    t.method("GetSubMatrix", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, const mfem::Array<int> &, mfem::DenseMatrix &)  const>(&mfem::SparseMatrix::GetSubMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetColPtr(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetColPtr(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:574:16
    t.method("SetColPtr", static_cast<void (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::SetColPtr));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ClearColPtr() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ClearColPtr()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:577:16
    t.method("ClearColPtr", static_cast<void (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::ClearColPtr));

    DEBUG_MSG("Adding wrapper for double & mfem::SparseMatrix::SearchRow(const int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::SparseMatrix::SearchRow(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:583:19
    t.method("SearchRow", static_cast<double & (mfem::SparseMatrix::*)(const int) >(&mfem::SparseMatrix::SearchRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::_Add_(const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::_Add_(const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:585:16
    t.method("_Add_", static_cast<void (mfem::SparseMatrix::*)(const int, const double) >(&mfem::SparseMatrix::_Add_));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::_Set_(const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::_Set_(const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:588:16
    t.method("_Set_", static_cast<void (mfem::SparseMatrix::*)(const int, const double) >(&mfem::SparseMatrix::_Set_));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::_Get_(const int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::_Get_(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:591:18
    t.method("_Get_", static_cast<double (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::_Get_));

    DEBUG_MSG("Adding wrapper for double & mfem::SparseMatrix::SearchRow(const int, const int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::SparseMatrix::SearchRow(const int, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:593:19
    t.method("SearchRow", static_cast<double & (mfem::SparseMatrix::*)(const int, const int) >(&mfem::SparseMatrix::SearchRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::_Add_(const int, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::_Add_(const int, const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:594:16
    t.method("_Add_", static_cast<void (mfem::SparseMatrix::*)(const int, const int, const double) >(&mfem::SparseMatrix::_Add_));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::_Set_(const int, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::_Set_(const int, const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:596:16
    t.method("_Set_", static_cast<void (mfem::SparseMatrix::*)(const int, const int, const double) >(&mfem::SparseMatrix::_Set_));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Set(const int, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Set(const int, const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:599:9
    t.method("Set", static_cast<void (mfem::SparseMatrix::*)(const int, const int, const double) >(&mfem::SparseMatrix::Set));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Add(const int, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Add(const int, const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:600:9
    t.method("Add", static_cast<void (mfem::SparseMatrix::*)(const int, const int, const double) >(&mfem::SparseMatrix::Add));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetSubMatrix(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetSubMatrix(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:602:9
    t.method("SetSubMatrix", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int) >(&mfem::SparseMatrix::SetSubMatrix));
    t.method("SetSubMatrix", [](mfem::SparseMatrix& a, const mfem::Array<int> & arg0, const mfem::Array<int> & arg1, const mfem::DenseMatrix & arg2)->void { a.SetSubMatrix(arg0, arg1, arg2); });
    t.method("SetSubMatrix", [](mfem::SparseMatrix* a, const mfem::Array<int> & arg0, const mfem::Array<int> & arg1, const mfem::DenseMatrix & arg2)->void { a->SetSubMatrix(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetSubMatrixTranspose(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetSubMatrixTranspose(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:605:9
    t.method("SetSubMatrixTranspose", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int) >(&mfem::SparseMatrix::SetSubMatrixTranspose));
    t.method("SetSubMatrixTranspose", [](mfem::SparseMatrix& a, const mfem::Array<int> & arg0, const mfem::Array<int> & arg1, const mfem::DenseMatrix & arg2)->void { a.SetSubMatrixTranspose(arg0, arg1, arg2); });
    t.method("SetSubMatrixTranspose", [](mfem::SparseMatrix* a, const mfem::Array<int> & arg0, const mfem::Array<int> & arg1, const mfem::DenseMatrix & arg2)->void { a->SetSubMatrixTranspose(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AddSubMatrix(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AddSubMatrix(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:614:9
    t.method("AddSubMatrix", static_cast<void (mfem::SparseMatrix::*)(const mfem::Array<int> &, const mfem::Array<int> &, const mfem::DenseMatrix &, int) >(&mfem::SparseMatrix::AddSubMatrix));
    t.method("AddSubMatrix", [](mfem::SparseMatrix& a, const mfem::Array<int> & arg0, const mfem::Array<int> & arg1, const mfem::DenseMatrix & arg2)->void { a.AddSubMatrix(arg0, arg1, arg2); });
    t.method("AddSubMatrix", [](mfem::SparseMatrix* a, const mfem::Array<int> & arg0, const mfem::Array<int> & arg1, const mfem::DenseMatrix & arg2)->void { a->AddSubMatrix(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::RowIsEmpty(const int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::RowIsEmpty(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:617:9
    t.method("RowIsEmpty", static_cast<bool (mfem::SparseMatrix::*)(const int)  const>(&mfem::SparseMatrix::RowIsEmpty));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::GetRow(const int, mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::GetRow(const int, mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:629:16
    t.method("GetRow", static_cast<int (mfem::SparseMatrix::*)(const int, mfem::Array<int> &, mfem::Vector &)  const>(&mfem::SparseMatrix::GetRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetRow(const int, const mfem::Array<int> &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetRow(const int, const mfem::Array<int> &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:631:9
    t.method("SetRow", static_cast<void (mfem::SparseMatrix::*)(const int, const mfem::Array<int> &, const mfem::Vector &) >(&mfem::SparseMatrix::SetRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::AddRow(const int, const mfem::Array<int> &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::AddRow(const int, const mfem::Array<int> &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:632:9
    t.method("AddRow", static_cast<void (mfem::SparseMatrix::*)(const int, const mfem::Array<int> &, const mfem::Vector &) >(&mfem::SparseMatrix::AddRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ScaleRow(const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ScaleRow(const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:634:9
    t.method("ScaleRow", static_cast<void (mfem::SparseMatrix::*)(const int, const double) >(&mfem::SparseMatrix::ScaleRow));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ScaleRows(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ScaleRows(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:636:9
    t.method("ScaleRows", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &) >(&mfem::SparseMatrix::ScaleRows));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::ScaleColumns(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::ScaleColumns(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:638:9
    t.method("ScaleColumns", static_cast<void (mfem::SparseMatrix::*)(const mfem::Vector &) >(&mfem::SparseMatrix::ScaleColumns));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::SparseMatrix::operator+=(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::SparseMatrix::operator+=(const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:642:18
    t.method("add!", static_cast<mfem::SparseMatrix & (mfem::SparseMatrix::*)(const mfem::SparseMatrix &) >(&mfem::SparseMatrix::operator+=));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Add(const double, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Add(const double, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:646:9
    t.method("Add", static_cast<void (mfem::SparseMatrix::*)(const double, const mfem::SparseMatrix &) >(&mfem::SparseMatrix::Add));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::SparseMatrix::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::SparseMatrix::operator=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:648:18
    t.method("assign", static_cast<mfem::SparseMatrix & (mfem::SparseMatrix::*)(double) >(&mfem::SparseMatrix::operator=));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::SparseMatrix::operator*=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::SparseMatrix::operator*=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:650:18
    t.method("mult!", static_cast<mfem::SparseMatrix & (mfem::SparseMatrix::*)(double) >(&mfem::SparseMatrix::operator*=));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::IsSymmetric() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::IsSymmetric()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:671:11
    t.method("IsSymmetric", static_cast<double (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::IsSymmetric));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Symmetrize() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Symmetrize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:674:9
    t.method("Symmetrize", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::Symmetrize));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::NumNonZeroElems() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::NumNonZeroElems()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:677:16
    t.method("NumNonZeroElems", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::NumNonZeroElems));

    DEBUG_MSG("Adding wrapper for double mfem::SparseMatrix::MaxNorm() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SparseMatrix::MaxNorm()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:679:11
    t.method("MaxNorm", static_cast<double (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::MaxNorm));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::CountSmallElems(double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::CountSmallElems(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:682:8
    t.method("CountSmallElems", static_cast<int (mfem::SparseMatrix::*)(double)  const>(&mfem::SparseMatrix::CountSmallElems));

    DEBUG_MSG("Adding wrapper for int mfem::SparseMatrix::CheckFinite() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SparseMatrix::CheckFinite()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:685:8
    t.method("CheckFinite", static_cast<int (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::CheckFinite));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetGraphOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetGraphOwner(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:688:9
    t.method("SetGraphOwner", static_cast<void (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::SetGraphOwner));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::SetDataOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::SetDataOwner(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:692:9
    t.method("SetDataOwner", static_cast<void (mfem::SparseMatrix::*)(bool) >(&mfem::SparseMatrix::SetDataOwner));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::OwnsGraph() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::OwnsGraph()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:695:9
    t.method("OwnsGraph", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::OwnsGraph));

    DEBUG_MSG("Adding wrapper for bool mfem::SparseMatrix::OwnsData() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::SparseMatrix::OwnsData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:698:9
    t.method("OwnsData", static_cast<bool (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::OwnsData));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::LoseData() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::LoseData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:701:9
    t.method("LoseData", static_cast<void (mfem::SparseMatrix::*)() >(&mfem::SparseMatrix::LoseData));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrix::Swap(mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrix::Swap(mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:703:9
    t.method("Swap", static_cast<void (mfem::SparseMatrix::*)(mfem::SparseMatrix &) >(&mfem::SparseMatrix::Swap));

    DEBUG_MSG("Adding wrapper for mfem::Operator::Type mfem::SparseMatrix::GetType() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator::Type mfem::SparseMatrix::GetType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:708:9
    t.method("GetType", static_cast<mfem::Operator::Type (mfem::SparseMatrix::*)()  const>(&mfem::SparseMatrix::GetType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SparseMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SparseMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SparseMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DenseMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DenseMatrix> : std::false_type { };
template<> struct SuperType<mfem::DenseMatrix> { typedef mfem::Matrix type; };
}

// Class generating the wrapper for type mfem::DenseMatrix
// signature to use in the veto file: mfem::DenseMatrix
struct Jlmfem_DenseMatrix: public Wrapper {

  Jlmfem_DenseMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DenseMatrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/densemat.hpp:23:7
    jlcxx::TypeWrapper<mfem::DenseMatrix>  t = jlModule.add_type<mfem::DenseMatrix>("mfem!DenseMatrix",
      jlcxx::julia_base_type<mfem::Matrix>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseMatrix>>(new jlcxx::TypeWrapper<mfem::DenseMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DenseMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DenseMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SparseSmoother> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SparseSmoother> : std::false_type { };
template<> struct SuperType<mfem::SparseSmoother> { typedef mfem::MatrixInverse type; };
}

// Class generating the wrapper for type mfem::SparseSmoother
// signature to use in the veto file: mfem::SparseSmoother
struct Jlmfem_SparseSmoother: public Wrapper {

  Jlmfem_SparseSmoother(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SparseSmoother (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:21:7
    jlcxx::TypeWrapper<mfem::SparseSmoother>  t = jlModule.add_type<mfem::SparseSmoother>("mfem!SparseSmoother",
      jlcxx::julia_base_type<mfem::MatrixInverse>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SparseSmoother>>(new jlcxx::TypeWrapper<mfem::SparseSmoother>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::SparseSmoother::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseSmoother::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:32:17
    t.method("SetOperator", static_cast<void (mfem::SparseSmoother::*)(const mfem::Operator &) >(&mfem::SparseSmoother::SetOperator));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SparseSmoother>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SparseSmoother(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SparseSmoother(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GSSmoother> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GSSmoother> : std::false_type { };
template<> struct SuperType<mfem::GSSmoother> { typedef mfem::SparseSmoother type; };
}

// Class generating the wrapper for type mfem::GSSmoother
// signature to use in the veto file: mfem::GSSmoother
struct Jlmfem_GSSmoother: public Wrapper {

  Jlmfem_GSSmoother(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GSSmoother (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:36:7
    jlcxx::TypeWrapper<mfem::GSSmoother>  t = jlModule.add_type<mfem::GSSmoother>("mfem!GSSmoother",
      jlcxx::julia_base_type<mfem::SparseSmoother>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GSSmoother>>(new jlcxx::TypeWrapper<mfem::GSSmoother>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GSSmoother::GSSmoother(int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:44:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GSSmoother::GSSmoother(const mfem::SparseMatrix &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:47:4
    t.constructor<const mfem::SparseMatrix &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::SparseMatrix &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::SparseMatrix &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::GSSmoother::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GSSmoother::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:51:17
    t.method("Mult", static_cast<void (mfem::GSSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::GSSmoother::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GSSmoother>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GSSmoother(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GSSmoother(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DSmoother> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DSmoother> : std::false_type { };
template<> struct SuperType<mfem::DSmoother> { typedef mfem::SparseSmoother type; };
}

// Class generating the wrapper for type mfem::DSmoother
// signature to use in the veto file: mfem::DSmoother
struct Jlmfem_DSmoother: public Wrapper {

  Jlmfem_DSmoother(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DSmoother (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:55:7
    jlcxx::TypeWrapper<mfem::DSmoother>  t = jlModule.add_type<mfem::DSmoother>("mfem!DSmoother",
      jlcxx::julia_base_type<mfem::SparseSmoother>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DSmoother>>(new jlcxx::TypeWrapper<mfem::DSmoother>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DSmoother::DSmoother(int, double, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:68:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, double, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DSmoother::DSmoother(const mfem::SparseMatrix &, int, double, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:72:4
    t.constructor<const mfem::SparseMatrix &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::SparseMatrix &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::SparseMatrix &, int, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::SparseMatrix &, int, double, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DSmoother::SetPositiveDiagonal(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DSmoother::SetPositiveDiagonal(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:75:9
    t.method("SetPositiveDiagonal", static_cast<void (mfem::DSmoother::*)(bool) >(&mfem::DSmoother::SetPositiveDiagonal));
    t.method("SetPositiveDiagonal", [](mfem::DSmoother& a)->void { a.SetPositiveDiagonal(); });
    t.method("SetPositiveDiagonal", [](mfem::DSmoother* a)->void { a->SetPositiveDiagonal(); });

    DEBUG_MSG("Adding wrapper for void mfem::DSmoother::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DSmoother::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/sparsesmoothers.hpp:78:17
    t.method("Mult", static_cast<void (mfem::DSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DSmoother::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DSmoother>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DSmoother(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DSmoother(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OperatorHandle> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OperatorHandle> : std::false_type { };
}

// Class generating the wrapper for type mfem::OperatorHandle
// signature to use in the veto file: mfem::OperatorHandle
struct Jlmfem_OperatorHandle: public Wrapper {

  Jlmfem_OperatorHandle(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OperatorHandle (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:33:7
    jlcxx::TypeWrapper<mfem::OperatorHandle>  t = jlModule.add_type<mfem::OperatorHandle>("mfem!OperatorHandle");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorHandle>>(new jlcxx::TypeWrapper<mfem::OperatorHandle>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::OperatorHandle(mfem::Operator::Type) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:60:13
    t.constructor<mfem::Operator::Type>(/*finalize=*/jlcxx::finalize_policy::yes);

    // Custom templates
    t.constructor<mfem::SparseMatrix*>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::SparseMatrix*, bool>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::OperatorHandle(const mfem::OperatorHandle &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:73:4
    t.constructor<const mfem::OperatorHandle &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::OperatorHandle & mfem::OperatorHandle::operator=(const mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::OperatorHandle & mfem::OperatorHandle::operator=(const mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:80:20
    t.method("assign", static_cast<mfem::OperatorHandle & (mfem::OperatorHandle::*)(const mfem::OperatorHandle &) >(&mfem::OperatorHandle::operator=));

    DEBUG_MSG("Adding wrapper for mfem::Operator * mfem::OperatorHandle::Ptr() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator * mfem::OperatorHandle::Ptr()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:87:14
    t.method("Ptr", static_cast<mfem::Operator * (mfem::OperatorHandle::*)()  const>(&mfem::OperatorHandle::Ptr));

    DEBUG_MSG("Adding wrapper for mfem::Operator * mfem::OperatorHandle::operator->() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator * mfem::OperatorHandle::operator->()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:90:14
    t.method("arrow", static_cast<mfem::Operator * (mfem::OperatorHandle::*)()  const>(&mfem::OperatorHandle::operator->));
    module_.set_override_module(jl_base_module);

    DEBUG_MSG("Adding wrapper for mfem::Operator & mfem::OperatorHandle::operator*() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator & mfem::OperatorHandle::operator*()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:93:14
    t.method("getindex", static_cast<mfem::Operator & (mfem::OperatorHandle::*)() >(&mfem::OperatorHandle::operator*));

    DEBUG_MSG("Adding wrapper for const mfem::Operator & mfem::OperatorHandle::operator*() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator & mfem::OperatorHandle::operator*()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:96:20
    t.method("getindex", static_cast<const mfem::Operator & (mfem::OperatorHandle::*)()  const>(&mfem::OperatorHandle::operator*));

    module_.unset_override_module();

    DEBUG_MSG("Adding wrapper for mfem::Operator::Type mfem::OperatorHandle::Type() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator::Type mfem::OperatorHandle::Type()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:99:19
    t.method("Type", static_cast<mfem::Operator::Type (mfem::OperatorHandle::*)()  const>(&mfem::OperatorHandle::Type));

    DEBUG_MSG("Adding wrapper for bool mfem::OperatorHandle::OwnsOperator() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::OperatorHandle::OwnsOperator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:117:9
    t.method("OwnsOperator", static_cast<bool (mfem::OperatorHandle::*)()  const>(&mfem::OperatorHandle::OwnsOperator));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::SetOperatorOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::SetOperatorOwner(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:120:9
    t.method("SetOperatorOwner", static_cast<void (mfem::OperatorHandle::*)(bool) >(&mfem::OperatorHandle::SetOperatorOwner));
    t.method("SetOperatorOwner", [](mfem::OperatorHandle& a)->void { a.SetOperatorOwner(); });
    t.method("SetOperatorOwner", [](mfem::OperatorHandle* a)->void { a->SetOperatorOwner(); });

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::Clear()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:124:9
    t.method("Clear", static_cast<void (mfem::OperatorHandle::*)() >(&mfem::OperatorHandle::Clear));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::SetType(mfem::Operator::Type) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::SetType(mfem::Operator::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:132:9
    t.method("SetType", static_cast<void (mfem::OperatorHandle::*)(mfem::Operator::Type) >(&mfem::OperatorHandle::SetType));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::MakePtAP(mfem::OperatorHandle &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::MakePtAP(mfem::OperatorHandle &, mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:169:9
    t.method("MakePtAP", static_cast<void (mfem::OperatorHandle::*)(mfem::OperatorHandle &, mfem::OperatorHandle &) >(&mfem::OperatorHandle::MakePtAP));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::MakeRAP(mfem::OperatorHandle &, mfem::OperatorHandle &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::MakeRAP(mfem::OperatorHandle &, mfem::OperatorHandle &, mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:175:9
    t.method("MakeRAP", static_cast<void (mfem::OperatorHandle::*)(mfem::OperatorHandle &, mfem::OperatorHandle &, mfem::OperatorHandle &) >(&mfem::OperatorHandle::MakeRAP));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::ConvertFrom(mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::ConvertFrom(mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:181:9
    t.method("ConvertFrom", static_cast<void (mfem::OperatorHandle::*)(mfem::OperatorHandle &) >(&mfem::OperatorHandle::ConvertFrom));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::EliminateRowsCols(mfem::OperatorHandle &, const mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::EliminateRowsCols(mfem::OperatorHandle &, const mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:195:9
    t.method("EliminateRowsCols", static_cast<void (mfem::OperatorHandle::*)(mfem::OperatorHandle &, const mfem::Array<int> &) >(&mfem::OperatorHandle::EliminateRowsCols));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::EliminateRows(const mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::EliminateRows(const mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:198:9
    t.method("EliminateRows", static_cast<void (mfem::OperatorHandle::*)(const mfem::Array<int> &) >(&mfem::OperatorHandle::EliminateRows));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::EliminateCols(const mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::EliminateCols(const mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:201:9
    t.method("EliminateCols", static_cast<void (mfem::OperatorHandle::*)(const mfem::Array<int> &) >(&mfem::OperatorHandle::EliminateCols));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorHandle::EliminateBC(const mfem::OperatorHandle &, const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorHandle::EliminateBC(const mfem::OperatorHandle &, const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:206:9
    t.method("EliminateBC", static_cast<void (mfem::OperatorHandle::*)(const mfem::OperatorHandle &, const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorHandle::EliminateBC));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorHandle>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OperatorHandle(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OperatorHandle(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IterativeSolverMonitor> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IterativeSolverMonitor> : std::false_type { };
}

// Class generating the wrapper for type mfem::IterativeSolverMonitor
// signature to use in the veto file: mfem::IterativeSolverMonitor
struct Jlmfem_IterativeSolverMonitor: public Wrapper {

  Jlmfem_IterativeSolverMonitor(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IterativeSolverMonitor (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:36:7
    jlcxx::TypeWrapper<mfem::IterativeSolverMonitor>  t = jlModule.add_type<mfem::IterativeSolverMonitor>("mfem!IterativeSolverMonitor");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolverMonitor>>(new jlcxx::TypeWrapper<mfem::IterativeSolverMonitor>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolverMonitor::MonitorResidual(int, double, const mfem::Vector &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolverMonitor::MonitorResidual(int, double, const mfem::Vector &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:48:17
    t.method("MonitorResidual", static_cast<void (mfem::IterativeSolverMonitor::*)(int, double, const mfem::Vector &, bool) >(&mfem::IterativeSolverMonitor::MonitorResidual));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolverMonitor::MonitorSolution(int, double, const mfem::Vector &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolverMonitor::MonitorSolution(int, double, const mfem::Vector &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:54:17
    t.method("MonitorSolution", static_cast<void (mfem::IterativeSolverMonitor::*)(int, double, const mfem::Vector &, bool) >(&mfem::IterativeSolverMonitor::MonitorSolution));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolverMonitor::SetIterativeSolver(const mfem::IterativeSolver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolverMonitor::SetIterativeSolver(const mfem::IterativeSolver &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:61:9
    t.method("SetIterativeSolver", static_cast<void (mfem::IterativeSolverMonitor::*)(const mfem::IterativeSolver &) >(&mfem::IterativeSolverMonitor::SetIterativeSolver));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolverMonitor>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IterativeSolverMonitor(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IterativeSolverMonitor(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IterativeSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IterativeSolver> : std::false_type { };
template<> struct SuperType<mfem::IterativeSolver> { typedef mfem::Solver type; };
}

// Class generating the wrapper for type mfem::IterativeSolver
// signature to use in the veto file: mfem::IterativeSolver
struct Jlmfem_IterativeSolver: public Wrapper {

  Jlmfem_IterativeSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IterativeSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:66:7
    jlcxx::TypeWrapper<mfem::IterativeSolver>  t = jlModule.add_type<mfem::IterativeSolver>("mfem!IterativeSolver",
      jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolver>>(new jlcxx::TypeWrapper<mfem::IterativeSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetRelTol(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetRelTol(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:199:9
    t.method("SetRelTol", static_cast<void (mfem::IterativeSolver::*)(double) >(&mfem::IterativeSolver::SetRelTol));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetAbsTol(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetAbsTol(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:200:9
    t.method("SetAbsTol", static_cast<void (mfem::IterativeSolver::*)(double) >(&mfem::IterativeSolver::SetAbsTol));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetMaxIter(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetMaxIter(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:201:9
    t.method("SetMaxIter", static_cast<void (mfem::IterativeSolver::*)(int) >(&mfem::IterativeSolver::SetMaxIter));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetPrintLevel(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetPrintLevel(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:229:17
    t.method("SetPrintLevel", static_cast<void (mfem::IterativeSolver::*)(int) >(&mfem::IterativeSolver::SetPrintLevel));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetPrintLevel(mfem::IterativeSolver::PrintLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetPrintLevel(mfem::IterativeSolver::PrintLevel)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:242:17
    t.method("SetPrintLevel", static_cast<void (mfem::IterativeSolver::*)(mfem::IterativeSolver::PrintLevel) >(&mfem::IterativeSolver::SetPrintLevel));

    DEBUG_MSG("Adding wrapper for int mfem::IterativeSolver::GetNumIterations() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::IterativeSolver::GetNumIterations()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:250:8
    t.method("GetNumIterations", static_cast<int (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetNumIterations));

    DEBUG_MSG("Adding wrapper for bool mfem::IterativeSolver::GetConverged() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::IterativeSolver::GetConverged()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:252:9
    t.method("GetConverged", static_cast<bool (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetConverged));

    DEBUG_MSG("Adding wrapper for double mfem::IterativeSolver::GetInitialNorm() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::IterativeSolver::GetInitialNorm()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:258:11
    t.method("GetInitialNorm", static_cast<double (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetInitialNorm));

    DEBUG_MSG("Adding wrapper for double mfem::IterativeSolver::GetFinalNorm() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::IterativeSolver::GetFinalNorm()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:265:11
    t.method("GetFinalNorm", static_cast<double (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetFinalNorm));

    DEBUG_MSG("Adding wrapper for double mfem::IterativeSolver::GetFinalRelNorm() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::IterativeSolver::GetFinalRelNorm()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:271:11
    t.method("GetFinalRelNorm", static_cast<double (mfem::IterativeSolver::*)()  const>(&mfem::IterativeSolver::GetFinalRelNorm));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetPreconditioner(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetPreconditioner(mfem::Solver &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:280:17
    t.method("SetPreconditioner", static_cast<void (mfem::IterativeSolver::*)(mfem::Solver &) >(&mfem::IterativeSolver::SetPreconditioner));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:283:17
    t.method("SetOperator", static_cast<void (mfem::IterativeSolver::*)(const mfem::Operator &) >(&mfem::IterativeSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::IterativeSolver::SetMonitor(mfem::IterativeSolverMonitor &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IterativeSolver::SetMonitor(mfem::IterativeSolverMonitor &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:286:9
    t.method("SetMonitor", static_cast<void (mfem::IterativeSolver::*)(mfem::IterativeSolverMonitor &) >(&mfem::IterativeSolver::SetMonitor));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IterativeSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IterativeSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IterativeSolver::PrintLevel> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IterativeSolver::PrintLevel> : std::false_type { };
}

// Class generating the wrapper for type mfem::IterativeSolver::PrintLevel
// signature to use in the veto file: mfem::IterativeSolver::PrintLevel
struct Jlmfem_IterativeSolver_PrintLevel: public Wrapper {

  Jlmfem_IterativeSolver_PrintLevel(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IterativeSolver::PrintLevel (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:78:11
    jlcxx::TypeWrapper<mfem::IterativeSolver::PrintLevel>  t = jlModule.add_type<mfem::IterativeSolver::PrintLevel>("mfem!IterativeSolver!PrintLevel");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolver::PrintLevel>>(new jlcxx::TypeWrapper<mfem::IterativeSolver::PrintLevel>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::None() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::None()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:103:19
    t.method("None", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::None));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Warnings() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Warnings()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:104:19
    t.method("Warnings", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::Warnings));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Errors() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Errors()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:105:19
    t.method("Errors", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::Errors));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Iterations() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Iterations()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:106:19
    t.method("Iterations", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::Iterations));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::FirstAndLast() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::FirstAndLast()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:107:19
    t.method("FirstAndLast", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::FirstAndLast));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Summary() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::Summary()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:108:19
    t.method("Summary", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::Summary));

    DEBUG_MSG("Adding wrapper for mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::All() (" __HERE__ ")");
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel & mfem::IterativeSolver::PrintLevel::All()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:109:19
    t.method("All", static_cast<mfem::IterativeSolver::PrintLevel & (mfem::IterativeSolver::PrintLevel::*)() >(&mfem::IterativeSolver::PrintLevel::All));

    DEBUG_MSG("Adding errors methods  to provide read access to the field errors (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:82:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::errors
    t.method("errors", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.errors; });
    t.method("errors", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.errors; });
    t.method("errors", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->errors; });
    t.method("errors", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->errors; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:82:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::errors
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding errors! methods to provide write access to the field errors (" __HERE__ ")");
    t.method("errors!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.errors = val; });

    DEBUG_MSG("Adding errors! methods to provide write access to the field errors (" __HERE__ ")");
    t.method("errors!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->errors = val; });

    DEBUG_MSG("Adding warnings methods  to provide read access to the field warnings (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:85:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::warnings
    t.method("warnings", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.warnings; });
    t.method("warnings", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.warnings; });
    t.method("warnings", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->warnings; });
    t.method("warnings", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->warnings; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:85:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::warnings
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding warnings! methods to provide write access to the field warnings (" __HERE__ ")");
    t.method("warnings!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.warnings = val; });

    DEBUG_MSG("Adding warnings! methods to provide write access to the field warnings (" __HERE__ ")");
    t.method("warnings!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->warnings = val; });

    DEBUG_MSG("Adding iterations methods  to provide read access to the field iterations (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:88:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::iterations
    t.method("iterations", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.iterations; });
    t.method("iterations", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.iterations; });
    t.method("iterations", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->iterations; });
    t.method("iterations", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->iterations; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:88:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::iterations
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding iterations! methods to provide write access to the field iterations (" __HERE__ ")");
    t.method("iterations!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.iterations = val; });

    DEBUG_MSG("Adding iterations! methods to provide write access to the field iterations (" __HERE__ ")");
    t.method("iterations!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->iterations = val; });

    DEBUG_MSG("Adding summary methods  to provide read access to the field summary (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:91:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::summary
    t.method("summary", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.summary; });
    t.method("summary", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.summary; });
    t.method("summary", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->summary; });
    t.method("summary", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->summary; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:91:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::summary
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding summary! methods to provide write access to the field summary (" __HERE__ ")");
    t.method("summary!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.summary = val; });

    DEBUG_MSG("Adding summary! methods to provide write access to the field summary (" __HERE__ ")");
    t.method("summary!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->summary = val; });

    DEBUG_MSG("Adding first_and_last methods  to provide read access to the field first_and_last (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:94:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::first_and_last
    t.method("first_and_last", [](const mfem::IterativeSolver::PrintLevel& a) -> bool { return a.first_and_last; });
    t.method("first_and_last", [](mfem::IterativeSolver::PrintLevel& a) -> bool { return a.first_and_last; });
    t.method("first_and_last", [](const mfem::IterativeSolver::PrintLevel* a) -> bool { return a->first_and_last; });
    t.method("first_and_last", [](mfem::IterativeSolver::PrintLevel* a) -> bool { return a->first_and_last; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:94:12
    // signature to use in the veto list: mfem::IterativeSolver::PrintLevel::first_and_last
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding first_and_last! methods to provide write access to the field first_and_last (" __HERE__ ")");
    t.method("first_and_last!", [](mfem::IterativeSolver::PrintLevel& a, bool val) -> bool { return a.first_and_last = val; });

    DEBUG_MSG("Adding first_and_last! methods to provide write access to the field first_and_last (" __HERE__ ")");
    t.method("first_and_last!", [](mfem::IterativeSolver::PrintLevel* a, bool val) -> bool { return a->first_and_last = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IterativeSolver::PrintLevel>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IterativeSolver_PrintLevel(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IterativeSolver_PrintLevel(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OperatorJacobiSmoother> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OperatorJacobiSmoother> : std::false_type { };
template<> struct SuperType<mfem::OperatorJacobiSmoother> { typedef mfem::Solver type; };
}

// Class generating the wrapper for type mfem::OperatorJacobiSmoother
// signature to use in the veto file: mfem::OperatorJacobiSmoother
struct Jlmfem_OperatorJacobiSmoother: public Wrapper {

  Jlmfem_OperatorJacobiSmoother(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OperatorJacobiSmoother (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:302:7
    jlcxx::TypeWrapper<mfem::OperatorJacobiSmoother>  t = jlModule.add_type<mfem::OperatorJacobiSmoother>("mfem!OperatorJacobiSmoother",
      jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorJacobiSmoother>>(new jlcxx::TypeWrapper<mfem::OperatorJacobiSmoother>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::OperatorJacobiSmoother(const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:308:4
    t.constructor<const double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::OperatorJacobiSmoother(const mfem::BilinearForm &, const mfem::Array<int> &, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:319:4
    t.constructor<const mfem::BilinearForm &, const mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::BilinearForm &, const mfem::Array<int> &, const double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::OperatorJacobiSmoother(const mfem::Vector &, const mfem::Array<int> &, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:332:4
    t.constructor<const mfem::Vector &, const mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Vector &, const mfem::Array<int> &, const double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::SetPositiveDiagonal(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::SetPositiveDiagonal(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:339:9
    t.method("SetPositiveDiagonal", static_cast<void (mfem::OperatorJacobiSmoother::*)(bool) >(&mfem::OperatorJacobiSmoother::SetPositiveDiagonal));
    t.method("SetPositiveDiagonal", [](mfem::OperatorJacobiSmoother& a)->void { a.SetPositiveDiagonal(); });
    t.method("SetPositiveDiagonal", [](mfem::OperatorJacobiSmoother* a)->void { a->SetPositiveDiagonal(); });

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:341:9
    t.method("Mult", static_cast<void (mfem::OperatorJacobiSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorJacobiSmoother::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:342:9
    t.method("MultTranspose", static_cast<void (mfem::OperatorJacobiSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorJacobiSmoother::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:355:9
    t.method("SetOperator", static_cast<void (mfem::OperatorJacobiSmoother::*)(const mfem::Operator &) >(&mfem::OperatorJacobiSmoother::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorJacobiSmoother::Setup(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorJacobiSmoother::Setup(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:372:9
    t.method("Setup", static_cast<void (mfem::OperatorJacobiSmoother::*)(const mfem::Vector &) >(&mfem::OperatorJacobiSmoother::Setup));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorJacobiSmoother>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OperatorJacobiSmoother(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OperatorJacobiSmoother(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BilinearForm> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BilinearForm> : std::false_type { };
template<> struct SuperType<mfem::BilinearForm> { typedef mfem::Matrix type; };
}

// Class generating the wrapper for type mfem::BilinearForm
// signature to use in the veto file: mfem::BilinearForm
struct Jlmfem_BilinearForm: public Wrapper {

  Jlmfem_BilinearForm(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BilinearForm (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:60:7
    jlcxx::TypeWrapper<mfem::BilinearForm>  t = jlModule.add_type<mfem::BilinearForm>("mfem!BilinearForm",
      jlcxx::julia_base_type<mfem::Matrix>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearForm>>(new jlcxx::TypeWrapper<mfem::BilinearForm>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::BilinearForm(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:170:4
    t.constructor<mfem::FiniteElementSpace *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::BilinearForm(mfem::FiniteElementSpace *, mfem::BilinearForm *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:182:4
    t.constructor<mfem::FiniteElementSpace *, mfem::BilinearForm *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::FiniteElementSpace *, mfem::BilinearForm *, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::BilinearForm::Size() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::BilinearForm::Size()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:185:8
    t.method("Size", static_cast<int (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::Size));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::SetAssemblyLevel(mfem::AssemblyLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::SetAssemblyLevel(mfem::AssemblyLevel)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:197:9
    t.method("SetAssemblyLevel", static_cast<void (mfem::BilinearForm::*)(mfem::AssemblyLevel) >(&mfem::BilinearForm::SetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EnableSparseMatrixSorting(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EnableSparseMatrixSorting(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:209:9
    t.method("EnableSparseMatrixSorting", static_cast<void (mfem::BilinearForm::*)(bool) >(&mfem::BilinearForm::EnableSparseMatrixSorting));

    DEBUG_MSG("Adding wrapper for mfem::AssemblyLevel mfem::BilinearForm::GetAssemblyLevel() (" __HERE__ ")");
    // signature to use in the veto list: mfem::AssemblyLevel mfem::BilinearForm::GetAssemblyLevel()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:215:18
    t.method("GetAssemblyLevel", static_cast<mfem::AssemblyLevel (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for mfem::Hybridization * mfem::BilinearForm::GetHybridization() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Hybridization * mfem::BilinearForm::GetHybridization()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:217:19
    t.method("GetHybridization", static_cast<mfem::Hybridization * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetHybridization));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EnableStaticCondensation() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EnableStaticCondensation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:223:9
    t.method("EnableStaticCondensation", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::EnableStaticCondensation));

    DEBUG_MSG("Adding wrapper for bool mfem::BilinearForm::StaticCondensationIsEnabled() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::BilinearForm::StaticCondensationIsEnabled()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:227:9
    t.method("StaticCondensationIsEnabled", static_cast<bool (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::StaticCondensationIsEnabled));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::BilinearForm::SCFESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::BilinearForm::SCFESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:230:24
    t.method("SCFESpace", static_cast<mfem::FiniteElementSpace * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::SCFESpace));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EnableHybridization(mfem::FiniteElementSpace *, mfem::BilinearFormIntegrator *, const mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EnableHybridization(mfem::FiniteElementSpace *, mfem::BilinearFormIntegrator *, const mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:237:9
    t.method("EnableHybridization", static_cast<void (mfem::BilinearForm::*)(mfem::FiniteElementSpace *, mfem::BilinearFormIntegrator *, const mfem::Array<int> &) >(&mfem::BilinearForm::EnableHybridization));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::UsePrecomputedSparsity(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::UsePrecomputedSparsity(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:244:9
    t.method("UsePrecomputedSparsity", static_cast<void (mfem::BilinearForm::*)(int) >(&mfem::BilinearForm::UsePrecomputedSparsity));
    t.method("UsePrecomputedSparsity", [](mfem::BilinearForm& a)->void { a.UsePrecomputedSparsity(); });
    t.method("UsePrecomputedSparsity", [](mfem::BilinearForm* a)->void { a->UsePrecomputedSparsity(); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::UseSparsity(int *, int *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::UseSparsity(int *, int *, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:255:9
    t.method("UseSparsity", static_cast<void (mfem::BilinearForm::*)(int *, int *, bool) >(&mfem::BilinearForm::UseSparsity));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::UseSparsity(mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::UseSparsity(mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:258:9
    t.method("UseSparsity", static_cast<void (mfem::BilinearForm::*)(mfem::SparseMatrix &) >(&mfem::BilinearForm::UseSparsity));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AllocateMatrix() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AllocateMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:264:9
    t.method("AllocateMatrix", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::AllocateMatrix));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::BilinearForm::GetDBFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::BilinearForm::GetDBFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:267:36
    t.method("GetDBFI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetDBFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::BilinearForm::GetDBFI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::BilinearForm::GetDBFI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:272:24
    t.method("GetDBFI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetDBFI_Marker));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::BilinearForm::GetBBFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::BilinearForm::GetBBFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:275:36
    t.method("GetBBFI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetBBFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::BilinearForm::GetBBFI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::BilinearForm::GetBBFI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:279:24
    t.method("GetBBFI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetBBFI_Marker));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::BilinearForm::GetFBFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::BilinearForm::GetFBFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:282:36
    t.method("GetFBFI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetFBFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::BilinearForm::GetBFBFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::BilinearForm::GetBFBFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:285:36
    t.method("GetBFBFI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetBFBFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::BilinearForm::GetBFBFI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::BilinearForm::GetBFBFI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:290:24
    t.method("GetBFBFI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetBFBFI_Marker));

    DEBUG_MSG("Adding wrapper for const double & mfem::BilinearForm::operator()(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::BilinearForm::operator()(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:294:18
    t.method("paren", static_cast<const double & (mfem::BilinearForm::*)(int, int) >(&mfem::BilinearForm::operator()));

    DEBUG_MSG("Adding wrapper for double & mfem::BilinearForm::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::BilinearForm::Elem(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:297:20
    t.method("Elem", static_cast<double & (mfem::BilinearForm::*)(int, int) >(&mfem::BilinearForm::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::BilinearForm::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::BilinearForm::Elem(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:300:26
    t.method("Elem", static_cast<const double & (mfem::BilinearForm::*)(int, int)  const>(&mfem::BilinearForm::Elem));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:303:17
    t.method("Mult", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FullMult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FullMult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:308:9
    t.method("FullMult", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::FullMult));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddMult(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddMult(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:312:17
    t.method("AddMult", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::BilinearForm::AddMult));
    t.method("AddMult", [](mfem::BilinearForm const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMult(arg0, arg1); });
    t.method("AddMult", [](mfem::BilinearForm const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FullAddMult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FullAddMult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:318:9
    t.method("FullAddMult", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::FullAddMult));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:322:17
    t.method("AddMultTranspose", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::BilinearForm::AddMultTranspose));
    t.method("AddMultTranspose", [](mfem::BilinearForm const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMultTranspose(arg0, arg1); });
    t.method("AddMultTranspose", [](mfem::BilinearForm const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMultTranspose(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FullAddMultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FullAddMultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:329:9
    t.method("FullAddMultTranspose", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::FullAddMultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:333:17
    t.method("MultTranspose", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearForm::MultTranspose));

    DEBUG_MSG("Adding wrapper for double mfem::BilinearForm::InnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::BilinearForm::InnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:336:11
    t.method("InnerProduct", static_cast<double (mfem::BilinearForm::*)(const mfem::Vector &, const mfem::Vector &)  const>(&mfem::BilinearForm::InnerProduct));

    DEBUG_MSG("Adding wrapper for mfem::MatrixInverse * mfem::BilinearForm::Inverse() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixInverse * mfem::BilinearForm::Inverse()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:341:27
    t.method("Inverse", static_cast<mfem::MatrixInverse * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::Inverse));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::Finalize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::Finalize(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:347:17
    t.method("Finalize", static_cast<void (mfem::BilinearForm::*)(int) >(&mfem::BilinearForm::Finalize));
    t.method("Finalize", [](mfem::BilinearForm& a)->void { a.Finalize(); });
    t.method("Finalize", [](mfem::BilinearForm* a)->void { a->Finalize(); });

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix & mfem::BilinearForm::SpMat() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix & mfem::BilinearForm::SpMat()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:352:24
    t.method("SpMat", static_cast<const mfem::SparseMatrix & (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::SpMat));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::BilinearForm::SpMat() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::BilinearForm::SpMat()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:361:18
    t.method("SpMat", static_cast<mfem::SparseMatrix & (mfem::BilinearForm::*)() >(&mfem::BilinearForm::SpMat));

    DEBUG_MSG("Adding wrapper for bool mfem::BilinearForm::HasSpMat() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::BilinearForm::HasSpMat()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:370:9
    t.method("HasSpMat", static_cast<bool (mfem::BilinearForm::*)() >(&mfem::BilinearForm::HasSpMat));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::BilinearForm::LoseMat() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::BilinearForm::LoseMat()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:378:18
    t.method("LoseMat", static_cast<mfem::SparseMatrix * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::LoseMat));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix & mfem::BilinearForm::SpMatElim() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix & mfem::BilinearForm::SpMatElim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:384:24
    t.method("SpMatElim", static_cast<const mfem::SparseMatrix & (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::SpMatElim));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::BilinearForm::SpMatElim() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::BilinearForm::SpMatElim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:394:18
    t.method("SpMatElim", static_cast<mfem::SparseMatrix & (mfem::BilinearForm::*)() >(&mfem::BilinearForm::SpMatElim));

    DEBUG_MSG("Adding wrapper for bool mfem::BilinearForm::HasSpMatElim() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::BilinearForm::HasSpMatElim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:404:9
    t.method("HasSpMatElim", static_cast<bool (mfem::BilinearForm::*)() >(&mfem::BilinearForm::HasSpMatElim));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:410:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::BilinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:414:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *, mfem::Array<int> &) >(&mfem::BilinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:418:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::BilinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:425:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *, mfem::Array<int> &) >(&mfem::BilinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddInteriorFaceIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddInteriorFaceIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:429:9
    t.method("AddInteriorFaceIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::BilinearForm::AddInteriorFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddBdrFaceIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddBdrFaceIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:432:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::BilinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AddBdrFaceIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AddBdrFaceIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:439:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::BilinearForm::*)(mfem::BilinearFormIntegrator *, mfem::Array<int> &) >(&mfem::BilinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::operator=(const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::operator=(const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:443:9
    t.method("assign", static_cast<void (mfem::BilinearForm::*)(const double) >(&mfem::BilinearForm::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::Assemble(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::Assemble(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:450:9
    t.method("Assemble", static_cast<void (mfem::BilinearForm::*)(int) >(&mfem::BilinearForm::Assemble));
    t.method("Assemble", [](mfem::BilinearForm& a)->void { a.Assemble(); });
    t.method("Assemble", [](mfem::BilinearForm* a)->void { a->Assemble(); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AssembleDiagonal(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AssembleDiagonal(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:461:17
    t.method("AssembleDiagonal", static_cast<void (mfem::BilinearForm::*)(mfem::Vector &)  const>(&mfem::BilinearForm::AssembleDiagonal));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:464:28
    t.method("GetProlongation", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:468:28
    t.method("GetRestriction", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetOutputProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetOutputProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:472:28
    t.method("GetOutputProlongation", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetOutputProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetOutputRestrictionTranspose() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetOutputRestrictionTranspose()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:480:28
    t.method("GetOutputRestrictionTranspose", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetOutputRestrictionTranspose));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::BilinearForm::GetOutputRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::BilinearForm::GetOutputRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:484:28
    t.method("GetOutputRestriction", static_cast<const mfem::Operator * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::GetOutputRestriction));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::SerialRAP(mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::SerialRAP(mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:488:9
    t.method("SerialRAP", static_cast<void (mfem::BilinearForm::*)(mfem::OperatorHandle &) >(&mfem::BilinearForm::SerialRAP));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FormLinearSystem(const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::OperatorHandle &, mfem::Vector &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FormLinearSystem(const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::OperatorHandle &, mfem::Vector &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:521:17
    t.method("FormLinearSystem", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::OperatorHandle &, mfem::Vector &, mfem::Vector &, int) >(&mfem::BilinearForm::FormLinearSystem));
    t.method("FormLinearSystem", [](mfem::BilinearForm& a, const mfem::Array<int> & arg0, mfem::Vector & arg1, mfem::Vector & arg2, mfem::OperatorHandle & arg3, mfem::Vector & arg4, mfem::Vector & arg5)->void { a.FormLinearSystem(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("FormLinearSystem", [](mfem::BilinearForm* a, const mfem::Array<int> & arg0, mfem::Vector & arg1, mfem::Vector & arg2, mfem::OperatorHandle & arg3, mfem::Vector & arg4, mfem::Vector & arg5)->void { a->FormLinearSystem(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FormLinearSystem(const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::SparseMatrix &, mfem::Vector &, mfem::Vector &, int) (" __HERE__ ")");
    // Template stuff
    t.method("FormLinearSystem", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::SparseMatrix &, mfem::Vector &, mfem::Vector &, int) >(&mfem::BilinearForm::FormLinearSystem));
    t.method("FormLinearSystem", [](mfem::BilinearForm& a, const mfem::Array<int> & arg0, mfem::Vector & arg1, mfem::Vector & arg2, mfem::SparseMatrix & arg3, mfem::Vector & arg4, mfem::Vector & arg5)->void { a.FormLinearSystem(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("FormLinearSystem", [](mfem::BilinearForm* a, const mfem::Array<int> & arg0, mfem::Vector & arg1, mfem::Vector & arg2, mfem::SparseMatrix & arg3, mfem::Vector & arg4, mfem::Vector & arg5)->void { a->FormLinearSystem(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FormSystemMatrix(const mfem::Array<int> &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FormSystemMatrix(const mfem::Array<int> &, mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:545:17
    t.method("FormSystemMatrix", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, mfem::OperatorHandle &) >(&mfem::BilinearForm::FormSystemMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::RecoverFEMSolution(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::RecoverFEMSolution(const mfem::Vector &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:569:17
    t.method("RecoverFEMSolution", static_cast<void (mfem::BilinearForm::*)(const mfem::Vector &, const mfem::Vector &, mfem::Vector &) >(&mfem::BilinearForm::RecoverFEMSolution));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::ComputeElementMatrices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::ComputeElementMatrices()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:572:9
    t.method("ComputeElementMatrices", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::ComputeElementMatrices));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::FreeElementMatrices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::FreeElementMatrices()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:575:9
    t.method("FreeElementMatrices", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::FreeElementMatrices));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::ComputeElementMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::ComputeElementMatrix(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:583:9
    t.method("ComputeElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, mfem::DenseMatrix &) >(&mfem::BilinearForm::ComputeElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::ComputeBdrElementMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::ComputeBdrElementMatrix(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:586:9
    t.method("ComputeBdrElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, mfem::DenseMatrix &) >(&mfem::BilinearForm::ComputeBdrElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:594:9
    t.method("AssembleElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, const mfem::DenseMatrix &, int) >(&mfem::BilinearForm::AssembleElementMatrix));
    t.method("AssembleElementMatrix", [](mfem::BilinearForm& a, int arg0, const mfem::DenseMatrix & arg1)->void { a.AssembleElementMatrix(arg0, arg1); });
    t.method("AssembleElementMatrix", [](mfem::BilinearForm* a, int arg0, const mfem::DenseMatrix & arg1)->void { a->AssembleElementMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:603:9
    t.method("AssembleElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, const mfem::DenseMatrix &, mfem::Array<int> &, int) >(&mfem::BilinearForm::AssembleElementMatrix));
    t.method("AssembleElementMatrix", [](mfem::BilinearForm& a, int arg0, const mfem::DenseMatrix & arg1, mfem::Array<int> & arg2)->void { a.AssembleElementMatrix(arg0, arg1, arg2); });
    t.method("AssembleElementMatrix", [](mfem::BilinearForm* a, int arg0, const mfem::DenseMatrix & arg1, mfem::Array<int> & arg2)->void { a->AssembleElementMatrix(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:612:9
    t.method("AssembleBdrElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, const mfem::DenseMatrix &, int) >(&mfem::BilinearForm::AssembleBdrElementMatrix));
    t.method("AssembleBdrElementMatrix", [](mfem::BilinearForm& a, int arg0, const mfem::DenseMatrix & arg1)->void { a.AssembleBdrElementMatrix(arg0, arg1); });
    t.method("AssembleBdrElementMatrix", [](mfem::BilinearForm* a, int arg0, const mfem::DenseMatrix & arg1)->void { a->AssembleBdrElementMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:621:9
    t.method("AssembleBdrElementMatrix", static_cast<void (mfem::BilinearForm::*)(int, const mfem::DenseMatrix &, mfem::Array<int> &, int) >(&mfem::BilinearForm::AssembleBdrElementMatrix));
    t.method("AssembleBdrElementMatrix", [](mfem::BilinearForm& a, int arg0, const mfem::DenseMatrix & arg1, mfem::Array<int> & arg2)->void { a.AssembleBdrElementMatrix(arg0, arg1, arg2); });
    t.method("AssembleBdrElementMatrix", [](mfem::BilinearForm* a, int arg0, const mfem::DenseMatrix & arg1, mfem::Array<int> & arg2)->void { a->AssembleBdrElementMatrix(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateEssentialBC(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateEssentialBC(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:629:9
    t.method("EliminateEssentialBC", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy) >(&mfem::BilinearForm::EliminateEssentialBC));
    t.method("EliminateEssentialBC", [](mfem::BilinearForm& a, const mfem::Array<int> & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a.EliminateEssentialBC(arg0, arg1, arg2); });
    t.method("EliminateEssentialBC", [](mfem::BilinearForm* a, const mfem::Array<int> & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a->EliminateEssentialBC(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateEssentialBC(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateEssentialBC(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:634:9
    t.method("EliminateEssentialBC", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy) >(&mfem::BilinearForm::EliminateEssentialBC));
    t.method("EliminateEssentialBC", [](mfem::BilinearForm& a, const mfem::Array<int> & arg0)->void { a.EliminateEssentialBC(arg0); });
    t.method("EliminateEssentialBC", [](mfem::BilinearForm* a, const mfem::Array<int> & arg0)->void { a->EliminateEssentialBC(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateEssentialBCDiag(const mfem::Array<int> &, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateEssentialBCDiag(const mfem::Array<int> &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:637:9
    t.method("EliminateEssentialBCDiag", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, double) >(&mfem::BilinearForm::EliminateEssentialBCDiag));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateVDofs(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateVDofs(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:643:9
    t.method("EliminateVDofs", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy) >(&mfem::BilinearForm::EliminateVDofs));
    t.method("EliminateVDofs", [](mfem::BilinearForm& a, const mfem::Array<int> & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a.EliminateVDofs(arg0, arg1, arg2); });
    t.method("EliminateVDofs", [](mfem::BilinearForm* a, const mfem::Array<int> & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a->EliminateVDofs(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateVDofs(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateVDofs(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:652:9
    t.method("EliminateVDofs", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy) >(&mfem::BilinearForm::EliminateVDofs));
    t.method("EliminateVDofs", [](mfem::BilinearForm& a, const mfem::Array<int> & arg0)->void { a.EliminateVDofs(arg0); });
    t.method("EliminateVDofs", [](mfem::BilinearForm* a, const mfem::Array<int> & arg0)->void { a->EliminateVDofs(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateEssentialBCFromDofs(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateEssentialBCFromDofs(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:660:9
    t.method("EliminateEssentialBCFromDofs", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &, mfem::Operator::DiagonalPolicy) >(&mfem::BilinearForm::EliminateEssentialBCFromDofs));
    t.method("EliminateEssentialBCFromDofs", [](mfem::BilinearForm& a, const mfem::Array<int> & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a.EliminateEssentialBCFromDofs(arg0, arg1, arg2); });
    t.method("EliminateEssentialBCFromDofs", [](mfem::BilinearForm* a, const mfem::Array<int> & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { a->EliminateEssentialBCFromDofs(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateEssentialBCFromDofs(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateEssentialBCFromDofs(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:668:9
    t.method("EliminateEssentialBCFromDofs", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, mfem::Operator::DiagonalPolicy) >(&mfem::BilinearForm::EliminateEssentialBCFromDofs));
    t.method("EliminateEssentialBCFromDofs", [](mfem::BilinearForm& a, const mfem::Array<int> & arg0)->void { a.EliminateEssentialBCFromDofs(arg0); });
    t.method("EliminateEssentialBCFromDofs", [](mfem::BilinearForm* a, const mfem::Array<int> & arg0)->void { a->EliminateEssentialBCFromDofs(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateEssentialBCFromDofsDiag(const mfem::Array<int> &, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateEssentialBCFromDofsDiag(const mfem::Array<int> &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:671:9
    t.method("EliminateEssentialBCFromDofsDiag", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, double) >(&mfem::BilinearForm::EliminateEssentialBCFromDofsDiag));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::EliminateVDofsInRHS(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::EliminateVDofsInRHS(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:677:9
    t.method("EliminateVDofsInRHS", static_cast<void (mfem::BilinearForm::*)(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &) >(&mfem::BilinearForm::EliminateVDofsInRHS));

    DEBUG_MSG("Adding wrapper for double mfem::BilinearForm::FullInnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::BilinearForm::FullInnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:682:11
    t.method("FullInnerProduct", static_cast<double (mfem::BilinearForm::*)(const mfem::Vector &, const mfem::Vector &)  const>(&mfem::BilinearForm::FullInnerProduct));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::Update(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::Update(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:687:17
    t.method("Update", static_cast<void (mfem::BilinearForm::*)(mfem::FiniteElementSpace *) >(&mfem::BilinearForm::Update));
    t.method("Update", [](mfem::BilinearForm& a)->void { a.Update(); });
    t.method("Update", [](mfem::BilinearForm* a)->void { a->Update(); });

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::BilinearForm::GetFES() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::BilinearForm::GetFES()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:691:40
    t.method("GetFES", static_cast<mfem::FiniteElementSpace * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::GetFES));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::BilinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::BilinearForm::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:694:24
    t.method("FESpace", static_cast<mfem::FiniteElementSpace * (mfem::BilinearForm::*)() >(&mfem::BilinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::BilinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::BilinearForm::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:697:30
    t.method("FESpace", static_cast<const mfem::FiniteElementSpace * (mfem::BilinearForm::*)()  const>(&mfem::BilinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::SetDiagonalPolicy(mfem::Operator::DiagonalPolicy) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::SetDiagonalPolicy(mfem::Operator::DiagonalPolicy)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:707:9
    t.method("SetDiagonalPolicy", static_cast<void (mfem::BilinearForm::*)(mfem::Operator::DiagonalPolicy) >(&mfem::BilinearForm::SetDiagonalPolicy));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearForm::UseExternalIntegrators() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearForm::UseExternalIntegrators()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:710:9
    t.method("UseExternalIntegrators", static_cast<void (mfem::BilinearForm::*)() >(&mfem::BilinearForm::UseExternalIntegrators));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearForm>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BilinearForm(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BilinearForm(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OperatorChebyshevSmoother> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OperatorChebyshevSmoother> : std::false_type { };
template<> struct SuperType<mfem::OperatorChebyshevSmoother> { typedef mfem::Solver type; };
}

// Class generating the wrapper for type mfem::OperatorChebyshevSmoother
// signature to use in the veto file: mfem::OperatorChebyshevSmoother
struct Jlmfem_OperatorChebyshevSmoother: public Wrapper {

  Jlmfem_OperatorChebyshevSmoother(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OperatorChebyshevSmoother (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:379:7
    jlcxx::TypeWrapper<mfem::OperatorChebyshevSmoother>  t = jlModule.add_type<mfem::OperatorChebyshevSmoother>("mfem!OperatorChebyshevSmoother",
      jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorChebyshevSmoother>>(new jlcxx::TypeWrapper<mfem::OperatorChebyshevSmoother>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::OperatorChebyshevSmoother(const mfem::Operator &, const mfem::Vector &, const mfem::Array<int> &, int, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:388:4
    t.constructor<const mfem::Operator &, const mfem::Vector &, const mfem::Array<int> &, int, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::OperatorChebyshevSmoother(const mfem::Operator *, const mfem::Vector &, const mfem::Array<int> &, int, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:394:4
    t.constructor<const mfem::Operator *, const mfem::Vector &, const mfem::Array<int> &, int, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::OperatorChebyshevSmoother(const mfem::Operator &, const mfem::Vector &, const mfem::Array<int> &, int, int, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:420:4
    t.constructor<const mfem::Operator &, const mfem::Vector &, const mfem::Array<int> &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Operator &, const mfem::Vector &, const mfem::Array<int> &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Operator &, const mfem::Vector &, const mfem::Array<int> &, int, int, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::OperatorChebyshevSmoother(const mfem::Operator *, const mfem::Vector &, const mfem::Array<int> &, int, int, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:427:4
    t.constructor<const mfem::Operator *, const mfem::Vector &, const mfem::Array<int> &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Operator *, const mfem::Vector &, const mfem::Array<int> &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Operator *, const mfem::Vector &, const mfem::Array<int> &, int, int, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorChebyshevSmoother::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:435:9
    t.method("Mult", static_cast<void (mfem::OperatorChebyshevSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorChebyshevSmoother::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorChebyshevSmoother::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:437:9
    t.method("MultTranspose", static_cast<void (mfem::OperatorChebyshevSmoother::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OperatorChebyshevSmoother::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorChebyshevSmoother::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:439:9
    t.method("SetOperator", static_cast<void (mfem::OperatorChebyshevSmoother::*)(const mfem::Operator &) >(&mfem::OperatorChebyshevSmoother::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::OperatorChebyshevSmoother::Setup() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OperatorChebyshevSmoother::Setup()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:444:9
    t.method("Setup", static_cast<void (mfem::OperatorChebyshevSmoother::*)() >(&mfem::OperatorChebyshevSmoother::Setup));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorChebyshevSmoother>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OperatorChebyshevSmoother(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OperatorChebyshevSmoother(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SLISolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SLISolver> : std::false_type { };
template<> struct SuperType<mfem::SLISolver> { typedef mfem::IterativeSolver type; };
}

// Class generating the wrapper for type mfem::SLISolver
// signature to use in the veto file: mfem::SLISolver
struct Jlmfem_SLISolver: public Wrapper {

  Jlmfem_SLISolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SLISolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:461:7
    jlcxx::TypeWrapper<mfem::SLISolver>  t = jlModule.add_type<mfem::SLISolver>("mfem!SLISolver",
      jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SLISolver>>(new jlcxx::TypeWrapper<mfem::SLISolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::SLISolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLISolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:475:17
    t.method("SetOperator", static_cast<void (mfem::SLISolver::*)(const mfem::Operator &) >(&mfem::SLISolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::SLISolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLISolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:478:17
    t.method("Mult", static_cast<void (mfem::SLISolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SLISolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SLISolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SLISolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SLISolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CGSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CGSolver> : std::false_type { };
template<> struct SuperType<mfem::CGSolver> { typedef mfem::IterativeSolver type; };
}

// Class generating the wrapper for type mfem::CGSolver
// signature to use in the veto file: mfem::CGSolver
struct Jlmfem_CGSolver: public Wrapper {

  Jlmfem_CGSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CGSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:493:7
    jlcxx::TypeWrapper<mfem::CGSolver>  t = jlModule.add_type<mfem::CGSolver>("mfem!CGSolver",
      jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CGSolver>>(new jlcxx::TypeWrapper<mfem::CGSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::CGSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CGSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:507:17
    t.method("SetOperator", static_cast<void (mfem::CGSolver::*)(const mfem::Operator &) >(&mfem::CGSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::CGSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CGSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:510:17
    t.method("Mult", static_cast<void (mfem::CGSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::CGSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CGSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CGSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CGSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GMRESSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GMRESSolver> : std::false_type { };
template<> struct SuperType<mfem::GMRESSolver> { typedef mfem::IterativeSolver type; };
}

// Class generating the wrapper for type mfem::GMRESSolver
// signature to use in the veto file: mfem::GMRESSolver
struct Jlmfem_GMRESSolver: public Wrapper {

  Jlmfem_GMRESSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GMRESSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:525:7
    jlcxx::TypeWrapper<mfem::GMRESSolver>  t = jlModule.add_type<mfem::GMRESSolver>("mfem!GMRESSolver",
      jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GMRESSolver>>(new jlcxx::TypeWrapper<mfem::GMRESSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::GMRESSolver::SetKDim(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GMRESSolver::SetKDim(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:538:9
    t.method("SetKDim", static_cast<void (mfem::GMRESSolver::*)(int) >(&mfem::GMRESSolver::SetKDim));

    DEBUG_MSG("Adding wrapper for void mfem::GMRESSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GMRESSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:540:17
    t.method("Mult", static_cast<void (mfem::GMRESSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::GMRESSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GMRESSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GMRESSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GMRESSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FGMRESSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FGMRESSolver> : std::false_type { };
template<> struct SuperType<mfem::FGMRESSolver> { typedef mfem::IterativeSolver type; };
}

// Class generating the wrapper for type mfem::FGMRESSolver
// signature to use in the veto file: mfem::FGMRESSolver
struct Jlmfem_FGMRESSolver: public Wrapper {

  Jlmfem_FGMRESSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FGMRESSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:544:7
    jlcxx::TypeWrapper<mfem::FGMRESSolver>  t = jlModule.add_type<mfem::FGMRESSolver>("mfem!FGMRESSolver",
      jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FGMRESSolver>>(new jlcxx::TypeWrapper<mfem::FGMRESSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::FGMRESSolver::SetKDim(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FGMRESSolver::SetKDim(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:556:9
    t.method("SetKDim", static_cast<void (mfem::FGMRESSolver::*)(int) >(&mfem::FGMRESSolver::SetKDim));

    DEBUG_MSG("Adding wrapper for void mfem::FGMRESSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FGMRESSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:558:17
    t.method("Mult", static_cast<void (mfem::FGMRESSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::FGMRESSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FGMRESSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FGMRESSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FGMRESSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BiCGSTABSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BiCGSTABSolver> : std::false_type { };
template<> struct SuperType<mfem::BiCGSTABSolver> { typedef mfem::IterativeSolver type; };
}

// Class generating the wrapper for type mfem::BiCGSTABSolver
// signature to use in the veto file: mfem::BiCGSTABSolver
struct Jlmfem_BiCGSTABSolver: public Wrapper {

  Jlmfem_BiCGSTABSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BiCGSTABSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:572:7
    jlcxx::TypeWrapper<mfem::BiCGSTABSolver>  t = jlModule.add_type<mfem::BiCGSTABSolver>("mfem!BiCGSTABSolver",
      jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BiCGSTABSolver>>(new jlcxx::TypeWrapper<mfem::BiCGSTABSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::BiCGSTABSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BiCGSTABSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:586:17
    t.method("SetOperator", static_cast<void (mfem::BiCGSTABSolver::*)(const mfem::Operator &) >(&mfem::BiCGSTABSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::BiCGSTABSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BiCGSTABSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:589:17
    t.method("Mult", static_cast<void (mfem::BiCGSTABSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BiCGSTABSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BiCGSTABSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BiCGSTABSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BiCGSTABSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MINRESSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MINRESSolver> : std::false_type { };
template<> struct SuperType<mfem::MINRESSolver> { typedef mfem::IterativeSolver type; };
}

// Class generating the wrapper for type mfem::MINRESSolver
// signature to use in the veto file: mfem::MINRESSolver
struct Jlmfem_MINRESSolver: public Wrapper {

  Jlmfem_MINRESSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MINRESSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:603:7
    jlcxx::TypeWrapper<mfem::MINRESSolver>  t = jlModule.add_type<mfem::MINRESSolver>("mfem!MINRESSolver",
      jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MINRESSolver>>(new jlcxx::TypeWrapper<mfem::MINRESSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MINRESSolver::SetPreconditioner(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRESSolver::SetPreconditioner(mfem::Solver &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:616:17
    t.method("SetPreconditioner", static_cast<void (mfem::MINRESSolver::*)(mfem::Solver &) >(&mfem::MINRESSolver::SetPreconditioner));

    DEBUG_MSG("Adding wrapper for void mfem::MINRESSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRESSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:622:17
    t.method("SetOperator", static_cast<void (mfem::MINRESSolver::*)(const mfem::Operator &) >(&mfem::MINRESSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::MINRESSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRESSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:624:17
    t.method("Mult", static_cast<void (mfem::MINRESSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MINRESSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MINRESSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MINRESSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MINRESSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NewtonSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NewtonSolver> : std::false_type { };
template<> struct SuperType<mfem::NewtonSolver> { typedef mfem::IterativeSolver type; };
}

// Class generating the wrapper for type mfem::NewtonSolver
// signature to use in the veto file: mfem::NewtonSolver
struct Jlmfem_NewtonSolver: public Wrapper {

  Jlmfem_NewtonSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NewtonSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:641:7
    jlcxx::TypeWrapper<mfem::NewtonSolver>  t = jlModule.add_type<mfem::NewtonSolver>("mfem!NewtonSolver",
      jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NewtonSolver>>(new jlcxx::TypeWrapper<mfem::NewtonSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:685:17
    t.method("SetOperator", static_cast<void (mfem::NewtonSolver::*)(const mfem::Operator &) >(&mfem::NewtonSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::SetSolver(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::SetSolver(mfem::Solver &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:689:17
    t.method("SetSolver", static_cast<void (mfem::NewtonSolver::*)(mfem::Solver &) >(&mfem::NewtonSolver::SetSolver));

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:693:17
    t.method("Mult", static_cast<void (mfem::NewtonSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::NewtonSolver::Mult));

    DEBUG_MSG("Adding wrapper for double mfem::NewtonSolver::ComputeScalingFactor(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::NewtonSolver::ComputeScalingFactor(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:699:19
    t.method("ComputeScalingFactor", static_cast<double (mfem::NewtonSolver::*)(const mfem::Vector &, const mfem::Vector &)  const>(&mfem::NewtonSolver::ComputeScalingFactor));

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::ProcessNewState(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::ProcessNewState(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:704:17
    t.method("ProcessNewState", static_cast<void (mfem::NewtonSolver::*)(const mfem::Vector &)  const>(&mfem::NewtonSolver::ProcessNewState));

    DEBUG_MSG("Adding wrapper for void mfem::NewtonSolver::SetAdaptiveLinRtol(const int, const double, const double, const double, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NewtonSolver::SetAdaptiveLinRtol(const int, const double, const double, const double, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:717:9
    t.method("SetAdaptiveLinRtol", static_cast<void (mfem::NewtonSolver::*)(const int, const double, const double, const double, const double) >(&mfem::NewtonSolver::SetAdaptiveLinRtol));
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a)->void { a.SetAdaptiveLinRtol(); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a, const int arg0)->void { a.SetAdaptiveLinRtol(arg0); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a, const int arg0, const double arg1)->void { a.SetAdaptiveLinRtol(arg0, arg1); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a, const int arg0, const double arg1, const double arg2)->void { a.SetAdaptiveLinRtol(arg0, arg1, arg2); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver& a, const int arg0, const double arg1, const double arg2, const double arg3)->void { a.SetAdaptiveLinRtol(arg0, arg1, arg2, arg3); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a)->void { a->SetAdaptiveLinRtol(); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a, const int arg0)->void { a->SetAdaptiveLinRtol(arg0); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a, const int arg0, const double arg1)->void { a->SetAdaptiveLinRtol(arg0, arg1); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a, const int arg0, const double arg1, const double arg2)->void { a->SetAdaptiveLinRtol(arg0, arg1, arg2); });
    t.method("SetAdaptiveLinRtol", [](mfem::NewtonSolver* a, const int arg0, const double arg1, const double arg2, const double arg3)->void { a->SetAdaptiveLinRtol(arg0, arg1, arg2, arg3); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NewtonSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NewtonSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NewtonSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LBFGSSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LBFGSSolver> : std::false_type { };
template<> struct SuperType<mfem::LBFGSSolver> { typedef mfem::NewtonSolver type; };
}

// Class generating the wrapper for type mfem::LBFGSSolver
// signature to use in the veto file: mfem::LBFGSSolver
struct Jlmfem_LBFGSSolver: public Wrapper {

  Jlmfem_LBFGSSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LBFGSSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:726:7
    jlcxx::TypeWrapper<mfem::LBFGSSolver>  t = jlModule.add_type<mfem::LBFGSSolver>("mfem!LBFGSSolver",
      jlcxx::julia_base_type<mfem::NewtonSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LBFGSSolver>>(new jlcxx::TypeWrapper<mfem::LBFGSSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:762:17
    t.method("SetOperator", static_cast<void (mfem::LBFGSSolver::*)(const mfem::Operator &) >(&mfem::LBFGSSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::SetHistorySize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::SetHistorySize(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:768:9
    t.method("SetHistorySize", static_cast<void (mfem::LBFGSSolver::*)(int) >(&mfem::LBFGSSolver::SetHistorySize));

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:776:17
    t.method("Mult", static_cast<void (mfem::LBFGSSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::LBFGSSolver::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::SetPreconditioner(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::SetPreconditioner(mfem::Solver &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:778:17
    t.method("SetPreconditioner", static_cast<void (mfem::LBFGSSolver::*)(mfem::Solver &) >(&mfem::LBFGSSolver::SetPreconditioner));

    DEBUG_MSG("Adding wrapper for void mfem::LBFGSSolver::SetSolver(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LBFGSSolver::SetSolver(mfem::Solver &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:780:17
    t.method("SetSolver", static_cast<void (mfem::LBFGSSolver::*)(mfem::Solver &) >(&mfem::LBFGSSolver::SetSolver));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LBFGSSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LBFGSSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LBFGSSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OptimizationProblem> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OptimizationProblem> : std::false_type { };
}

// Class generating the wrapper for type mfem::OptimizationProblem
// signature to use in the veto file: mfem::OptimizationProblem
struct Jlmfem_OptimizationProblem: public Wrapper {

  Jlmfem_OptimizationProblem(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OptimizationProblem (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:816:7
    jlcxx::TypeWrapper<mfem::OptimizationProblem>  t = jlModule.add_type<mfem::OptimizationProblem>("mfem!OptimizationProblem");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OptimizationProblem>>(new jlcxx::TypeWrapper<mfem::OptimizationProblem>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for double mfem::OptimizationProblem::CalcObjective(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::OptimizationProblem::CalcObjective(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:844:19
    t.method("CalcObjective", static_cast<double (mfem::OptimizationProblem::*)(const mfem::Vector &)  const>(&mfem::OptimizationProblem::CalcObjective));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationProblem::CalcObjectiveGrad(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationProblem::CalcObjectiveGrad(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:846:17
    t.method("CalcObjectiveGrad", static_cast<void (mfem::OptimizationProblem::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OptimizationProblem::CalcObjectiveGrad));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationProblem::SetEqualityConstraint(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationProblem::SetEqualityConstraint(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:849:9
    t.method("SetEqualityConstraint", static_cast<void (mfem::OptimizationProblem::*)(const mfem::Vector &) >(&mfem::OptimizationProblem::SetEqualityConstraint));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationProblem::SetInequalityConstraint(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationProblem::SetInequalityConstraint(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:850:9
    t.method("SetInequalityConstraint", static_cast<void (mfem::OptimizationProblem::*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::OptimizationProblem::SetInequalityConstraint));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationProblem::SetSolutionBounds(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationProblem::SetSolutionBounds(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:851:9
    t.method("SetSolutionBounds", static_cast<void (mfem::OptimizationProblem::*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::OptimizationProblem::SetSolutionBounds));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::OptimizationProblem::GetC() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::OptimizationProblem::GetC()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:853:20
    t.method("GetC", static_cast<const mfem::Operator * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetC));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::OptimizationProblem::GetD() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::OptimizationProblem::GetD()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:854:20
    t.method("GetD", static_cast<const mfem::Operator * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetD));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetEqualityVec() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetEqualityVec()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:855:18
    t.method("GetEqualityVec", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetEqualityVec));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetInequalityVec_Lo() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetInequalityVec_Lo()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:856:18
    t.method("GetInequalityVec_Lo", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetInequalityVec_Lo));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetInequalityVec_Hi() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetInequalityVec_Hi()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:857:18
    t.method("GetInequalityVec_Hi", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetInequalityVec_Hi));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetBoundsVec_Lo() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetBoundsVec_Lo()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:858:18
    t.method("GetBoundsVec_Lo", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetBoundsVec_Lo));

    DEBUG_MSG("Adding wrapper for const mfem::Vector * mfem::OptimizationProblem::GetBoundsVec_Hi() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector * mfem::OptimizationProblem::GetBoundsVec_Hi()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:859:18
    t.method("GetBoundsVec_Hi", static_cast<const mfem::Vector * (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetBoundsVec_Hi));

    DEBUG_MSG("Adding wrapper for int mfem::OptimizationProblem::GetNumConstraints() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::OptimizationProblem::GetNumConstraints()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:861:8
    t.method("GetNumConstraints", static_cast<int (mfem::OptimizationProblem::*)()  const>(&mfem::OptimizationProblem::GetNumConstraints));

    DEBUG_MSG("Adding input_size methods  to provide read access to the field input_size (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:838:14
    // signature to use in the veto list: mfem::OptimizationProblem::input_size
    t.method("input_size", [](const mfem::OptimizationProblem& a) -> int { return a.input_size; });
    t.method("input_size", [](const mfem::OptimizationProblem* a) -> int { return a->input_size; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OptimizationProblem>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OptimizationProblem(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OptimizationProblem(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OptimizationSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OptimizationSolver> : std::false_type { };
template<> struct SuperType<mfem::OptimizationSolver> { typedef mfem::IterativeSolver type; };
}

// Class generating the wrapper for type mfem::OptimizationSolver
// signature to use in the veto file: mfem::OptimizationSolver
struct Jlmfem_OptimizationSolver: public Wrapper {

  Jlmfem_OptimizationSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OptimizationSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:865:7
    jlcxx::TypeWrapper<mfem::OptimizationSolver>  t = jlModule.add_type<mfem::OptimizationSolver>("mfem!OptimizationSolver",
      jlcxx::julia_base_type<mfem::IterativeSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OptimizationSolver>>(new jlcxx::TypeWrapper<mfem::OptimizationSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationSolver::SetOptimizationProblem(const mfem::OptimizationProblem &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationSolver::SetOptimizationProblem(const mfem::OptimizationProblem &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:879:17
    t.method("SetOptimizationProblem", static_cast<void (mfem::OptimizationSolver::*)(const mfem::OptimizationProblem &) >(&mfem::OptimizationSolver::SetOptimizationProblem));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:882:17
    t.method("Mult", static_cast<void (mfem::OptimizationSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OptimizationSolver::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationSolver::SetPreconditioner(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationSolver::SetPreconditioner(mfem::Solver &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:884:17
    t.method("SetPreconditioner", static_cast<void (mfem::OptimizationSolver::*)(mfem::Solver &) >(&mfem::OptimizationSolver::SetPreconditioner));

    DEBUG_MSG("Adding wrapper for void mfem::OptimizationSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OptimizationSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:886:17
    t.method("SetOperator", static_cast<void (mfem::OptimizationSolver::*)(const mfem::Operator &) >(&mfem::OptimizationSolver::SetOperator));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OptimizationSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OptimizationSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OptimizationSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SLBQPOptimizer> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SLBQPOptimizer> : std::false_type { };
template<> struct SuperType<mfem::SLBQPOptimizer> { typedef mfem::OptimizationSolver type; };
}

// Class generating the wrapper for type mfem::SLBQPOptimizer
// signature to use in the veto file: mfem::SLBQPOptimizer
struct Jlmfem_SLBQPOptimizer: public Wrapper {

  Jlmfem_SLBQPOptimizer(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SLBQPOptimizer (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:897:7
    jlcxx::TypeWrapper<mfem::SLBQPOptimizer>  t = jlModule.add_type<mfem::SLBQPOptimizer>("mfem!SLBQPOptimizer",
      jlcxx::julia_base_type<mfem::OptimizationSolver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SLBQPOptimizer>>(new jlcxx::TypeWrapper<mfem::SLBQPOptimizer>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::SLBQPOptimizer::SetOptimizationProblem(const mfem::OptimizationProblem &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLBQPOptimizer::SetOptimizationProblem(const mfem::OptimizationProblem &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:937:17
    t.method("SetOptimizationProblem", static_cast<void (mfem::SLBQPOptimizer::*)(const mfem::OptimizationProblem &) >(&mfem::SLBQPOptimizer::SetOptimizationProblem));

    DEBUG_MSG("Adding wrapper for void mfem::SLBQPOptimizer::SetBounds(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLBQPOptimizer::SetBounds(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:939:9
    t.method("SetBounds", static_cast<void (mfem::SLBQPOptimizer::*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::SLBQPOptimizer::SetBounds));

    DEBUG_MSG("Adding wrapper for void mfem::SLBQPOptimizer::SetLinearConstraint(const mfem::Vector &, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLBQPOptimizer::SetLinearConstraint(const mfem::Vector &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:940:9
    t.method("SetLinearConstraint", static_cast<void (mfem::SLBQPOptimizer::*)(const mfem::Vector &, double) >(&mfem::SLBQPOptimizer::SetLinearConstraint));

    DEBUG_MSG("Adding wrapper for void mfem::SLBQPOptimizer::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLBQPOptimizer::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:944:17
    t.method("Mult", static_cast<void (mfem::SLBQPOptimizer::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SLBQPOptimizer::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SLBQPOptimizer>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SLBQPOptimizer(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SLBQPOptimizer(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BlockILU> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BlockILU> : std::false_type { };
template<> struct SuperType<mfem::BlockILU> { typedef mfem::Solver type; };
}

// Class generating the wrapper for type mfem::BlockILU
// signature to use in the veto file: mfem::BlockILU
struct Jlmfem_BlockILU: public Wrapper {

  Jlmfem_BlockILU(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BlockILU (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:963:7
    jlcxx::TypeWrapper<mfem::BlockILU>  t = jlModule.add_type<mfem::BlockILU>("mfem!BlockILU",
      jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BlockILU>>(new jlcxx::TypeWrapper<mfem::BlockILU>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BlockILU::BlockILU(int, mfem::BlockILU::Reordering, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:977:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, mfem::BlockILU::Reordering>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, mfem::BlockILU::Reordering, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::BlockILU::BlockILU(const mfem::Operator &, int, mfem::BlockILU::Reordering, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:986:4
    t.constructor<const mfem::Operator &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Operator &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Operator &, int, mfem::BlockILU::Reordering>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Operator &, int, mfem::BlockILU::Reordering, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::BlockILU::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockILU::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:994:9
    t.method("SetOperator", static_cast<void (mfem::BlockILU::*)(const mfem::Operator &) >(&mfem::BlockILU::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::BlockILU::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockILU::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:997:9
    t.method("Mult", static_cast<void (mfem::BlockILU::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BlockILU::Mult));

    DEBUG_MSG("Adding wrapper for int * mfem::BlockILU::GetBlockI() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::BlockILU::GetBlockI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1002:9
    t.method("GetBlockI", static_cast<int * (mfem::BlockILU::*)() >(&mfem::BlockILU::GetBlockI));

    DEBUG_MSG("Adding wrapper for int * mfem::BlockILU::GetBlockJ() (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::BlockILU::GetBlockJ()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1007:9
    t.method("GetBlockJ", static_cast<int * (mfem::BlockILU::*)() >(&mfem::BlockILU::GetBlockJ));

    DEBUG_MSG("Adding wrapper for double * mfem::BlockILU::GetBlockData() (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::BlockILU::GetBlockData()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1012:12
    t.method("GetBlockData", static_cast<double * (mfem::BlockILU::*)() >(&mfem::BlockILU::GetBlockData));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BlockILU>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BlockILU(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BlockILU(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ResidualBCMonitor> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ResidualBCMonitor> : std::false_type { };
template<> struct SuperType<mfem::ResidualBCMonitor> { typedef mfem::IterativeSolverMonitor type; };
}

// Class generating the wrapper for type mfem::ResidualBCMonitor
// signature to use in the veto file: mfem::ResidualBCMonitor
struct Jlmfem_ResidualBCMonitor: public Wrapper {

  Jlmfem_ResidualBCMonitor(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ResidualBCMonitor (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1053:7
    jlcxx::TypeWrapper<mfem::ResidualBCMonitor>  t = jlModule.add_type<mfem::ResidualBCMonitor>("mfem!ResidualBCMonitor",
      jlcxx::julia_base_type<mfem::IterativeSolverMonitor>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ResidualBCMonitor>>(new jlcxx::TypeWrapper<mfem::ResidualBCMonitor>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ResidualBCMonitor::ResidualBCMonitor(const mfem::Array<int> &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1059:4
    t.constructor<const mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ResidualBCMonitor::MonitorResidual(int, double, const mfem::Vector &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ResidualBCMonitor::MonitorResidual(int, double, const mfem::Vector &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1062:9
    t.method("MonitorResidual", static_cast<void (mfem::ResidualBCMonitor::*)(int, double, const mfem::Vector &, bool) >(&mfem::ResidualBCMonitor::MonitorResidual));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ResidualBCMonitor>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ResidualBCMonitor(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ResidualBCMonitor(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DirectSubBlockSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DirectSubBlockSolver> : std::false_type { };
template<> struct SuperType<mfem::DirectSubBlockSolver> { typedef mfem::Solver type; };
}

// Class generating the wrapper for type mfem::DirectSubBlockSolver
// signature to use in the veto file: mfem::DirectSubBlockSolver
struct Jlmfem_DirectSubBlockSolver: public Wrapper {

  Jlmfem_DirectSubBlockSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DirectSubBlockSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1142:7
    jlcxx::TypeWrapper<mfem::DirectSubBlockSolver>  t = jlModule.add_type<mfem::DirectSubBlockSolver>("mfem!DirectSubBlockSolver",
      jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DirectSubBlockSolver>>(new jlcxx::TypeWrapper<mfem::DirectSubBlockSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DirectSubBlockSolver::DirectSubBlockSolver(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1152:4
    t.constructor<const mfem::SparseMatrix &, const mfem::SparseMatrix &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DirectSubBlockSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DirectSubBlockSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1153:17
    t.method("Mult", static_cast<void (mfem::DirectSubBlockSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DirectSubBlockSolver::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::DirectSubBlockSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DirectSubBlockSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1154:17
    t.method("SetOperator", static_cast<void (mfem::DirectSubBlockSolver::*)(const mfem::Operator &) >(&mfem::DirectSubBlockSolver::SetOperator));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DirectSubBlockSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DirectSubBlockSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DirectSubBlockSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ProductSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ProductSolver> : std::false_type { };
template<> struct SuperType<mfem::ProductSolver> { typedef mfem::Solver type; };
}

// Class generating the wrapper for type mfem::ProductSolver
// signature to use in the veto file: mfem::ProductSolver
struct Jlmfem_ProductSolver: public Wrapper {

  Jlmfem_ProductSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ProductSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1159:7
    jlcxx::TypeWrapper<mfem::ProductSolver>  t = jlModule.add_type<mfem::ProductSolver>("mfem!ProductSolver",
      jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductSolver>>(new jlcxx::TypeWrapper<mfem::ProductSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ProductSolver::ProductSolver(mfem::Operator *, mfem::Solver *, mfem::Solver *, bool, bool, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1165:4
    t.constructor<mfem::Operator *, mfem::Solver *, mfem::Solver *, bool, bool, bool>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ProductSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1168:17
    t.method("Mult", static_cast<void (mfem::ProductSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ProductSolver::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::ProductSolver::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductSolver::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1169:17
    t.method("MultTranspose", static_cast<void (mfem::ProductSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ProductSolver::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::ProductSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1170:17
    t.method("SetOperator", static_cast<void (mfem::ProductSolver::*)(const mfem::Operator &) >(&mfem::ProductSolver::SetOperator));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ProductSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ProductSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OrthoSolver> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OrthoSolver> : std::false_type { };
template<> struct SuperType<mfem::OrthoSolver> { typedef mfem::Solver type; };
}

// Class generating the wrapper for type mfem::OrthoSolver
// signature to use in the veto file: mfem::OrthoSolver
struct Jlmfem_OrthoSolver: public Wrapper {

  Jlmfem_OrthoSolver(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OrthoSolver (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1180:7
    jlcxx::TypeWrapper<mfem::OrthoSolver>  t = jlModule.add_type<mfem::OrthoSolver>("mfem!OrthoSolver",
      jlcxx::julia_base_type<mfem::Solver>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OrthoSolver>>(new jlcxx::TypeWrapper<mfem::OrthoSolver>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::OrthoSolver::SetSolver(mfem::Solver &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OrthoSolver::SetSolver(mfem::Solver &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1201:9
    t.method("SetSolver", static_cast<void (mfem::OrthoSolver::*)(mfem::Solver &) >(&mfem::OrthoSolver::SetSolver));

    DEBUG_MSG("Adding wrapper for void mfem::OrthoSolver::SetOperator(const mfem::Operator &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OrthoSolver::SetOperator(const mfem::Operator &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1207:17
    t.method("SetOperator", static_cast<void (mfem::OrthoSolver::*)(const mfem::Operator &) >(&mfem::OrthoSolver::SetOperator));

    DEBUG_MSG("Adding wrapper for void mfem::OrthoSolver::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OrthoSolver::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:1214:9
    t.method("Mult", static_cast<void (mfem::OrthoSolver::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::OrthoSolver::Mult));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OrthoSolver>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OrthoSolver(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OrthoSolver(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IntegrationRule> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IntegrationRule> : std::false_type { };
}

// Class generating the wrapper for type mfem::IntegrationRule
// signature to use in the veto file: mfem::IntegrationRule
struct Jlmfem_IntegrationRule: public Wrapper {

  Jlmfem_IntegrationRule(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IntegrationRule (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:99:7
    jlcxx::TypeWrapper<mfem::IntegrationRule>  t = jlModule.add_type<mfem::IntegrationRule>("mfem!IntegrationRule");
    jlcxx::stl::apply_stl<mfem::IntegrationRule*>(jlModule);
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRule>>(new jlcxx::TypeWrapper<mfem::IntegrationRule>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::IntegrationRule(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:227:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::SetPointIndices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationRule::SetPointIndices()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:239:9
    t.method("SetPointIndices", static_cast<void (mfem::IntegrationRule::*)() >(&mfem::IntegrationRule::SetPointIndices));


    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::IntegrationRule(mfem::IntegrationRule &, mfem::IntegrationRule &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:242:4
    t.constructor<mfem::IntegrationRule &, mfem::IntegrationRule &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::IntegrationRule(mfem::IntegrationRule &, mfem::IntegrationRule &, mfem::IntegrationRule &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:245:4
    t.constructor<mfem::IntegrationRule &, mfem::IntegrationRule &, mfem::IntegrationRule &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::IntegrationRule::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::IntegrationRule::GetOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:249:8
    t.method("GetOrder", static_cast<int (mfem::IntegrationRule::*)()  const>(&mfem::IntegrationRule::GetOrder));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRule::SetOrder(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationRule::SetOrder(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:253:9
    t.method("SetOrder", static_cast<void (mfem::IntegrationRule::*)(const int) >(&mfem::IntegrationRule::SetOrder));

    DEBUG_MSG("Adding wrapper for int mfem::IntegrationRule::GetNPoints() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::IntegrationRule::GetNPoints()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:256:8
    t.method("GetNPoints", static_cast<int (mfem::IntegrationRule::*)()  const>(&mfem::IntegrationRule::GetNPoints));

    DEBUG_MSG("Adding wrapper for mfem::IntegrationPoint & mfem::IntegrationRule::IntPoint(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::IntegrationPoint & mfem::IntegrationRule::IntPoint(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:259:22
    t.method("IntPoint", static_cast<mfem::IntegrationPoint & (mfem::IntegrationRule::*)(int) >(&mfem::IntegrationRule::IntPoint));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationPoint & mfem::IntegrationRule::IntPoint(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationPoint & mfem::IntegrationRule::IntPoint(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:262:28
    t.method("IntPoint", static_cast<const mfem::IntegrationPoint & (mfem::IntegrationRule::*)(int)  const>(&mfem::IntegrationRule::IntPoint));

    DEBUG_MSG("Adding wrapper for const mfem::Array<double> & mfem::IntegrationRule::GetWeights() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<double> & mfem::IntegrationRule::GetWeights()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:267:25
    t.method("GetWeights", static_cast<const mfem::Array<double> & (mfem::IntegrationRule::*)()  const>(&mfem::IntegrationRule::GetWeights));

    DEBUG_MSG("Adding wrapper for mfem::IntegrationRule * mfem::IntegrationRule::ApplyToKnotIntervals(const mfem::KnotVector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::IntegrationRule * mfem::IntegrationRule::ApplyToKnotIntervals(const mfem::KnotVector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:271:21
    t.method("ApplyToKnotIntervals", static_cast<mfem::IntegrationRule * (mfem::IntegrationRule::*)(const mfem::KnotVector &)  const>(&mfem::IntegrationRule::ApplyToKnotIntervals));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRule>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IntegrationRule(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IntegrationRule(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::KnotVector> : std::false_type { };
  template<> struct DefaultConstructible<mfem::KnotVector> : std::false_type { };
}

// Class generating the wrapper for type mfem::KnotVector
// signature to use in the veto file: mfem::KnotVector
struct Jlmfem_KnotVector: public Wrapper {

  Jlmfem_KnotVector(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::KnotVector (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:32:7
    jlcxx::TypeWrapper<mfem::KnotVector>  t = jlModule.add_type<mfem::KnotVector>("mfem!KnotVector");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::KnotVector>>(new jlcxx::TypeWrapper<mfem::KnotVector>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::KnotVector>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_KnotVector(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_KnotVector(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSMeshRules> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSMeshRules> : std::false_type { };
}

// Class generating the wrapper for type mfem::NURBSMeshRules
// signature to use in the veto file: mfem::NURBSMeshRules
struct Jlmfem_NURBSMeshRules: public Wrapper {

  Jlmfem_NURBSMeshRules(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSMeshRules (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:278:7
    jlcxx::TypeWrapper<mfem::NURBSMeshRules>  t = jlModule.add_type<mfem::NURBSMeshRules>("mfem!NURBSMeshRules");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSMeshRules>>(new jlcxx::TypeWrapper<mfem::NURBSMeshRules>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::NURBSMeshRules(const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:282:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::IntegrationRule & mfem::NURBSMeshRules::GetElementRule(const int, const int, const int *, const mfem::Array<const mfem::KnotVector *> &, bool &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::IntegrationRule & mfem::NURBSMeshRules::GetElementRule(const int, const int, const int *, const mfem::Array<const mfem::KnotVector *> &, bool &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:287:21
    t.method("GetElementRule", static_cast<mfem::IntegrationRule & (mfem::NURBSMeshRules::*)(const int, const int, const int *, const mfem::Array<const mfem::KnotVector *> &, bool &)  const>(&mfem::NURBSMeshRules::GetElementRule));

    DEBUG_MSG("Adding wrapper for std::size_t mfem::NURBSMeshRules::AddElementRule(mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: std::size_t mfem::NURBSMeshRules::AddElementRule(mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:293:16
    t.method("AddElementRule", static_cast<std::size_t (mfem::NURBSMeshRules::*)(mfem::IntegrationRule *) >(&mfem::NURBSMeshRules::AddElementRule));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::SetElementRule(const std::size_t, const std::size_t) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSMeshRules::SetElementRule(const std::size_t, const std::size_t)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:301:9
    t.method("SetElementRule", static_cast<void (mfem::NURBSMeshRules::*)(const std::size_t, const std::size_t) >(&mfem::NURBSMeshRules::SetElementRule));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::SetPatchRules1D(const int, std::vector<const mfem::IntegrationRule *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSMeshRules::SetPatchRules1D(const int, std::vector<const mfem::IntegrationRule *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:309:9
    t.method("SetPatchRules1D", static_cast<void (mfem::NURBSMeshRules::*)(const int, std::vector<const mfem::IntegrationRule *> &) >(&mfem::NURBSMeshRules::SetPatchRules1D));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule * mfem::NURBSMeshRules::GetPatchRule1D(const int, const int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule * mfem::NURBSMeshRules::GetPatchRule1D(const int, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:315:27
    t.method("GetPatchRule1D", static_cast<const mfem::IntegrationRule * (mfem::NURBSMeshRules::*)(const int, const int)  const>(&mfem::NURBSMeshRules::GetPatchRule1D));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::GetIntegrationPointFrom1D(const int, int, int, int, mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSMeshRules::GetIntegrationPointFrom1D(const int, int, int, int, mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:323:9
    t.method("GetIntegrationPointFrom1D", static_cast<void (mfem::NURBSMeshRules::*)(const int, int, int, int, mfem::IntegrationPoint &) >(&mfem::NURBSMeshRules::GetIntegrationPointFrom1D));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSMeshRules::Finalize(const mfem::Mesh &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSMeshRules::Finalize(const mfem::Mesh &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:328:9
    t.method("Finalize", static_cast<void (mfem::NURBSMeshRules::*)(const mfem::Mesh &) >(&mfem::NURBSMeshRules::Finalize));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSMeshRules::GetPointElement(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSMeshRules::GetPointElement(int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:334:8
    t.method("GetPointElement", static_cast<int (mfem::NURBSMeshRules::*)(int, int, int, int)  const>(&mfem::NURBSMeshRules::GetPointElement));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSMeshRules::GetDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSMeshRules::GetDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:339:8
    t.method("GetDim", static_cast<int (mfem::NURBSMeshRules::*)()  const>(&mfem::NURBSMeshRules::GetDim));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::NURBSMeshRules::GetPatchRule1D_KnotSpan(const int, const int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::NURBSMeshRules::GetPatchRule1D_KnotSpan(const int, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:344:22
    t.method("GetPatchRule1D_KnotSpan", static_cast<const mfem::Array<int> & (mfem::NURBSMeshRules::*)(const int, const int)  const>(&mfem::NURBSMeshRules::GetPatchRule1D_KnotSpan));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSMeshRules>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSMeshRules(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSMeshRules(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh> : std::false_type { };
}

// Class generating the wrapper for type mfem::Mesh
// signature to use in the veto file: mfem::Mesh
struct Jlmfem_Mesh: public Wrapper {

  Jlmfem_Mesh(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:53:7
    jlcxx::TypeWrapper<mfem::Mesh>  t = jlModule.add_type<mfem::Mesh>("mfem!Mesh");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh>>(new jlcxx::TypeWrapper<mfem::Mesh>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(const mfem::Mesh &, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:631:13
    t.constructor<const mfem::Mesh &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Mesh &, bool>(/*finalize=*/jlcxx::finalize_policy::yes);




    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:652:4
    t.constructor<double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, int, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:667:4
    t.constructor<int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(const std::string &, int, int, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:676:13
    t.constructor<const std::string &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, int, int, bool>(/*finalize=*/jlcxx::finalize_policy::yes);


    // DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(Mesh *[], int) (" __HERE__ ")");
    // // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:688:4
    // t.constructor<Mesh *[], int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Swap(mfem::Mesh &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Swap(mfem::Mesh &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:705:9
    t.method("Swap", static_cast<void (mfem::Mesh::*)(mfem::Mesh &, bool) >(&mfem::Mesh::Swap));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Clear()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:708:9
    t.method("Clear", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::Clear));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::LoadFromFile(const std::string &, int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::LoadFromFile(const std::string &, int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:730:16
    module_.method("mfem!Mesh!LoadFromFile", static_cast<mfem::Mesh (*)(const std::string &, int, int, bool) >(&mfem::Mesh::LoadFromFile));
    module_.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0)->mfem::Mesh { return mfem::Mesh::LoadFromFile(arg0); });
    module_.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0, int arg1)->mfem::Mesh { return mfem::Mesh::LoadFromFile(arg0, arg1); });
    module_.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0, int arg1, int arg2)->mfem::Mesh { return mfem::Mesh::LoadFromFile(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian1D(int, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian1D(int, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:735:16
    module_.method("mfem!Mesh!MakeCartesian1D", static_cast<mfem::Mesh (*)(int, double) >(&mfem::Mesh::MakeCartesian1D));
    module_.method("mfem!Mesh!MakeCartesian1D", [](int arg0)->mfem::Mesh { return mfem::Mesh::MakeCartesian1D(arg0); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian2D(int, int, mfem::Element::Type, bool, double, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian2D(int, int, mfem::Element::Type, bool, double, double, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:745:16
    module_.method("mfem!Mesh!MakeCartesian2D", static_cast<mfem::Mesh (*)(int, int, mfem::Element::Type, bool, double, double, bool) >(&mfem::Mesh::MakeCartesian2D));
    module_.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2)->mfem::Mesh { return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2); });
    module_.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3)->mfem::Mesh { return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3); });
    module_.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3, double arg4)->mfem::Mesh { return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3, arg4); });
    module_.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3, double arg4, double arg5)->mfem::Mesh { return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian3D(int, int, int, mfem::Element::Type, double, double, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian3D(int, int, int, mfem::Element::Type, double, double, double, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:756:16
    module_.method("mfem!Mesh!MakeCartesian3D", static_cast<mfem::Mesh (*)(int, int, int, mfem::Element::Type, double, double, double, bool) >(&mfem::Mesh::MakeCartesian3D));
    module_.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3)->mfem::Mesh { return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3); });
    module_.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4)->mfem::Mesh { return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4); });
    module_.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4, double arg5)->mfem::Mesh { return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4, arg5); });
    module_.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4, double arg5, double arg6)->mfem::Mesh { return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian3DWith24TetsPerHex(int, int, int, double, double, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian3DWith24TetsPerHex(int, int, int, double, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:768:16
    module_.method("mfem!Mesh!MakeCartesian3DWith24TetsPerHex", static_cast<mfem::Mesh (*)(int, int, int, double, double, double) >(&mfem::Mesh::MakeCartesian3DWith24TetsPerHex));
    module_.method("mfem!Mesh!MakeCartesian3DWith24TetsPerHex", [](int arg0, int arg1, int arg2)->mfem::Mesh { return mfem::Mesh::MakeCartesian3DWith24TetsPerHex(arg0, arg1, arg2); });
    module_.method("mfem!Mesh!MakeCartesian3DWith24TetsPerHex", [](int arg0, int arg1, int arg2, double arg3)->mfem::Mesh { return mfem::Mesh::MakeCartesian3DWith24TetsPerHex(arg0, arg1, arg2, arg3); });
    module_.method("mfem!Mesh!MakeCartesian3DWith24TetsPerHex", [](int arg0, int arg1, int arg2, double arg3, double arg4)->mfem::Mesh { return mfem::Mesh::MakeCartesian3DWith24TetsPerHex(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian2DWith4TrisPerQuad(int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian2DWith4TrisPerQuad(int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:778:16
    module_.method("mfem!Mesh!MakeCartesian2DWith4TrisPerQuad", static_cast<mfem::Mesh (*)(int, int, double, double) >(&mfem::Mesh::MakeCartesian2DWith4TrisPerQuad));
    module_.method("mfem!Mesh!MakeCartesian2DWith4TrisPerQuad", [](int arg0, int arg1)->mfem::Mesh { return mfem::Mesh::MakeCartesian2DWith4TrisPerQuad(arg0, arg1); });
    module_.method("mfem!Mesh!MakeCartesian2DWith4TrisPerQuad", [](int arg0, int arg1, double arg2)->mfem::Mesh { return mfem::Mesh::MakeCartesian2DWith4TrisPerQuad(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad(int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad(int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:787:16
    module_.method("mfem!Mesh!MakeCartesian2DWith5QuadsPerQuad", static_cast<mfem::Mesh (*)(int, int, double, double) >(&mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad));
    module_.method("mfem!Mesh!MakeCartesian2DWith5QuadsPerQuad", [](int arg0, int arg1)->mfem::Mesh { return mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad(arg0, arg1); });
    module_.method("mfem!Mesh!MakeCartesian2DWith5QuadsPerQuad", [](int arg0, int arg1, double arg2)->mfem::Mesh { return mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:802:16
    module_.method("mfem!Mesh!MakeRefined", static_cast<mfem::Mesh (*)(mfem::Mesh &, int, int) >(&mfem::Mesh::MakeRefined));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, const mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, const mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:820:16
    module_.method("mfem!Mesh!MakeRefined", static_cast<mfem::Mesh (*)(mfem::Mesh &, const mfem::Array<int> &, int) >(&mfem::Mesh::MakeRefined));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeSimplicial(const mfem::Mesh &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeSimplicial(const mfem::Mesh &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:829:16
    module_.method("mfem!Mesh!MakeSimplicial", static_cast<mfem::Mesh (*)(const mfem::Mesh &) >(&mfem::Mesh::MakeSimplicial));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakePeriodic(const mfem::Mesh &, const std::vector<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakePeriodic(const mfem::Mesh &, const std::vector<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:839:16
    module_.method("mfem!Mesh!MakePeriodic", static_cast<mfem::Mesh (*)(const mfem::Mesh &, const std::vector<int> &) >(&mfem::Mesh::MakePeriodic));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::NewElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::NewElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:851:13
    t.method("NewElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::NewElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(double, double, double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(double, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:853:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(double, double, double) >(&mfem::Mesh::AddVertex));
    t.method("AddVertex", [](mfem::Mesh& a, double arg0)->int { return a.AddVertex(arg0); });
    t.method("AddVertex", [](mfem::Mesh& a, double arg0, double arg1)->int { return a.AddVertex(arg0, arg1); });
    t.method("AddVertex", [](mfem::Mesh* a, double arg0)->int { return a->AddVertex(arg0); });
    t.method("AddVertex", [](mfem::Mesh* a, double arg0, double arg1)->int { return a->AddVertex(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(const double *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:854:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(const double *) >(&mfem::Mesh::AddVertex));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:855:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::AddVertex));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddVertexParents(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddVertexParents(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:857:9
    t.method("AddVertexParents", static_cast<void (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddVertexParents));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertexAtMeanCenter(const int *, const int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertexAtMeanCenter(const int *, const int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:860:8
    t.method("AddVertexAtMeanCenter", static_cast<int (mfem::Mesh::*)(const int *, const int, int) >(&mfem::Mesh::AddVertexAtMeanCenter));
    t.method("AddVertexAtMeanCenter", [](mfem::Mesh& a, const int * arg0, const int arg1)->int { return a.AddVertexAtMeanCenter(arg0, arg1); });
    t.method("AddVertexAtMeanCenter", [](mfem::Mesh* a, const int * arg0, const int arg1)->int { return a->AddVertexAtMeanCenter(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddSegment(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddSegment(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:863:8
    t.method("AddSegment", static_cast<int (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddSegment));
    t.method("AddSegment", [](mfem::Mesh& a, int arg0, int arg1)->int { return a.AddSegment(arg0, arg1); });
    t.method("AddSegment", [](mfem::Mesh* a, int arg0, int arg1)->int { return a->AddSegment(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddSegment(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddSegment(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:865:8
    t.method("AddSegment", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddSegment));
    t.method("AddSegment", [](mfem::Mesh& a, const int * arg0)->int { return a.AddSegment(arg0); });
    t.method("AddSegment", [](mfem::Mesh* a, const int * arg0)->int { return a->AddSegment(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTriangle(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTriangle(int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:868:8
    t.method("AddTriangle", static_cast<int (mfem::Mesh::*)(int, int, int, int) >(&mfem::Mesh::AddTriangle));
    t.method("AddTriangle", [](mfem::Mesh& a, int arg0, int arg1, int arg2)->int { return a.AddTriangle(arg0, arg1, arg2); });
    t.method("AddTriangle", [](mfem::Mesh* a, int arg0, int arg1, int arg2)->int { return a->AddTriangle(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTriangle(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTriangle(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:870:8
    t.method("AddTriangle", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTriangle));
    t.method("AddTriangle", [](mfem::Mesh& a, const int * arg0)->int { return a.AddTriangle(arg0); });
    t.method("AddTriangle", [](mfem::Mesh* a, const int * arg0)->int { return a->AddTriangle(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTri(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTri(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:872:8
    t.method("AddTri", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTri));
    t.method("AddTri", [](mfem::Mesh& a, const int * arg0)->int { return a.AddTri(arg0); });
    t.method("AddTri", [](mfem::Mesh* a, const int * arg0)->int { return a->AddTri(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddQuad(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddQuad(int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:875:8
    t.method("AddQuad", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddQuad));
    t.method("AddQuad", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int { return a.AddQuad(arg0, arg1, arg2, arg3); });
    t.method("AddQuad", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int { return a->AddQuad(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddQuad(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddQuad(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:877:8
    t.method("AddQuad", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddQuad));
    t.method("AddQuad", [](mfem::Mesh& a, const int * arg0)->int { return a.AddQuad(arg0); });
    t.method("AddQuad", [](mfem::Mesh* a, const int * arg0)->int { return a->AddQuad(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTet(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTet(int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:880:8
    t.method("AddTet", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddTet));
    t.method("AddTet", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int { return a.AddTet(arg0, arg1, arg2, arg3); });
    t.method("AddTet", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int { return a->AddTet(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTet(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTet(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:882:8
    t.method("AddTet", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTet));
    t.method("AddTet", [](mfem::Mesh& a, const int * arg0)->int { return a.AddTet(arg0); });
    t.method("AddTet", [](mfem::Mesh* a, const int * arg0)->int { return a->AddTet(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddWedge(int, int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddWedge(int, int, int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:885:8
    t.method("AddWedge", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int, int) >(&mfem::Mesh::AddWedge));
    t.method("AddWedge", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)->int { return a.AddWedge(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("AddWedge", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)->int { return a->AddWedge(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddWedge(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddWedge(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:887:8
    t.method("AddWedge", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddWedge));
    t.method("AddWedge", [](mfem::Mesh& a, const int * arg0)->int { return a.AddWedge(arg0); });
    t.method("AddWedge", [](mfem::Mesh* a, const int * arg0)->int { return a->AddWedge(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddPyramid(int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddPyramid(int, int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:890:8
    t.method("AddPyramid", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int) >(&mfem::Mesh::AddPyramid));
    t.method("AddPyramid", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4)->int { return a.AddPyramid(arg0, arg1, arg2, arg3, arg4); });
    t.method("AddPyramid", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4)->int { return a->AddPyramid(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddPyramid(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddPyramid(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:892:8
    t.method("AddPyramid", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddPyramid));
    t.method("AddPyramid", [](mfem::Mesh& a, const int * arg0)->int { return a.AddPyramid(arg0); });
    t.method("AddPyramid", [](mfem::Mesh* a, const int * arg0)->int { return a->AddPyramid(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddHex(int, int, int, int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddHex(int, int, int, int, int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:895:8
    t.method("AddHex", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int, int, int, int) >(&mfem::Mesh::AddHex));
    t.method("AddHex", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7)->int { return a.AddHex(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });
    t.method("AddHex", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7)->int { return a->AddHex(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddHex(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddHex(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:898:8
    t.method("AddHex", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHex));
    t.method("AddHex", [](mfem::Mesh& a, const int * arg0)->int { return a.AddHex(arg0); });
    t.method("AddHex", [](mfem::Mesh* a, const int * arg0)->int { return a->AddHex(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsTets(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsTets(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:901:9
    t.method("AddHexAsTets", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsTets));
    t.method("AddHexAsTets", [](mfem::Mesh& a, const int * arg0)->void { a.AddHexAsTets(arg0); });
    t.method("AddHexAsTets", [](mfem::Mesh* a, const int * arg0)->void { a->AddHexAsTets(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsWedges(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsWedges(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:904:9
    t.method("AddHexAsWedges", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsWedges));
    t.method("AddHexAsWedges", [](mfem::Mesh& a, const int * arg0)->void { a.AddHexAsWedges(arg0); });
    t.method("AddHexAsWedges", [](mfem::Mesh* a, const int * arg0)->void { a->AddHexAsWedges(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsPyramids(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsPyramids(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:907:9
    t.method("AddHexAsPyramids", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsPyramids));
    t.method("AddHexAsPyramids", [](mfem::Mesh& a, const int * arg0)->void { a.AddHexAsPyramids(arg0); });
    t.method("AddHexAsPyramids", [](mfem::Mesh* a, const int * arg0)->void { a->AddHexAsPyramids(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddQuadAs4TrisWithPoints(int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddQuadAs4TrisWithPoints(int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:925:9
    t.method("AddQuadAs4TrisWithPoints", static_cast<void (mfem::Mesh::*)(int *, int) >(&mfem::Mesh::AddQuadAs4TrisWithPoints));
    t.method("AddQuadAs4TrisWithPoints", [](mfem::Mesh& a, int * arg0)->void { a.AddQuadAs4TrisWithPoints(arg0); });
    t.method("AddQuadAs4TrisWithPoints", [](mfem::Mesh* a, int * arg0)->void { a->AddQuadAs4TrisWithPoints(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddQuadAs5QuadsWithPoints(int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddQuadAs5QuadsWithPoints(int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:932:9
    t.method("AddQuadAs5QuadsWithPoints", static_cast<void (mfem::Mesh::*)(int *, int) >(&mfem::Mesh::AddQuadAs5QuadsWithPoints));
    t.method("AddQuadAs5QuadsWithPoints", [](mfem::Mesh& a, int * arg0)->void { a.AddQuadAs5QuadsWithPoints(arg0); });
    t.method("AddQuadAs5QuadsWithPoints", [](mfem::Mesh* a, int * arg0)->void { a->AddQuadAs5QuadsWithPoints(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddElement(mfem::Element *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddElement(mfem::Element *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:936:8
    t.method("AddElement", static_cast<int (mfem::Mesh::*)(mfem::Element *) >(&mfem::Mesh::AddElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrElement(mfem::Element *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrElement(mfem::Element *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:939:8
    t.method("AddBdrElement", static_cast<int (mfem::Mesh::*)(mfem::Element *) >(&mfem::Mesh::AddBdrElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrSegment(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrSegment(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:941:8
    t.method("AddBdrSegment", static_cast<int (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddBdrSegment));
    t.method("AddBdrSegment", [](mfem::Mesh& a, int arg0, int arg1)->int { return a.AddBdrSegment(arg0, arg1); });
    t.method("AddBdrSegment", [](mfem::Mesh* a, int arg0, int arg1)->int { return a->AddBdrSegment(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrSegment(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrSegment(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:942:8
    t.method("AddBdrSegment", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrSegment));
    t.method("AddBdrSegment", [](mfem::Mesh& a, const int * arg0)->int { return a.AddBdrSegment(arg0); });
    t.method("AddBdrSegment", [](mfem::Mesh* a, const int * arg0)->int { return a->AddBdrSegment(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrTriangle(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrTriangle(int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:944:8
    t.method("AddBdrTriangle", static_cast<int (mfem::Mesh::*)(int, int, int, int) >(&mfem::Mesh::AddBdrTriangle));
    t.method("AddBdrTriangle", [](mfem::Mesh& a, int arg0, int arg1, int arg2)->int { return a.AddBdrTriangle(arg0, arg1, arg2); });
    t.method("AddBdrTriangle", [](mfem::Mesh* a, int arg0, int arg1, int arg2)->int { return a->AddBdrTriangle(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrTriangle(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrTriangle(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:945:8
    t.method("AddBdrTriangle", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrTriangle));
    t.method("AddBdrTriangle", [](mfem::Mesh& a, const int * arg0)->int { return a.AddBdrTriangle(arg0); });
    t.method("AddBdrTriangle", [](mfem::Mesh* a, const int * arg0)->int { return a->AddBdrTriangle(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrQuad(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrQuad(int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:947:8
    t.method("AddBdrQuad", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddBdrQuad));
    t.method("AddBdrQuad", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int { return a.AddBdrQuad(arg0, arg1, arg2, arg3); });
    t.method("AddBdrQuad", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int { return a->AddBdrQuad(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrQuad(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrQuad(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:948:8
    t.method("AddBdrQuad", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrQuad));
    t.method("AddBdrQuad", [](mfem::Mesh& a, const int * arg0)->int { return a.AddBdrQuad(arg0); });
    t.method("AddBdrQuad", [](mfem::Mesh* a, const int * arg0)->int { return a->AddBdrQuad(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddBdrQuadAsTriangles(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddBdrQuadAsTriangles(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:949:9
    t.method("AddBdrQuadAsTriangles", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrQuadAsTriangles));
    t.method("AddBdrQuadAsTriangles", [](mfem::Mesh& a, const int * arg0)->void { a.AddBdrQuadAsTriangles(arg0); });
    t.method("AddBdrQuadAsTriangles", [](mfem::Mesh* a, const int * arg0)->void { a->AddBdrQuadAsTriangles(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrPoint(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrPoint(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:951:8
    t.method("AddBdrPoint", static_cast<int (mfem::Mesh::*)(int, int) >(&mfem::Mesh::AddBdrPoint));
    t.method("AddBdrPoint", [](mfem::Mesh& a, int arg0)->int { return a.AddBdrPoint(arg0); });
    t.method("AddBdrPoint", [](mfem::Mesh* a, int arg0)->int { return a->AddBdrPoint(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GenerateBoundaryElements() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GenerateBoundaryElements()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:953:9
    t.method("GenerateBoundaryElements", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::GenerateBoundaryElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTriMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTriMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:955:9
    t.method("FinalizeTriMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeTriMesh));
    t.method("FinalizeTriMesh", [](mfem::Mesh& a)->void { a.FinalizeTriMesh(); });
    t.method("FinalizeTriMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeTriMesh(arg0); });
    t.method("FinalizeTriMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeTriMesh(arg0, arg1); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a)->void { a->FinalizeTriMesh(); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeTriMesh(arg0); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeTriMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeQuadMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeQuadMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:958:9
    t.method("FinalizeQuadMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeQuadMesh));
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a)->void { a.FinalizeQuadMesh(); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeQuadMesh(arg0); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeQuadMesh(arg0, arg1); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a)->void { a->FinalizeQuadMesh(); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeQuadMesh(arg0); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeQuadMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTetMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTetMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:961:9
    t.method("FinalizeTetMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeTetMesh));
    t.method("FinalizeTetMesh", [](mfem::Mesh& a)->void { a.FinalizeTetMesh(); });
    t.method("FinalizeTetMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeTetMesh(arg0); });
    t.method("FinalizeTetMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeTetMesh(arg0, arg1); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a)->void { a->FinalizeTetMesh(); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeTetMesh(arg0); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeTetMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeWedgeMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeWedgeMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:964:9
    t.method("FinalizeWedgeMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeWedgeMesh));
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a)->void { a.FinalizeWedgeMesh(); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeWedgeMesh(arg0); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeWedgeMesh(arg0, arg1); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a)->void { a->FinalizeWedgeMesh(); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeWedgeMesh(arg0); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeWedgeMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeHexMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeHexMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:967:9
    t.method("FinalizeHexMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeHexMesh));
    t.method("FinalizeHexMesh", [](mfem::Mesh& a)->void { a.FinalizeHexMesh(); });
    t.method("FinalizeHexMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeHexMesh(arg0); });
    t.method("FinalizeHexMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeHexMesh(arg0, arg1); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a)->void { a->FinalizeHexMesh(); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeHexMesh(arg0); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeHexMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeMesh(int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeMesh(int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:971:9
    t.method("FinalizeMesh", static_cast<void (mfem::Mesh::*)(int, bool) >(&mfem::Mesh::FinalizeMesh));
    t.method("FinalizeMesh", [](mfem::Mesh& a)->void { a.FinalizeMesh(); });
    t.method("FinalizeMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeMesh(arg0); });
    t.method("FinalizeMesh", [](mfem::Mesh* a)->void { a->FinalizeMesh(); });
    t.method("FinalizeMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeMesh(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTopology(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTopology(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:987:9
    t.method("FinalizeTopology", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::FinalizeTopology));
    t.method("FinalizeTopology", [](mfem::Mesh& a)->void { a.FinalizeTopology(); });
    t.method("FinalizeTopology", [](mfem::Mesh* a)->void { a->FinalizeTopology(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Finalize(bool, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Finalize(bool, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1003:17
    t.method("Finalize", static_cast<void (mfem::Mesh::*)(bool, bool) >(&mfem::Mesh::Finalize));
    t.method("Finalize", [](mfem::Mesh& a)->void { a.Finalize(); });
    t.method("Finalize", [](mfem::Mesh& a, bool arg0)->void { a.Finalize(arg0); });
    t.method("Finalize", [](mfem::Mesh* a)->void { a->Finalize(); });
    t.method("Finalize", [](mfem::Mesh* a, bool arg0)->void { a->Finalize(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetAttributes() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetAttributes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1011:17
    t.method("SetAttributes", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::SetAttributes));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::CheckElementOrientation(bool) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::CheckElementOrientation(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1027:8
    t.method("CheckElementOrientation", static_cast<int (mfem::Mesh::*)(bool) >(&mfem::Mesh::CheckElementOrientation));
    t.method("CheckElementOrientation", [](mfem::Mesh& a)->int { return a.CheckElementOrientation(); });
    t.method("CheckElementOrientation", [](mfem::Mesh* a)->int { return a->CheckElementOrientation(); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::CheckBdrElementOrientation(bool) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::CheckBdrElementOrientation(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1031:8
    t.method("CheckBdrElementOrientation", static_cast<int (mfem::Mesh::*)(bool) >(&mfem::Mesh::CheckBdrElementOrientation));
    t.method("CheckBdrElementOrientation", [](mfem::Mesh& a)->int { return a.CheckBdrElementOrientation(); });
    t.method("CheckBdrElementOrientation", [](mfem::Mesh* a)->int { return a->CheckBdrElementOrientation(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ReorientTetMesh() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ReorientTetMesh()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1041:33
    t.method("ReorientTetMesh", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::ReorientTetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RemoveUnusedVertices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RemoveUnusedVertices()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1044:9
    t.method("RemoveUnusedVertices", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::RemoveUnusedVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RemoveInternalBoundaries() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RemoveInternalBoundaries()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1048:9
    t.method("RemoveInternalBoundaries", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::RemoveInternalBoundaries));

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetGeckoElementOrdering(mfem::Array<int> &, int, int, int, int, bool, double) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetGeckoElementOrdering(mfem::Array<int> &, int, int, int, int, bool, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1074:11
    t.method("GetGeckoElementOrdering", static_cast<double (mfem::Mesh::*)(mfem::Array<int> &, int, int, int, int, bool, double) >(&mfem::Mesh::GetGeckoElementOrdering));
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0)->double { return a.GetGeckoElementOrdering(arg0); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1)->double { return a.GetGeckoElementOrdering(arg0, arg1); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1, int arg2)->double { return a.GetGeckoElementOrdering(arg0, arg1, arg2); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3)->double { return a.GetGeckoElementOrdering(arg0, arg1, arg2, arg3); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3, int arg4)->double { return a.GetGeckoElementOrdering(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3, int arg4, bool arg5)->double { return a.GetGeckoElementOrdering(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0)->double { return a->GetGeckoElementOrdering(arg0); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1)->double { return a->GetGeckoElementOrdering(arg0, arg1); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1, int arg2)->double { return a->GetGeckoElementOrdering(arg0, arg1, arg2); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3)->double { return a->GetGeckoElementOrdering(arg0, arg1, arg2, arg3); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3, int arg4)->double { return a->GetGeckoElementOrdering(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3, int arg4, bool arg5)->double { return a->GetGeckoElementOrdering(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetHilbertElementOrdering(mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetHilbertElementOrdering(mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1083:9
    t.method("GetHilbertElementOrdering", static_cast<void (mfem::Mesh::*)(mfem::Array<int> &) >(&mfem::Mesh::GetHilbertElementOrdering));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ReorderElements(const mfem::Array<int> &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ReorderElements(const mfem::Array<int> &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1088:9
    t.method("ReorderElements", static_cast<void (mfem::Mesh::*)(const mfem::Array<int> &, bool) >(&mfem::Mesh::ReorderElements));
    t.method("ReorderElements", [](mfem::Mesh& a, const mfem::Array<int> & arg0)->void { a.ReorderElements(arg0); });
    t.method("ReorderElements", [](mfem::Mesh* a, const mfem::Array<int> & arg0)->void { a->ReorderElements(arg0); });


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, int, mfem::Element::Type, bool, double, double, double, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1100:4
    t.constructor<int, int, int, mfem::Element::Type>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double, double, bool>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, mfem::Element::Type, bool, double, double, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1110:4
    t.constructor<int, int, mfem::Element::Type>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, mfem::Element::Type, bool>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, mfem::Element::Type, bool, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, mfem::Element::Type, bool, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, mfem::Element::Type, bool, double, double, bool>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1119:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(mfem::Mesh *, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1127:4
    t.constructor<mfem::Mesh *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::Dimension() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::Dimension()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1135:8
    t.method("Dimension", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::Dimension));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::SpaceDimension() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::SpaceDimension()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1138:8
    t.method("SpaceDimension", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::SpaceDimension));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::EulerNumber() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::EulerNumber()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1141:15
    t.method("EulerNumber", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::EulerNumber));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::EulerNumber2D() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::EulerNumber2D()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1144:15
    t.method("EulerNumber2D", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::EulerNumber2D));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::MeshGenerator() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::MeshGenerator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1162:15
    t.method("MeshGenerator", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::MeshGenerator));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::HasBoundaryElements() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::HasBoundaryElements()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1165:17
    t.method("HasBoundaryElements", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::HasBoundaryElements));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::HasGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::HasGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1169:9
    t.method("HasGeometry", static_cast<bool (mfem::Mesh::*)(mfem::Geometry::Type)  const>(&mfem::Mesh::HasGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumGeometries(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumGeometries(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1175:8
    t.method("GetNumGeometries", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetNumGeometries));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetGeometries(int, mfem::Array<mfem::Geometry::Type> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetGeometries(int, mfem::Array<mfem::Geometry::Type> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1181:9
    t.method("GetGeometries", static_cast<void (mfem::Mesh::*)(int, mfem::Array<mfem::Geometry::Type> &)  const>(&mfem::Mesh::GetGeometries));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBoundingBox(mfem::Vector &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBoundingBox(mfem::Vector &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1185:9
    t.method("GetBoundingBox", static_cast<void (mfem::Mesh::*)(mfem::Vector &, mfem::Vector &, int) >(&mfem::Mesh::GetBoundingBox));
    t.method("GetBoundingBox", [](mfem::Mesh& a, mfem::Vector & arg0, mfem::Vector & arg1)->void { a.GetBoundingBox(arg0, arg1); });
    t.method("GetBoundingBox", [](mfem::Mesh* a, mfem::Vector & arg0, mfem::Vector & arg1)->void { a->GetBoundingBox(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetCharacteristics(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetCharacteristics(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1187:9
    t.method("GetCharacteristics", static_cast<void (mfem::Mesh::*)(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *) >(&mfem::Mesh::GetCharacteristics));
    t.method("GetCharacteristics", [](mfem::Mesh& a, double & arg0, double & arg1, double & arg2, double & arg3)->void { a.GetCharacteristics(arg0, arg1, arg2, arg3); });
    t.method("GetCharacteristics", [](mfem::Mesh& a, double & arg0, double & arg1, double & arg2, double & arg3, mfem::Vector * arg4)->void { a.GetCharacteristics(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetCharacteristics", [](mfem::Mesh* a, double & arg0, double & arg1, double & arg2, double & arg3)->void { a->GetCharacteristics(arg0, arg1, arg2, arg3); });
    t.method("GetCharacteristics", [](mfem::Mesh* a, double & arg0, double & arg1, double & arg2, double & arg3, mfem::Vector * arg4)->void { a->GetCharacteristics(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNV()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1198:15
    t.method("GetNV", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNV));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1201:15
    t.method("GetNE", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNE));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNBE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNBE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1204:15
    t.method("GetNBE", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNBE));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNEdges() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNEdges()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1207:15
    t.method("GetNEdges", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNEdges));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNFaces() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNFaces()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1210:15
    t.method("GetNFaces", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNFaces));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumFaces() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumFaces()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1213:8
    t.method("GetNumFaces", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNumFaces));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumFacesWithGhost() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumFacesWithGhost()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1217:8
    t.method("GetNumFacesWithGhost", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNumFacesWithGhost));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNFbyType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNFbyType(mfem::FaceType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1227:16
    t.method("GetNFbyType", static_cast<int (mfem::Mesh::*)(mfem::FaceType)  const>(&mfem::Mesh::GetNFbyType));

    DEBUG_MSG("Adding wrapper for long long mfem::Mesh::GetGlobalNE() (" __HERE__ ")");
    // signature to use in the veto list: long long mfem::Mesh::GetGlobalNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1230:14
    t.method("GetGlobalNE", static_cast<long long (mfem::Mesh::*)()  const>(&mfem::Mesh::GetGlobalNE));

    DEBUG_MSG("Adding wrapper for const double * mfem::Mesh::GetVertex(int) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Mesh::GetVertex(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1240:18
    t.method("GetVertex", static_cast<const double * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetVertex));

    DEBUG_MSG("Adding wrapper for double * mfem::Mesh::GetVertex(int) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Mesh::GetVertex(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1250:12
    t.method("GetVertex", static_cast<double * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetVertex));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1258:19
    t.method("GetElement", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElement));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::GetElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::GetElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1265:13
    t.method("GetElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElement));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetBdrElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetBdrElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1273:19
    t.method("GetBdrElement", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElement));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::GetBdrElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::GetBdrElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1280:13
    t.method("GetBdrElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrElement));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetFace(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetFace(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1285:19
    t.method("GetFace", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFace));

    DEBUG_MSG("Adding wrapper for const mfem::Element *const * mfem::Mesh::GetElementsArray() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element *const * mfem::Mesh::GetElementsArray()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1292:26
    t.method("GetElementsArray", static_cast<const mfem::Element *const * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetElementsArray));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementData(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementData(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1295:9
    t.method("GetElementData", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetElementData));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementData(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementData(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1298:9
    t.method("GetBdrElementData", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetBdrElementData));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1308:8
    t.method("GetAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1311:9
    t.method("SetAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1314:8
    t.method("GetBdrAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetBdrAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetBdrAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1317:9
    t.method("SetBdrAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetBdrAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetPatchAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetPatchAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1320:8
    t.method("GetPatchAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetPatchAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetPatchAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetPatchAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1323:9
    t.method("SetPatchAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetPatchAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetPatchBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetPatchBdrAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1326:8
    t.method("GetPatchBdrAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetPatchBdrAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetPatchBdrAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetPatchBdrAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1329:9
    t.method("SetPatchBdrAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetPatchBdrAttribute));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1332:18
    t.method("GetElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementType));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetBdrElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetBdrElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1335:18
    t.method("GetBdrElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementType));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceGeometryType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceGeometryType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1338:35
    t.method("GetFaceGeometryType", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceGeometryType));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetFaceElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetFaceElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1341:19
    t.method("GetFaceElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceElementType));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1344:19
    t.method("GetFaceGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetElementGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetElementGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1346:19
    t.method("GetElementGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetBdrElementGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetBdrElementGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1351:19
    t.method("GetBdrElementGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceBaseGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1357:35
    t.method("GetFaceBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceBaseGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetElementBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetElementBaseGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1360:19
    t.method("GetElementBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementBaseGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetBdrElementBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetBdrElementBaseGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1363:19
    t.method("GetBdrElementBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementBaseGeometry));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceIsInterior(int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceIsInterior(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1367:9
    t.method("FaceIsInterior", static_cast<bool (mfem::Mesh::*)(int)  const>(&mfem::Mesh::FaceIsInterior));

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementSize(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementSize(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1374:11
    t.method("GetElementSize", static_cast<double (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GetElementSize));
    t.method("GetElementSize", [](mfem::Mesh& a, int arg0)->double { return a.GetElementSize(arg0); });
    t.method("GetElementSize", [](mfem::Mesh* a, int arg0)->double { return a->GetElementSize(arg0); });

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementSize(int, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementSize(int, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1376:11
    t.method("GetElementSize", static_cast<double (mfem::Mesh::*)(int, const mfem::Vector &) >(&mfem::Mesh::GetElementSize));

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementSize(mfem::ElementTransformation *, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementSize(mfem::ElementTransformation *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1378:11
    t.method("GetElementSize", static_cast<double (mfem::Mesh::*)(mfem::ElementTransformation *, int)  const>(&mfem::Mesh::GetElementSize));
    t.method("GetElementSize", [](mfem::Mesh const& a, mfem::ElementTransformation * arg0)->double { return a.GetElementSize(arg0); });
    t.method("GetElementSize", [](mfem::Mesh const* a, mfem::ElementTransformation * arg0)->double { return a->GetElementSize(arg0); });

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementVolume(int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementVolume(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1380:11
    t.method("GetElementVolume", static_cast<double (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElementVolume));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementCenter(int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementCenter(int, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1382:9
    t.method("GetElementCenter", static_cast<void (mfem::Mesh::*)(int, mfem::Vector &) >(&mfem::Mesh::GetElementCenter));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementJacobian(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementJacobian(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1387:9
    t.method("GetElementJacobian", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *) >(&mfem::Mesh::GetElementJacobian));
    t.method("GetElementJacobian", [](mfem::Mesh& a, int arg0, mfem::DenseMatrix & arg1)->void { a.GetElementJacobian(arg0, arg1); });
    t.method("GetElementJacobian", [](mfem::Mesh* a, int arg0, mfem::DenseMatrix & arg1)->void { a->GetElementJacobian(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1413:9
    t.method("GetElementVertices", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &)  const>(&mfem::Mesh::GetElementVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1417:9
    t.method("GetBdrElementVertices", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &)  const>(&mfem::Mesh::GetBdrElementVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementEdges(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementEdges(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1421:9
    t.method("GetElementEdges", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetElementEdges));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementEdges(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementEdges(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1424:9
    t.method("GetBdrElementEdges", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetBdrElementEdges));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceEdges(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceEdges(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1428:9
    t.method("GetFaceEdges", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetFaceEdges));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1431:9
    t.method("GetFaceVertices", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &)  const>(&mfem::Mesh::GetFaceVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetEdgeVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetEdgeVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1444:9
    t.method("GetEdgeVertices", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &)  const>(&mfem::Mesh::GetEdgeVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementFaces(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementFaces(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1447:9
    t.method("GetElementFaces", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetElementFaces));

    DEBUG_MSG("Adding wrapper for mfem::Array<int> mfem::Mesh::FindFaceNeighbors(const int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<int> mfem::Mesh::FindFaceNeighbors(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1451:15
    t.method("FindFaceNeighbors", static_cast<mfem::Array<int> (mfem::Mesh::*)(const int)  const>(&mfem::Mesh::FindFaceNeighbors));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementFace(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementFace(int, int *, int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1459:9
    t.method("GetBdrElementFace", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetBdrElementFace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementAdjacentElement(int, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementAdjacentElement(int, int &, int &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1468:9
    t.method("GetBdrElementAdjacentElement", static_cast<void (mfem::Mesh::*)(int, int &, int &)  const>(&mfem::Mesh::GetBdrElementAdjacentElement));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementAdjacentElement2(int, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementAdjacentElement2(int, int &, int &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1479:9
    t.method("GetBdrElementAdjacentElement2", static_cast<void (mfem::Mesh::*)(int, int &, int &)  const>(&mfem::Mesh::GetBdrElementAdjacentElement2));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrElementFaceIndex(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrElementFaceIndex(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1483:8
    t.method("GetBdrElementFaceIndex", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementFaceIndex));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrFace(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrFace(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1486:24
    t.method("GetBdrFace", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrFace));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrElementEdgeIndex(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrElementEdgeIndex(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1493:24
    t.method("GetBdrElementEdgeIndex", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementEdgeIndex));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetVertexToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetVertexToElementTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1501:11
    t.method("GetVertexToElementTable", static_cast<mfem::Table * (mfem::Mesh::*)() >(&mfem::Mesh::GetVertexToElementTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetFaceToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetFaceToElementTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1507:11
    t.method("GetFaceToElementTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetFaceToElementTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetFaceEdgeTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetFaceEdgeTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1512:11
    t.method("GetFaceEdgeTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetFaceEdgeTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetEdgeVertexTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetEdgeVertexTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1517:11
    t.method("GetEdgeVertexTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetEdgeVertexTable));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetVertexToVertexTable(mfem::DSTable &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetVertexToVertexTable(mfem::DSTable &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1527:9
    t.method("GetVertexToVertexTable", static_cast<void (mfem::Mesh::*)(mfem::DSTable &)  const>(&mfem::Mesh::GetVertexToVertexTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToElementTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1529:17
    t.method("ElementToElementTable", static_cast<const mfem::Table & (mfem::Mesh::*)() >(&mfem::Mesh::ElementToElementTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToFaceTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToFaceTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1531:17
    t.method("ElementToFaceTable", static_cast<const mfem::Table & (mfem::Mesh::*)()  const>(&mfem::Mesh::ElementToFaceTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToEdgeTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToEdgeTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1533:17
    t.method("ElementToEdgeTable", static_cast<const mfem::Table & (mfem::Mesh::*)()  const>(&mfem::Mesh::ElementToEdgeTable));

    DEBUG_MSG("Adding wrapper for mfem::Array<int> mfem::Mesh::GetFaceToBdrElMap() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<int> mfem::Mesh::GetFaceToBdrElMap()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1535:15
    t.method("GetFaceToBdrElMap", static_cast<mfem::Array<int> (mfem::Mesh::*)()  const>(&mfem::Mesh::GetFaceToBdrElMap));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElement * mfem::Mesh::GetTransformationFEforElementType(mfem::Element::Type) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElement * mfem::Mesh::GetTransformationFEforElementType(mfem::Element::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1543:26
    module_.method("mfem!Mesh!GetTransformationFEforElementType", static_cast<mfem::FiniteElement * (*)(mfem::Element::Type) >(&mfem::Mesh::GetTransformationFEforElementType));

    DEBUG_MSG("Adding wrapper for mfem::IntegrationPoint mfem::Mesh::TransformBdrElementToFace(mfem::Geometry::Type, int, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::IntegrationPoint mfem::Mesh::TransformBdrElementToFace(mfem::Geometry::Type, int, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1550:28
    module_.method("mfem!Mesh!TransformBdrElementToFace", static_cast<mfem::IntegrationPoint (*)(mfem::Geometry::Type, int, const mfem::IntegrationPoint &) >(&mfem::Mesh::TransformBdrElementToFace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1567:9
    t.method("GetElementTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetElementTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1575:27
    t.method("GetElementTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementTransformation(int, const mfem::Vector &, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementTransformation(int, const mfem::Vector &, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1584:9
    t.method("GetElementTransformation", static_cast<void (mfem::Mesh::*)(int, const mfem::Vector &, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetBdrElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetBdrElementTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1593:27
    t.method("GetBdrElementTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1602:9
    t.method("GetBdrElementTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetFaceTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetFaceTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1611:27
    t.method("GetFaceTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetFaceTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1620:9
    t.method("GetFaceTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetFaceTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetLocalFaceTransformation(int, int, mfem::IsoparametricTransformation &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetLocalFaceTransformation(int, int, mfem::IsoparametricTransformation &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1627:9
    t.method("GetLocalFaceTransformation", static_cast<void (mfem::Mesh::*)(int, int, mfem::IsoparametricTransformation &, int)  const>(&mfem::Mesh::GetLocalFaceTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetEdgeTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetEdgeTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1638:9
    t.method("GetEdgeTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetEdgeTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetEdgeTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetEdgeTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1646:27
    t.method("GetEdgeTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetEdgeTransformation));

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetFaceElementTransformations(int, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetFaceElementTransformations(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1683:4
    t.method("GetFaceElementTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GetFaceElementTransformations));
    t.method("GetFaceElementTransformations", [](mfem::Mesh& a, int arg0)->mfem::FaceElementTransformations * { return a.GetFaceElementTransformations(arg0); });
    t.method("GetFaceElementTransformations", [](mfem::Mesh* a, int arg0)->mfem::FaceElementTransformations * { return a->GetFaceElementTransformations(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceElementTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceElementTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1687:17
    t.method("GetFaceElementTransformations", static_cast<void (mfem::Mesh::*)(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &, int)  const>(&mfem::Mesh::GetFaceElementTransformations));
    t.method("GetFaceElementTransformations", [](mfem::Mesh const& a, int arg0, mfem::FaceElementTransformations & arg1, mfem::IsoparametricTransformation & arg2, mfem::IsoparametricTransformation & arg3)->void { a.GetFaceElementTransformations(arg0, arg1, arg2, arg3); });
    t.method("GetFaceElementTransformations", [](mfem::Mesh const* a, int arg0, mfem::FaceElementTransformations & arg1, mfem::IsoparametricTransformation & arg2, mfem::IsoparametricTransformation & arg3)->void { a->GetFaceElementTransformations(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetInteriorFaceTransformations(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetInteriorFaceTransformations(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1698:32
    t.method("GetInteriorFaceTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetInteriorFaceTransformations));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetInteriorFaceTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetInteriorFaceTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1702:9
    t.method("GetInteriorFaceTransformations", static_cast<void (mfem::Mesh::*)(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &)  const>(&mfem::Mesh::GetInteriorFaceTransformations));

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetBdrFaceTransformations(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetBdrFaceTransformations(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1712:32
    t.method("GetBdrFaceTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrFaceTransformations));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrFaceTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrFaceTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1716:9
    t.method("GetBdrFaceTransformations", static_cast<void (mfem::Mesh::*)(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &)  const>(&mfem::Mesh::GetBdrFaceTransformations));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetPointMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetPointMatrix(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1952:9
    t.method("GetPointMatrix", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &)  const>(&mfem::Mesh::GetPointMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrPointMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrPointMatrix(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1956:9
    t.method("GetBdrPointMatrix", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &)  const>(&mfem::Mesh::GetBdrPointMatrix));

    DEBUG_MSG("Adding wrapper for mfem::Mesh::FaceInformation mfem::Mesh::GetFaceInformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh::FaceInformation mfem::Mesh::GetFaceInformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1961:20
    t.method("GetFaceInformation", static_cast<mfem::Mesh::FaceInformation (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceInformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceElements(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceElements(int, int *, int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1963:9
    t.method("GetFaceElements", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetFaceElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceInfos(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceInfos(int, int *, int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1964:9
    t.method("GetFaceInfos", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetFaceInfos));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceInfos(int, int *, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceInfos(int, int *, int *, int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1965:9
    t.method("GetFaceInfos", static_cast<void (mfem::Mesh::*)(int, int *, int *, int *)  const>(&mfem::Mesh::GetFaceInfos));

    DEBUG_MSG("Adding wrapper for int * mfem::Mesh::CartesianPartitioning(int[]) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::Mesh::CartesianPartitioning(int[])
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1973:9
    t.method("CartesianPartitioning", static_cast<int * (mfem::Mesh::*)(int[]) >(&mfem::Mesh::CartesianPartitioning));

    DEBUG_MSG("Adding wrapper for int * mfem::Mesh::GeneratePartitioning(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::Mesh::GeneratePartitioning(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1975:9
    t.method("GeneratePartitioning", static_cast<int * (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GeneratePartitioning));
    t.method("GeneratePartitioning", [](mfem::Mesh& a, int arg0)->int * { return a.GeneratePartitioning(arg0); });
    t.method("GeneratePartitioning", [](mfem::Mesh* a, int arg0)->int * { return a->GeneratePartitioning(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::CheckPartitioning(int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::CheckPartitioning(int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1977:9
    t.method("CheckPartitioning", static_cast<void (mfem::Mesh::*)(int *) >(&mfem::Mesh::CheckPartitioning));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::MoveVertices(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::MoveVertices(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1989:9
    t.method("MoveVertices", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::MoveVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetVertices(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetVertices(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1990:9
    t.method("GetVertices", static_cast<void (mfem::Mesh::*)(mfem::Vector &)  const>(&mfem::Mesh::GetVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetVertices(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetVertices(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1991:9
    t.method("SetVertices", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::SetVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ChangeVertexDataOwnership(double *, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ChangeVertexDataOwnership(double *, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1998:9
    t.method("ChangeVertexDataOwnership", static_cast<void (mfem::Mesh::*)(double *, int, bool) >(&mfem::Mesh::ChangeVertexDataOwnership));
    t.method("ChangeVertexDataOwnership", [](mfem::Mesh& a, double * arg0, int arg1)->void { a.ChangeVertexDataOwnership(arg0, arg1); });
    t.method("ChangeVertexDataOwnership", [](mfem::Mesh* a, double * arg0, int arg1)->void { a->ChangeVertexDataOwnership(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNode(int, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNode(int, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2004:9
    t.method("GetNode", static_cast<void (mfem::Mesh::*)(int, double *)  const>(&mfem::Mesh::GetNode));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNode(int, const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNode(int, const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2005:9
    t.method("SetNode", static_cast<void (mfem::Mesh::*)(int, const double *) >(&mfem::Mesh::SetNode));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::MoveNodes(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::MoveNodes(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2010:9
    t.method("MoveNodes", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::MoveNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNodes(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNodes(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2011:9
    t.method("GetNodes", static_cast<void (mfem::Mesh::*)(mfem::Vector &)  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodes(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodes(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2013:9
    t.method("SetNodes", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::SetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ScaleSubdomains(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ScaleSubdomains(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2015:9
    t.method("ScaleSubdomains", static_cast<void (mfem::Mesh::*)(double) >(&mfem::Mesh::ScaleSubdomains));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ScaleElements(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ScaleElements(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2016:9
    t.method("ScaleElements", static_cast<void (mfem::Mesh::*)(double) >(&mfem::Mesh::ScaleElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Transform(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Transform(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2019:9
    t.method("Transform", static_cast<void (mfem::Mesh::*)(mfem::VectorCoefficient &) >(&mfem::Mesh::Transform));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::NodesUpdated() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::NodesUpdated()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2029:9
    t.method("NodesUpdated", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::NodesUpdated));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction * mfem::Mesh::GetNodes() (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction * mfem::Mesh::GetNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2047:18
    t.method("GetNodes", static_cast<mfem::GridFunction * (mfem::Mesh::*)() >(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::Mesh::GetNodes() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::Mesh::GetNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2048:24
    t.method("GetNodes", static_cast<const mfem::GridFunction * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::OwnsNodes() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::OwnsNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2050:9
    t.method("OwnsNodes", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::OwnsNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodesOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodesOwner(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2052:9
    t.method("SetNodesOwner", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::SetNodesOwner));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::NewNodes(mfem::GridFunction &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::NewNodes(mfem::GridFunction &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2055:9
    t.method("NewNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction &, bool) >(&mfem::Mesh::NewNodes));
    t.method("NewNodes", [](mfem::Mesh& a, mfem::GridFunction & arg0)->void { a.NewNodes(arg0); });
    t.method("NewNodes", [](mfem::Mesh* a, mfem::GridFunction & arg0)->void { a->NewNodes(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SwapNodes(mfem::GridFunction *&, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SwapNodes(mfem::GridFunction *&, int &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2059:9
    t.method("SwapNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction *&, int &) >(&mfem::Mesh::SwapNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNodes(mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNodes(mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2062:9
    t.method("GetNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction &)  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodalFESpace(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodalFESpace(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2066:17
    t.method("SetNodalFESpace", static_cast<void (mfem::Mesh::*)(mfem::FiniteElementSpace *) >(&mfem::Mesh::SetNodalFESpace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodalGridFunction(mfem::GridFunction *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodalGridFunction(mfem::GridFunction *, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2070:9
    t.method("SetNodalGridFunction", static_cast<void (mfem::Mesh::*)(mfem::GridFunction *, bool) >(&mfem::Mesh::SetNodalGridFunction));
    t.method("SetNodalGridFunction", [](mfem::Mesh& a, mfem::GridFunction * arg0)->void { a.SetNodalGridFunction(arg0); });
    t.method("SetNodalGridFunction", [](mfem::Mesh* a, mfem::GridFunction * arg0)->void { a->SetNodalGridFunction(arg0); });

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::Mesh::GetNodalFESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::Mesh::GetNodalFESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2073:30
    t.method("GetNodalFESpace", static_cast<const mfem::FiniteElementSpace * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNodalFESpace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::EnsureNodes() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::EnsureNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2079:9
    t.method("EnsureNodes", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::EnsureNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetCurvature(int, bool, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetCurvature(int, bool, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2090:17
    t.method("SetCurvature", static_cast<void (mfem::Mesh::*)(int, bool, int, int) >(&mfem::Mesh::SetCurvature));
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0)->void { a.SetCurvature(arg0); });
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0, bool arg1)->void { a.SetCurvature(arg0, arg1); });
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0, bool arg1, int arg2)->void { a.SetCurvature(arg0, arg1, arg2); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0)->void { a->SetCurvature(arg0); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0, bool arg1)->void { a->SetCurvature(arg0, arg1); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0, bool arg1, int arg2)->void { a->SetCurvature(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::UniformRefinement(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::UniformRefinement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2109:9
    t.method("UniformRefinement", static_cast<void (mfem::Mesh::*)(int) >(&mfem::Mesh::UniformRefinement));
    t.method("UniformRefinement", [](mfem::Mesh& a)->void { a.UniformRefinement(); });
    t.method("UniformRefinement", [](mfem::Mesh* a)->void { a->UniformRefinement(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeneralRefinement(const mfem::Array<mfem::Refinement> &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GeneralRefinement(const mfem::Array<mfem::Refinement> &, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2119:9
    t.method("GeneralRefinement", static_cast<void (mfem::Mesh::*)(const mfem::Array<mfem::Refinement> &, int, int) >(&mfem::Mesh::GeneralRefinement));
    t.method("GeneralRefinement", [](mfem::Mesh& a, const mfem::Array<mfem::Refinement> & arg0)->void { a.GeneralRefinement(arg0); });
    t.method("GeneralRefinement", [](mfem::Mesh& a, const mfem::Array<mfem::Refinement> & arg0, int arg1)->void { a.GeneralRefinement(arg0, arg1); });
    t.method("GeneralRefinement", [](mfem::Mesh* a, const mfem::Array<mfem::Refinement> & arg0)->void { a->GeneralRefinement(arg0); });
    t.method("GeneralRefinement", [](mfem::Mesh* a, const mfem::Array<mfem::Refinement> & arg0, int arg1)->void { a->GeneralRefinement(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeneralRefinement(const mfem::Array<int> &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GeneralRefinement(const mfem::Array<int> &, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2124:9
    t.method("GeneralRefinement", static_cast<void (mfem::Mesh::*)(const mfem::Array<int> &, int, int) >(&mfem::Mesh::GeneralRefinement));
    t.method("GeneralRefinement", [](mfem::Mesh& a, const mfem::Array<int> & arg0)->void { a.GeneralRefinement(arg0); });
    t.method("GeneralRefinement", [](mfem::Mesh& a, const mfem::Array<int> & arg0, int arg1)->void { a.GeneralRefinement(arg0, arg1); });
    t.method("GeneralRefinement", [](mfem::Mesh* a, const mfem::Array<int> & arg0)->void { a->GeneralRefinement(arg0); });
    t.method("GeneralRefinement", [](mfem::Mesh* a, const mfem::Array<int> & arg0, int arg1)->void { a->GeneralRefinement(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RandomRefinement(double, bool, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RandomRefinement(double, bool, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2128:9
    t.method("RandomRefinement", static_cast<void (mfem::Mesh::*)(double, bool, int, int) >(&mfem::Mesh::RandomRefinement));
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0)->void { a.RandomRefinement(arg0); });
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0, bool arg1)->void { a.RandomRefinement(arg0, arg1); });
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0, bool arg1, int arg2)->void { a.RandomRefinement(arg0, arg1, arg2); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0)->void { a->RandomRefinement(arg0); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0, bool arg1)->void { a->RandomRefinement(arg0, arg1); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0, bool arg1, int arg2)->void { a->RandomRefinement(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RefineAtVertex(const mfem::Vertex &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RefineAtVertex(const mfem::Vertex &, double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2132:9
    t.method("RefineAtVertex", static_cast<void (mfem::Mesh::*)(const mfem::Vertex &, double, int) >(&mfem::Mesh::RefineAtVertex));
    t.method("RefineAtVertex", [](mfem::Mesh& a, const mfem::Vertex & arg0)->void { a.RefineAtVertex(arg0); });
    t.method("RefineAtVertex", [](mfem::Mesh& a, const mfem::Vertex & arg0, double arg1)->void { a.RefineAtVertex(arg0, arg1); });
    t.method("RefineAtVertex", [](mfem::Mesh* a, const mfem::Vertex & arg0)->void { a->RefineAtVertex(arg0); });
    t.method("RefineAtVertex", [](mfem::Mesh* a, const mfem::Vertex & arg0, double arg1)->void { a->RefineAtVertex(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::RefineByError(const mfem::Array<double> &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::RefineByError(const mfem::Array<double> &, double, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2137:9
    t.method("RefineByError", static_cast<bool (mfem::Mesh::*)(const mfem::Array<double> &, double, int, int) >(&mfem::Mesh::RefineByError));
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Array<double> & arg0, double arg1)->bool { return a.RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Array<double> & arg0, double arg1, int arg2)->bool { return a.RefineByError(arg0, arg1, arg2); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Array<double> & arg0, double arg1)->bool { return a->RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Array<double> & arg0, double arg1, int arg2)->bool { return a->RefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::RefineByError(const mfem::Vector &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::RefineByError(const mfem::Vector &, double, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2142:9
    t.method("RefineByError", static_cast<bool (mfem::Mesh::*)(const mfem::Vector &, double, int, int) >(&mfem::Mesh::RefineByError));
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1)->bool { return a.RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1, int arg2)->bool { return a.RefineByError(arg0, arg1, arg2); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1)->bool { return a->RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1, int arg2)->bool { return a->RefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::DerefineByError(mfem::Array<double> &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::DerefineByError(mfem::Array<double> &, double, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2150:9
    t.method("DerefineByError", static_cast<bool (mfem::Mesh::*)(mfem::Array<double> &, double, int, int) >(&mfem::Mesh::DerefineByError));
    t.method("DerefineByError", [](mfem::Mesh& a, mfem::Array<double> & arg0, double arg1)->bool { return a.DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh& a, mfem::Array<double> & arg0, double arg1, int arg2)->bool { return a.DerefineByError(arg0, arg1, arg2); });
    t.method("DerefineByError", [](mfem::Mesh* a, mfem::Array<double> & arg0, double arg1)->bool { return a->DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh* a, mfem::Array<double> & arg0, double arg1, int arg2)->bool { return a->DerefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::DerefineByError(const mfem::Vector &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::DerefineByError(const mfem::Vector &, double, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2154:9
    t.method("DerefineByError", static_cast<bool (mfem::Mesh::*)(const mfem::Vector &, double, int, int) >(&mfem::Mesh::DerefineByError));
    t.method("DerefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1)->bool { return a.DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1, int arg2)->bool { return a.DerefineByError(arg0, arg1, arg2); });
    t.method("DerefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1)->bool { return a->DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1, int arg2)->bool { return a->DerefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::EnsureNCMesh(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::EnsureNCMesh(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2160:9
    t.method("EnsureNCMesh", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::EnsureNCMesh));
    t.method("EnsureNCMesh", [](mfem::Mesh& a)->void { a.EnsureNCMesh(); });
    t.method("EnsureNCMesh", [](mfem::Mesh* a)->void { a->EnsureNCMesh(); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::Conforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::Conforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2162:9
    t.method("Conforming", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::Conforming));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::Nonconforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::Nonconforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2163:9
    t.method("Nonconforming", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::Nonconforming));

    DEBUG_MSG("Adding wrapper for const mfem::CoarseFineTransformations & mfem::Mesh::GetRefinementTransforms() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::CoarseFineTransformations & mfem::Mesh::GetRefinementTransforms()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2167:37
    t.method("GetRefinementTransforms", static_cast<const mfem::CoarseFineTransformations & (mfem::Mesh::*)()  const>(&mfem::Mesh::GetRefinementTransforms));

    DEBUG_MSG("Adding wrapper for mfem::Mesh::Operation mfem::Mesh::GetLastOperation() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh::Operation mfem::Mesh::GetLastOperation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2170:14
    t.method("GetLastOperation", static_cast<mfem::Mesh::Operation (mfem::Mesh::*)()  const>(&mfem::Mesh::GetLastOperation));

    DEBUG_MSG("Adding wrapper for long mfem::Mesh::GetSequence() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::Mesh::GetSequence()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2176:9
    t.method("GetSequence", static_cast<long (mfem::Mesh::*)()  const>(&mfem::Mesh::GetSequence));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RefineNURBSFromFile(std::string) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RefineNURBSFromFile(std::string)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2189:9
    t.method("RefineNURBSFromFile", static_cast<void (mfem::Mesh::*)(std::string) >(&mfem::Mesh::RefineNURBSFromFile));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::KnotInsert(mfem::Array<mfem::KnotVector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::KnotInsert(mfem::Array<mfem::KnotVector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2190:9
    t.method("KnotInsert", static_cast<void (mfem::Mesh::*)(mfem::Array<mfem::KnotVector *> &) >(&mfem::Mesh::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::KnotInsert(mfem::Array<mfem::Vector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::KnotInsert(mfem::Array<mfem::Vector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2191:9
    t.method("KnotInsert", static_cast<void (mfem::Mesh::*)(mfem::Array<mfem::Vector *> &) >(&mfem::Mesh::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::DegreeElevate(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::DegreeElevate(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2194:9
    t.method("DegreeElevate", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::DegreeElevate));
    t.method("DegreeElevate", [](mfem::Mesh& a, int arg0)->void { a.DegreeElevate(arg0); });
    t.method("DegreeElevate", [](mfem::Mesh* a, int arg0)->void { a->DegreeElevate(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Save(const std::string &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Save(const std::string &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2213:17
    t.method("Save", static_cast<void (mfem::Mesh::*)(const std::string &, int)  const>(&mfem::Mesh::Save));
    t.method("Save", [](mfem::Mesh const& a, const std::string & arg0)->void { a.Save(arg0); });
    t.method("Save", [](mfem::Mesh const* a, const std::string & arg0)->void { a->Save(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::PrintVTU(std::string, mfem::VTKFormat, bool, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::PrintVTU(std::string, mfem::VTKFormat, bool, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2239:17
    t.method("PrintVTU", static_cast<void (mfem::Mesh::*)(std::string, mfem::VTKFormat, bool, int, bool) >(&mfem::Mesh::PrintVTU));
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0)->void { a.PrintVTU(arg0); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1)->void { a.PrintVTU(arg0, arg1); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void { a.PrintVTU(arg0, arg1, arg2); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2, int arg3)->void { a.PrintVTU(arg0, arg1, arg2, arg3); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0)->void { a->PrintVTU(arg0); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1)->void { a->PrintVTU(arg0, arg1); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void { a->PrintVTU(arg0, arg1, arg2); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2, int arg3)->void { a->PrintVTU(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::PrintBdrVTU(std::string, mfem::VTKFormat, bool, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::PrintBdrVTU(std::string, mfem::VTKFormat, bool, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2246:9
    t.method("PrintBdrVTU", static_cast<void (mfem::Mesh::*)(std::string, mfem::VTKFormat, bool, int) >(&mfem::Mesh::PrintBdrVTU));
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0)->void { a.PrintBdrVTU(arg0); });
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1)->void { a.PrintBdrVTU(arg0, arg1); });
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void { a.PrintBdrVTU(arg0, arg1, arg2); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0)->void { a->PrintBdrVTU(arg0); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1)->void { a->PrintBdrVTU(arg0, arg1); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void { a->PrintBdrVTU(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for std::vector<int> mfem::Mesh::CreatePeriodicVertexMapping(const std::vector<mfem::Vector> &, double) (" __HERE__ ")");
    // signature to use in the veto list: std::vector<int> mfem::Mesh::CreatePeriodicVertexMapping(const std::vector<mfem::Vector> &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2310:21
    t.method("CreatePeriodicVertexMapping", static_cast<std::vector<int> (mfem::Mesh::*)(const std::vector<mfem::Vector> &, double)  const>(&mfem::Mesh::CreatePeriodicVertexMapping));
    t.method("CreatePeriodicVertexMapping", [](mfem::Mesh const& a, const std::vector<mfem::Vector> & arg0)->std::vector<int> { return a.CreatePeriodicVertexMapping(arg0); });
    t.method("CreatePeriodicVertexMapping", [](mfem::Mesh const* a, const std::vector<mfem::Vector> & arg0)->std::vector<int> { return a->CreatePeriodicVertexMapping(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::FindPoints(mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<mfem::IntegrationPoint> &, bool, mfem::InverseElementTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::FindPoints(mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<mfem::IntegrationPoint> &, bool, mfem::InverseElementTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2338:16
    t.method("FindPoints", static_cast<int (mfem::Mesh::*)(mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<mfem::IntegrationPoint> &, bool, mfem::InverseElementTransformation *) >(&mfem::Mesh::FindPoints));
    t.method("FindPoints", [](mfem::Mesh& a, mfem::DenseMatrix & arg0, mfem::Array<int> & arg1, mfem::Array<mfem::IntegrationPoint> & arg2)->int { return a.FindPoints(arg0, arg1, arg2); });
    t.method("FindPoints", [](mfem::Mesh& a, mfem::DenseMatrix & arg0, mfem::Array<int> & arg1, mfem::Array<mfem::IntegrationPoint> & arg2, bool arg3)->int { return a.FindPoints(arg0, arg1, arg2, arg3); });
    t.method("FindPoints", [](mfem::Mesh* a, mfem::DenseMatrix & arg0, mfem::Array<int> & arg1, mfem::Array<mfem::IntegrationPoint> & arg2)->int { return a->FindPoints(arg0, arg1, arg2); });
    t.method("FindPoints", [](mfem::Mesh* a, mfem::DenseMatrix & arg0, mfem::Array<int> & arg1, mfem::Array<mfem::IntegrationPoint> & arg2, bool arg3)->int { return a->FindPoints(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetGeometricParametersFromJacobian(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetGeometricParametersFromJacobian(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2351:9
    t.method("GetGeometricParametersFromJacobian", static_cast<void (mfem::Mesh::*)(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &)  const>(&mfem::Mesh::GetGeometricParametersFromJacobian));

    DEBUG_MSG("Adding wrapper for long long mfem::Mesh::ReduceInt(int) (" __HERE__ ")");
    // signature to use in the veto list: long long mfem::Mesh::ReduceInt(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2358:22
    t.method("ReduceInt", static_cast<long long (mfem::Mesh::*)(int)  const>(&mfem::Mesh::ReduceInt));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementColoring(mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementColoring(mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2361:9
    t.method("GetElementColoring", static_cast<void (mfem::Mesh::*)(mfem::Array<int> &, int) >(&mfem::Mesh::GetElementColoring));
    t.method("GetElementColoring", [](mfem::Mesh& a, mfem::Array<int> & arg0)->void { a.GetElementColoring(arg0); });
    t.method("GetElementColoring", [](mfem::Mesh* a, mfem::Array<int> & arg0)->void { a->GetElementColoring(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::CheckDisplacements(const mfem::Vector &, double &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::CheckDisplacements(const mfem::Vector &, double &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2367:9
    t.method("CheckDisplacements", static_cast<void (mfem::Mesh::*)(const mfem::Vector &, double &) >(&mfem::Mesh::CheckDisplacements));

    DEBUG_MSG("Adding attributes methods  to provide read access to the field attributes (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:273:15
    // signature to use in the veto list: mfem::Mesh::attributes
    t.method("attributes", [](const mfem::Mesh& a) -> const mfem::Array<int>& { return a.attributes; });
    t.method("attributes", [](mfem::Mesh& a) -> mfem::Array<int>& { return a.attributes; });
    t.method("attributes", [](const mfem::Mesh* a) -> const mfem::Array<int>& { return a->attributes; });
    t.method("attributes", [](mfem::Mesh* a) -> mfem::Array<int>& { return a->attributes; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:273:15
    // signature to use in the veto list: mfem::Mesh::attributes
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding attributes! methods to provide write access to the field attributes (" __HERE__ ")");
    t.method("attributes!", [](mfem::Mesh& a, const mfem::Array<int>& val) -> mfem::Array<int>& { return a.attributes = val; });

    DEBUG_MSG("Adding attributes! methods to provide write access to the field attributes (" __HERE__ ")");
    t.method("attributes!", [](mfem::Mesh* a, const mfem::Array<int>& val) -> mfem::Array<int>& { return a->attributes = val; });

    DEBUG_MSG("Adding bdr_attributes methods  to provide read access to the field bdr_attributes (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:275:15
    // signature to use in the veto list: mfem::Mesh::bdr_attributes
    t.method("bdr_attributes", [](const mfem::Mesh& a) -> const mfem::Array<int>& { return a.bdr_attributes; });
    t.method("bdr_attributes", [](mfem::Mesh& a) -> mfem::Array<int>& { return a.bdr_attributes; });
    t.method("bdr_attributes", [](const mfem::Mesh* a) -> const mfem::Array<int>& { return a->bdr_attributes; });
    t.method("bdr_attributes", [](mfem::Mesh* a) -> mfem::Array<int>& { return a->bdr_attributes; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:275:15
    // signature to use in the veto list: mfem::Mesh::bdr_attributes
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding bdr_attributes! methods to provide write access to the field bdr_attributes (" __HERE__ ")");
    t.method("bdr_attributes!", [](mfem::Mesh& a, const mfem::Array<int>& val) -> mfem::Array<int>& { return a.bdr_attributes = val; });

    DEBUG_MSG("Adding bdr_attributes! methods to provide write access to the field bdr_attributes (" __HERE__ ")");
    t.method("bdr_attributes!", [](mfem::Mesh* a, const mfem::Array<int>& val) -> mfem::Array<int>& { return a->bdr_attributes = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureFunctions1D> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureFunctions1D> : std::false_type { };
}

// Class generating the wrapper for type mfem::QuadratureFunctions1D
// signature to use in the veto file: mfem::QuadratureFunctions1D
struct Jlmfem_QuadratureFunctions1D: public Wrapper {

  Jlmfem_QuadratureFunctions1D(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureFunctions1D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:369:7
    jlcxx::TypeWrapper<mfem::QuadratureFunctions1D>  t = jlModule.add_type<mfem::QuadratureFunctions1D>("mfem!QuadratureFunctions1D");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunctions1D>>(new jlcxx::TypeWrapper<mfem::QuadratureFunctions1D>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::GaussLegendre(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::GaussLegendre(const int, mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:376:16
    module_.method("mfem!QuadratureFunctions1D!GaussLegendre", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::GaussLegendre));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::GaussLobatto(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::GaussLobatto(const int, mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:377:16
    module_.method("mfem!QuadratureFunctions1D!GaussLobatto", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::GaussLobatto));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::OpenUniform(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::OpenUniform(const int, mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:378:16
    module_.method("mfem!QuadratureFunctions1D!OpenUniform", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::OpenUniform));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::ClosedUniform(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::ClosedUniform(const int, mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:379:16
    module_.method("mfem!QuadratureFunctions1D!ClosedUniform", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::ClosedUniform));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::OpenHalfUniform(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::OpenHalfUniform(const int, mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:380:16
    module_.method("mfem!QuadratureFunctions1D!OpenHalfUniform", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::OpenHalfUniform));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::ClosedGL(const int, mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::ClosedGL(const int, mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:381:16
    module_.method("mfem!QuadratureFunctions1D!ClosedGL", static_cast<void (*)(const int, mfem::IntegrationRule *) >(&mfem::QuadratureFunctions1D::ClosedGL));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctions1D::GivePolyPoints(const int, double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctions1D::GivePolyPoints(const int, double *, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:386:16
    module_.method("mfem!QuadratureFunctions1D!GivePolyPoints", static_cast<void (*)(const int, double *, const int) >(&mfem::QuadratureFunctions1D::GivePolyPoints));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunctions1D>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunctions1D(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureFunctions1D(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Quadrature1D> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Quadrature1D> : std::false_type { };
}

// Class generating the wrapper for type mfem::Quadrature1D
// signature to use in the veto file: mfem::Quadrature1D
struct Jlmfem_Quadrature1D: public Wrapper {

  Jlmfem_Quadrature1D(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Quadrature1D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:393:7
    jlcxx::TypeWrapper<mfem::Quadrature1D>  t = jlModule.add_type<mfem::Quadrature1D>("mfem!Quadrature1D");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Quadrature1D>>(new jlcxx::TypeWrapper<mfem::Quadrature1D>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::Quadrature1D::CheckClosed(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Quadrature1D::CheckClosed(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:408:15
    module_.method("mfem!Quadrature1D!CheckClosed", static_cast<int (*)(int) >(&mfem::Quadrature1D::CheckClosed));

    DEBUG_MSG("Adding wrapper for int mfem::Quadrature1D::CheckOpen(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Quadrature1D::CheckOpen(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:411:15
    module_.method("mfem!Quadrature1D!CheckOpen", static_cast<int (*)(int) >(&mfem::Quadrature1D::CheckOpen));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Quadrature1D>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Quadrature1D(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Quadrature1D(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IntegrationRules> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IntegrationRules> : std::false_type { };
}

// Class generating the wrapper for type mfem::IntegrationRules
// signature to use in the veto file: mfem::IntegrationRules
struct Jlmfem_IntegrationRules: public Wrapper {

  Jlmfem_IntegrationRules(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IntegrationRules (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:415:7
    jlcxx::TypeWrapper<mfem::IntegrationRules>  t = jlModule.add_type<mfem::IntegrationRules>("mfem!IntegrationRules");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRules>>(new jlcxx::TypeWrapper<mfem::IntegrationRules>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRules::IntegrationRules(int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:471:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::IntegrationRules::Get(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::IntegrationRules::Get(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:475:27
    t.method("Get", static_cast<const mfem::IntegrationRule & (mfem::IntegrationRules::*)(int, int) >(&mfem::IntegrationRules::Get));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRules::Set(int, int, mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationRules::Set(int, int, mfem::IntegrationRule &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:477:9
    t.method("Set", static_cast<void (mfem::IntegrationRules::*)(int, int, mfem::IntegrationRule &) >(&mfem::IntegrationRules::Set));

    DEBUG_MSG("Adding wrapper for void mfem::IntegrationRules::SetOwnRules(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IntegrationRules::SetOwnRules(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:479:9
    t.method("SetOwnRules", static_cast<void (mfem::IntegrationRules::*)(int) >(&mfem::IntegrationRules::SetOwnRules));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRules>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IntegrationRules(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IntegrationRules(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CoarseFineTransformations> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CoarseFineTransformations> : std::false_type { };
}

// Class generating the wrapper for type mfem::CoarseFineTransformations
// signature to use in the veto file: mfem::CoarseFineTransformations
struct Jlmfem_CoarseFineTransformations: public Wrapper {

  Jlmfem_CoarseFineTransformations(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CoarseFineTransformations (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:71:8
    jlcxx::TypeWrapper<mfem::CoarseFineTransformations>  t = jlModule.add_type<mfem::CoarseFineTransformations>("mfem!CoarseFineTransformations");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CoarseFineTransformations>>(new jlcxx::TypeWrapper<mfem::CoarseFineTransformations>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::CoarseFineTransformations::MakeCoarseToFineTable(mfem::Table &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoarseFineTransformations::MakeCoarseToFineTable(mfem::Table &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:83:9
    t.method("MakeCoarseToFineTable", static_cast<void (mfem::CoarseFineTransformations::*)(mfem::Table &, bool)  const>(&mfem::CoarseFineTransformations::MakeCoarseToFineTable));
    t.method("MakeCoarseToFineTable", [](mfem::CoarseFineTransformations const& a, mfem::Table & arg0)->void { a.MakeCoarseToFineTable(arg0); });
    t.method("MakeCoarseToFineTable", [](mfem::CoarseFineTransformations const* a, mfem::Table & arg0)->void { a->MakeCoarseToFineTable(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::CoarseFineTransformations::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoarseFineTransformations::Clear()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:86:9
    t.method("Clear", static_cast<void (mfem::CoarseFineTransformations::*)() >(&mfem::CoarseFineTransformations::Clear));

    DEBUG_MSG("Adding wrapper for bool mfem::CoarseFineTransformations::IsInitialized() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::CoarseFineTransformations::IsInitialized()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:87:9
    t.method("IsInitialized", static_cast<bool (mfem::CoarseFineTransformations::*)()  const>(&mfem::CoarseFineTransformations::IsInitialized));

    DEBUG_MSG("Adding wrapper for long mfem::CoarseFineTransformations::MemoryUsage() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::CoarseFineTransformations::MemoryUsage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:88:9
    t.method("MemoryUsage", static_cast<long (mfem::CoarseFineTransformations::*)()  const>(&mfem::CoarseFineTransformations::MemoryUsage));

    DEBUG_MSG("Adding wrapper for void mfem::CoarseFineTransformations::GetCoarseToFineMap(const mfem::Mesh &, mfem::Table &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoarseFineTransformations::GetCoarseToFineMap(const mfem::Mesh &, mfem::Table &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:91:9
    t.method("GetCoarseToFineMap", static_cast<void (mfem::CoarseFineTransformations::*)(const mfem::Mesh &, mfem::Table &)  const>(&mfem::CoarseFineTransformations::GetCoarseToFineMap));

    DEBUG_MSG("Adding embeddings methods  to provide read access to the field embeddings (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:74:21
    // signature to use in the veto list: mfem::CoarseFineTransformations::embeddings
    t.method("embeddings", [](const mfem::CoarseFineTransformations& a) -> const mfem::Array<mfem::Embedding>& { return a.embeddings; });
    t.method("embeddings", [](mfem::CoarseFineTransformations& a) -> mfem::Array<mfem::Embedding>& { return a.embeddings; });
    t.method("embeddings", [](const mfem::CoarseFineTransformations* a) -> const mfem::Array<mfem::Embedding>& { return a->embeddings; });
    t.method("embeddings", [](mfem::CoarseFineTransformations* a) -> mfem::Array<mfem::Embedding>& { return a->embeddings; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:74:21
    // signature to use in the veto list: mfem::CoarseFineTransformations::embeddings
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding embeddings! methods to provide write access to the field embeddings (" __HERE__ ")");
    t.method("embeddings!", [](mfem::CoarseFineTransformations& a, const mfem::Array<mfem::Embedding>& val) -> mfem::Array<mfem::Embedding>& { return a.embeddings = val; });

    DEBUG_MSG("Adding embeddings! methods to provide write access to the field embeddings (" __HERE__ ")");
    t.method("embeddings!", [](mfem::CoarseFineTransformations* a, const mfem::Array<mfem::Embedding>& val) -> mfem::Array<mfem::Embedding>& { return a->embeddings = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CoarseFineTransformations>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CoarseFineTransformations(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CoarseFineTransformations(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Table> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Table> : std::false_type { };
}

// Class generating the wrapper for type mfem::Table
// signature to use in the veto file: mfem::Table
struct Jlmfem_Table: public Wrapper {

  Jlmfem_Table(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Table (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../general/table.hpp:43:7
    jlcxx::TypeWrapper<mfem::Table>  t = jlModule.add_type<mfem::Table>("mfem!Table");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Table>>(new jlcxx::TypeWrapper<mfem::Table>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Table>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Table(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Table(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Coefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Coefficient> : std::false_type { };
}

// Class generating the wrapper for type mfem::Coefficient
// signature to use in the veto file: mfem::Coefficient
struct Jlmfem_Coefficient: public Wrapper {

  Jlmfem_Coefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Coefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:41:7
    jlcxx::TypeWrapper<mfem::Coefficient>  t = jlModule.add_type<mfem::Coefficient>("mfem!Coefficient");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Coefficient>>(new jlcxx::TypeWrapper<mfem::Coefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::Coefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Coefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:50:17
    t.method("SetTime", static_cast<void (mfem::Coefficient::*)(double) >(&mfem::Coefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::Coefficient::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Coefficient::GetTime()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:53:11
    t.method("GetTime", static_cast<double (mfem::Coefficient::*)() >(&mfem::Coefficient::GetTime));

    DEBUG_MSG("Adding wrapper for double mfem::Coefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Coefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:60:19
    t.method("Eval", static_cast<double (mfem::Coefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::Coefficient::Eval));

    DEBUG_MSG("Adding wrapper for double mfem::Coefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &, double) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Coefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:68:11
    t.method("Eval", static_cast<double (mfem::Coefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &, double) >(&mfem::Coefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::Coefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Coefficient::Project(mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:77:17
    t.method("Project", static_cast<void (mfem::Coefficient::*)(mfem::QuadratureFunction &) >(&mfem::Coefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Coefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Coefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Coefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ElementTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ElementTransformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::ElementTransformation
// signature to use in the veto file: mfem::ElementTransformation
struct Jlmfem_ElementTransformation: public Wrapper {

  Jlmfem_ElementTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ElementTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/eltrans.hpp:23:7
    jlcxx::TypeWrapper<mfem::ElementTransformation>  t = jlModule.add_type<mfem::ElementTransformation>("mfem!ElementTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementTransformation>>(new jlcxx::TypeWrapper<mfem::ElementTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ElementTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ElementTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureFunction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureFunction> : std::false_type { };
template<> struct SuperType<mfem::QuadratureFunction> { typedef mfem::Vector type; };
}

// Class generating the wrapper for type mfem::QuadratureFunction
// signature to use in the veto file: mfem::QuadratureFunction
struct Jlmfem_QuadratureFunction: public Wrapper {

  Jlmfem_QuadratureFunction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureFunction (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/qfunction.hpp:23:7
    jlcxx::TypeWrapper<mfem::QuadratureFunction>  t = jlModule.add_type<mfem::QuadratureFunction>("mfem!QuadratureFunction",
      jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunction>>(new jlcxx::TypeWrapper<mfem::QuadratureFunction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureFunction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ConstantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ConstantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ConstantCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::ConstantCoefficient
// signature to use in the veto file: mfem::ConstantCoefficient
struct Jlmfem_ConstantCoefficient: public Wrapper {

  Jlmfem_ConstantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ConstantCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:84:7
    jlcxx::TypeWrapper<mfem::ConstantCoefficient>  t = jlModule.add_type<mfem::ConstantCoefficient>("mfem!ConstantCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ConstantCoefficient>>(new jlcxx::TypeWrapper<mfem::ConstantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::ConstantCoefficient::ConstantCoefficient(double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:90:13
    t.constructor<double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::ConstantCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ConstantCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:93:19
    t.method("Eval", static_cast<double (mfem::ConstantCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ConstantCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::ConstantCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConstantCoefficient::Project(mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:98:9
    t.method("Project", static_cast<void (mfem::ConstantCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::ConstantCoefficient::Project));

    DEBUG_MSG("Adding constant methods  to provide read access to the field constant (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:87:11
    // signature to use in the veto list: mfem::ConstantCoefficient::constant
    t.method("constant", [](const mfem::ConstantCoefficient& a) -> double { return a.constant; });
    t.method("constant", [](mfem::ConstantCoefficient& a) -> double { return a.constant; });
    t.method("constant", [](const mfem::ConstantCoefficient* a) -> double { return a->constant; });
    t.method("constant", [](mfem::ConstantCoefficient* a) -> double { return a->constant; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:87:11
    // signature to use in the veto list: mfem::ConstantCoefficient::constant
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding constant! methods to provide write access to the field constant (" __HERE__ ")");
    t.method("constant!", [](mfem::ConstantCoefficient& a, double val) -> double { return a.constant = val; });

    DEBUG_MSG("Adding constant! methods to provide write access to the field constant (" __HERE__ ")");
    t.method("constant!", [](mfem::ConstantCoefficient* a, double val) -> double { return a->constant = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ConstantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ConstantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ConstantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PWConstCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PWConstCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PWConstCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::PWConstCoefficient
// signature to use in the veto file: mfem::PWConstCoefficient
struct Jlmfem_PWConstCoefficient: public Wrapper {

  Jlmfem_PWConstCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PWConstCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:103:7
    jlcxx::TypeWrapper<mfem::PWConstCoefficient>  t = jlModule.add_type<mfem::PWConstCoefficient>("mfem!PWConstCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PWConstCoefficient>>(new jlcxx::TypeWrapper<mfem::PWConstCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::PWConstCoefficient::PWConstCoefficient(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:111:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::PWConstCoefficient::PWConstCoefficient(mfem::Vector &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:117:4
    t.constructor<mfem::Vector &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::PWConstCoefficient::UpdateConstants(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWConstCoefficient::UpdateConstants(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:121:9
    t.method("UpdateConstants", static_cast<void (mfem::PWConstCoefficient::*)(mfem::Vector &) >(&mfem::PWConstCoefficient::UpdateConstants));

    DEBUG_MSG("Adding wrapper for double & mfem::PWConstCoefficient::operator()(int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::PWConstCoefficient::operator()(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:124:12
    t.method("paren", static_cast<double & (mfem::PWConstCoefficient::*)(int) >(&mfem::PWConstCoefficient::operator()));

    DEBUG_MSG("Adding wrapper for void mfem::PWConstCoefficient::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWConstCoefficient::operator=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:127:9
    t.method("assign", static_cast<void (mfem::PWConstCoefficient::*)(double) >(&mfem::PWConstCoefficient::operator=));

    DEBUG_MSG("Adding wrapper for int mfem::PWConstCoefficient::GetNConst() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::PWConstCoefficient::GetNConst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:130:8
    t.method("GetNConst", static_cast<int (mfem::PWConstCoefficient::*)() >(&mfem::PWConstCoefficient::GetNConst));

    DEBUG_MSG("Adding wrapper for double mfem::PWConstCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PWConstCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:133:19
    t.method("Eval", static_cast<double (mfem::PWConstCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PWConstCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PWConstCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PWConstCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PWConstCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PWCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PWCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PWCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::PWCoefficient
// signature to use in the veto file: mfem::PWCoefficient
struct Jlmfem_PWCoefficient: public Wrapper {

  Jlmfem_PWCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PWCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:153:7
    jlcxx::TypeWrapper<mfem::PWCoefficient>  t = jlModule.add_type<mfem::PWCoefficient>("mfem!PWCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PWCoefficient>>(new jlcxx::TypeWrapper<mfem::PWCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::PWCoefficient::PWCoefficient(const mfem::Array<int> &, const mfem::Array<mfem::Coefficient *> &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:193:4
    t.constructor<const mfem::Array<int> &, const mfem::Array<mfem::Coefficient *> &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::PWCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:198:17
    t.method("SetTime", static_cast<void (mfem::PWCoefficient::*)(double) >(&mfem::PWCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::PWCoefficient::UpdateCoefficients(const mfem::Array<int> &, const mfem::Array<mfem::Coefficient *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWCoefficient::UpdateCoefficients(const mfem::Array<int> &, const mfem::Array<mfem::Coefficient *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:201:9
    t.method("UpdateCoefficients", static_cast<void (mfem::PWCoefficient::*)(const mfem::Array<int> &, const mfem::Array<mfem::Coefficient *> &) >(&mfem::PWCoefficient::UpdateCoefficients));

    DEBUG_MSG("Adding wrapper for void mfem::PWCoefficient::UpdateCoefficient(int, mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWCoefficient::UpdateCoefficient(int, mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:206:9
    t.method("UpdateCoefficient", static_cast<void (mfem::PWCoefficient::*)(int, mfem::Coefficient &) >(&mfem::PWCoefficient::UpdateCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWCoefficient::ZeroCoefficient(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWCoefficient::ZeroCoefficient(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:210:9
    t.method("ZeroCoefficient", static_cast<void (mfem::PWCoefficient::*)(int) >(&mfem::PWCoefficient::ZeroCoefficient));

    DEBUG_MSG("Adding wrapper for double mfem::PWCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PWCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:214:19
    t.method("Eval", static_cast<double (mfem::PWCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PWCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PWCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PWCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PWCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CartesianCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CartesianCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CartesianCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::CartesianCoefficient
// signature to use in the veto file: mfem::CartesianCoefficient
struct Jlmfem_CartesianCoefficient: public Wrapper {

  Jlmfem_CartesianCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CartesianCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:263:7
    jlcxx::TypeWrapper<mfem::CartesianCoefficient>  t = jlModule.add_type<mfem::CartesianCoefficient>("mfem!CartesianCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianCoefficient>>(new jlcxx::TypeWrapper<mfem::CartesianCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for double mfem::CartesianCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CartesianCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:274:19
    t.method("Eval", static_cast<double (mfem::CartesianCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CartesianCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CartesianCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CartesianCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CartesianXCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CartesianXCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CartesianXCoefficient> { typedef mfem::CartesianCoefficient type; };
}

// Class generating the wrapper for type mfem::CartesianXCoefficient
// signature to use in the veto file: mfem::CartesianXCoefficient
struct Jlmfem_CartesianXCoefficient: public Wrapper {

  Jlmfem_CartesianXCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CartesianXCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:279:7
    jlcxx::TypeWrapper<mfem::CartesianXCoefficient>  t = jlModule.add_type<mfem::CartesianXCoefficient>("mfem!CartesianXCoefficient",
      jlcxx::julia_base_type<mfem::CartesianCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianXCoefficient>>(new jlcxx::TypeWrapper<mfem::CartesianXCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianXCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CartesianXCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CartesianXCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CartesianYCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CartesianYCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CartesianYCoefficient> { typedef mfem::CartesianCoefficient type; };
}

// Class generating the wrapper for type mfem::CartesianYCoefficient
// signature to use in the veto file: mfem::CartesianYCoefficient
struct Jlmfem_CartesianYCoefficient: public Wrapper {

  Jlmfem_CartesianYCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CartesianYCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:286:7
    jlcxx::TypeWrapper<mfem::CartesianYCoefficient>  t = jlModule.add_type<mfem::CartesianYCoefficient>("mfem!CartesianYCoefficient",
      jlcxx::julia_base_type<mfem::CartesianCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianYCoefficient>>(new jlcxx::TypeWrapper<mfem::CartesianYCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianYCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CartesianYCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CartesianYCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CartesianZCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CartesianZCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CartesianZCoefficient> { typedef mfem::CartesianCoefficient type; };
}

// Class generating the wrapper for type mfem::CartesianZCoefficient
// signature to use in the veto file: mfem::CartesianZCoefficient
struct Jlmfem_CartesianZCoefficient: public Wrapper {

  Jlmfem_CartesianZCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CartesianZCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:293:7
    jlcxx::TypeWrapper<mfem::CartesianZCoefficient>  t = jlModule.add_type<mfem::CartesianZCoefficient>("mfem!CartesianZCoefficient",
      jlcxx::julia_base_type<mfem::CartesianCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianZCoefficient>>(new jlcxx::TypeWrapper<mfem::CartesianZCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CartesianZCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CartesianZCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CartesianZCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CylindricalRadialCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CylindricalRadialCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CylindricalRadialCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::CylindricalRadialCoefficient
// signature to use in the veto file: mfem::CylindricalRadialCoefficient
struct Jlmfem_CylindricalRadialCoefficient: public Wrapper {

  Jlmfem_CylindricalRadialCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CylindricalRadialCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:301:7
    jlcxx::TypeWrapper<mfem::CylindricalRadialCoefficient>  t = jlModule.add_type<mfem::CylindricalRadialCoefficient>("mfem!CylindricalRadialCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CylindricalRadialCoefficient>>(new jlcxx::TypeWrapper<mfem::CylindricalRadialCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::CylindricalRadialCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CylindricalRadialCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:310:19
    t.method("Eval", static_cast<double (mfem::CylindricalRadialCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CylindricalRadialCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CylindricalRadialCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CylindricalRadialCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CylindricalRadialCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CylindricalAzimuthalCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CylindricalAzimuthalCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CylindricalAzimuthalCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::CylindricalAzimuthalCoefficient
// signature to use in the veto file: mfem::CylindricalAzimuthalCoefficient
struct Jlmfem_CylindricalAzimuthalCoefficient: public Wrapper {

  Jlmfem_CylindricalAzimuthalCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CylindricalAzimuthalCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:317:7
    jlcxx::TypeWrapper<mfem::CylindricalAzimuthalCoefficient>  t = jlModule.add_type<mfem::CylindricalAzimuthalCoefficient>("mfem!CylindricalAzimuthalCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CylindricalAzimuthalCoefficient>>(new jlcxx::TypeWrapper<mfem::CylindricalAzimuthalCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::CylindricalAzimuthalCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CylindricalAzimuthalCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:326:19
    t.method("Eval", static_cast<double (mfem::CylindricalAzimuthalCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CylindricalAzimuthalCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CylindricalAzimuthalCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CylindricalAzimuthalCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CylindricalAzimuthalCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SphericalRadialCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SphericalRadialCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SphericalRadialCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::SphericalRadialCoefficient
// signature to use in the veto file: mfem::SphericalRadialCoefficient
struct Jlmfem_SphericalRadialCoefficient: public Wrapper {

  Jlmfem_SphericalRadialCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SphericalRadialCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:336:7
    jlcxx::TypeWrapper<mfem::SphericalRadialCoefficient>  t = jlModule.add_type<mfem::SphericalRadialCoefficient>("mfem!SphericalRadialCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalRadialCoefficient>>(new jlcxx::TypeWrapper<mfem::SphericalRadialCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::SphericalRadialCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SphericalRadialCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:345:19
    t.method("Eval", static_cast<double (mfem::SphericalRadialCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SphericalRadialCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalRadialCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SphericalRadialCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SphericalRadialCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SphericalAzimuthalCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SphericalAzimuthalCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SphericalAzimuthalCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::SphericalAzimuthalCoefficient
// signature to use in the veto file: mfem::SphericalAzimuthalCoefficient
struct Jlmfem_SphericalAzimuthalCoefficient: public Wrapper {

  Jlmfem_SphericalAzimuthalCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SphericalAzimuthalCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:351:7
    jlcxx::TypeWrapper<mfem::SphericalAzimuthalCoefficient>  t = jlModule.add_type<mfem::SphericalAzimuthalCoefficient>("mfem!SphericalAzimuthalCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalAzimuthalCoefficient>>(new jlcxx::TypeWrapper<mfem::SphericalAzimuthalCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::SphericalAzimuthalCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SphericalAzimuthalCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:360:19
    t.method("Eval", static_cast<double (mfem::SphericalAzimuthalCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SphericalAzimuthalCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalAzimuthalCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SphericalAzimuthalCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SphericalAzimuthalCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SphericalPolarCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SphericalPolarCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SphericalPolarCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::SphericalPolarCoefficient
// signature to use in the veto file: mfem::SphericalPolarCoefficient
struct Jlmfem_SphericalPolarCoefficient: public Wrapper {

  Jlmfem_SphericalPolarCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SphericalPolarCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:366:7
    jlcxx::TypeWrapper<mfem::SphericalPolarCoefficient>  t = jlModule.add_type<mfem::SphericalPolarCoefficient>("mfem!SphericalPolarCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalPolarCoefficient>>(new jlcxx::TypeWrapper<mfem::SphericalPolarCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::SphericalPolarCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SphericalPolarCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:375:19
    t.method("Eval", static_cast<double (mfem::SphericalPolarCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SphericalPolarCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SphericalPolarCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SphericalPolarCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SphericalPolarCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::GridFunctionCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::GridFunctionCoefficient
// signature to use in the veto file: mfem::GridFunctionCoefficient
struct Jlmfem_GridFunctionCoefficient: public Wrapper {

  Jlmfem_GridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GridFunctionCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:382:7
    jlcxx::TypeWrapper<mfem::GridFunctionCoefficient>  t = jlModule.add_type<mfem::GridFunctionCoefficient>("mfem!GridFunctionCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::GridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunctionCoefficient::GridFunctionCoefficient(const mfem::GridFunction *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:392:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::GridFunction *, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::GridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:396:9
    t.method("SetGridFunction", static_cast<void (mfem::GridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::GridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::GridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::GridFunctionCoefficient::GetGridFunction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:399:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::GridFunctionCoefficient::*)()  const>(&mfem::GridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for double mfem::GridFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:402:19
    t.method("Eval", static_cast<double (mfem::GridFunctionCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::GridFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunctionCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunctionCoefficient::Project(mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:410:17
    t.method("Project", static_cast<void (mfem::GridFunctionCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::GridFunctionCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GridFunction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GridFunction> : std::false_type { };
template<> struct SuperType<mfem::GridFunction> { typedef mfem::Vector type; };
}

// Class generating the wrapper for type mfem::GridFunction
// signature to use in the veto file: mfem::GridFunction
struct Jlmfem_GridFunction: public Wrapper {

  Jlmfem_GridFunction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GridFunction (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:30:7
    jlcxx::TypeWrapper<mfem::GridFunction>  t = jlModule.add_type<mfem::GridFunction>("mfem!GridFunction",
      jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunction>>(new jlcxx::TypeWrapper<mfem::GridFunction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(const mfem::GridFunction &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:78:4
    t.constructor<const mfem::GridFunction &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:83:4
    t.constructor<mfem::FiniteElementSpace *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(mfem::FiniteElementSpace *, double *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:92:4
    t.constructor<mfem::FiniteElementSpace *, double *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:98:4
    t.constructor<mfem::FiniteElementSpace *, mfem::Vector &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::FiniteElementSpace *, mfem::Vector &, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    // DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(mfem::Mesh *, GridFunction *[], int) (" __HERE__ ")");
    // // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:108:4
    // t.constructor<mfem::Mesh *, GridFunction *[], int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::GridFunction & mfem::GridFunction::operator=(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction & mfem::GridFunction::operator=(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:116:18
    t.method("assign", static_cast<mfem::GridFunction & (mfem::GridFunction::*)(const mfem::GridFunction &) >(&mfem::GridFunction::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeOwner(mfem::FiniteElementCollection *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeOwner(mfem::FiniteElementCollection *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:122:9
    t.method("MakeOwner", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementCollection *) >(&mfem::GridFunction::MakeOwner));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::GridFunction::OwnFEC() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::GridFunction::OwnFEC()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:124:29
    t.method("OwnFEC", static_cast<mfem::FiniteElementCollection * (mfem::GridFunction::*)() >(&mfem::GridFunction::OwnFEC));

    DEBUG_MSG("Adding wrapper for int mfem::GridFunction::VectorDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GridFunction::VectorDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:126:8
    t.method("VectorDim", static_cast<int (mfem::GridFunction::*)()  const>(&mfem::GridFunction::VectorDim));

    DEBUG_MSG("Adding wrapper for int mfem::GridFunction::CurlDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GridFunction::CurlDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:127:8
    t.method("CurlDim", static_cast<int (mfem::GridFunction::*)()  const>(&mfem::GridFunction::CurlDim));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::GridFunction::GetTrueVector() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::GridFunction::GetTrueVector()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:130:18
    t.method("GetTrueVector", static_cast<const mfem::Vector & (mfem::GridFunction::*)()  const>(&mfem::GridFunction::GetTrueVector));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::GridFunction::GetTrueVector() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::GridFunction::GetTrueVector()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:137:12
    t.method("GetTrueVector", static_cast<mfem::Vector & (mfem::GridFunction::*)() >(&mfem::GridFunction::GetTrueVector));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetTrueDofs(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetTrueDofs(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:141:9
    t.method("GetTrueDofs", static_cast<void (mfem::GridFunction::*)(mfem::Vector &)  const>(&mfem::GridFunction::GetTrueDofs));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::SetTrueVector() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::SetTrueVector()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:144:9
    t.method("SetTrueVector", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::SetTrueVector));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::SetFromTrueDofs(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::SetFromTrueDofs(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:147:17
    t.method("SetFromTrueDofs", static_cast<void (mfem::GridFunction::*)(const mfem::Vector &) >(&mfem::GridFunction::SetFromTrueDofs));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::SetFromTrueVector() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::SetFromTrueVector()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:150:9
    t.method("SetFromTrueVector", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::SetFromTrueVector));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetNodalValues(int, mfem::Array<double> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetNodalValues(int, mfem::Array<double> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:153:9
    t.method("GetNodalValues", static_cast<void (mfem::GridFunction::*)(int, mfem::Array<double> &, int)  const>(&mfem::GridFunction::GetNodalValues));
    t.method("GetNodalValues", [](mfem::GridFunction const& a, int arg0, mfem::Array<double> & arg1)->void { a.GetNodalValues(arg0, arg1); });
    t.method("GetNodalValues", [](mfem::GridFunction const* a, int arg0, mfem::Array<double> & arg1)->void { a->GetNodalValues(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for double mfem::GridFunction::GetValue(int, const mfem::IntegrationPoint &, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunction::GetValue(int, const mfem::IntegrationPoint &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:169:19
    t.method("GetValue", static_cast<double (mfem::GridFunction::*)(int, const mfem::IntegrationPoint &, int)  const>(&mfem::GridFunction::GetValue));
    t.method("GetValue", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationPoint & arg1)->double { return a.GetValue(arg0, arg1); });
    t.method("GetValue", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationPoint & arg1)->double { return a->GetValue(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorValue(int, const mfem::IntegrationPoint &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorValue(int, const mfem::IntegrationPoint &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:173:17
    t.method("GetVectorValue", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationPoint &, mfem::Vector &)  const>(&mfem::GridFunction::GetVectorValue));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetValues(int, const mfem::IntegrationRule &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetValues(int, const mfem::IntegrationRule &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:194:9
    t.method("GetValues", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::Vector &, int)  const>(&mfem::GridFunction::GetValues));
    t.method("GetValues", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a.GetValues(arg0, arg1, arg2); });
    t.method("GetValues", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a->GetValues(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetValues(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetValues(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:199:9
    t.method("GetValues", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetValues));
    t.method("GetValues", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, mfem::DenseMatrix & arg3)->void { a.GetValues(arg0, arg1, arg2, arg3); });
    t.method("GetValues", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, mfem::DenseMatrix & arg3)->void { a->GetValues(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorValues(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorValues(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:202:9
    t.method("GetVectorValues", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetVectorValues));

    DEBUG_MSG("Adding wrapper for double mfem::GridFunction::GetValue(mfem::ElementTransformation &, const mfem::IntegrationPoint &, int, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunction::GetValue(mfem::ElementTransformation &, const mfem::IntegrationPoint &, int, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:220:19
    t.method("GetValue", static_cast<double (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &, int, mfem::Vector *)  const>(&mfem::GridFunction::GetValue));
    t.method("GetValue", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1)->double { return a.GetValue(arg0, arg1); });
    t.method("GetValue", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1, int arg2)->double { return a.GetValue(arg0, arg1, arg2); });
    t.method("GetValue", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1)->double { return a->GetValue(arg0, arg1); });
    t.method("GetValue", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1, int arg2)->double { return a->GetValue(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorValue(mfem::ElementTransformation &, const mfem::IntegrationPoint &, mfem::Vector &, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorValue(mfem::ElementTransformation &, const mfem::IntegrationPoint &, mfem::Vector &, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:225:17
    t.method("GetVectorValue", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &, mfem::Vector &, mfem::Vector *)  const>(&mfem::GridFunction::GetVectorValue));
    t.method("GetVectorValue", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1, mfem::Vector & arg2)->void { a.GetVectorValue(arg0, arg1, arg2); });
    t.method("GetVectorValue", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1, mfem::Vector & arg2)->void { a->GetVectorValue(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetValues(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::Vector &, int, mfem::DenseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetValues(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::Vector &, int, mfem::DenseMatrix *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:248:9
    t.method("GetValues", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::Vector &, int, mfem::DenseMatrix *)  const>(&mfem::GridFunction::GetValues));
    t.method("GetValues", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a.GetValues(arg0, arg1, arg2); });
    t.method("GetValues", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, int arg3)->void { a.GetValues(arg0, arg1, arg2, arg3); });
    t.method("GetValues", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a->GetValues(arg0, arg1, arg2); });
    t.method("GetValues", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, int arg3)->void { a->GetValues(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorValues(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorValues(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:253:9
    t.method("GetVectorValues", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix *)  const>(&mfem::GridFunction::GetVectorValues));
    t.method("GetVectorValues", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2)->void { a.GetVectorValues(arg0, arg1, arg2); });
    t.method("GetVectorValues", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2)->void { a->GetVectorValues(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for int mfem::GridFunction::GetFaceValues(int, int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GridFunction::GetFaceValues(int, int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:275:8
    t.method("GetFaceValues", static_cast<int (mfem::GridFunction::*)(int, int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetFaceValues));
    t.method("GetFaceValues", [](mfem::GridFunction const& a, int arg0, int arg1, const mfem::IntegrationRule & arg2, mfem::Vector & arg3, mfem::DenseMatrix & arg4)->int { return a.GetFaceValues(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetFaceValues", [](mfem::GridFunction const* a, int arg0, int arg1, const mfem::IntegrationRule & arg2, mfem::Vector & arg3, mfem::DenseMatrix & arg4)->int { return a->GetFaceValues(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for int mfem::GridFunction::GetFaceVectorValues(int, int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GridFunction::GetFaceVectorValues(int, int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:280:8
    t.method("GetFaceVectorValues", static_cast<int (mfem::GridFunction::*)(int, int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetFaceVectorValues));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetLaplacians(int, const mfem::IntegrationRule &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetLaplacians(int, const mfem::IntegrationRule &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:284:9
    t.method("GetLaplacians", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::Vector &, int)  const>(&mfem::GridFunction::GetLaplacians));
    t.method("GetLaplacians", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a.GetLaplacians(arg0, arg1, arg2); });
    t.method("GetLaplacians", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a->GetLaplacians(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetLaplacians(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetLaplacians(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:287:9
    t.method("GetLaplacians", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetLaplacians));
    t.method("GetLaplacians", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, mfem::DenseMatrix & arg3)->void { a.GetLaplacians(arg0, arg1, arg2, arg3); });
    t.method("GetLaplacians", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, mfem::DenseMatrix & arg3)->void { a->GetLaplacians(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetHessians(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetHessians(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:290:9
    t.method("GetHessians", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetHessians));
    t.method("GetHessians", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2)->void { a.GetHessians(arg0, arg1, arg2); });
    t.method("GetHessians", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2)->void { a->GetHessians(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetHessians(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetHessians(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:293:9
    t.method("GetHessians", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetHessians));
    t.method("GetHessians", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2, mfem::DenseMatrix & arg3)->void { a.GetHessians(arg0, arg1, arg2, arg3); });
    t.method("GetHessians", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2, mfem::DenseMatrix & arg3)->void { a->GetHessians(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetValuesFrom(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetValuesFrom(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:296:9
    t.method("GetValuesFrom", static_cast<void (mfem::GridFunction::*)(const mfem::GridFunction &) >(&mfem::GridFunction::GetValuesFrom));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetBdrValuesFrom(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetBdrValuesFrom(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:298:9
    t.method("GetBdrValuesFrom", static_cast<void (mfem::GridFunction::*)(const mfem::GridFunction &) >(&mfem::GridFunction::GetBdrValuesFrom));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorFieldValues(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorFieldValues(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:300:9
    t.method("GetVectorFieldValues", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetVectorFieldValues));
    t.method("GetVectorFieldValues", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2, mfem::DenseMatrix & arg3)->void { a.GetVectorFieldValues(arg0, arg1, arg2, arg3); });
    t.method("GetVectorFieldValues", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2, mfem::DenseMatrix & arg3)->void { a->GetVectorFieldValues(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ReorderByNodes() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ReorderByNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:305:9
    t.method("ReorderByNodes", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::ReorderByNodes));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetNodalValues(mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetNodalValues(mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:308:9
    t.method("GetNodalValues", static_cast<void (mfem::GridFunction::*)(mfem::Vector &, int)  const>(&mfem::GridFunction::GetNodalValues));
    t.method("GetNodalValues", [](mfem::GridFunction const& a, mfem::Vector & arg0)->void { a.GetNodalValues(arg0); });
    t.method("GetNodalValues", [](mfem::GridFunction const* a, mfem::Vector & arg0)->void { a->GetNodalValues(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorFieldNodalValues(mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorFieldNodalValues(mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:310:9
    t.method("GetVectorFieldNodalValues", static_cast<void (mfem::GridFunction::*)(mfem::Vector &, int)  const>(&mfem::GridFunction::GetVectorFieldNodalValues));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectVectorFieldOn(mfem::GridFunction &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectVectorFieldOn(mfem::GridFunction &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:312:9
    t.method("ProjectVectorFieldOn", static_cast<void (mfem::GridFunction::*)(mfem::GridFunction &, int) >(&mfem::GridFunction::ProjectVectorFieldOn));
    t.method("ProjectVectorFieldOn", [](mfem::GridFunction& a, mfem::GridFunction & arg0)->void { a.ProjectVectorFieldOn(arg0); });
    t.method("ProjectVectorFieldOn", [](mfem::GridFunction* a, mfem::GridFunction & arg0)->void { a->ProjectVectorFieldOn(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetDerivative(int, int, mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetDerivative(int, int, mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:324:9
    t.method("GetDerivative", static_cast<void (mfem::GridFunction::*)(int, int, mfem::GridFunction &) >(&mfem::GridFunction::GetDerivative));

    DEBUG_MSG("Adding wrapper for double mfem::GridFunction::GetDivergence(mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunction::GetDivergence(mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:326:11
    t.method("GetDivergence", static_cast<double (mfem::GridFunction::*)(mfem::ElementTransformation &)  const>(&mfem::GridFunction::GetDivergence));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetCurl(mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetCurl(mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:328:9
    t.method("GetCurl", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, mfem::Vector &)  const>(&mfem::GridFunction::GetCurl));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetGradient(mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetGradient(mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:339:9
    t.method("GetGradient", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, mfem::Vector &)  const>(&mfem::GridFunction::GetGradient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetGradients(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetGradients(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:342:9
    t.method("GetGradients", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetGradients));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetGradients(const int, const mfem::IntegrationRule &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetGradients(const int, const mfem::IntegrationRule &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:346:9
    t.method("GetGradients", static_cast<void (mfem::GridFunction::*)(const int, const mfem::IntegrationRule &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetGradients));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorGradient(mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorGradient(mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:352:9
    t.method("GetVectorGradient", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetVectorGradient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorGradientHat(mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorGradientHat(mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:356:9
    t.method("GetVectorGradientHat", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetVectorGradientHat));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetElementAverages(mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetElementAverages(mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:361:9
    t.method("GetElementAverages", static_cast<void (mfem::GridFunction::*)(mfem::GridFunction &)  const>(&mfem::GridFunction::GetElementAverages));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetElementDofValues(int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetElementDofValues(int, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:365:17
    t.method("GetElementDofValues", static_cast<void (mfem::GridFunction::*)(int, mfem::Vector &)  const>(&mfem::GridFunction::GetElementDofValues));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ImposeBounds(int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ImposeBounds(int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:371:9
    t.method("ImposeBounds", static_cast<void (mfem::GridFunction::*)(int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &) >(&mfem::GridFunction::ImposeBounds));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ImposeBounds(int, const mfem::Vector &, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ImposeBounds(int, const mfem::Vector &, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:373:9
    t.method("ImposeBounds", static_cast<void (mfem::GridFunction::*)(int, const mfem::Vector &, double, double) >(&mfem::GridFunction::ImposeBounds));
    t.method("ImposeBounds", [](mfem::GridFunction& a, int arg0, const mfem::Vector & arg1)->void { a.ImposeBounds(arg0, arg1); });
    t.method("ImposeBounds", [](mfem::GridFunction& a, int arg0, const mfem::Vector & arg1, double arg2)->void { a.ImposeBounds(arg0, arg1, arg2); });
    t.method("ImposeBounds", [](mfem::GridFunction* a, int arg0, const mfem::Vector & arg1)->void { a->ImposeBounds(arg0, arg1); });
    t.method("ImposeBounds", [](mfem::GridFunction* a, int arg0, const mfem::Vector & arg1, double arg2)->void { a->ImposeBounds(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::RestrictConforming() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::RestrictConforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:379:9
    t.method("RestrictConforming", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::RestrictConforming));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectGridFunction(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectGridFunction(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:385:9
    t.method("ProjectGridFunction", static_cast<void (mfem::GridFunction::*)(const mfem::GridFunction &) >(&mfem::GridFunction::ProjectGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:391:17
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::Coefficient &) >(&mfem::GridFunction::ProjectCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::Coefficient &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::Coefficient &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:396:9
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::Coefficient &, mfem::Array<int> &, int) >(&mfem::GridFunction::ProjectCoefficient));
    t.method("ProjectCoefficient", [](mfem::GridFunction& a, mfem::Coefficient & arg0, mfem::Array<int> & arg1)->void { a.ProjectCoefficient(arg0, arg1); });
    t.method("ProjectCoefficient", [](mfem::GridFunction* a, mfem::Coefficient & arg0, mfem::Array<int> & arg1)->void { a->ProjectCoefficient(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:402:9
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &) >(&mfem::GridFunction::ProjectCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:407:9
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:411:9
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, int) >(&mfem::GridFunction::ProjectCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectDiscCoefficient(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectDiscCoefficient(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:420:17
    t.method("ProjectDiscCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &) >(&mfem::GridFunction::ProjectDiscCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectDiscCoefficient(mfem::Coefficient &, mfem::GridFunction::AvgType) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectDiscCoefficient(mfem::Coefficient &, mfem::GridFunction::AvgType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:425:17
    t.method("ProjectDiscCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::Coefficient &, mfem::GridFunction::AvgType) >(&mfem::GridFunction::ProjectDiscCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectDiscCoefficient(mfem::VectorCoefficient &, mfem::GridFunction::AvgType) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectDiscCoefficient(mfem::VectorCoefficient &, mfem::GridFunction::AvgType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:429:17
    t.method("ProjectDiscCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::GridFunction::AvgType) >(&mfem::GridFunction::ProjectDiscCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::CountElementsPerVDof(mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::CountElementsPerVDof(mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:463:17
    t.method("CountElementsPerVDof", static_cast<void (mfem::GridFunction::*)(mfem::Array<int> &)  const>(&mfem::GridFunction::CountElementsPerVDof));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectBdrCoefficient(mfem::Coefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectBdrCoefficient(mfem::Coefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:468:9
    t.method("ProjectBdrCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::Coefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectBdrCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectBdrCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectBdrCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:477:17
    t.method("ProjectBdrCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectBdrCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectBdrCoefficientNormal(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectBdrCoefficientNormal(mfem::VectorCoefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:490:9
    t.method("ProjectBdrCoefficientNormal", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectBdrCoefficientNormal));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectBdrCoefficientTangent(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectBdrCoefficientTangent(mfem::VectorCoefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:496:17
    t.method("ProjectBdrCoefficientTangent", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectBdrCoefficientTangent));

    DEBUG_MSG("Adding wrapper for double mfem::GridFunction::ComputeH1Error(mfem::Coefficient *, mfem::VectorCoefficient *, mfem::Coefficient *, double, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunction::ComputeH1Error(mfem::Coefficient *, mfem::VectorCoefficient *, mfem::Coefficient *, double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:554:19
    t.method("ComputeH1Error", static_cast<double (mfem::GridFunction::*)(mfem::Coefficient *, mfem::VectorCoefficient *, mfem::Coefficient *, double, int)  const>(&mfem::GridFunction::ComputeH1Error));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ComputeFlux(mfem::BilinearFormIntegrator &, mfem::GridFunction &, bool, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ComputeFlux(mfem::BilinearFormIntegrator &, mfem::GridFunction &, bool, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:675:17
    t.method("ComputeFlux", static_cast<void (mfem::GridFunction::*)(mfem::BilinearFormIntegrator &, mfem::GridFunction &, bool, int) >(&mfem::GridFunction::ComputeFlux));
    t.method("ComputeFlux", [](mfem::GridFunction& a, mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1)->void { a.ComputeFlux(arg0, arg1); });
    t.method("ComputeFlux", [](mfem::GridFunction& a, mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, bool arg2)->void { a.ComputeFlux(arg0, arg1, arg2); });
    t.method("ComputeFlux", [](mfem::GridFunction* a, mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1)->void { a->ComputeFlux(arg0, arg1); });
    t.method("ComputeFlux", [](mfem::GridFunction* a, mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, bool arg2)->void { a->ComputeFlux(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::GridFunction & mfem::GridFunction::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction & mfem::GridFunction::operator=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:680:18
    t.method("assign", static_cast<mfem::GridFunction & (mfem::GridFunction::*)(double) >(&mfem::GridFunction::operator=));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction & mfem::GridFunction::operator=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction & mfem::GridFunction::operator=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:685:18
    t.method("assign", static_cast<mfem::GridFunction & (mfem::GridFunction::*)(const mfem::Vector &) >(&mfem::GridFunction::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::Update() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::Update()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:688:17
    t.method("Update", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::Update));

    DEBUG_MSG("Adding wrapper for long mfem::GridFunction::GetSequence() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::GridFunction::GetSequence()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:692:9
    t.method("GetSequence", static_cast<long (mfem::GridFunction::*)()  const>(&mfem::GridFunction::GetSequence));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::GridFunction::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::GridFunction::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:694:24
    t.method("FESpace", static_cast<mfem::FiniteElementSpace * (mfem::GridFunction::*)() >(&mfem::GridFunction::FESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::GridFunction::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::GridFunction::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:695:30
    t.method("FESpace", static_cast<const mfem::FiniteElementSpace * (mfem::GridFunction::*)()  const>(&mfem::GridFunction::FESpace));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::SetSpace(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::SetSpace(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:699:17
    t.method("SetSpace", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *) >(&mfem::GridFunction::SetSpace));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeRef(mfem::FiniteElementSpace *, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeRef(mfem::FiniteElementSpace *, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:708:17
    t.method("MakeRef", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *, double *) >(&mfem::GridFunction::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeRef(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeRef(mfem::FiniteElementSpace *, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:717:17
    t.method("MakeRef", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *, mfem::Vector &, int) >(&mfem::GridFunction::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeTRef(mfem::FiniteElementSpace *, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeTRef(mfem::FiniteElementSpace *, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:726:9
    t.method("MakeTRef", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *, double *) >(&mfem::GridFunction::MakeTRef));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeTRef(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeTRef(mfem::FiniteElementSpace *, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:736:9
    t.method("MakeTRef", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *, mfem::Vector &, int) >(&mfem::GridFunction::MakeTRef));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::Save(const char *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::Save(const char *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:743:17
    t.method("Save", static_cast<void (mfem::GridFunction::*)(const char *, int)  const>(&mfem::GridFunction::Save));
    t.method("Save", [](mfem::GridFunction const& a, const char * arg0)->void { a.Save(arg0); });
    t.method("Save", [](mfem::GridFunction const* a, const char * arg0)->void { a->Save(arg0); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GridFunction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GridFunction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TransformedCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TransformedCoefficient> : std::false_type { };
template<> struct SuperType<mfem::TransformedCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::TransformedCoefficient
// signature to use in the veto file: mfem::TransformedCoefficient
struct Jlmfem_TransformedCoefficient: public Wrapper {

  Jlmfem_TransformedCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TransformedCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:420:7
    jlcxx::TypeWrapper<mfem::TransformedCoefficient>  t = jlModule.add_type<mfem::TransformedCoefficient>("mfem!TransformedCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TransformedCoefficient>>(new jlcxx::TypeWrapper<mfem::TransformedCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::TransformedCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransformedCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:436:9
    t.method("SetTime", static_cast<void (mfem::TransformedCoefficient::*)(double) >(&mfem::TransformedCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::TransformedCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::TransformedCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:439:19
    t.method("Eval", static_cast<double (mfem::TransformedCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::TransformedCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TransformedCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TransformedCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TransformedCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DeltaCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DeltaCoefficient> : std::false_type { };
template<> struct SuperType<mfem::DeltaCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::DeltaCoefficient
// signature to use in the veto file: mfem::DeltaCoefficient
struct Jlmfem_DeltaCoefficient: public Wrapper {

  Jlmfem_DeltaCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DeltaCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:452:7
    jlcxx::TypeWrapper<mfem::DeltaCoefficient>  t = jlModule.add_type<mfem::DeltaCoefficient>("mfem!DeltaCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DeltaCoefficient>>(new jlcxx::TypeWrapper<mfem::DeltaCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::DeltaCoefficient(double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:470:4
    t.constructor<double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::DeltaCoefficient(double, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:477:4
    t.constructor<double, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::DeltaCoefficient(double, double, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:484:4
    t.constructor<double, double, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:491:9
    t.method("SetTime", static_cast<void (mfem::DeltaCoefficient::*)(double) >(&mfem::DeltaCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetDeltaCenter(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetDeltaCenter(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:494:9
    t.method("SetDeltaCenter", static_cast<void (mfem::DeltaCoefficient::*)(const mfem::Vector &) >(&mfem::DeltaCoefficient::SetDeltaCenter));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetScale(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetScale(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:497:9
    t.method("SetScale", static_cast<void (mfem::DeltaCoefficient::*)(double) >(&mfem::DeltaCoefficient::SetScale));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetFunction(double (*)(double)) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetFunction(double (*)(double))
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:500:9
    t.method("SetFunction", static_cast<void (mfem::DeltaCoefficient::*)(double (*)(double)) >(&mfem::DeltaCoefficient::SetFunction));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetTol(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetTol(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:505:9
    t.method("SetTol", static_cast<void (mfem::DeltaCoefficient::*)(double) >(&mfem::DeltaCoefficient::SetTol));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::SetWeight(mfem::Coefficient *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::SetWeight(mfem::Coefficient *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:513:9
    t.method("SetWeight", static_cast<void (mfem::DeltaCoefficient::*)(mfem::Coefficient *) >(&mfem::DeltaCoefficient::SetWeight));

    DEBUG_MSG("Adding wrapper for const double * mfem::DeltaCoefficient::Center() (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::DeltaCoefficient::Center()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:517:18
    t.method("Center", static_cast<const double * (mfem::DeltaCoefficient::*)() >(&mfem::DeltaCoefficient::Center));

    DEBUG_MSG("Adding wrapper for double mfem::DeltaCoefficient::Scale() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeltaCoefficient::Scale()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:522:11
    t.method("Scale", static_cast<double (mfem::DeltaCoefficient::*)() >(&mfem::DeltaCoefficient::Scale));

    DEBUG_MSG("Adding wrapper for double mfem::DeltaCoefficient::Tol() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeltaCoefficient::Tol()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:525:11
    t.method("Tol", static_cast<double (mfem::DeltaCoefficient::*)() >(&mfem::DeltaCoefficient::Tol));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::DeltaCoefficient::Weight() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::DeltaCoefficient::Weight()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:528:17
    t.method("Weight", static_cast<mfem::Coefficient * (mfem::DeltaCoefficient::*)() >(&mfem::DeltaCoefficient::Weight));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaCoefficient::GetDeltaCenter(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaCoefficient::GetDeltaCenter(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:531:9
    t.method("GetDeltaCenter", static_cast<void (mfem::DeltaCoefficient::*)(mfem::Vector &) >(&mfem::DeltaCoefficient::GetDeltaCenter));

    DEBUG_MSG("Adding wrapper for double mfem::DeltaCoefficient::EvalDelta(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeltaCoefficient::EvalDelta(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:534:19
    t.method("EvalDelta", static_cast<double (mfem::DeltaCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::DeltaCoefficient::EvalDelta));

    DEBUG_MSG("Adding wrapper for double mfem::DeltaCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeltaCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:537:19
    t.method("Eval", static_cast<double (mfem::DeltaCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::DeltaCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DeltaCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DeltaCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DeltaCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RestrictedCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RestrictedCoefficient> : std::false_type { };
template<> struct SuperType<mfem::RestrictedCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::RestrictedCoefficient
// signature to use in the veto file: mfem::RestrictedCoefficient
struct Jlmfem_RestrictedCoefficient: public Wrapper {

  Jlmfem_RestrictedCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RestrictedCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:544:7
    jlcxx::TypeWrapper<mfem::RestrictedCoefficient>  t = jlModule.add_type<mfem::RestrictedCoefficient>("mfem!RestrictedCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RestrictedCoefficient>>(new jlcxx::TypeWrapper<mfem::RestrictedCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RestrictedCoefficient::RestrictedCoefficient(mfem::Coefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:554:4
    t.constructor<mfem::Coefficient &, mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::RestrictedCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RestrictedCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:558:9
    t.method("SetTime", static_cast<void (mfem::RestrictedCoefficient::*)(double) >(&mfem::RestrictedCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::RestrictedCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::RestrictedCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:561:19
    t.method("Eval", static_cast<double (mfem::RestrictedCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::RestrictedCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RestrictedCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RestrictedCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RestrictedCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorCoefficient> : std::false_type { };
}

// Class generating the wrapper for type mfem::VectorCoefficient
// signature to use in the veto file: mfem::VectorCoefficient
struct Jlmfem_VectorCoefficient: public Wrapper {

  Jlmfem_VectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:566:7
    jlcxx::TypeWrapper<mfem::VectorCoefficient>  t = jlModule.add_type<mfem::VectorCoefficient>("mfem!VectorCoefficient");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:577:17
    t.method("SetTime", static_cast<void (mfem::VectorCoefficient::*)(double) >(&mfem::VectorCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::VectorCoefficient::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorCoefficient::GetTime()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:580:11
    t.method("GetTime", static_cast<double (mfem::VectorCoefficient::*)() >(&mfem::VectorCoefficient::GetTime));

    DEBUG_MSG("Adding wrapper for int mfem::VectorCoefficient::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::VectorCoefficient::GetVDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:583:8
    t.method("GetVDim", static_cast<int (mfem::VectorCoefficient::*)() >(&mfem::VectorCoefficient::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:590:17
    t.method("Eval", static_cast<void (mfem::VectorCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:605:17
    t.method("Eval", static_cast<void (mfem::VectorCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) >(&mfem::VectorCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCoefficient::Project(mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:613:17
    t.method("Project", static_cast<void (mfem::VectorCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::VectorCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorConstantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorConstantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorConstantCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::VectorConstantCoefficient
// signature to use in the veto file: mfem::VectorConstantCoefficient
struct Jlmfem_VectorConstantCoefficient: public Wrapper {

  Jlmfem_VectorConstantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorConstantCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:620:7
    jlcxx::TypeWrapper<mfem::VectorConstantCoefficient>  t = jlModule.add_type<mfem::VectorConstantCoefficient>("mfem!VectorConstantCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorConstantCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorConstantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorConstantCoefficient::VectorConstantCoefficient(const mfem::Vector &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:626:4
    t.constructor<const mfem::Vector &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorConstantCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorConstantCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:631:17
    t.method("Eval", static_cast<void (mfem::VectorConstantCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorConstantCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::VectorConstantCoefficient::GetVec() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::VectorConstantCoefficient::GetVec()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:635:18
    t.method("GetVec", static_cast<const mfem::Vector & (mfem::VectorConstantCoefficient::*)()  const>(&mfem::VectorConstantCoefficient::GetVec));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorConstantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorConstantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorConstantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PWVectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PWVectorCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PWVectorCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::PWVectorCoefficient
// signature to use in the veto file: mfem::PWVectorCoefficient
struct Jlmfem_PWVectorCoefficient: public Wrapper {

  Jlmfem_PWVectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PWVectorCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:655:7
    jlcxx::TypeWrapper<mfem::PWVectorCoefficient>  t = jlModule.add_type<mfem::PWVectorCoefficient>("mfem!PWVectorCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PWVectorCoefficient>>(new jlcxx::TypeWrapper<mfem::PWVectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::PWVectorCoefficient(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:684:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWVectorCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:701:17
    t.method("SetTime", static_cast<void (mfem::PWVectorCoefficient::*)(double) >(&mfem::PWVectorCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::UpdateCoefficient(int, mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWVectorCoefficient::UpdateCoefficient(int, mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:709:9
    t.method("UpdateCoefficient", static_cast<void (mfem::PWVectorCoefficient::*)(int, mfem::VectorCoefficient &) >(&mfem::PWVectorCoefficient::UpdateCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::ZeroCoefficient(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWVectorCoefficient::ZeroCoefficient(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:712:9
    t.method("ZeroCoefficient", static_cast<void (mfem::PWVectorCoefficient::*)(int) >(&mfem::PWVectorCoefficient::ZeroCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:716:17
    t.method("Eval", static_cast<void (mfem::PWVectorCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PWVectorCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PWVectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PWVectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PWVectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PositionVectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PositionVectorCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PositionVectorCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::PositionVectorCoefficient
// signature to use in the veto file: mfem::PositionVectorCoefficient
struct Jlmfem_PositionVectorCoefficient: public Wrapper {

  Jlmfem_PositionVectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PositionVectorCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:723:7
    jlcxx::TypeWrapper<mfem::PositionVectorCoefficient>  t = jlModule.add_type<mfem::PositionVectorCoefficient>("mfem!PositionVectorCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PositionVectorCoefficient>>(new jlcxx::TypeWrapper<mfem::PositionVectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::PositionVectorCoefficient::PositionVectorCoefficient(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:727:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::PositionVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PositionVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:731:17
    t.method("Eval", static_cast<void (mfem::PositionVectorCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PositionVectorCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PositionVectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PositionVectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PositionVectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorArrayCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorArrayCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorArrayCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::VectorArrayCoefficient
// signature to use in the veto file: mfem::VectorArrayCoefficient
struct Jlmfem_VectorArrayCoefficient: public Wrapper {

  Jlmfem_VectorArrayCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorArrayCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:778:7
    jlcxx::TypeWrapper<mfem::VectorArrayCoefficient>  t = jlModule.add_type<mfem::VectorArrayCoefficient>("mfem!VectorArrayCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorArrayCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorArrayCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorArrayCoefficient::VectorArrayCoefficient(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:787:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorArrayCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorArrayCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:790:9
    t.method("SetTime", static_cast<void (mfem::VectorArrayCoefficient::*)(double) >(&mfem::VectorArrayCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::VectorArrayCoefficient::GetCoeff(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::VectorArrayCoefficient::GetCoeff(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:793:17
    t.method("GetCoeff", static_cast<mfem::Coefficient * (mfem::VectorArrayCoefficient::*)(int) >(&mfem::VectorArrayCoefficient::GetCoeff));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient ** mfem::VectorArrayCoefficient::GetCoeffs() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient ** mfem::VectorArrayCoefficient::GetCoeffs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:796:18
    t.method("GetCoeffs", static_cast<mfem::Coefficient ** (mfem::VectorArrayCoefficient::*)() >(&mfem::VectorArrayCoefficient::GetCoeffs));

    DEBUG_MSG("Adding wrapper for void mfem::VectorArrayCoefficient::Set(int, mfem::Coefficient *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorArrayCoefficient::Set(int, mfem::Coefficient *, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:799:9
    t.method("Set", static_cast<void (mfem::VectorArrayCoefficient::*)(int, mfem::Coefficient *, bool) >(&mfem::VectorArrayCoefficient::Set));
    t.method("Set", [](mfem::VectorArrayCoefficient& a, int arg0, mfem::Coefficient * arg1)->void { a.Set(arg0, arg1); });
    t.method("Set", [](mfem::VectorArrayCoefficient* a, int arg0, mfem::Coefficient * arg1)->void { a->Set(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for double mfem::VectorArrayCoefficient::Eval(int, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorArrayCoefficient::Eval(int, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:803:11
    t.method("Eval", static_cast<double (mfem::VectorArrayCoefficient::*)(int, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorArrayCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorArrayCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorArrayCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:809:17
    t.method("Eval", static_cast<void (mfem::VectorArrayCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorArrayCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorArrayCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorArrayCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorArrayCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorGridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorGridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorGridFunctionCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::VectorGridFunctionCoefficient
// signature to use in the veto file: mfem::VectorGridFunctionCoefficient
struct Jlmfem_VectorGridFunctionCoefficient: public Wrapper {

  Jlmfem_VectorGridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorGridFunctionCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:817:7
    jlcxx::TypeWrapper<mfem::VectorGridFunctionCoefficient>  t = jlModule.add_type<mfem::VectorGridFunctionCoefficient>("mfem!VectorGridFunctionCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorGridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorGridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::VectorGridFunctionCoefficient(const mfem::GridFunction *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:829:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:833:9
    t.method("SetGridFunction", static_cast<void (mfem::VectorGridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::VectorGridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::VectorGridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::VectorGridFunctionCoefficient::GetGridFunction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:836:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::VectorGridFunctionCoefficient::*)()  const>(&mfem::VectorGridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:839:17
    t.method("Eval", static_cast<void (mfem::VectorGridFunctionCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorGridFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorGridFunctionCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:845:17
    t.method("Eval", static_cast<void (mfem::VectorGridFunctionCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) >(&mfem::VectorGridFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorGridFunctionCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorGridFunctionCoefficient::Project(mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:853:17
    t.method("Project", static_cast<void (mfem::VectorGridFunctionCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::VectorGridFunctionCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorGridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorGridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorGridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GradientGridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GradientGridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::GradientGridFunctionCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::GradientGridFunctionCoefficient
// signature to use in the veto file: mfem::GradientGridFunctionCoefficient
struct Jlmfem_GradientGridFunctionCoefficient: public Wrapper {

  Jlmfem_GradientGridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GradientGridFunctionCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:859:7
    jlcxx::TypeWrapper<mfem::GradientGridFunctionCoefficient>  t = jlModule.add_type<mfem::GradientGridFunctionCoefficient>("mfem!GradientGridFunctionCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GradientGridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::GradientGridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::GradientGridFunctionCoefficient::GradientGridFunctionCoefficient(const mfem::GridFunction *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:868:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::GradientGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:871:9
    t.method("SetGridFunction", static_cast<void (mfem::GradientGridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::GradientGridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::GradientGridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::GradientGridFunctionCoefficient::GetGridFunction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:874:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::GradientGridFunctionCoefficient::*)()  const>(&mfem::GradientGridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::GradientGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:877:17
    t.method("Eval", static_cast<void (mfem::GradientGridFunctionCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::GradientGridFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::GradientGridFunctionCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientGridFunctionCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:883:17
    t.method("Eval", static_cast<void (mfem::GradientGridFunctionCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) >(&mfem::GradientGridFunctionCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GradientGridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GradientGridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GradientGridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CurlGridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CurlGridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CurlGridFunctionCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::CurlGridFunctionCoefficient
// signature to use in the veto file: mfem::CurlGridFunctionCoefficient
struct Jlmfem_CurlGridFunctionCoefficient: public Wrapper {

  Jlmfem_CurlGridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CurlGridFunctionCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:890:7
    jlcxx::TypeWrapper<mfem::CurlGridFunctionCoefficient>  t = jlModule.add_type<mfem::CurlGridFunctionCoefficient>("mfem!CurlGridFunctionCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CurlGridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::CurlGridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::CurlGridFunctionCoefficient::CurlGridFunctionCoefficient(const mfem::GridFunction *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:898:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::CurlGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:901:9
    t.method("SetGridFunction", static_cast<void (mfem::CurlGridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::CurlGridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::CurlGridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::CurlGridFunctionCoefficient::GetGridFunction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:904:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::CurlGridFunctionCoefficient::*)()  const>(&mfem::CurlGridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::CurlGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlGridFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:908:17
    t.method("Eval", static_cast<void (mfem::CurlGridFunctionCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CurlGridFunctionCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CurlGridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CurlGridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CurlGridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DivergenceGridFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DivergenceGridFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::DivergenceGridFunctionCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::DivergenceGridFunctionCoefficient
// signature to use in the veto file: mfem::DivergenceGridFunctionCoefficient
struct Jlmfem_DivergenceGridFunctionCoefficient: public Wrapper {

  Jlmfem_DivergenceGridFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DivergenceGridFunctionCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:915:7
    jlcxx::TypeWrapper<mfem::DivergenceGridFunctionCoefficient>  t = jlModule.add_type<mfem::DivergenceGridFunctionCoefficient>("mfem!DivergenceGridFunctionCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DivergenceGridFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::DivergenceGridFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DivergenceGridFunctionCoefficient::DivergenceGridFunctionCoefficient(const mfem::GridFunction *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:923:4
    t.constructor<const mfem::GridFunction *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DivergenceGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DivergenceGridFunctionCoefficient::SetGridFunction(const mfem::GridFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:926:9
    t.method("SetGridFunction", static_cast<void (mfem::DivergenceGridFunctionCoefficient::*)(const mfem::GridFunction *) >(&mfem::DivergenceGridFunctionCoefficient::SetGridFunction));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::DivergenceGridFunctionCoefficient::GetGridFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::DivergenceGridFunctionCoefficient::GetGridFunction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:929:25
    t.method("GetGridFunction", static_cast<const mfem::GridFunction * (mfem::DivergenceGridFunctionCoefficient::*)()  const>(&mfem::DivergenceGridFunctionCoefficient::GetGridFunction));

    DEBUG_MSG("Adding wrapper for double mfem::DivergenceGridFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DivergenceGridFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:932:19
    t.method("Eval", static_cast<double (mfem::DivergenceGridFunctionCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::DivergenceGridFunctionCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DivergenceGridFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DivergenceGridFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DivergenceGridFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorDeltaCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorDeltaCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorDeltaCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::VectorDeltaCoefficient
// signature to use in the veto file: mfem::VectorDeltaCoefficient
struct Jlmfem_VectorDeltaCoefficient: public Wrapper {

  Jlmfem_VectorDeltaCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorDeltaCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:943:7
    jlcxx::TypeWrapper<mfem::VectorDeltaCoefficient>  t = jlModule.add_type<mfem::VectorDeltaCoefficient>("mfem!VectorDeltaCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDeltaCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorDeltaCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:951:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(const mfem::Vector &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:956:4
    t.constructor<const mfem::Vector &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(const mfem::Vector &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:961:4
    t.constructor<const mfem::Vector &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(const mfem::Vector &, double, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:966:4
    t.constructor<const mfem::Vector &, double, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::VectorDeltaCoefficient(const mfem::Vector &, double, double, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:971:4
    t.constructor<const mfem::Vector &, double, double, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:976:9
    t.method("SetTime", static_cast<void (mfem::VectorDeltaCoefficient::*)(double) >(&mfem::VectorDeltaCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetDeltaCoefficient(const mfem::DeltaCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetDeltaCoefficient(const mfem::DeltaCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:981:9
    t.method("SetDeltaCoefficient", static_cast<void (mfem::VectorDeltaCoefficient::*)(const mfem::DeltaCoefficient &) >(&mfem::VectorDeltaCoefficient::SetDeltaCoefficient));

    DEBUG_MSG("Adding wrapper for mfem::DeltaCoefficient & mfem::VectorDeltaCoefficient::GetDeltaCoefficient() (" __HERE__ ")");
    // signature to use in the veto list: mfem::DeltaCoefficient & mfem::VectorDeltaCoefficient::GetDeltaCoefficient()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:984:22
    t.method("GetDeltaCoefficient", static_cast<mfem::DeltaCoefficient & (mfem::VectorDeltaCoefficient::*)() >(&mfem::VectorDeltaCoefficient::GetDeltaCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetScale(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetScale(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:986:9
    t.method("SetScale", static_cast<void (mfem::VectorDeltaCoefficient::*)(double) >(&mfem::VectorDeltaCoefficient::SetScale));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetDirection(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetDirection(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:987:9
    t.method("SetDirection", static_cast<void (mfem::VectorDeltaCoefficient::*)(const mfem::Vector &) >(&mfem::VectorDeltaCoefficient::SetDirection));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::SetDeltaCenter(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::SetDeltaCenter(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:989:9
    t.method("SetDeltaCenter", static_cast<void (mfem::VectorDeltaCoefficient::*)(const mfem::Vector &) >(&mfem::VectorDeltaCoefficient::SetDeltaCenter));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::GetDeltaCenter(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::GetDeltaCenter(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:990:9
    t.method("GetDeltaCenter", static_cast<void (mfem::VectorDeltaCoefficient::*)(mfem::Vector &) >(&mfem::VectorDeltaCoefficient::GetDeltaCenter));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::EvalDelta(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::EvalDelta(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:995:17
    t.method("EvalDelta", static_cast<void (mfem::VectorDeltaCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorDeltaCoefficient::EvalDelta));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDeltaCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDeltaCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1001:17
    t.method("Eval", static_cast<void (mfem::VectorDeltaCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorDeltaCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDeltaCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorDeltaCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorDeltaCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorRestrictedCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorRestrictedCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorRestrictedCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::VectorRestrictedCoefficient
// signature to use in the veto file: mfem::VectorRestrictedCoefficient
struct Jlmfem_VectorRestrictedCoefficient: public Wrapper {

  Jlmfem_VectorRestrictedCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorRestrictedCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1009:7
    jlcxx::TypeWrapper<mfem::VectorRestrictedCoefficient>  t = jlModule.add_type<mfem::VectorRestrictedCoefficient>("mfem!VectorRestrictedCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorRestrictedCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorRestrictedCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorRestrictedCoefficient::VectorRestrictedCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1019:4
    t.constructor<mfem::VectorCoefficient &, mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorRestrictedCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRestrictedCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1024:9
    t.method("SetTime", static_cast<void (mfem::VectorRestrictedCoefficient::*)(double) >(&mfem::VectorRestrictedCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorRestrictedCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRestrictedCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1027:17
    t.method("Eval", static_cast<void (mfem::VectorRestrictedCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorRestrictedCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorRestrictedCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRestrictedCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1033:17
    t.method("Eval", static_cast<void (mfem::VectorRestrictedCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationRule &) >(&mfem::VectorRestrictedCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorRestrictedCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorRestrictedCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorRestrictedCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixCoefficient> : std::false_type { };
}

// Class generating the wrapper for type mfem::MatrixCoefficient
// signature to use in the veto file: mfem::MatrixCoefficient
struct Jlmfem_MatrixCoefficient: public Wrapper {

  Jlmfem_MatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1040:7
    jlcxx::TypeWrapper<mfem::MatrixCoefficient>  t = jlModule.add_type<mfem::MatrixCoefficient>("mfem!MatrixCoefficient");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;



    DEBUG_MSG("Adding wrapper for void mfem::MatrixCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1057:17
    t.method("SetTime", static_cast<void (mfem::MatrixCoefficient::*)(double) >(&mfem::MatrixCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for double mfem::MatrixCoefficient::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::MatrixCoefficient::GetTime()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1060:11
    t.method("GetTime", static_cast<double (mfem::MatrixCoefficient::*)() >(&mfem::MatrixCoefficient::GetTime));

    DEBUG_MSG("Adding wrapper for int mfem::MatrixCoefficient::GetHeight() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MatrixCoefficient::GetHeight()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1063:8
    t.method("GetHeight", static_cast<int (mfem::MatrixCoefficient::*)()  const>(&mfem::MatrixCoefficient::GetHeight));

    DEBUG_MSG("Adding wrapper for int mfem::MatrixCoefficient::GetWidth() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MatrixCoefficient::GetWidth()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1066:8
    t.method("GetWidth", static_cast<int (mfem::MatrixCoefficient::*)()  const>(&mfem::MatrixCoefficient::GetWidth));

    DEBUG_MSG("Adding wrapper for int mfem::MatrixCoefficient::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MatrixCoefficient::GetVDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1069:8
    t.method("GetVDim", static_cast<int (mfem::MatrixCoefficient::*)()  const>(&mfem::MatrixCoefficient::GetVDim));

    DEBUG_MSG("Adding wrapper for bool mfem::MatrixCoefficient::IsSymmetric() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MatrixCoefficient::IsSymmetric()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1072:9
    t.method("IsSymmetric", static_cast<bool (mfem::MatrixCoefficient::*)()  const>(&mfem::MatrixCoefficient::IsSymmetric));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1079:17
    t.method("Eval", static_cast<void (mfem::MatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixCoefficient::Project(mfem::QuadratureFunction &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixCoefficient::Project(mfem::QuadratureFunction &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1088:17
    t.method("Project", static_cast<void (mfem::MatrixCoefficient::*)(mfem::QuadratureFunction &, bool) >(&mfem::MatrixCoefficient::Project));
    t.method("Project", [](mfem::MatrixCoefficient& a, mfem::QuadratureFunction & arg0)->void { a.Project(arg0); });
    t.method("Project", [](mfem::MatrixCoefficient* a, mfem::QuadratureFunction & arg0)->void { a->Project(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::MatrixCoefficient::EvalSymmetric(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixCoefficient::EvalSymmetric(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1097:17
    t.method("EvalSymmetric", static_cast<void (mfem::MatrixCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixCoefficient::EvalSymmetric));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixConstantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixConstantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixConstantCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::MatrixConstantCoefficient
// signature to use in the veto file: mfem::MatrixConstantCoefficient
struct Jlmfem_MatrixConstantCoefficient: public Wrapper {

  Jlmfem_MatrixConstantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixConstantCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1106:7
    jlcxx::TypeWrapper<mfem::MatrixConstantCoefficient>  t = jlModule.add_type<mfem::MatrixConstantCoefficient>("mfem!MatrixConstantCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixConstantCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixConstantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixConstantCoefficient::MatrixConstantCoefficient(const mfem::DenseMatrix &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1112:4
    t.constructor<const mfem::DenseMatrix &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixConstantCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixConstantCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1116:17
    t.method("Eval", static_cast<void (mfem::MatrixConstantCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixConstantCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for const mfem::DenseMatrix & mfem::MatrixConstantCoefficient::GetMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::DenseMatrix & mfem::MatrixConstantCoefficient::GetMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1119:23
    t.method("GetMatrix", static_cast<const mfem::DenseMatrix & (mfem::MatrixConstantCoefficient::*)() >(&mfem::MatrixConstantCoefficient::GetMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixConstantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixConstantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixConstantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PWMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PWMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PWMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::PWMatrixCoefficient
// signature to use in the veto file: mfem::PWMatrixCoefficient
struct Jlmfem_PWMatrixCoefficient: public Wrapper {

  Jlmfem_PWMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PWMatrixCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1140:7
    jlcxx::TypeWrapper<mfem::PWMatrixCoefficient>  t = jlModule.add_type<mfem::PWMatrixCoefficient>("mfem!PWMatrixCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PWMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::PWMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::PWMatrixCoefficient(int, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1169:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, bool>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::PWMatrixCoefficient(int, int, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1173:13
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, bool>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWMatrixCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1210:17
    t.method("SetTime", static_cast<void (mfem::PWMatrixCoefficient::*)(double) >(&mfem::PWMatrixCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::UpdateCoefficient(int, mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWMatrixCoefficient::UpdateCoefficient(int, mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1218:9
    t.method("UpdateCoefficient", static_cast<void (mfem::PWMatrixCoefficient::*)(int, mfem::MatrixCoefficient &) >(&mfem::PWMatrixCoefficient::UpdateCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::ZeroCoefficient(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWMatrixCoefficient::ZeroCoefficient(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1221:9
    t.method("ZeroCoefficient", static_cast<void (mfem::PWMatrixCoefficient::*)(int) >(&mfem::PWMatrixCoefficient::ZeroCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::PWMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PWMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1225:17
    t.method("Eval", static_cast<void (mfem::PWMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PWMatrixCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PWMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PWMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PWMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixArrayCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixArrayCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixArrayCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::MatrixArrayCoefficient
// signature to use in the veto file: mfem::MatrixArrayCoefficient
struct Jlmfem_MatrixArrayCoefficient: public Wrapper {

  Jlmfem_MatrixArrayCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixArrayCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1301:7
    jlcxx::TypeWrapper<mfem::MatrixArrayCoefficient>  t = jlModule.add_type<mfem::MatrixArrayCoefficient>("mfem!MatrixArrayCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixArrayCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixArrayCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixArrayCoefficient::MatrixArrayCoefficient(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1310:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixArrayCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixArrayCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1313:9
    t.method("SetTime", static_cast<void (mfem::MatrixArrayCoefficient::*)(double) >(&mfem::MatrixArrayCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::MatrixArrayCoefficient::GetCoeff(int, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::MatrixArrayCoefficient::GetCoeff(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1316:17
    t.method("GetCoeff", static_cast<mfem::Coefficient * (mfem::MatrixArrayCoefficient::*)(int, int) >(&mfem::MatrixArrayCoefficient::GetCoeff));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixArrayCoefficient::Set(int, int, mfem::Coefficient *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixArrayCoefficient::Set(int, int, mfem::Coefficient *, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1321:9
    t.method("Set", static_cast<void (mfem::MatrixArrayCoefficient::*)(int, int, mfem::Coefficient *, bool) >(&mfem::MatrixArrayCoefficient::Set));
    t.method("Set", [](mfem::MatrixArrayCoefficient& a, int arg0, int arg1, mfem::Coefficient * arg2)->void { a.Set(arg0, arg1, arg2); });
    t.method("Set", [](mfem::MatrixArrayCoefficient* a, int arg0, int arg1, mfem::Coefficient * arg2)->void { a->Set(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for double mfem::MatrixArrayCoefficient::Eval(int, int, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::MatrixArrayCoefficient::Eval(int, int, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1327:11
    t.method("Eval", static_cast<double (mfem::MatrixArrayCoefficient::*)(int, int, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixArrayCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixArrayCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixArrayCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1331:17
    t.method("Eval", static_cast<void (mfem::MatrixArrayCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixArrayCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixArrayCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixArrayCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixArrayCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixRestrictedCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixRestrictedCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixRestrictedCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::MatrixRestrictedCoefficient
// signature to use in the veto file: mfem::MatrixRestrictedCoefficient
struct Jlmfem_MatrixRestrictedCoefficient: public Wrapper {

  Jlmfem_MatrixRestrictedCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixRestrictedCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1340:7
    jlcxx::TypeWrapper<mfem::MatrixRestrictedCoefficient>  t = jlModule.add_type<mfem::MatrixRestrictedCoefficient>("mfem!MatrixRestrictedCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixRestrictedCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixRestrictedCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixRestrictedCoefficient::MatrixRestrictedCoefficient(mfem::MatrixCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1350:4
    t.constructor<mfem::MatrixCoefficient &, mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixRestrictedCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixRestrictedCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1355:9
    t.method("SetTime", static_cast<void (mfem::MatrixRestrictedCoefficient::*)(double) >(&mfem::MatrixRestrictedCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixRestrictedCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixRestrictedCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1358:17
    t.method("Eval", static_cast<void (mfem::MatrixRestrictedCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixRestrictedCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixRestrictedCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixRestrictedCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixRestrictedCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SumCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SumCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SumCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::SumCoefficient
// signature to use in the veto file: mfem::SumCoefficient
struct Jlmfem_SumCoefficient: public Wrapper {

  Jlmfem_SumCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SumCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1366:7
    jlcxx::TypeWrapper<mfem::SumCoefficient>  t = jlModule.add_type<mfem::SumCoefficient>("mfem!SumCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SumCoefficient>>(new jlcxx::TypeWrapper<mfem::SumCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SumCoefficient(double, mfem::Coefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1378:4
    t.constructor<double, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<double, mfem::Coefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<double, mfem::Coefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SumCoefficient(mfem::Coefficient &, mfem::Coefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1383:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, mfem::Coefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, mfem::Coefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1388:9
    t.method("SetTime", static_cast<void (mfem::SumCoefficient::*)(double) >(&mfem::SumCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetAConst(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1391:9
    t.method("SetAConst", static_cast<void (mfem::SumCoefficient::*)(double) >(&mfem::SumCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::SumCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SumCoefficient::GetAConst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1393:11
    t.method("GetAConst", static_cast<double (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetACoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1396:9
    t.method("SetACoef", static_cast<void (mfem::SumCoefficient::*)(mfem::Coefficient &) >(&mfem::SumCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::SumCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::SumCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1398:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetBCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetBCoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1401:9
    t.method("SetBCoef", static_cast<void (mfem::SumCoefficient::*)(mfem::Coefficient &) >(&mfem::SumCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::SumCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::SumCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1403:18
    t.method("GetBCoef", static_cast<mfem::Coefficient * (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetAlpha(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetAlpha(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1406:9
    t.method("SetAlpha", static_cast<void (mfem::SumCoefficient::*)(double) >(&mfem::SumCoefficient::SetAlpha));

    DEBUG_MSG("Adding wrapper for double mfem::SumCoefficient::GetAlpha() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SumCoefficient::GetAlpha()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1408:11
    t.method("GetAlpha", static_cast<double (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetAlpha));

    DEBUG_MSG("Adding wrapper for void mfem::SumCoefficient::SetBeta(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumCoefficient::SetBeta(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1411:9
    t.method("SetBeta", static_cast<void (mfem::SumCoefficient::*)(double) >(&mfem::SumCoefficient::SetBeta));

    DEBUG_MSG("Adding wrapper for double mfem::SumCoefficient::GetBeta() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SumCoefficient::GetBeta()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1413:11
    t.method("GetBeta", static_cast<double (mfem::SumCoefficient::*)()  const>(&mfem::SumCoefficient::GetBeta));

    DEBUG_MSG("Adding wrapper for double mfem::SumCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::SumCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1416:19
    t.method("Eval", static_cast<double (mfem::SumCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SumCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SumCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SumCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SumCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SymmetricMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SymmetricMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SymmetricMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::SymmetricMatrixCoefficient
// signature to use in the veto file: mfem::SymmetricMatrixCoefficient
struct Jlmfem_SymmetricMatrixCoefficient: public Wrapper {

  Jlmfem_SymmetricMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SymmetricMatrixCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1426:7
    jlcxx::TypeWrapper<mfem::SymmetricMatrixCoefficient>  t = jlModule.add_type<mfem::SymmetricMatrixCoefficient>("mfem!SymmetricMatrixCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SymmetricMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::SymmetricMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for int mfem::SymmetricMatrixCoefficient::GetSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::SymmetricMatrixCoefficient::GetSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1437:8
    t.method("GetSize", static_cast<int (mfem::SymmetricMatrixCoefficient::*)()  const>(&mfem::SymmetricMatrixCoefficient::GetSize));

    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixCoefficient::ProjectSymmetric(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SymmetricMatrixCoefficient::ProjectSymmetric(mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1446:17
    t.method("ProjectSymmetric", static_cast<void (mfem::SymmetricMatrixCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::SymmetricMatrixCoefficient::ProjectSymmetric));

    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixCoefficient::Eval(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SymmetricMatrixCoefficient::Eval(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1453:17
    t.method("Eval", static_cast<void (mfem::SymmetricMatrixCoefficient::*)(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SymmetricMatrixCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SymmetricMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1464:17
    t.method("Eval", static_cast<void (mfem::SymmetricMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SymmetricMatrixCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for const mfem::DenseSymmetricMatrix & mfem::SymmetricMatrixCoefficient::GetMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::DenseSymmetricMatrix & mfem::SymmetricMatrixCoefficient::GetMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1468:32
    t.method("GetMatrix", static_cast<const mfem::DenseSymmetricMatrix & (mfem::SymmetricMatrixCoefficient::*)() >(&mfem::SymmetricMatrixCoefficient::GetMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SymmetricMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SymmetricMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SymmetricMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DenseSymmetricMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DenseSymmetricMatrix> : std::false_type { };
template<> struct SuperType<mfem::DenseSymmetricMatrix> { typedef mfem::Matrix type; };
}

// Class generating the wrapper for type mfem::DenseSymmetricMatrix
// signature to use in the veto file: mfem::DenseSymmetricMatrix
struct Jlmfem_DenseSymmetricMatrix: public Wrapper {

  Jlmfem_DenseSymmetricMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DenseSymmetricMatrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/symmat.hpp:24:7
    jlcxx::TypeWrapper<mfem::DenseSymmetricMatrix>  t = jlModule.add_type<mfem::DenseSymmetricMatrix>("mfem!DenseSymmetricMatrix",
      jlcxx::julia_base_type<mfem::Matrix>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseSymmetricMatrix>>(new jlcxx::TypeWrapper<mfem::DenseSymmetricMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseSymmetricMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DenseSymmetricMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DenseSymmetricMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SymmetricMatrixConstantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SymmetricMatrixConstantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::SymmetricMatrixConstantCoefficient> { typedef mfem::SymmetricMatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::SymmetricMatrixConstantCoefficient
// signature to use in the veto file: mfem::SymmetricMatrixConstantCoefficient
struct Jlmfem_SymmetricMatrixConstantCoefficient: public Wrapper {

  Jlmfem_SymmetricMatrixConstantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SymmetricMatrixConstantCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1475:7
    jlcxx::TypeWrapper<mfem::SymmetricMatrixConstantCoefficient>  t = jlModule.add_type<mfem::SymmetricMatrixConstantCoefficient>("mfem!SymmetricMatrixConstantCoefficient",
      jlcxx::julia_base_type<mfem::SymmetricMatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SymmetricMatrixConstantCoefficient>>(new jlcxx::TypeWrapper<mfem::SymmetricMatrixConstantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixConstantCoefficient::SymmetricMatrixConstantCoefficient(const mfem::DenseSymmetricMatrix &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1482:4
    t.constructor<const mfem::DenseSymmetricMatrix &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::SymmetricMatrixConstantCoefficient::Eval(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SymmetricMatrixConstantCoefficient::Eval(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1486:17
    t.method("Eval", static_cast<void (mfem::SymmetricMatrixConstantCoefficient::*)(mfem::DenseSymmetricMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::SymmetricMatrixConstantCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SymmetricMatrixConstantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SymmetricMatrixConstantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SymmetricMatrixConstantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ProductCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::ProductCoefficient
// signature to use in the veto file: mfem::ProductCoefficient
struct Jlmfem_ProductCoefficient: public Wrapper {

  Jlmfem_ProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1546:7
    jlcxx::TypeWrapper<mfem::ProductCoefficient>  t = jlModule.add_type<mfem::ProductCoefficient>("mfem!ProductCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductCoefficient>>(new jlcxx::TypeWrapper<mfem::ProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::ProductCoefficient(double, mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1555:4
    t.constructor<double, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::ProductCoefficient(mfem::Coefficient &, mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1559:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1563:9
    t.method("SetTime", static_cast<void (mfem::ProductCoefficient::*)(double) >(&mfem::ProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductCoefficient::SetAConst(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1566:9
    t.method("SetAConst", static_cast<void (mfem::ProductCoefficient::*)(double) >(&mfem::ProductCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::ProductCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ProductCoefficient::GetAConst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1568:11
    t.method("GetAConst", static_cast<double (mfem::ProductCoefficient::*)()  const>(&mfem::ProductCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductCoefficient::SetACoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1571:9
    t.method("SetACoef", static_cast<void (mfem::ProductCoefficient::*)(mfem::Coefficient &) >(&mfem::ProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::ProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::ProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1573:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::ProductCoefficient::*)()  const>(&mfem::ProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::ProductCoefficient::SetBCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ProductCoefficient::SetBCoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1576:9
    t.method("SetBCoef", static_cast<void (mfem::ProductCoefficient::*)(mfem::Coefficient &) >(&mfem::ProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::ProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::ProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1578:18
    t.method("GetBCoef", static_cast<mfem::Coefficient * (mfem::ProductCoefficient::*)()  const>(&mfem::ProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for double mfem::ProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1581:19
    t.method("Eval", static_cast<double (mfem::ProductCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RatioCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RatioCoefficient> : std::false_type { };
template<> struct SuperType<mfem::RatioCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::RatioCoefficient
// signature to use in the veto file: mfem::RatioCoefficient
struct Jlmfem_RatioCoefficient: public Wrapper {

  Jlmfem_RatioCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RatioCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1588:7
    jlcxx::TypeWrapper<mfem::RatioCoefficient>  t = jlModule.add_type<mfem::RatioCoefficient>("mfem!RatioCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RatioCoefficient>>(new jlcxx::TypeWrapper<mfem::RatioCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::RatioCoefficient(double, mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1599:4
    t.constructor<double, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::RatioCoefficient(mfem::Coefficient &, mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1603:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::RatioCoefficient(mfem::Coefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1607:4
    t.constructor<mfem::Coefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1611:9
    t.method("SetTime", static_cast<void (mfem::RatioCoefficient::*)(double) >(&mfem::RatioCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetAConst(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1614:9
    t.method("SetAConst", static_cast<void (mfem::RatioCoefficient::*)(double) >(&mfem::RatioCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::RatioCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::RatioCoefficient::GetAConst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1616:11
    t.method("GetAConst", static_cast<double (mfem::RatioCoefficient::*)()  const>(&mfem::RatioCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetBConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetBConst(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1619:9
    t.method("SetBConst", static_cast<void (mfem::RatioCoefficient::*)(double) >(&mfem::RatioCoefficient::SetBConst));

    DEBUG_MSG("Adding wrapper for double mfem::RatioCoefficient::GetBConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::RatioCoefficient::GetBConst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1621:11
    t.method("GetBConst", static_cast<double (mfem::RatioCoefficient::*)()  const>(&mfem::RatioCoefficient::GetBConst));

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetACoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1624:9
    t.method("SetACoef", static_cast<void (mfem::RatioCoefficient::*)(mfem::Coefficient &) >(&mfem::RatioCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::RatioCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::RatioCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1626:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::RatioCoefficient::*)()  const>(&mfem::RatioCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::RatioCoefficient::SetBCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::RatioCoefficient::SetBCoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1629:9
    t.method("SetBCoef", static_cast<void (mfem::RatioCoefficient::*)(mfem::Coefficient &) >(&mfem::RatioCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::RatioCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::RatioCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1631:18
    t.method("GetBCoef", static_cast<mfem::Coefficient * (mfem::RatioCoefficient::*)()  const>(&mfem::RatioCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for double mfem::RatioCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::RatioCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1634:19
    t.method("Eval", static_cast<double (mfem::RatioCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::RatioCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RatioCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RatioCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RatioCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::PowerCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::PowerCoefficient> : std::false_type { };
template<> struct SuperType<mfem::PowerCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::PowerCoefficient
// signature to use in the veto file: mfem::PowerCoefficient
struct Jlmfem_PowerCoefficient: public Wrapper {

  Jlmfem_PowerCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::PowerCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1644:7
    jlcxx::TypeWrapper<mfem::PowerCoefficient>  t = jlModule.add_type<mfem::PowerCoefficient>("mfem!PowerCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::PowerCoefficient>>(new jlcxx::TypeWrapper<mfem::PowerCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::PowerCoefficient::PowerCoefficient(mfem::Coefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1653:4
    t.constructor<mfem::Coefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::PowerCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PowerCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1657:9
    t.method("SetTime", static_cast<void (mfem::PowerCoefficient::*)(double) >(&mfem::PowerCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::PowerCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PowerCoefficient::SetACoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1660:9
    t.method("SetACoef", static_cast<void (mfem::PowerCoefficient::*)(mfem::Coefficient &) >(&mfem::PowerCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::PowerCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::PowerCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1662:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::PowerCoefficient::*)()  const>(&mfem::PowerCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::PowerCoefficient::SetExponent(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PowerCoefficient::SetExponent(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1665:9
    t.method("SetExponent", static_cast<void (mfem::PowerCoefficient::*)(double) >(&mfem::PowerCoefficient::SetExponent));

    DEBUG_MSG("Adding wrapper for double mfem::PowerCoefficient::GetExponent() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PowerCoefficient::GetExponent()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1667:11
    t.method("GetExponent", static_cast<double (mfem::PowerCoefficient::*)()  const>(&mfem::PowerCoefficient::GetExponent));

    DEBUG_MSG("Adding wrapper for double mfem::PowerCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::PowerCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1670:19
    t.method("Eval", static_cast<double (mfem::PowerCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::PowerCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::PowerCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_PowerCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_PowerCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InnerProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InnerProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::InnerProductCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::InnerProductCoefficient
// signature to use in the veto file: mfem::InnerProductCoefficient
struct Jlmfem_InnerProductCoefficient: public Wrapper {

  Jlmfem_InnerProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InnerProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1677:7
    jlcxx::TypeWrapper<mfem::InnerProductCoefficient>  t = jlModule.add_type<mfem::InnerProductCoefficient>("mfem!InnerProductCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InnerProductCoefficient>>(new jlcxx::TypeWrapper<mfem::InnerProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::InnerProductCoefficient::InnerProductCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1687:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::InnerProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InnerProductCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1690:9
    t.method("SetTime", static_cast<void (mfem::InnerProductCoefficient::*)(double) >(&mfem::InnerProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::InnerProductCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InnerProductCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1693:9
    t.method("SetACoef", static_cast<void (mfem::InnerProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::InnerProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::InnerProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::InnerProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1695:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::InnerProductCoefficient::*)()  const>(&mfem::InnerProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::InnerProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InnerProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1698:9
    t.method("SetBCoef", static_cast<void (mfem::InnerProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::InnerProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::InnerProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::InnerProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1700:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::InnerProductCoefficient::*)()  const>(&mfem::InnerProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for double mfem::InnerProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::InnerProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1703:19
    t.method("Eval", static_cast<double (mfem::InnerProductCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::InnerProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InnerProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InnerProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InnerProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorRotProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorRotProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorRotProductCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::VectorRotProductCoefficient
// signature to use in the veto file: mfem::VectorRotProductCoefficient
struct Jlmfem_VectorRotProductCoefficient: public Wrapper {

  Jlmfem_VectorRotProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorRotProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1708:7
    jlcxx::TypeWrapper<mfem::VectorRotProductCoefficient>  t = jlModule.add_type<mfem::VectorRotProductCoefficient>("mfem!VectorRotProductCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorRotProductCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorRotProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorRotProductCoefficient::VectorRotProductCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1719:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorRotProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRotProductCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1722:9
    t.method("SetTime", static_cast<void (mfem::VectorRotProductCoefficient::*)(double) >(&mfem::VectorRotProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorRotProductCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRotProductCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1725:9
    t.method("SetACoef", static_cast<void (mfem::VectorRotProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorRotProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorRotProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorRotProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1727:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::VectorRotProductCoefficient::*)()  const>(&mfem::VectorRotProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorRotProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorRotProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1730:9
    t.method("SetBCoef", static_cast<void (mfem::VectorRotProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorRotProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorRotProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorRotProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1732:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::VectorRotProductCoefficient::*)()  const>(&mfem::VectorRotProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for double mfem::VectorRotProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorRotProductCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1735:19
    t.method("Eval", static_cast<double (mfem::VectorRotProductCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorRotProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorRotProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorRotProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorRotProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DeterminantCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DeterminantCoefficient> : std::false_type { };
template<> struct SuperType<mfem::DeterminantCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::DeterminantCoefficient
// signature to use in the veto file: mfem::DeterminantCoefficient
struct Jlmfem_DeterminantCoefficient: public Wrapper {

  Jlmfem_DeterminantCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DeterminantCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1740:7
    jlcxx::TypeWrapper<mfem::DeterminantCoefficient>  t = jlModule.add_type<mfem::DeterminantCoefficient>("mfem!DeterminantCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DeterminantCoefficient>>(new jlcxx::TypeWrapper<mfem::DeterminantCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DeterminantCoefficient::DeterminantCoefficient(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1749:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DeterminantCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeterminantCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1752:9
    t.method("SetTime", static_cast<void (mfem::DeterminantCoefficient::*)(double) >(&mfem::DeterminantCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::DeterminantCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeterminantCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1755:9
    t.method("SetACoef", static_cast<void (mfem::DeterminantCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::DeterminantCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::DeterminantCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::DeterminantCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1757:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::DeterminantCoefficient::*)()  const>(&mfem::DeterminantCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for double mfem::DeterminantCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DeterminantCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1760:19
    t.method("Eval", static_cast<double (mfem::DeterminantCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::DeterminantCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DeterminantCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DeterminantCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DeterminantCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorSumCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorSumCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorSumCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::VectorSumCoefficient
// signature to use in the veto file: mfem::VectorSumCoefficient
struct Jlmfem_VectorSumCoefficient: public Wrapper {

  Jlmfem_VectorSumCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorSumCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1765:7
    jlcxx::TypeWrapper<mfem::VectorSumCoefficient>  t = jlModule.add_type<mfem::VectorSumCoefficient>("mfem!VectorSumCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorSumCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorSumCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::VectorSumCoefficient(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1785:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::VectorSumCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1789:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::VectorSumCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &, mfem::Coefficient &, mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1794:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &, mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1798:9
    t.method("SetTime", static_cast<void (mfem::VectorSumCoefficient::*)(double) >(&mfem::VectorSumCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1801:9
    t.method("SetACoef", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorSumCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorSumCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorSumCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1803:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1806:9
    t.method("SetBCoef", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorSumCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorSumCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorSumCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1808:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetAlphaCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetAlphaCoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1811:9
    t.method("SetAlphaCoef", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::Coefficient &) >(&mfem::VectorSumCoefficient::SetAlphaCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::VectorSumCoefficient::GetAlphaCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::VectorSumCoefficient::GetAlphaCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1813:18
    t.method("GetAlphaCoef", static_cast<mfem::Coefficient * (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetAlphaCoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetBetaCoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetBetaCoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1816:9
    t.method("SetBetaCoef", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::Coefficient &) >(&mfem::VectorSumCoefficient::SetBetaCoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::VectorSumCoefficient::GetBetaCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::VectorSumCoefficient::GetBetaCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1818:18
    t.method("GetBetaCoef", static_cast<mfem::Coefficient * (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetBetaCoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetA(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetA(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1821:9
    t.method("SetA", static_cast<void (mfem::VectorSumCoefficient::*)(const mfem::Vector &) >(&mfem::VectorSumCoefficient::SetA));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::VectorSumCoefficient::GetA() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::VectorSumCoefficient::GetA()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1823:19
    t.method("GetA", static_cast<const mfem::Vector & (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetB(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetB(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1826:9
    t.method("SetB", static_cast<void (mfem::VectorSumCoefficient::*)(const mfem::Vector &) >(&mfem::VectorSumCoefficient::SetB));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::VectorSumCoefficient::GetB() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::VectorSumCoefficient::GetB()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1828:19
    t.method("GetB", static_cast<const mfem::Vector & (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetB));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetAlpha(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetAlpha(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1831:9
    t.method("SetAlpha", static_cast<void (mfem::VectorSumCoefficient::*)(double) >(&mfem::VectorSumCoefficient::SetAlpha));

    DEBUG_MSG("Adding wrapper for double mfem::VectorSumCoefficient::GetAlpha() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorSumCoefficient::GetAlpha()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1833:11
    t.method("GetAlpha", static_cast<double (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetAlpha));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::SetBeta(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::SetBeta(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1836:9
    t.method("SetBeta", static_cast<void (mfem::VectorSumCoefficient::*)(double) >(&mfem::VectorSumCoefficient::SetBeta));

    DEBUG_MSG("Adding wrapper for double mfem::VectorSumCoefficient::GetBeta() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorSumCoefficient::GetBeta()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1838:11
    t.method("GetBeta", static_cast<double (mfem::VectorSumCoefficient::*)()  const>(&mfem::VectorSumCoefficient::GetBeta));

    DEBUG_MSG("Adding wrapper for void mfem::VectorSumCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorSumCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1841:17
    t.method("Eval", static_cast<void (mfem::VectorSumCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorSumCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorSumCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorSumCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorSumCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ScalarVectorProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ScalarVectorProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ScalarVectorProductCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::ScalarVectorProductCoefficient
// signature to use in the veto file: mfem::ScalarVectorProductCoefficient
struct Jlmfem_ScalarVectorProductCoefficient: public Wrapper {

  Jlmfem_ScalarVectorProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ScalarVectorProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1847:7
    jlcxx::TypeWrapper<mfem::ScalarVectorProductCoefficient>  t = jlModule.add_type<mfem::ScalarVectorProductCoefficient>("mfem!ScalarVectorProductCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarVectorProductCoefficient>>(new jlcxx::TypeWrapper<mfem::ScalarVectorProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::ScalarVectorProductCoefficient(double, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1856:4
    t.constructor<double, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::ScalarVectorProductCoefficient(mfem::Coefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1859:4
    t.constructor<mfem::Coefficient &, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1862:9
    t.method("SetTime", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(double) >(&mfem::ScalarVectorProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::SetAConst(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1865:9
    t.method("SetAConst", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(double) >(&mfem::ScalarVectorProductCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::ScalarVectorProductCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ScalarVectorProductCoefficient::GetAConst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1867:11
    t.method("GetAConst", static_cast<double (mfem::ScalarVectorProductCoefficient::*)()  const>(&mfem::ScalarVectorProductCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::SetACoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1870:9
    t.method("SetACoef", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(mfem::Coefficient &) >(&mfem::ScalarVectorProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::ScalarVectorProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::ScalarVectorProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1872:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::ScalarVectorProductCoefficient::*)()  const>(&mfem::ScalarVectorProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1875:9
    t.method("SetBCoef", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::ScalarVectorProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::ScalarVectorProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::ScalarVectorProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1877:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::ScalarVectorProductCoefficient::*)()  const>(&mfem::ScalarVectorProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1880:17
    t.method("Eval", static_cast<void (mfem::ScalarVectorProductCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ScalarVectorProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarVectorProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ScalarVectorProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ScalarVectorProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NormalizedVectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NormalizedVectorCoefficient> : std::false_type { };
template<> struct SuperType<mfem::NormalizedVectorCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::NormalizedVectorCoefficient
// signature to use in the veto file: mfem::NormalizedVectorCoefficient
struct Jlmfem_NormalizedVectorCoefficient: public Wrapper {

  Jlmfem_NormalizedVectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NormalizedVectorCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1886:7
    jlcxx::TypeWrapper<mfem::NormalizedVectorCoefficient>  t = jlModule.add_type<mfem::NormalizedVectorCoefficient>("mfem!NormalizedVectorCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalizedVectorCoefficient>>(new jlcxx::TypeWrapper<mfem::NormalizedVectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NormalizedVectorCoefficient::NormalizedVectorCoefficient(mfem::VectorCoefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1900:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NormalizedVectorCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalizedVectorCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1903:9
    t.method("SetTime", static_cast<void (mfem::NormalizedVectorCoefficient::*)(double) >(&mfem::NormalizedVectorCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::NormalizedVectorCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalizedVectorCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1906:9
    t.method("SetACoef", static_cast<void (mfem::NormalizedVectorCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::NormalizedVectorCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::NormalizedVectorCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::NormalizedVectorCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1908:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::NormalizedVectorCoefficient::*)()  const>(&mfem::NormalizedVectorCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::NormalizedVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalizedVectorCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1911:17
    t.method("Eval", static_cast<void (mfem::NormalizedVectorCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::NormalizedVectorCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalizedVectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NormalizedVectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NormalizedVectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorCrossProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorCrossProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorCrossProductCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::VectorCrossProductCoefficient
// signature to use in the veto file: mfem::VectorCrossProductCoefficient
struct Jlmfem_VectorCrossProductCoefficient: public Wrapper {

  Jlmfem_VectorCrossProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorCrossProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1917:7
    jlcxx::TypeWrapper<mfem::VectorCrossProductCoefficient>  t = jlModule.add_type<mfem::VectorCrossProductCoefficient>("mfem!VectorCrossProductCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCrossProductCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorCrossProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::VectorCrossProductCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1928:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1931:9
    t.method("SetTime", static_cast<void (mfem::VectorCrossProductCoefficient::*)(double) >(&mfem::VectorCrossProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1934:9
    t.method("SetACoef", static_cast<void (mfem::VectorCrossProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorCrossProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorCrossProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorCrossProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1936:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::VectorCrossProductCoefficient::*)()  const>(&mfem::VectorCrossProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1939:9
    t.method("SetBCoef", static_cast<void (mfem::VectorCrossProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::VectorCrossProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::VectorCrossProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::VectorCrossProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1941:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::VectorCrossProductCoefficient::*)()  const>(&mfem::VectorCrossProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1944:17
    t.method("Eval", static_cast<void (mfem::VectorCrossProductCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorCrossProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCrossProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorCrossProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorCrossProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixVectorProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixVectorProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixVectorProductCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::MatrixVectorProductCoefficient
// signature to use in the veto file: mfem::MatrixVectorProductCoefficient
struct Jlmfem_MatrixVectorProductCoefficient: public Wrapper {

  Jlmfem_MatrixVectorProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixVectorProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1951:7
    jlcxx::TypeWrapper<mfem::MatrixVectorProductCoefficient>  t = jlModule.add_type<mfem::MatrixVectorProductCoefficient>("mfem!MatrixVectorProductCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixVectorProductCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixVectorProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::MatrixVectorProductCoefficient(mfem::MatrixCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1962:4
    t.constructor<mfem::MatrixCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixVectorProductCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1965:9
    t.method("SetTime", static_cast<void (mfem::MatrixVectorProductCoefficient::*)(double) >(&mfem::MatrixVectorProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixVectorProductCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1968:9
    t.method("SetACoef", static_cast<void (mfem::MatrixVectorProductCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixVectorProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixVectorProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixVectorProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1970:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixVectorProductCoefficient::*)()  const>(&mfem::MatrixVectorProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixVectorProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1973:9
    t.method("SetBCoef", static_cast<void (mfem::MatrixVectorProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::MatrixVectorProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::MatrixVectorProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::MatrixVectorProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1975:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::MatrixVectorProductCoefficient::*)()  const>(&mfem::MatrixVectorProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixVectorProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixVectorProductCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1978:17
    t.method("Eval", static_cast<void (mfem::MatrixVectorProductCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixVectorProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixVectorProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixVectorProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixVectorProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IdentityMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IdentityMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::IdentityMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::IdentityMatrixCoefficient
// signature to use in the veto file: mfem::IdentityMatrixCoefficient
struct Jlmfem_IdentityMatrixCoefficient: public Wrapper {

  Jlmfem_IdentityMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IdentityMatrixCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1987:7
    jlcxx::TypeWrapper<mfem::IdentityMatrixCoefficient>  t = jlModule.add_type<mfem::IdentityMatrixCoefficient>("mfem!IdentityMatrixCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IdentityMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::IdentityMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::IdentityMatrixCoefficient::IdentityMatrixCoefficient(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1994:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::IdentityMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IdentityMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:1998:17
    t.method("Eval", static_cast<void (mfem::IdentityMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::IdentityMatrixCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IdentityMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IdentityMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IdentityMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixSumCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixSumCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixSumCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::MatrixSumCoefficient
// signature to use in the veto file: mfem::MatrixSumCoefficient
struct Jlmfem_MatrixSumCoefficient: public Wrapper {

  Jlmfem_MatrixSumCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixSumCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2003:7
    jlcxx::TypeWrapper<mfem::MatrixSumCoefficient>  t = jlModule.add_type<mfem::MatrixSumCoefficient>("mfem!MatrixSumCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixSumCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixSumCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::MatrixSumCoefficient(mfem::MatrixCoefficient &, mfem::MatrixCoefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2016:4
    t.constructor<mfem::MatrixCoefficient &, mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::MatrixCoefficient &, mfem::MatrixCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::MatrixCoefficient &, mfem::MatrixCoefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2020:9
    t.method("SetTime", static_cast<void (mfem::MatrixSumCoefficient::*)(double) >(&mfem::MatrixSumCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2023:9
    t.method("SetACoef", static_cast<void (mfem::MatrixSumCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixSumCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixSumCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixSumCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2025:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixSumCoefficient::*)()  const>(&mfem::MatrixSumCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetBCoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetBCoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2028:9
    t.method("SetBCoef", static_cast<void (mfem::MatrixSumCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixSumCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixSumCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixSumCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2030:24
    t.method("GetBCoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixSumCoefficient::*)()  const>(&mfem::MatrixSumCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetAlpha(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetAlpha(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2033:9
    t.method("SetAlpha", static_cast<void (mfem::MatrixSumCoefficient::*)(double) >(&mfem::MatrixSumCoefficient::SetAlpha));

    DEBUG_MSG("Adding wrapper for double mfem::MatrixSumCoefficient::GetAlpha() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::MatrixSumCoefficient::GetAlpha()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2035:11
    t.method("GetAlpha", static_cast<double (mfem::MatrixSumCoefficient::*)()  const>(&mfem::MatrixSumCoefficient::GetAlpha));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::SetBeta(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::SetBeta(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2038:9
    t.method("SetBeta", static_cast<void (mfem::MatrixSumCoefficient::*)(double) >(&mfem::MatrixSumCoefficient::SetBeta));

    DEBUG_MSG("Adding wrapper for double mfem::MatrixSumCoefficient::GetBeta() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::MatrixSumCoefficient::GetBeta()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2040:11
    t.method("GetBeta", static_cast<double (mfem::MatrixSumCoefficient::*)()  const>(&mfem::MatrixSumCoefficient::GetBeta));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixSumCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixSumCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2043:17
    t.method("Eval", static_cast<void (mfem::MatrixSumCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixSumCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixSumCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixSumCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixSumCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MatrixProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MatrixProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::MatrixProductCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::MatrixProductCoefficient
// signature to use in the veto file: mfem::MatrixProductCoefficient
struct Jlmfem_MatrixProductCoefficient: public Wrapper {

  Jlmfem_MatrixProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MatrixProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2048:7
    jlcxx::TypeWrapper<mfem::MatrixProductCoefficient>  t = jlModule.add_type<mfem::MatrixProductCoefficient>("mfem!MatrixProductCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixProductCoefficient>>(new jlcxx::TypeWrapper<mfem::MatrixProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MatrixProductCoefficient::MatrixProductCoefficient(mfem::MatrixCoefficient &, mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2059:4
    t.constructor<mfem::MatrixCoefficient &, mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MatrixProductCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixProductCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2062:9
    t.method("SetACoef", static_cast<void (mfem::MatrixProductCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2064:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixProductCoefficient::*)()  const>(&mfem::MatrixProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixProductCoefficient::SetBCoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixProductCoefficient::SetBCoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2067:9
    t.method("SetBCoef", static_cast<void (mfem::MatrixProductCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::MatrixProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::MatrixProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::MatrixProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2069:24
    t.method("GetBCoef", static_cast<mfem::MatrixCoefficient * (mfem::MatrixProductCoefficient::*)()  const>(&mfem::MatrixProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::MatrixProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MatrixProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2072:17
    t.method("Eval", static_cast<void (mfem::MatrixProductCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::MatrixProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MatrixProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MatrixProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MatrixProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ScalarMatrixProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ScalarMatrixProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ScalarMatrixProductCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::ScalarMatrixProductCoefficient
// signature to use in the veto file: mfem::ScalarMatrixProductCoefficient
struct Jlmfem_ScalarMatrixProductCoefficient: public Wrapper {

  Jlmfem_ScalarMatrixProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ScalarMatrixProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2078:7
    jlcxx::TypeWrapper<mfem::ScalarMatrixProductCoefficient>  t = jlModule.add_type<mfem::ScalarMatrixProductCoefficient>("mfem!ScalarMatrixProductCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarMatrixProductCoefficient>>(new jlcxx::TypeWrapper<mfem::ScalarMatrixProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::ScalarMatrixProductCoefficient(double, mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2087:4
    t.constructor<double, mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::ScalarMatrixProductCoefficient(mfem::Coefficient &, mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2090:4
    t.constructor<mfem::Coefficient &, mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2093:9
    t.method("SetTime", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(double) >(&mfem::ScalarMatrixProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::SetAConst(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2096:9
    t.method("SetAConst", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(double) >(&mfem::ScalarMatrixProductCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::ScalarMatrixProductCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ScalarMatrixProductCoefficient::GetAConst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2098:11
    t.method("GetAConst", static_cast<double (mfem::ScalarMatrixProductCoefficient::*)()  const>(&mfem::ScalarMatrixProductCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::SetACoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2101:9
    t.method("SetACoef", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(mfem::Coefficient &) >(&mfem::ScalarMatrixProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::ScalarMatrixProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::ScalarMatrixProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2103:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::ScalarMatrixProductCoefficient::*)()  const>(&mfem::ScalarMatrixProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::SetBCoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::SetBCoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2106:9
    t.method("SetBCoef", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::ScalarMatrixProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::ScalarMatrixProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::ScalarMatrixProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2108:24
    t.method("GetBCoef", static_cast<mfem::MatrixCoefficient * (mfem::ScalarMatrixProductCoefficient::*)()  const>(&mfem::ScalarMatrixProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::ScalarMatrixProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarMatrixProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2111:17
    t.method("Eval", static_cast<void (mfem::ScalarMatrixProductCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ScalarMatrixProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarMatrixProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ScalarMatrixProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ScalarMatrixProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TransposeMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TransposeMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::TransposeMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::TransposeMatrixCoefficient
// signature to use in the veto file: mfem::TransposeMatrixCoefficient
struct Jlmfem_TransposeMatrixCoefficient: public Wrapper {

  Jlmfem_TransposeMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TransposeMatrixCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2116:7
    jlcxx::TypeWrapper<mfem::TransposeMatrixCoefficient>  t = jlModule.add_type<mfem::TransposeMatrixCoefficient>("mfem!TransposeMatrixCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TransposeMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::TransposeMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::TransposeMatrixCoefficient::TransposeMatrixCoefficient(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2123:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::TransposeMatrixCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeMatrixCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2126:9
    t.method("SetTime", static_cast<void (mfem::TransposeMatrixCoefficient::*)(double) >(&mfem::TransposeMatrixCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeMatrixCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeMatrixCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2129:9
    t.method("SetACoef", static_cast<void (mfem::TransposeMatrixCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::TransposeMatrixCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::TransposeMatrixCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::TransposeMatrixCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2131:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::TransposeMatrixCoefficient::*)()  const>(&mfem::TransposeMatrixCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2134:17
    t.method("Eval", static_cast<void (mfem::TransposeMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::TransposeMatrixCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TransposeMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TransposeMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TransposeMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InverseMatrixCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InverseMatrixCoefficient> : std::false_type { };
template<> struct SuperType<mfem::InverseMatrixCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::InverseMatrixCoefficient
// signature to use in the veto file: mfem::InverseMatrixCoefficient
struct Jlmfem_InverseMatrixCoefficient: public Wrapper {

  Jlmfem_InverseMatrixCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InverseMatrixCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2139:7
    jlcxx::TypeWrapper<mfem::InverseMatrixCoefficient>  t = jlModule.add_type<mfem::InverseMatrixCoefficient>("mfem!InverseMatrixCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseMatrixCoefficient>>(new jlcxx::TypeWrapper<mfem::InverseMatrixCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::InverseMatrixCoefficient::InverseMatrixCoefficient(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2146:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::InverseMatrixCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseMatrixCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2149:9
    t.method("SetTime", static_cast<void (mfem::InverseMatrixCoefficient::*)(double) >(&mfem::InverseMatrixCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::InverseMatrixCoefficient::SetACoef(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseMatrixCoefficient::SetACoef(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2152:9
    t.method("SetACoef", static_cast<void (mfem::InverseMatrixCoefficient::*)(mfem::MatrixCoefficient &) >(&mfem::InverseMatrixCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::MatrixCoefficient * mfem::InverseMatrixCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixCoefficient * mfem::InverseMatrixCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2154:24
    t.method("GetACoef", static_cast<mfem::MatrixCoefficient * (mfem::InverseMatrixCoefficient::*)()  const>(&mfem::InverseMatrixCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::InverseMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseMatrixCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2157:17
    t.method("Eval", static_cast<void (mfem::InverseMatrixCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::InverseMatrixCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseMatrixCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InverseMatrixCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InverseMatrixCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OuterProductCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OuterProductCoefficient> : std::false_type { };
template<> struct SuperType<mfem::OuterProductCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::OuterProductCoefficient
// signature to use in the veto file: mfem::OuterProductCoefficient
struct Jlmfem_OuterProductCoefficient: public Wrapper {

  Jlmfem_OuterProductCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OuterProductCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2162:7
    jlcxx::TypeWrapper<mfem::OuterProductCoefficient>  t = jlModule.add_type<mfem::OuterProductCoefficient>("mfem!OuterProductCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OuterProductCoefficient>>(new jlcxx::TypeWrapper<mfem::OuterProductCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::OuterProductCoefficient(mfem::VectorCoefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2173:4
    t.constructor<mfem::VectorCoefficient &, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OuterProductCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2176:9
    t.method("SetTime", static_cast<void (mfem::OuterProductCoefficient::*)(double) >(&mfem::OuterProductCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::SetACoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OuterProductCoefficient::SetACoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2179:9
    t.method("SetACoef", static_cast<void (mfem::OuterProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::OuterProductCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::OuterProductCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::OuterProductCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2181:24
    t.method("GetACoef", static_cast<mfem::VectorCoefficient * (mfem::OuterProductCoefficient::*)()  const>(&mfem::OuterProductCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::SetBCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OuterProductCoefficient::SetBCoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2184:9
    t.method("SetBCoef", static_cast<void (mfem::OuterProductCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::OuterProductCoefficient::SetBCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::OuterProductCoefficient::GetBCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::OuterProductCoefficient::GetBCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2186:24
    t.method("GetBCoef", static_cast<mfem::VectorCoefficient * (mfem::OuterProductCoefficient::*)()  const>(&mfem::OuterProductCoefficient::GetBCoef));

    DEBUG_MSG("Adding wrapper for void mfem::OuterProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::OuterProductCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2189:17
    t.method("Eval", static_cast<void (mfem::OuterProductCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::OuterProductCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OuterProductCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OuterProductCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OuterProductCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CrossCrossCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CrossCrossCoefficient> : std::false_type { };
template<> struct SuperType<mfem::CrossCrossCoefficient> { typedef mfem::MatrixCoefficient type; };
}

// Class generating the wrapper for type mfem::CrossCrossCoefficient
// signature to use in the veto file: mfem::CrossCrossCoefficient
struct Jlmfem_CrossCrossCoefficient: public Wrapper {

  Jlmfem_CrossCrossCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CrossCrossCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2200:7
    jlcxx::TypeWrapper<mfem::CrossCrossCoefficient>  t = jlModule.add_type<mfem::CrossCrossCoefficient>("mfem!CrossCrossCoefficient",
      jlcxx::julia_base_type<mfem::MatrixCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CrossCrossCoefficient>>(new jlcxx::TypeWrapper<mfem::CrossCrossCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::CrossCrossCoefficient(double, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2210:4
    t.constructor<double, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::CrossCrossCoefficient(mfem::Coefficient &, mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2211:4
    t.constructor<mfem::Coefficient &, mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2214:9
    t.method("SetTime", static_cast<void (mfem::CrossCrossCoefficient::*)(double) >(&mfem::CrossCrossCoefficient::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::SetAConst(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::SetAConst(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2217:9
    t.method("SetAConst", static_cast<void (mfem::CrossCrossCoefficient::*)(double) >(&mfem::CrossCrossCoefficient::SetAConst));

    DEBUG_MSG("Adding wrapper for double mfem::CrossCrossCoefficient::GetAConst() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CrossCrossCoefficient::GetAConst()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2219:11
    t.method("GetAConst", static_cast<double (mfem::CrossCrossCoefficient::*)()  const>(&mfem::CrossCrossCoefficient::GetAConst));

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::SetACoef(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::SetACoef(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2222:9
    t.method("SetACoef", static_cast<void (mfem::CrossCrossCoefficient::*)(mfem::Coefficient &) >(&mfem::CrossCrossCoefficient::SetACoef));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::CrossCrossCoefficient::GetACoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::CrossCrossCoefficient::GetACoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2224:18
    t.method("GetACoef", static_cast<mfem::Coefficient * (mfem::CrossCrossCoefficient::*)()  const>(&mfem::CrossCrossCoefficient::GetACoef));

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::SetKCoef(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::SetKCoef(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2227:9
    t.method("SetKCoef", static_cast<void (mfem::CrossCrossCoefficient::*)(mfem::VectorCoefficient &) >(&mfem::CrossCrossCoefficient::SetKCoef));

    DEBUG_MSG("Adding wrapper for mfem::VectorCoefficient * mfem::CrossCrossCoefficient::GetKCoef() (" __HERE__ ")");
    // signature to use in the veto list: mfem::VectorCoefficient * mfem::CrossCrossCoefficient::GetKCoef()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2229:24
    t.method("GetKCoef", static_cast<mfem::VectorCoefficient * (mfem::CrossCrossCoefficient::*)()  const>(&mfem::CrossCrossCoefficient::GetKCoef));

    DEBUG_MSG("Adding wrapper for void mfem::CrossCrossCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CrossCrossCoefficient::Eval(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2232:17
    t.method("Eval", static_cast<void (mfem::CrossCrossCoefficient::*)(mfem::DenseMatrix &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::CrossCrossCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CrossCrossCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CrossCrossCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CrossCrossCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorQuadratureFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorQuadratureFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::VectorQuadratureFunctionCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::VectorQuadratureFunctionCoefficient
// signature to use in the veto file: mfem::VectorQuadratureFunctionCoefficient
struct Jlmfem_VectorQuadratureFunctionCoefficient: public Wrapper {

  Jlmfem_VectorQuadratureFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorQuadratureFunctionCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2240:7
    jlcxx::TypeWrapper<mfem::VectorQuadratureFunctionCoefficient>  t = jlModule.add_type<mfem::VectorQuadratureFunctionCoefficient>("mfem!VectorQuadratureFunctionCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorQuadratureFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorQuadratureFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureFunctionCoefficient::VectorQuadratureFunctionCoefficient(mfem::QuadratureFunction &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2248:4
    t.constructor<mfem::QuadratureFunction &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureFunctionCoefficient::SetComponent(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorQuadratureFunctionCoefficient::SetComponent(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2253:9
    t.method("SetComponent", static_cast<void (mfem::VectorQuadratureFunctionCoefficient::*)(int, int) >(&mfem::VectorQuadratureFunctionCoefficient::SetComponent));

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureFunction & mfem::VectorQuadratureFunctionCoefficient::GetQuadFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureFunction & mfem::VectorQuadratureFunctionCoefficient::GetQuadFunction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2255:30
    t.method("GetQuadFunction", static_cast<const mfem::QuadratureFunction & (mfem::VectorQuadratureFunctionCoefficient::*)()  const>(&mfem::VectorQuadratureFunctionCoefficient::GetQuadFunction));

    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorQuadratureFunctionCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2258:17
    t.method("Eval", static_cast<void (mfem::VectorQuadratureFunctionCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::VectorQuadratureFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureFunctionCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorQuadratureFunctionCoefficient::Project(mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2261:17
    t.method("Project", static_cast<void (mfem::VectorQuadratureFunctionCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::VectorQuadratureFunctionCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorQuadratureFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorQuadratureFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorQuadratureFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureFunctionCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureFunctionCoefficient> : std::false_type { };
template<> struct SuperType<mfem::QuadratureFunctionCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::QuadratureFunctionCoefficient
// signature to use in the veto file: mfem::QuadratureFunctionCoefficient
struct Jlmfem_QuadratureFunctionCoefficient: public Wrapper {

  Jlmfem_QuadratureFunctionCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureFunctionCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2269:7
    jlcxx::TypeWrapper<mfem::QuadratureFunctionCoefficient>  t = jlModule.add_type<mfem::QuadratureFunctionCoefficient>("mfem!QuadratureFunctionCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunctionCoefficient>>(new jlcxx::TypeWrapper<mfem::QuadratureFunctionCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctionCoefficient::QuadratureFunctionCoefficient(mfem::QuadratureFunction &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2276:4
    t.constructor<mfem::QuadratureFunction &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureFunction & mfem::QuadratureFunctionCoefficient::GetQuadFunction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureFunction & mfem::QuadratureFunctionCoefficient::GetQuadFunction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2278:30
    t.method("GetQuadFunction", static_cast<const mfem::QuadratureFunction & (mfem::QuadratureFunctionCoefficient::*)()  const>(&mfem::QuadratureFunctionCoefficient::GetQuadFunction));

    DEBUG_MSG("Adding wrapper for double mfem::QuadratureFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::QuadratureFunctionCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2280:19
    t.method("Eval", static_cast<double (mfem::QuadratureFunctionCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::QuadratureFunctionCoefficient::Eval));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunctionCoefficient::Project(mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunctionCoefficient::Project(mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2282:17
    t.method("Project", static_cast<void (mfem::QuadratureFunctionCoefficient::*)(mfem::QuadratureFunction &) >(&mfem::QuadratureFunctionCoefficient::Project));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunctionCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunctionCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureFunctionCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CoefficientVector> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CoefficientVector> : std::false_type { };
template<> struct SuperType<mfem::CoefficientVector> { typedef mfem::Vector type; };
}

// Class generating the wrapper for type mfem::CoefficientVector
// signature to use in the veto file: mfem::CoefficientVector
struct Jlmfem_CoefficientVector: public Wrapper {

  Jlmfem_CoefficientVector(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CoefficientVector (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2316:7
    jlcxx::TypeWrapper<mfem::CoefficientVector>  t = jlModule.add_type<mfem::CoefficientVector>("mfem!CoefficientVector",
      jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CoefficientVector>>(new jlcxx::TypeWrapper<mfem::CoefficientVector>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2325:4
    t.constructor<mfem::QuadratureSpaceBase &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::Coefficient *, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2333:4
    t.constructor<mfem::Coefficient *, mfem::QuadratureSpaceBase &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient *, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::Coefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2340:4
    t.constructor<mfem::Coefficient &, mfem::QuadratureSpaceBase &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::VectorCoefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2347:4
    t.constructor<mfem::VectorCoefficient &, mfem::QuadratureSpaceBase &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::CoefficientVector(mfem::MatrixCoefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2354:4
    t.constructor<mfem::MatrixCoefficient &, mfem::QuadratureSpaceBase &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::MatrixCoefficient &, mfem::QuadratureSpaceBase &, mfem::CoefficientStorage>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::Project(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::Project(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2359:9
    t.method("Project", static_cast<void (mfem::CoefficientVector::*)(mfem::Coefficient &) >(&mfem::CoefficientVector::Project));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::Project(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::Project(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2365:9
    t.method("Project", static_cast<void (mfem::CoefficientVector::*)(mfem::VectorCoefficient &) >(&mfem::CoefficientVector::Project));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::Project(mfem::MatrixCoefficient &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::Project(mfem::MatrixCoefficient &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2371:9
    t.method("Project", static_cast<void (mfem::CoefficientVector::*)(mfem::MatrixCoefficient &, bool) >(&mfem::CoefficientVector::Project));
    t.method("Project", [](mfem::CoefficientVector& a, mfem::MatrixCoefficient & arg0)->void { a.Project(arg0); });
    t.method("Project", [](mfem::CoefficientVector* a, mfem::MatrixCoefficient & arg0)->void { a->Project(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::ProjectTranspose(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::ProjectTranspose(mfem::MatrixCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2376:9
    t.method("ProjectTranspose", static_cast<void (mfem::CoefficientVector::*)(mfem::MatrixCoefficient &) >(&mfem::CoefficientVector::ProjectTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::MakeRef(const mfem::QuadratureFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::MakeRef(const mfem::QuadratureFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2379:9
    t.method("MakeRef", static_cast<void (mfem::CoefficientVector::*)(const mfem::QuadratureFunction &) >(&mfem::CoefficientVector::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::SetConstant(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::SetConstant(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2382:9
    t.method("SetConstant", static_cast<void (mfem::CoefficientVector::*)(double) >(&mfem::CoefficientVector::SetConstant));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::SetConstant(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::SetConstant(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2385:9
    t.method("SetConstant", static_cast<void (mfem::CoefficientVector::*)(const mfem::Vector &) >(&mfem::CoefficientVector::SetConstant));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::SetConstant(const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::SetConstant(const mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2388:9
    t.method("SetConstant", static_cast<void (mfem::CoefficientVector::*)(const mfem::DenseMatrix &) >(&mfem::CoefficientVector::SetConstant));

    DEBUG_MSG("Adding wrapper for void mfem::CoefficientVector::SetConstant(const mfem::DenseSymmetricMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoefficientVector::SetConstant(const mfem::DenseSymmetricMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2391:9
    t.method("SetConstant", static_cast<void (mfem::CoefficientVector::*)(const mfem::DenseSymmetricMatrix &) >(&mfem::CoefficientVector::SetConstant));

    DEBUG_MSG("Adding wrapper for int mfem::CoefficientVector::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CoefficientVector::GetVDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2394:8
    t.method("GetVDim", static_cast<int (mfem::CoefficientVector::*)()  const>(&mfem::CoefficientVector::GetVDim));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CoefficientVector>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CoefficientVector(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CoefficientVector(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureSpaceBase> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureSpaceBase> : std::false_type { };
}

// Class generating the wrapper for type mfem::QuadratureSpaceBase
// signature to use in the veto file: mfem::QuadratureSpaceBase
struct Jlmfem_QuadratureSpaceBase: public Wrapper {

  Jlmfem_QuadratureSpaceBase(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureSpaceBase (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/qspace.hpp:25:7
    jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>  t = jlModule.add_type<mfem::QuadratureSpaceBase>("mfem!QuadratureSpaceBase");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>>(new jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpaceBase(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureSpaceBase(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSExtension> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSExtension> : std::false_type { };
}

// Class generating the wrapper for type mfem::NURBSExtension
// signature to use in the veto file: mfem::NURBSExtension
struct Jlmfem_NURBSExtension: public Wrapper {

  Jlmfem_NURBSExtension(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSExtension (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:201:7
    jlcxx::TypeWrapper<mfem::NURBSExtension>  t = jlModule.add_type<mfem::NURBSExtension>("mfem!NURBSExtension");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSExtension>>(new jlcxx::TypeWrapper<mfem::NURBSExtension>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSExtension>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSExtension(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSExtension(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Element> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Element> : std::false_type { };
}

// Class generating the wrapper for type mfem::Element
// signature to use in the veto file: mfem::Element
struct Jlmfem_Element: public Wrapper {

  Jlmfem_Element(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Element (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/element.hpp:28:7
    jlcxx::TypeWrapper<mfem::Element>  t = jlModule.add_type<mfem::Element>("mfem!Element");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Element>>(new jlcxx::TypeWrapper<mfem::Element>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Element>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Element(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Element(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh::GeometryList> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh::GeometryList> : std::false_type { };
}

// Class generating the wrapper for type mfem::Mesh::GeometryList
// signature to use in the veto file: mfem::Mesh::GeometryList
struct Jlmfem_Mesh_GeometryList: public Wrapper {

  Jlmfem_Mesh_GeometryList(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh::GeometryList (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1393:10
    jlcxx::TypeWrapper<mfem::Mesh::GeometryList>  t = jlModule.add_type<mfem::Mesh::GeometryList>("mfem!Mesh!GeometryList");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::GeometryList>>(new jlcxx::TypeWrapper<mfem::Mesh::GeometryList>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeometryList::GeometryList(const mfem::Mesh &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1399:7
    t.constructor<const mfem::Mesh &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeometryList::GeometryList(const mfem::Mesh &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1404:7
    t.constructor<const mfem::Mesh &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::GeometryList>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh_GeometryList(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh_GeometryList(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DSTable> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DSTable> : std::false_type { };
}

// Class generating the wrapper for type mfem::DSTable
// signature to use in the veto file: mfem::DSTable
struct Jlmfem_DSTable: public Wrapper {

  Jlmfem_DSTable(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DSTable (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../general/table.hpp:244:7
    jlcxx::TypeWrapper<mfem::DSTable>  t = jlModule.add_type<mfem::DSTable>("mfem!DSTable");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DSTable>>(new jlcxx::TypeWrapper<mfem::DSTable>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DSTable>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DSTable(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DSTable(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElement> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElement> : std::false_type { };
}

// Class generating the wrapper for type mfem::FiniteElement
// signature to use in the veto file: mfem::FiniteElement
struct Jlmfem_FiniteElement: public Wrapper {

  Jlmfem_FiniteElement(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElement (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/fe/fe_base.hpp:238:7
    jlcxx::TypeWrapper<mfem::FiniteElement>  t = jlModule.add_type<mfem::FiniteElement>("mfem!FiniteElement");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElement>>(new jlcxx::TypeWrapper<mfem::FiniteElement>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElement>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElement(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElement(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IsoparametricTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IsoparametricTransformation> : std::false_type { };
template<> struct SuperType<mfem::IsoparametricTransformation> { typedef mfem::ElementTransformation type; };
}

// Class generating the wrapper for type mfem::IsoparametricTransformation
// signature to use in the veto file: mfem::IsoparametricTransformation
struct Jlmfem_IsoparametricTransformation: public Wrapper {

  Jlmfem_IsoparametricTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IsoparametricTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/eltrans.hpp:361:7
    jlcxx::TypeWrapper<mfem::IsoparametricTransformation>  t = jlModule.add_type<mfem::IsoparametricTransformation>("mfem!IsoparametricTransformation",
      jlcxx::julia_base_type<mfem::ElementTransformation>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IsoparametricTransformation>>(new jlcxx::TypeWrapper<mfem::IsoparametricTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IsoparametricTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IsoparametricTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IsoparametricTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceElementTransformations> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceElementTransformations> : std::false_type { };
template<> struct SuperType<mfem::FaceElementTransformations> { typedef mfem::IsoparametricTransformation type; };
}

// Class generating the wrapper for type mfem::FaceElementTransformations
// signature to use in the veto file: mfem::FaceElementTransformations
struct Jlmfem_FaceElementTransformations: public Wrapper {

  Jlmfem_FaceElementTransformations(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceElementTransformations (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/eltrans.hpp:480:7
    jlcxx::TypeWrapper<mfem::FaceElementTransformations>  t = jlModule.add_type<mfem::FaceElementTransformations>("mfem!FaceElementTransformations",
      jlcxx::julia_base_type<mfem::IsoparametricTransformation>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceElementTransformations>>(new jlcxx::TypeWrapper<mfem::FaceElementTransformations>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceElementTransformations>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceElementTransformations(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceElementTransformations(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh::FaceInformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh::FaceInformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::Mesh::FaceInformation
// signature to use in the veto file: mfem::Mesh::FaceInformation
struct Jlmfem_Mesh_FaceInformation: public Wrapper {

  Jlmfem_Mesh_FaceInformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh::FaceInformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1858:11
    jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>  t = jlModule.add_type<mfem::Mesh::FaceInformation>("mfem!Mesh!FaceInformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>>(new jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsLocal() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsLocal()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1877:12
    t.method("IsLocal", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsLocal));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsShared() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsShared()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1884:12
    t.method("IsShared", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsShared));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsInterior() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsInterior()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1893:12
    t.method("IsInterior", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsInterior));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsBoundary() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsBoundary()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1900:12
    t.method("IsBoundary", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsBoundary));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsOfFaceType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsOfFaceType(mfem::FaceType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1906:12
    t.method("IsOfFaceType", static_cast<bool (mfem::Mesh::FaceInformation::*)(mfem::FaceType)  const>(&mfem::Mesh::FaceInformation::IsOfFaceType));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsConforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsConforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1920:12
    t.method("IsConforming", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsConforming));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsNonconformingFine() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsNonconformingFine()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1926:12
    t.method("IsNonconformingFine", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsNonconformingFine));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsNonconformingCoarse() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsNonconformingCoarse()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1937:12
    t.method("IsNonconformingCoarse", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsNonconformingCoarse));

    DEBUG_MSG("Adding topology methods  to provide read access to the field topology (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1860:20
    // signature to use in the veto list: mfem::Mesh::FaceInformation::topology
    t.method("topology", [](const mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceTopology { return a.topology; });
    t.method("topology", [](mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceTopology { return a.topology; });
    t.method("topology", [](const mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceTopology { return a->topology; });
    t.method("topology", [](mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceTopology { return a->topology; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1860:20
    // signature to use in the veto list: mfem::Mesh::FaceInformation::topology
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding topology! methods to provide write access to the field topology (" __HERE__ ")");
    t.method("topology!", [](mfem::Mesh::FaceInformation& a, mfem::Mesh::FaceTopology val) -> mfem::Mesh::FaceTopology { return a.topology = val; });

    DEBUG_MSG("Adding topology! methods to provide write access to the field topology (" __HERE__ ")");
    t.method("topology!", [](mfem::Mesh::FaceInformation* a, mfem::Mesh::FaceTopology val) -> mfem::Mesh::FaceTopology { return a->topology = val; });

    DEBUG_MSG("Adding tag methods  to provide read access to the field tag (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1871:19
    // signature to use in the veto list: mfem::Mesh::FaceInformation::tag
    t.method("tag", [](const mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceInfoTag { return a.tag; });
    t.method("tag", [](mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceInfoTag { return a.tag; });
    t.method("tag", [](const mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceInfoTag { return a->tag; });
    t.method("tag", [](mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceInfoTag { return a->tag; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1871:19
    // signature to use in the veto list: mfem::Mesh::FaceInformation::tag
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding tag! methods to provide write access to the field tag (" __HERE__ ")");
    t.method("tag!", [](mfem::Mesh::FaceInformation& a, mfem::Mesh::FaceInfoTag val) -> mfem::Mesh::FaceInfoTag { return a.tag = val; });

    DEBUG_MSG("Adding tag! methods to provide write access to the field tag (" __HERE__ ")");
    t.method("tag!", [](mfem::Mesh::FaceInformation* a, mfem::Mesh::FaceInfoTag val) -> mfem::Mesh::FaceInfoTag { return a->tag = val; });

    DEBUG_MSG("Adding ncface methods  to provide read access to the field ncface (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1872:11
    // signature to use in the veto list: mfem::Mesh::FaceInformation::ncface
    t.method("ncface", [](const mfem::Mesh::FaceInformation& a) -> int { return a.ncface; });
    t.method("ncface", [](mfem::Mesh::FaceInformation& a) -> int { return a.ncface; });
    t.method("ncface", [](const mfem::Mesh::FaceInformation* a) -> int { return a->ncface; });
    t.method("ncface", [](mfem::Mesh::FaceInformation* a) -> int { return a->ncface; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1872:11
    // signature to use in the veto list: mfem::Mesh::FaceInformation::ncface
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding ncface! methods to provide write access to the field ncface (" __HERE__ ")");
    t.method("ncface!", [](mfem::Mesh::FaceInformation& a, int val) -> int { return a.ncface = val; });

    DEBUG_MSG("Adding ncface! methods to provide write access to the field ncface (" __HERE__ ")");
    t.method("ncface!", [](mfem::Mesh::FaceInformation* a, int val) -> int { return a->ncface = val; });

    DEBUG_MSG("Adding point_matrix methods  to provide read access to the field point_matrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1873:26
    // signature to use in the veto list: mfem::Mesh::FaceInformation::point_matrix
    t.method("point_matrix", [](const mfem::Mesh::FaceInformation& a) -> const mfem::DenseMatrix * { return a.point_matrix; });
    t.method("point_matrix", [](const mfem::Mesh::FaceInformation* a) -> const mfem::DenseMatrix * { return a->point_matrix; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh_FaceInformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh_FaceInformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElementSpace> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElementSpace> : std::false_type { };
}

// Class generating the wrapper for type mfem::FiniteElementSpace
// signature to use in the veto file: mfem::FiniteElementSpace
struct Jlmfem_FiniteElementSpace: public Wrapper {

  Jlmfem_FiniteElementSpace(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElementSpace (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:219:7
    jlcxx::TypeWrapper<mfem::FiniteElementSpace>  t = jlModule.add_type<mfem::FiniteElementSpace>("mfem!FiniteElementSpace");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementSpace>>(new jlcxx::TypeWrapper<mfem::FiniteElementSpace>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::FiniteElementSpace(const mfem::FiniteElementSpace &, mfem::Mesh *, const mfem::FiniteElementCollection *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:538:4
    t.constructor<const mfem::FiniteElementSpace &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::FiniteElementSpace &, mfem::Mesh *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::FiniteElementSpace &, mfem::Mesh *, const mfem::FiniteElementCollection *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::FiniteElementSpace(mfem::Mesh *, const mfem::FiniteElementCollection *, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:541:4
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::FiniteElementSpace(mfem::Mesh *, mfem::NURBSExtension *, const mfem::FiniteElementCollection *, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:550:4
    t.constructor<mfem::Mesh *, mfem::NURBSExtension *, const mfem::FiniteElementCollection *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Mesh *, mfem::NURBSExtension *, const mfem::FiniteElementCollection *, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Mesh *, mfem::NURBSExtension *, const mfem::FiniteElementCollection *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::FiniteElementSpace::GetMesh() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::FiniteElementSpace::GetMesh()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:559:17
    t.method("GetMesh", static_cast<mfem::Mesh * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetMesh));

    DEBUG_MSG("Adding wrapper for const mfem::NURBSExtension * mfem::FiniteElementSpace::GetNURBSext() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::NURBSExtension * mfem::FiniteElementSpace::GetNURBSext()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:561:26
    t.method("GetNURBSext", static_cast<const mfem::NURBSExtension * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNURBSext));

    DEBUG_MSG("Adding wrapper for mfem::NURBSExtension * mfem::FiniteElementSpace::GetNURBSext() (" __HERE__ ")");
    // signature to use in the veto list: mfem::NURBSExtension * mfem::FiniteElementSpace::GetNURBSext()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:562:20
    t.method("GetNURBSext", static_cast<mfem::NURBSExtension * (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::GetNURBSext));

    DEBUG_MSG("Adding wrapper for mfem::NURBSExtension * mfem::FiniteElementSpace::StealNURBSext() (" __HERE__ ")");
    // signature to use in the veto list: mfem::NURBSExtension * mfem::FiniteElementSpace::StealNURBSext()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:563:20
    t.method("StealNURBSext", static_cast<mfem::NURBSExtension * (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::StealNURBSext));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::Conforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::Conforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:565:9
    t.method("Conforming", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::Conforming));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::Nonconforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::Nonconforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:566:9
    t.method("Nonconforming", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::Nonconforming));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetElementOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetElementOrder(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:571:9
    t.method("SetElementOrder", static_cast<void (mfem::FiniteElementSpace::*)(int, int) >(&mfem::FiniteElementSpace::SetElementOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementOrder(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:574:8
    t.method("GetElementOrder", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetMaxElementOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetMaxElementOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:577:8
    t.method("GetMaxElementOrder", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetMaxElementOrder));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::IsVariableOrder() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::IsVariableOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:581:9
    t.method("IsVariableOrder", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::IsVariableOrder));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:584:24
    t.method("GetConformingProlongation", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:587:24
    t.method("GetConformingRestriction", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpConformingRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpConformingRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:594:24
    t.method("GetHpConformingRestriction", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetHpConformingRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetProlongationMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetProlongationMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:597:28
    t.method("GetProlongationMatrix", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetProlongationMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionTransposeOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionTransposeOperator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:611:20
    t.method("GetRestrictionTransposeOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionTransposeOperator));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionOperator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:616:28
    t.method("GetRestrictionOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionOperator));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetRestrictionMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetRestrictionMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:620:32
    t.method("GetRestrictionMatrix", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpRestrictionMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpRestrictionMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:624:32
    t.method("GetHpRestrictionMatrix", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetHpRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::ElementRestrictionOperator * mfem::FiniteElementSpace::GetElementRestriction(mfem::ElementDofOrdering) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::ElementRestrictionOperator * mfem::FiniteElementSpace::GetElementRestriction(mfem::ElementDofOrdering)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:644:38
    t.method("GetElementRestriction", static_cast<const mfem::ElementRestrictionOperator * (mfem::FiniteElementSpace::*)(mfem::ElementDofOrdering)  const>(&mfem::FiniteElementSpace::GetElementRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::FaceRestriction * mfem::FiniteElementSpace::GetFaceRestriction(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FaceRestriction * mfem::FiniteElementSpace::GetFaceRestriction(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:648:35
    t.method("GetFaceRestriction", static_cast<const mfem::FaceRestriction * (mfem::FiniteElementSpace::*)(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues)  const>(&mfem::FiniteElementSpace::GetFaceRestriction));
    t.method("GetFaceRestriction", [](mfem::FiniteElementSpace const& a, mfem::ElementDofOrdering arg0, mfem::FaceType arg1)->const mfem::FaceRestriction * { return a.GetFaceRestriction(arg0, arg1); });
    t.method("GetFaceRestriction", [](mfem::FiniteElementSpace const* a, mfem::ElementDofOrdering arg0, mfem::FaceType arg1)->const mfem::FaceRestriction * { return a->GetFaceRestriction(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureInterpolator * mfem::FiniteElementSpace::GetQuadratureInterpolator(const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureInterpolator * mfem::FiniteElementSpace::GetQuadratureInterpolator(const mfem::IntegrationRule &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:665:34
    t.method("GetQuadratureInterpolator", static_cast<const mfem::QuadratureInterpolator * (mfem::FiniteElementSpace::*)(const mfem::IntegrationRule &)  const>(&mfem::FiniteElementSpace::GetQuadratureInterpolator));

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureInterpolator * mfem::FiniteElementSpace::GetQuadratureInterpolator(const mfem::QuadratureSpace &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureInterpolator * mfem::FiniteElementSpace::GetQuadratureInterpolator(const mfem::QuadratureSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:681:34
    t.method("GetQuadratureInterpolator", static_cast<const mfem::QuadratureInterpolator * (mfem::FiniteElementSpace::*)(const mfem::QuadratureSpace &)  const>(&mfem::FiniteElementSpace::GetQuadratureInterpolator));

    DEBUG_MSG("Adding wrapper for const mfem::FaceQuadratureInterpolator * mfem::FiniteElementSpace::GetFaceQuadratureInterpolator(const mfem::IntegrationRule &, mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FaceQuadratureInterpolator * mfem::FiniteElementSpace::GetFaceQuadratureInterpolator(const mfem::IntegrationRule &, mfem::FaceType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:691:38
    t.method("GetFaceQuadratureInterpolator", static_cast<const mfem::FaceQuadratureInterpolator * (mfem::FiniteElementSpace::*)(const mfem::IntegrationRule &, mfem::FaceType)  const>(&mfem::FiniteElementSpace::GetFaceQuadratureInterpolator));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetOrder(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:696:8
    t.method("GetOrder", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetEdgeOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetEdgeOrder(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:700:8
    t.method("GetEdgeOrder", static_cast<int (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetEdgeOrder));
    t.method("GetEdgeOrder", [](mfem::FiniteElementSpace const& a, int arg0)->int { return a.GetEdgeOrder(arg0); });
    t.method("GetEdgeOrder", [](mfem::FiniteElementSpace const* a, int arg0)->int { return a->GetEdgeOrder(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetFaceOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetFaceOrder(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:703:8
    t.method("GetFaceOrder", static_cast<int (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetFaceOrder));
    t.method("GetFaceOrder", [](mfem::FiniteElementSpace const& a, int arg0)->int { return a.GetFaceOrder(arg0); });
    t.method("GetFaceOrder", [](mfem::FiniteElementSpace const* a, int arg0)->int { return a->GetFaceOrder(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetVDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:706:15
    t.method("GetVDim", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetVDim));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:710:15
    t.method("GetNDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetVSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:713:15
    t.method("GetVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetVSize));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetTrueVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetTrueVSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:716:16
    t.method("GetTrueVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetTrueVSize));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNConformingDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNConformingDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:720:8
    t.method("GetNConformingDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNConformingDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetConformingVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetConformingVSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:722:8
    t.method("GetConformingVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingVSize));

    DEBUG_MSG("Adding wrapper for mfem::Ordering::Type mfem::FiniteElementSpace::GetOrdering() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Ordering::Type mfem::FiniteElementSpace::GetOrdering()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:725:26
    t.method("GetOrdering", static_cast<mfem::Ordering::Type (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetOrdering));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementCollection * mfem::FiniteElementSpace::FEColl() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementCollection * mfem::FiniteElementSpace::FEColl()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:727:35
    t.method("FEColl", static_cast<const mfem::FiniteElementCollection * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::FEColl));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNVDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNVDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:730:8
    t.method("GetNVDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNVDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNEDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNEDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:732:8
    t.method("GetNEDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNEDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNFDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNFDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:734:8
    t.method("GetNFDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNFDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNV()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:737:15
    t.method("GetNV", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNV));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:740:15
    t.method("GetNE", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNF() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNF()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:746:15
    t.method("GetNF", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNF));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNBE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNBE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:749:15
    t.method("GetNBE", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNBE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNFbyType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNFbyType(mfem::FaceType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:757:15
    t.method("GetNFbyType", static_cast<int (mfem::FiniteElementSpace::*)(mfem::FaceType)  const>(&mfem::FiniteElementSpace::GetNFbyType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:761:15
    t.method("GetElementType", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementType));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:765:16
    t.method("GetElementVertices", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementVertices));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetBdrElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetBdrElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:769:15
    t.method("GetBdrElementType", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrElementType));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::FiniteElementSpace::GetElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::FiniteElementSpace::GetElementTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:773:27
    t.method("GetElementTransformation", static_cast<mfem::ElementTransformation * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:778:9
    t.method("GetElementTransformation", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::IsoparametricTransformation *) >(&mfem::FiniteElementSpace::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::FiniteElementSpace::GetBdrElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::FiniteElementSpace::GetBdrElementTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:782:27
    t.method("GetBdrElementTransformation", static_cast<mfem::ElementTransformation * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:785:8
    t.method("GetAttribute", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetBdrAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:787:8
    t.method("GetBdrAttribute", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrAttribute));

    DEBUG_MSG("Adding wrapper for mfem::DofTransformation * mfem::FiniteElementSpace::GetElementDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DofTransformation * mfem::FiniteElementSpace::GetElementDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:810:23
    t.method("GetElementDofs", static_cast<mfem::DofTransformation * (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementDofs(int, mfem::Array<int> &, mfem::DofTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementDofs(int, mfem::Array<int> &, mfem::DofTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:818:17
    t.method("GetElementDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, mfem::DofTransformation &)  const>(&mfem::FiniteElementSpace::GetElementDofs));

    DEBUG_MSG("Adding wrapper for mfem::DofTransformation * mfem::FiniteElementSpace::GetBdrElementDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DofTransformation * mfem::FiniteElementSpace::GetBdrElementDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:833:23
    t.method("GetBdrElementDofs", static_cast<mfem::DofTransformation * (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetBdrElementDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetBdrElementDofs(int, mfem::Array<int> &, mfem::DofTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetBdrElementDofs(int, mfem::Array<int> &, mfem::DofTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:841:17
    t.method("GetBdrElementDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, mfem::DofTransformation &)  const>(&mfem::FiniteElementSpace::GetBdrElementDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetFaceDofs(int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetFaceDofs(int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:854:16
    t.method("GetFaceDofs", static_cast<int (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetFaceDofs));
    t.method("GetFaceDofs", [](mfem::FiniteElementSpace const& a, int arg0, mfem::Array<int> & arg1)->int { return a.GetFaceDofs(arg0, arg1); });
    t.method("GetFaceDofs", [](mfem::FiniteElementSpace const* a, int arg0, mfem::Array<int> & arg1)->int { return a->GetFaceDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetEdgeDofs(int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetEdgeDofs(int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:868:8
    t.method("GetEdgeDofs", static_cast<int (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetEdgeDofs));
    t.method("GetEdgeDofs", [](mfem::FiniteElementSpace const& a, int arg0, mfem::Array<int> & arg1)->int { return a.GetEdgeDofs(arg0, arg1); });
    t.method("GetEdgeDofs", [](mfem::FiniteElementSpace const* a, int arg0, mfem::Array<int> & arg1)->int { return a->GetEdgeDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetVertexDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetVertexDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:875:9
    t.method("GetVertexDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetVertexDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementInteriorDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementInteriorDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:887:9
    t.method("GetElementInteriorDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementInteriorDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNumElementInteriorDofs(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNumElementInteriorDofs(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:894:8
    t.method("GetNumElementInteriorDofs", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetNumElementInteriorDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetFaceInteriorDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetFaceInteriorDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:906:9
    t.method("GetFaceInteriorDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetFaceInteriorDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEdgeInteriorDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEdgeInteriorDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:913:9
    t.method("GetEdgeInteriorDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetEdgeInteriorDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetPatchDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetPatchDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:919:9
    t.method("GetPatchDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetPatchDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetVDofs(int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetVDofs(int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:951:9
    t.method("GetVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetVDofs));
    t.method("GetVDofs", [](mfem::FiniteElementSpace const& a, int arg0, mfem::Array<int> & arg1)->void { a.GetVDofs(arg0, arg1); });
    t.method("GetVDofs", [](mfem::FiniteElementSpace const* a, int arg0, mfem::Array<int> & arg1)->void { a->GetVDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::DofsToVDofs(mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::DofsToVDofs(mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:967:9
    t.method("DofsToVDofs", static_cast<void (mfem::FiniteElementSpace::*)(mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::DofsToVDofs));
    t.method("DofsToVDofs", [](mfem::FiniteElementSpace const& a, mfem::Array<int> & arg0)->void { a.DofsToVDofs(arg0); });
    t.method("DofsToVDofs", [](mfem::FiniteElementSpace const* a, mfem::Array<int> & arg0)->void { a->DofsToVDofs(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::DofsToVDofs(int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::DofsToVDofs(int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:979:9
    t.method("DofsToVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::DofsToVDofs));
    t.method("DofsToVDofs", [](mfem::FiniteElementSpace const& a, int arg0, mfem::Array<int> & arg1)->void { a.DofsToVDofs(arg0, arg1); });
    t.method("DofsToVDofs", [](mfem::FiniteElementSpace const* a, int arg0, mfem::Array<int> & arg1)->void { a->DofsToVDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DofToVDof(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DofToVDof(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:988:8
    t.method("DofToVDof", static_cast<int (mfem::FiniteElementSpace::*)(int, int, int)  const>(&mfem::FiniteElementSpace::DofToVDof));
    t.method("DofToVDof", [](mfem::FiniteElementSpace const& a, int arg0, int arg1)->int { return a.DofToVDof(arg0, arg1); });
    t.method("DofToVDof", [](mfem::FiniteElementSpace const* a, int arg0, int arg1)->int { return a->DofToVDof(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::VDofToDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::VDofToDof(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:995:8
    t.method("VDofToDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::VDofToDof));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::AdjustVDofs(mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::AdjustVDofs(mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1010:16
    module_.method("mfem!FiniteElementSpace!AdjustVDofs", static_cast<void (*)(mfem::Array<int> &) >(&mfem::FiniteElementSpace::AdjustVDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::EncodeDof(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::EncodeDof(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1013:22
    module_.method("mfem!FiniteElementSpace!EncodeDof", static_cast<int (*)(int, int) >(&mfem::FiniteElementSpace::EncodeDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DecodeDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DecodeDof(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1017:22
    module_.method("mfem!FiniteElementSpace!DecodeDof", static_cast<int (*)(int) >(&mfem::FiniteElementSpace::DecodeDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DecodeDof(int, double &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DecodeDof(int, double &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1021:22
    module_.method("mfem!FiniteElementSpace!DecodeDof", static_cast<int (*)(int, double &) >(&mfem::FiniteElementSpace::DecodeDof));

    DEBUG_MSG("Adding wrapper for mfem::DofTransformation * mfem::FiniteElementSpace::GetElementVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DofTransformation * mfem::FiniteElementSpace::GetElementVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1045:23
    t.method("GetElementVDofs", static_cast<mfem::DofTransformation * (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementVDofs(int, mfem::Array<int> &, mfem::DofTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementVDofs(int, mfem::Array<int> &, mfem::DofTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1053:9
    t.method("GetElementVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, mfem::DofTransformation &)  const>(&mfem::FiniteElementSpace::GetElementVDofs));

    DEBUG_MSG("Adding wrapper for mfem::DofTransformation * mfem::FiniteElementSpace::GetBdrElementVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DofTransformation * mfem::FiniteElementSpace::GetBdrElementVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1069:23
    t.method("GetBdrElementVDofs", static_cast<mfem::DofTransformation * (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetBdrElementVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetBdrElementVDofs(int, mfem::Array<int> &, mfem::DofTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetBdrElementVDofs(int, mfem::Array<int> &, mfem::DofTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1077:9
    t.method("GetBdrElementVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, mfem::DofTransformation &)  const>(&mfem::FiniteElementSpace::GetBdrElementVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetPatchVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetPatchVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1081:9
    t.method("GetPatchVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetPatchVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetFaceVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetFaceVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1088:9
    t.method("GetFaceVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetFaceVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEdgeVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEdgeVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1095:9
    t.method("GetEdgeVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetEdgeVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetVertexVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetVertexVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1102:9
    t.method("GetVertexVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetVertexVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementInteriorVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementInteriorVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1110:9
    t.method("GetElementInteriorVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementInteriorVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEdgeInteriorVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEdgeInteriorVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1117:9
    t.method("GetEdgeInteriorVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetEdgeInteriorVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::RebuildElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::RebuildElementToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1121:25
    t.method("RebuildElementToDofTable", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::RebuildElementToDofTable));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ReorderElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ReorderElementToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1130:9
    t.method("ReorderElementToDofTable", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::ReorderElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table * mfem::FiniteElementSpace::GetElementToFaceOrientationTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table * mfem::FiniteElementSpace::GetElementToFaceOrientationTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1132:17
    t.method("GetElementToFaceOrientationTable", static_cast<const mfem::Table * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetElementToFaceOrientationTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetElementToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1136:17
    t.method("GetElementToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetBdrElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetBdrElementToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1141:17
    t.method("GetBdrElementToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetBdrElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetFaceToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetFaceToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1149:17
    t.method("GetFaceToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetFaceToDofTable));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::BuildDofToArrays() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::BuildDofToArrays()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1154:9
    t.method("BuildDofToArrays", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::BuildDofToArrays));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementForDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementForDof(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1159:8
    t.method("GetElementForDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementForDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetLocalDofForDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetLocalDofForDof(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1163:8
    t.method("GetLocalDofForDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetLocalDofForDof));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetFE(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetFE(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1169:33
    t.method("GetFE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetFE));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetBE(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetBE(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1173:25
    t.method("GetBE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBE));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetFaceElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetFaceElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1179:25
    t.method("GetFaceElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetFaceElement));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetEdgeElement(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetEdgeElement(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1183:25
    t.method("GetEdgeElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetEdgeElement));
    t.method("GetEdgeElement", [](mfem::FiniteElementSpace const& a, int arg0)->const mfem::FiniteElement * { return a.GetEdgeElement(arg0); });
    t.method("GetEdgeElement", [](mfem::FiniteElementSpace const* a, int arg0)->const mfem::FiniteElement * { return a->GetEdgeElement(arg0); });

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetTraceElement(int, mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetTraceElement(int, mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1186:25
    t.method("GetTraceElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int, mfem::Geometry::Type)  const>(&mfem::FiniteElementSpace::GetTraceElement));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEssentialVDofs(const mfem::Array<int> &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEssentialVDofs(const mfem::Array<int> &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1192:17
    t.method("GetEssentialVDofs", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::Array<int> &, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetEssentialVDofs));
    t.method("GetEssentialVDofs", [](mfem::FiniteElementSpace const& a, const mfem::Array<int> & arg0, mfem::Array<int> & arg1)->void { a.GetEssentialVDofs(arg0, arg1); });
    t.method("GetEssentialVDofs", [](mfem::FiniteElementSpace const* a, const mfem::Array<int> & arg0, mfem::Array<int> & arg1)->void { a->GetEssentialVDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEssentialTrueDofs(const mfem::Array<int> &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEssentialTrueDofs(const mfem::Array<int> &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1200:17
    t.method("GetEssentialTrueDofs", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::Array<int> &, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetEssentialTrueDofs));
    t.method("GetEssentialTrueDofs", [](mfem::FiniteElementSpace const& a, const mfem::Array<int> & arg0, mfem::Array<int> & arg1)->void { a.GetEssentialTrueDofs(arg0, arg1); });
    t.method("GetEssentialTrueDofs", [](mfem::FiniteElementSpace const* a, const mfem::Array<int> & arg0, mfem::Array<int> & arg1)->void { a->GetEssentialTrueDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetBoundaryTrueDofs(mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetBoundaryTrueDofs(mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1209:9
    t.method("GetBoundaryTrueDofs", static_cast<void (mfem::FiniteElementSpace::*)(mfem::Array<int> &, int) >(&mfem::FiniteElementSpace::GetBoundaryTrueDofs));
    t.method("GetBoundaryTrueDofs", [](mfem::FiniteElementSpace& a, mfem::Array<int> & arg0)->void { a.GetBoundaryTrueDofs(arg0); });
    t.method("GetBoundaryTrueDofs", [](mfem::FiniteElementSpace* a, mfem::Array<int> & arg0)->void { a->GetBoundaryTrueDofs(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::MarkerToList(const mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::MarkerToList(const mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1212:16
    module_.method("mfem!FiniteElementSpace!MarkerToList", static_cast<void (*)(const mfem::Array<int> &, mfem::Array<int> &) >(&mfem::FiniteElementSpace::MarkerToList));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ListToMarker(const mfem::Array<int> &, int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ListToMarker(const mfem::Array<int> &, int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1217:16
    module_.method("mfem!FiniteElementSpace!ListToMarker", static_cast<void (*)(const mfem::Array<int> &, int, mfem::Array<int> &, int) >(&mfem::FiniteElementSpace::ListToMarker));
    module_.method("mfem!FiniteElementSpace!ListToMarker", [](const mfem::Array<int> & arg0, int arg1, mfem::Array<int> & arg2)->void { mfem::FiniteElementSpace::ListToMarker(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ConvertToConformingVDofs(const mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ConvertToConformingVDofs(const mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1224:9
    t.method("ConvertToConformingVDofs", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::Array<int> &, mfem::Array<int> &) >(&mfem::FiniteElementSpace::ConvertToConformingVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ConvertFromConformingVDofs(const mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ConvertFromConformingVDofs(const mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1232:9
    t.method("ConvertFromConformingVDofs", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::Array<int> &, mfem::Array<int> &) >(&mfem::FiniteElementSpace::ConvertFromConformingVDofs));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1236:18
    t.method("D2C_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1240:18
    t.method("D2Const_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1245:18
    t.method("H2L_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1259:9
    t.method("GetTransferOperator", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)  const>(&mfem::FiniteElementSpace::GetTransferOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetTrueTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetTrueTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1276:17
    t.method("GetTrueTransferOperator", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)  const>(&mfem::FiniteElementSpace::GetTrueTransferOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::Update(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::Update(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1282:17
    t.method("Update", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::Update));
    t.method("Update", [](mfem::FiniteElementSpace& a)->void { a.Update(); });
    t.method("Update", [](mfem::FiniteElementSpace* a)->void { a->Update(); });

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetUpdateOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetUpdateOperator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1285:20
    t.method("GetUpdateOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::GetUpdateOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetUpdateOperator(mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetUpdateOperator(mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1288:9
    t.method("GetUpdateOperator", static_cast<void (mfem::FiniteElementSpace::*)(mfem::OperatorHandle &) >(&mfem::FiniteElementSpace::GetUpdateOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetUpdateOperatorOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetUpdateOperatorOwner(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1295:9
    t.method("SetUpdateOperatorOwner", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::SetUpdateOperatorOwner));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetUpdateOperatorType(mfem::Operator::Type) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetUpdateOperatorType(mfem::Operator::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1303:9
    t.method("SetUpdateOperatorType", static_cast<void (mfem::FiniteElementSpace::*)(mfem::Operator::Type) >(&mfem::FiniteElementSpace::SetUpdateOperatorType));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::UpdatesFinished() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::UpdatesFinished()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1306:17
    t.method("UpdatesFinished", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::UpdatesFinished));

    DEBUG_MSG("Adding wrapper for long mfem::FiniteElementSpace::GetSequence() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::FiniteElementSpace::GetSequence()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1310:9
    t.method("GetSequence", static_cast<long (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetSequence));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::IsDGSpace() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::IsDGSpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1313:9
    t.method("IsDGSpace", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::IsDGSpace));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetRelaxedHpConformity(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetRelaxedHpConformity(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1327:9
    t.method("SetRelaxedHpConformity", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::SetRelaxedHpConformity));
    t.method("SetRelaxedHpConformity", [](mfem::FiniteElementSpace& a)->void { a.SetRelaxedHpConformity(); });
    t.method("SetRelaxedHpConformity", [](mfem::FiniteElementSpace* a)->void { a->SetRelaxedHpConformity(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementSpace>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElementSpace(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElementSpace(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Vertex> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Vertex> : std::false_type { };
}

// Class generating the wrapper for type mfem::Vertex
// signature to use in the veto file: mfem::Vertex
struct Jlmfem_Vertex: public Wrapper {

  Jlmfem_Vertex(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Vertex (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/vertex.hpp:22:7
    jlcxx::TypeWrapper<mfem::Vertex>  t = jlModule.add_type<mfem::Vertex>("mfem!Vertex");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Vertex>>(new jlcxx::TypeWrapper<mfem::Vertex>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Vertex>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Vertex(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Vertex(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InverseElementTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InverseElementTransformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::InverseElementTransformation
// signature to use in the veto file: mfem::InverseElementTransformation
struct Jlmfem_InverseElementTransformation: public Wrapper {

  Jlmfem_InverseElementTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InverseElementTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/eltrans.hpp:185:7
    jlcxx::TypeWrapper<mfem::InverseElementTransformation>  t = jlModule.add_type<mfem::InverseElementTransformation>("mfem!InverseElementTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseElementTransformation>>(new jlcxx::TypeWrapper<mfem::InverseElementTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseElementTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InverseElementTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InverseElementTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NodeExtrudeCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NodeExtrudeCoefficient> : std::false_type { };
template<> struct SuperType<mfem::NodeExtrudeCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::NodeExtrudeCoefficient
// signature to use in the veto file: mfem::NodeExtrudeCoefficient
struct Jlmfem_NodeExtrudeCoefficient: public Wrapper {

  Jlmfem_NodeExtrudeCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NodeExtrudeCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2486:7
    jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>  t = jlModule.add_type<mfem::NodeExtrudeCoefficient>("mfem!NodeExtrudeCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>>(new jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::NodeExtrudeCoefficient(const int, const int, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2493:4
    t.constructor<const int, const int, const double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::SetLayer(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NodeExtrudeCoefficient::SetLayer(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2494:9
    t.method("SetLayer", static_cast<void (mfem::NodeExtrudeCoefficient::*)(const int) >(&mfem::NodeExtrudeCoefficient::SetLayer));

    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NodeExtrudeCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2496:17
    t.method("Eval", static_cast<void (mfem::NodeExtrudeCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::NodeExtrudeCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NodeExtrudeCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NodeExtrudeCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElementCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElementCollection> : std::false_type { };
}

// Class generating the wrapper for type mfem::FiniteElementCollection
// signature to use in the veto file: mfem::FiniteElementCollection
struct Jlmfem_FiniteElementCollection: public Wrapper {

  Jlmfem_FiniteElementCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElementCollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:26:7
    jlcxx::TypeWrapper<mfem::FiniteElementCollection>  t = jlModule.add_type<mfem::FiniteElementCollection>("mfem!FiniteElementCollection");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementCollection>>(new jlcxx::TypeWrapper<mfem::FiniteElementCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:52:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForDim(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForDim(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:59:33
    t.method("FiniteElementForDim", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::FiniteElementForDim));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:61:16
    t.method("DofForGeometry", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::StatelessDofTransformation * mfem::FiniteElementCollection::DofTransformationForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::StatelessDofTransformation * mfem::FiniteElementCollection::DofTransformationForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:67:4
    t.method("DofTransformationForGeometry", static_cast<const mfem::StatelessDofTransformation * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::DofTransformationForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::FiniteElementCollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::FiniteElementCollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:76:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::FiniteElementCollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::FiniteElementCollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:79:24
    t.method("Name", [](mfem::FiniteElementCollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::FiniteElementCollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:81:16
    t.method("GetContType", static_cast<int (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetContType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetRangeType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetRangeType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:87:8
    t.method("GetRangeType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetRangeType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivRangeType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivRangeType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:88:8
    t.method("GetDerivRangeType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivRangeType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetMapType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetMapType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:89:8
    t.method("GetMapType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetMapType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:90:8
    t.method("GetDerivType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivMapType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivMapType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:91:8
    t.method("GetDerivMapType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivMapType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetRangeDim(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetRangeDim(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:92:8
    t.method("GetRangeDim", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetRangeDim));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::HasFaceDofs(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::HasFaceDofs(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:95:8
    t.method("HasFaceDofs", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::HasFaceDofs));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::TraceFiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::TraceFiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:97:33
    t.method("TraceFiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::TraceFiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:103:37
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::New(const char *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::New(const char *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:175:36
    module_.method("mfem!FiniteElementCollection!New", static_cast<mfem::FiniteElementCollection * (*)(const char *) >(&mfem::FiniteElementCollection::New));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementCollection::SubDofOrder(mfem::Geometry::Type, int, int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementCollection::SubDofOrder(mfem::Geometry::Type, int, int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:184:9
    t.method("SubDofOrder", static_cast<void (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int, int, mfem::Array<int> &)  const>(&mfem::FiniteElementCollection::SubDofOrder));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::GetFE(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::GetFE(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:191:25
    t.method("GetFE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::GetFE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetNumDof(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetNumDof(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:203:8
    t.method("GetNumDof", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::GetNumDof));

    DEBUG_MSG("Adding wrapper for const int * mfem::FiniteElementCollection::GetDofOrdering(mfem::Geometry::Type, int, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::FiniteElementCollection::GetDofOrdering(mfem::Geometry::Type, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:215:15
    t.method("GetDofOrdering", static_cast<const int * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int, int)  const>(&mfem::FiniteElementCollection::GetDofOrdering));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:225:8
    t.method("GetOrder", static_cast<int (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetOrder));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:232:37
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElementCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElementCollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::StatelessDofTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::StatelessDofTransformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::StatelessDofTransformation
// signature to use in the veto file: mfem::StatelessDofTransformation
struct Jlmfem_StatelessDofTransformation: public Wrapper {

  Jlmfem_StatelessDofTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::StatelessDofTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/doftrans.hpp:68:7
    jlcxx::TypeWrapper<mfem::StatelessDofTransformation>  t = jlModule.add_type<mfem::StatelessDofTransformation>("mfem!StatelessDofTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::StatelessDofTransformation>>(new jlcxx::TypeWrapper<mfem::StatelessDofTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::StatelessDofTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_StatelessDofTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_StatelessDofTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::H1_FECollection
// signature to use in the veto file: mfem::H1_FECollection
struct Jlmfem_H1_FECollection: public Wrapper {

  Jlmfem_H1_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:259:7
    jlcxx::TypeWrapper<mfem::H1_FECollection>  t = jlModule.add_type<mfem::H1_FECollection>("mfem!H1_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_FECollection>>(new jlcxx::TypeWrapper<mfem::H1_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1_FECollection::H1_FECollection(const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:269:13
    t.constructor<const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::H1_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::H1_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:273:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:275:8
    t.method("DofForGeometry", static_cast<int (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:278:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::H1_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::H1_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::H1_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:281:16
    t.method("Name", [](mfem::H1_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::H1_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:283:8
    t.method("GetContType", static_cast<int (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::GetBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::GetBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:285:8
    t.method("GetBasisType", static_cast<int (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::H1_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::H1_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:287:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:290:15
    t.method("GetDofMap", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::GetDofMap));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:292:15
    t.method("GetDofMap", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::H1_FECollection::GetDofMap));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::H1_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::H1_FECollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:294:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::H1_FECollection::*)(int)  const>(&mfem::H1_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1Pos_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1Pos_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1Pos_FECollection> { typedef mfem::H1_FECollection type; };
}

// Class generating the wrapper for type mfem::H1Pos_FECollection
// signature to use in the veto file: mfem::H1Pos_FECollection
struct Jlmfem_H1Pos_FECollection: public Wrapper {

  Jlmfem_H1Pos_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1Pos_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:302:7
    jlcxx::TypeWrapper<mfem::H1Pos_FECollection>  t = jlModule.add_type<mfem::H1Pos_FECollection>("mfem!H1Pos_FECollection",
      jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Pos_FECollection>>(new jlcxx::TypeWrapper<mfem::H1Pos_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1Pos_FECollection::H1Pos_FECollection(const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:305:13
    t.constructor<const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Pos_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1Pos_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1Pos_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1Ser_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1Ser_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1Ser_FECollection> { typedef mfem::H1_FECollection type; };
}

// Class generating the wrapper for type mfem::H1Ser_FECollection
// signature to use in the veto file: mfem::H1Ser_FECollection
struct Jlmfem_H1Ser_FECollection: public Wrapper {

  Jlmfem_H1Ser_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1Ser_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:311:7
    jlcxx::TypeWrapper<mfem::H1Ser_FECollection>  t = jlModule.add_type<mfem::H1Ser_FECollection>("mfem!H1Ser_FECollection",
      jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Ser_FECollection>>(new jlcxx::TypeWrapper<mfem::H1Ser_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1Ser_FECollection::H1Ser_FECollection(const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:314:13
    t.constructor<const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Ser_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1Ser_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1Ser_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1_Trace_FECollection> { typedef mfem::H1_FECollection type; };
}

// Class generating the wrapper for type mfem::H1_Trace_FECollection
// signature to use in the veto file: mfem::H1_Trace_FECollection
struct Jlmfem_H1_Trace_FECollection: public Wrapper {

  Jlmfem_H1_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:321:7
    jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>  t = jlModule.add_type<mfem::H1_Trace_FECollection>("mfem!H1_Trace_FECollection",
      jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1_Trace_FECollection::H1_Trace_FECollection(const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:324:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::L2_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::L2_FECollection> : std::false_type { };
template<> struct SuperType<mfem::L2_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::L2_FECollection
// signature to use in the veto file: mfem::L2_FECollection
struct Jlmfem_L2_FECollection: public Wrapper {

  Jlmfem_L2_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::L2_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:329:7
    jlcxx::TypeWrapper<mfem::L2_FECollection>  t = jlModule.add_type<mfem::L2_FECollection>("mfem!L2_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::L2_FECollection>>(new jlcxx::TypeWrapper<mfem::L2_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::L2_FECollection::L2_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:344:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::L2_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::L2_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:349:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:351:8
    t.method("DofForGeometry", static_cast<int (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::L2_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::L2_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:360:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::L2_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::L2_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::L2_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::L2_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:363:16
    t.method("Name", [](mfem::L2_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::L2_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:365:8
    t.method("GetContType", static_cast<int (mfem::L2_FECollection::*)()  const>(&mfem::L2_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::L2_FECollection::TraceFiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::L2_FECollection::TraceFiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:368:4
    t.method("TraceFiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::TraceFiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::GetBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::GetBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:373:8
    t.method("GetBasisType", static_cast<int (mfem::L2_FECollection::*)()  const>(&mfem::L2_FECollection::GetBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::L2_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::L2_FECollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:375:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::L2_FECollection::*)(int)  const>(&mfem::L2_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::L2_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_L2_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_L2_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT_FECollection
// signature to use in the veto file: mfem::RT_FECollection
struct Jlmfem_RT_FECollection: public Wrapper {

  Jlmfem_RT_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:385:7
    jlcxx::TypeWrapper<mfem::RT_FECollection>  t = jlModule.add_type<mfem::RT_FECollection>("mfem!RT_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_FECollection::RT_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:413:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:418:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:420:8
    t.method("DofForGeometry", static_cast<int (mfem::RT_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:423:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:426:16
    t.method("Name", [](mfem::RT_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:428:8
    t.method("GetContType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:430:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetClosedBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetClosedBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:432:8
    t.method("GetClosedBasisType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetClosedBasisType));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetOpenBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetOpenBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:433:8
    t.method("GetOpenBasisType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetOpenBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_FECollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:435:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::RT_FECollection::*)(int)  const>(&mfem::RT_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_Trace_FECollection> { typedef mfem::RT_FECollection type; };
}

// Class generating the wrapper for type mfem::RT_Trace_FECollection
// signature to use in the veto file: mfem::RT_Trace_FECollection
struct Jlmfem_RT_Trace_FECollection: public Wrapper {

  Jlmfem_RT_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:444:7
    jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>  t = jlModule.add_type<mfem::RT_Trace_FECollection>("mfem!RT_Trace_FECollection",
      jlcxx::julia_base_type<mfem::RT_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_Trace_FECollection::RT_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:447:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DG_Interface_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DG_Interface_FECollection> : std::false_type { };
template<> struct SuperType<mfem::DG_Interface_FECollection> { typedef mfem::RT_FECollection type; };
}

// Class generating the wrapper for type mfem::DG_Interface_FECollection
// signature to use in the veto file: mfem::DG_Interface_FECollection
struct Jlmfem_DG_Interface_FECollection: public Wrapper {

  Jlmfem_DG_Interface_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DG_Interface_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:455:7
    jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>  t = jlModule.add_type<mfem::DG_Interface_FECollection>("mfem!DG_Interface_FECollection",
      jlcxx::julia_base_type<mfem::RT_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>>(new jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DG_Interface_FECollection::DG_Interface_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:458:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DG_Interface_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DG_Interface_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::ND_FECollection
// signature to use in the veto file: mfem::ND_FECollection
struct Jlmfem_ND_FECollection: public Wrapper {

  Jlmfem_ND_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:464:7
    jlcxx::TypeWrapper<mfem::ND_FECollection>  t = jlModule.add_type<mfem::ND_FECollection>("mfem!ND_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_FECollection::ND_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:476:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:481:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:483:8
    t.method("DofForGeometry", static_cast<int (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::StatelessDofTransformation * mfem::ND_FECollection::DofTransformationForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::StatelessDofTransformation * mfem::ND_FECollection::DofTransformationForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:487:4
    t.method("DofTransformationForGeometry", static_cast<const mfem::StatelessDofTransformation * (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::DofTransformationForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:489:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:492:16
    t.method("Name", [](mfem::ND_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::ND_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:494:8
    t.method("GetContType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:496:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetClosedBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetClosedBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:498:8
    t.method("GetClosedBasisType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetClosedBasisType));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetOpenBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetOpenBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:499:8
    t.method("GetOpenBasisType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetOpenBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_FECollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:501:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::ND_FECollection::*)(int)  const>(&mfem::ND_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_Trace_FECollection> { typedef mfem::ND_FECollection type; };
}

// Class generating the wrapper for type mfem::ND_Trace_FECollection
// signature to use in the veto file: mfem::ND_Trace_FECollection
struct Jlmfem_ND_Trace_FECollection: public Wrapper {

  Jlmfem_ND_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:510:7
    jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>  t = jlModule.add_type<mfem::ND_Trace_FECollection>("mfem!ND_Trace_FECollection",
      jlcxx::julia_base_type<mfem::ND_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_Trace_FECollection::ND_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:513:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R1D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R1D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R1D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::ND_R1D_FECollection
// signature to use in the veto file: mfem::ND_R1D_FECollection
struct Jlmfem_ND_R1D_FECollection: public Wrapper {

  Jlmfem_ND_R1D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R1D_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:519:7
    jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>  t = jlModule.add_type<mfem::ND_R1D_FECollection>("mfem!ND_R1D_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R1D_FECollection::ND_R1D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:527:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:532:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R1D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_R1D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R1D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:535:8
    t.method("DofForGeometry", static_cast<int (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R1D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:538:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_R1D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_R1D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_R1D_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:541:16
    t.method("Name", [](mfem::ND_R1D_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::ND_R1D_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::ND_R1D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R1D_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:543:8
    t.method("GetContType", static_cast<int (mfem::ND_R1D_FECollection::*)()  const>(&mfem::ND_R1D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_R1D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_R1D_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:545:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_R1D_FECollection::*)()  const>(&mfem::ND_R1D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R1D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R1D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R1D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R1D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R1D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT_R1D_FECollection
// signature to use in the veto file: mfem::RT_R1D_FECollection
struct Jlmfem_RT_R1D_FECollection: public Wrapper {

  Jlmfem_RT_R1D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R1D_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:551:7
    jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>  t = jlModule.add_type<mfem::RT_R1D_FECollection>("mfem!RT_R1D_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R1D_FECollection::RT_R1D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:559:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:564:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R1D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_R1D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R1D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:567:8
    t.method("DofForGeometry", static_cast<int (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R1D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:570:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_R1D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_R1D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_R1D_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:573:16
    t.method("Name", [](mfem::RT_R1D_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT_R1D_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT_R1D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R1D_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:575:8
    t.method("GetContType", static_cast<int (mfem::RT_R1D_FECollection::*)()  const>(&mfem::RT_R1D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_R1D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_R1D_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:577:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_R1D_FECollection::*)()  const>(&mfem::RT_R1D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R1D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R1D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R2D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R2D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R2D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::ND_R2D_FECollection
// signature to use in the veto file: mfem::ND_R2D_FECollection
struct Jlmfem_ND_R2D_FECollection: public Wrapper {

  Jlmfem_ND_R2D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R2D_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:583:7
    jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>  t = jlModule.add_type<mfem::ND_R2D_FECollection>("mfem!ND_R2D_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R2D_FECollection::ND_R2D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:592:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:597:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R2D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_R2D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R2D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:600:8
    t.method("DofForGeometry", static_cast<int (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R2D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:603:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_R2D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_R2D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_R2D_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:606:16
    t.method("Name", [](mfem::ND_R2D_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::ND_R2D_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::ND_R2D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R2D_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:608:8
    t.method("GetContType", static_cast<int (mfem::ND_R2D_FECollection::*)()  const>(&mfem::ND_R2D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_R2D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_R2D_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:610:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_R2D_FECollection::*)()  const>(&mfem::ND_R2D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R2D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R2D_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R2D_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R2D_Trace_FECollection> { typedef mfem::ND_R2D_FECollection type; };
}

// Class generating the wrapper for type mfem::ND_R2D_Trace_FECollection
// signature to use in the veto file: mfem::ND_R2D_Trace_FECollection
struct Jlmfem_ND_R2D_Trace_FECollection: public Wrapper {

  Jlmfem_ND_R2D_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R2D_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:618:7
    jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>  t = jlModule.add_type<mfem::ND_R2D_Trace_FECollection>("mfem!ND_R2D_Trace_FECollection",
      jlcxx::julia_base_type<mfem::ND_R2D_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R2D_Trace_FECollection::ND_R2D_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:621:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R2D_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R2D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R2D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R2D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT_R2D_FECollection
// signature to use in the veto file: mfem::RT_R2D_FECollection
struct Jlmfem_RT_R2D_FECollection: public Wrapper {

  Jlmfem_RT_R2D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R2D_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:627:7
    jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>  t = jlModule.add_type<mfem::RT_R2D_FECollection>("mfem!RT_R2D_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R2D_FECollection::RT_R2D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:646:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:651:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R2D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_R2D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R2D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:654:8
    t.method("DofForGeometry", static_cast<int (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R2D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:657:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_R2D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_R2D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_R2D_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:660:16
    t.method("Name", [](mfem::RT_R2D_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT_R2D_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT_R2D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R2D_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:662:8
    t.method("GetContType", static_cast<int (mfem::RT_R2D_FECollection::*)()  const>(&mfem::RT_R2D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_R2D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_R2D_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:664:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_R2D_FECollection::*)()  const>(&mfem::RT_R2D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R2D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R2D_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R2D_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R2D_Trace_FECollection> { typedef mfem::RT_R2D_FECollection type; };
}

// Class generating the wrapper for type mfem::RT_R2D_Trace_FECollection
// signature to use in the veto file: mfem::RT_R2D_Trace_FECollection
struct Jlmfem_RT_R2D_Trace_FECollection: public Wrapper {

  Jlmfem_RT_R2D_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R2D_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:672:7
    jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>  t = jlModule.add_type<mfem::RT_R2D_Trace_FECollection>("mfem!RT_R2D_Trace_FECollection",
      jlcxx::julia_base_type<mfem::RT_R2D_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R2D_Trace_FECollection::RT_R2D_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:675:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R2D_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSFECollection> : std::false_type { };
template<> struct SuperType<mfem::NURBSFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::NURBSFECollection
// signature to use in the veto file: mfem::NURBSFECollection
struct Jlmfem_NURBSFECollection: public Wrapper {

  Jlmfem_NURBSFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:681:7
    jlcxx::TypeWrapper<mfem::NURBSFECollection>  t = jlModule.add_type<mfem::NURBSFECollection>("mfem!NURBSFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSFECollection>>(new jlcxx::TypeWrapper<mfem::NURBSFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::NURBSFECollection(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:702:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::Reset() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSFECollection::Reset()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:704:9
    t.method("Reset", static_cast<void (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::Reset));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::GetOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:714:8
    t.method("GetOrder", static_cast<int (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetOrder));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::SetOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSFECollection::SetOrder(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:718:9
    t.method("SetOrder", static_cast<void (mfem::NURBSFECollection::*)(int)  const>(&mfem::NURBSFECollection::SetOrder));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::NURBSFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::NURBSFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:721:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::NURBSFECollection::*)(mfem::Geometry::Type)  const>(&mfem::NURBSFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:723:8
    t.method("DofForGeometry", static_cast<int (mfem::NURBSFECollection::*)(mfem::Geometry::Type)  const>(&mfem::NURBSFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::NURBSFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::NURBSFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:725:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::NURBSFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::NURBSFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::NURBSFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::NURBSFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:728:16
    t.method("Name", [](mfem::NURBSFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::NURBSFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:730:8
    t.method("GetContType", static_cast<int (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::NURBSFECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::NURBSFECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:732:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::LinearFECollection
// signature to use in the veto file: mfem::LinearFECollection
struct Jlmfem_LinearFECollection: public Wrapper {

  Jlmfem_LinearFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:738:7
    jlcxx::TypeWrapper<mfem::LinearFECollection>  t = jlModule.add_type<mfem::LinearFECollection>("mfem!LinearFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFECollection>>(new jlcxx::TypeWrapper<mfem::LinearFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:753:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:755:8
    t.method("DofForGeometry", static_cast<int (mfem::LinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:757:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:760:16
    t.method("Name", [](mfem::LinearFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::LinearFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::LinearFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:762:8
    t.method("GetContType", static_cast<int (mfem::LinearFECollection::*)()  const>(&mfem::LinearFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticFECollection
// signature to use in the veto file: mfem::QuadraticFECollection
struct Jlmfem_QuadraticFECollection: public Wrapper {

  Jlmfem_QuadraticFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:766:7
    jlcxx::TypeWrapper<mfem::QuadraticFECollection>  t = jlModule.add_type<mfem::QuadraticFECollection>("mfem!QuadraticFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:782:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:784:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:786:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:789:16
    t.method("Name", [](mfem::QuadraticFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:791:8
    t.method("GetContType", static_cast<int (mfem::QuadraticFECollection::*)()  const>(&mfem::QuadraticFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticPosFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticPosFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticPosFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticPosFECollection
// signature to use in the veto file: mfem::QuadraticPosFECollection
struct Jlmfem_QuadraticPosFECollection: public Wrapper {

  Jlmfem_QuadraticPosFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticPosFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:795:7
    jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>  t = jlModule.add_type<mfem::QuadraticPosFECollection>("mfem!QuadraticPosFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticPosFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticPosFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:805:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:807:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticPosFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticPosFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:809:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticPosFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticPosFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticPosFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:812:16
    t.method("Name", [](mfem::QuadraticPosFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticPosFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:814:8
    t.method("GetContType", static_cast<int (mfem::QuadraticPosFECollection::*)()  const>(&mfem::QuadraticPosFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticPosFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CubicFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CubicFECollection> : std::false_type { };
template<> struct SuperType<mfem::CubicFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::CubicFECollection
// signature to use in the veto file: mfem::CubicFECollection
struct Jlmfem_CubicFECollection: public Wrapper {

  Jlmfem_CubicFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CubicFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:818:7
    jlcxx::TypeWrapper<mfem::CubicFECollection>  t = jlModule.add_type<mfem::CubicFECollection>("mfem!CubicFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicFECollection>>(new jlcxx::TypeWrapper<mfem::CubicFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CubicFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CubicFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:836:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CubicFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CubicFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:838:8
    t.method("DofForGeometry", static_cast<int (mfem::CubicFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CubicFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CubicFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:840:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CubicFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CubicFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CubicFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CubicFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:843:16
    t.method("Name", [](mfem::CubicFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::CubicFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::CubicFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:845:8
    t.method("GetContType", static_cast<int (mfem::CubicFECollection::*)()  const>(&mfem::CubicFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CubicFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CubicFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CrouzeixRaviartFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CrouzeixRaviartFECollection> : std::false_type { };
template<> struct SuperType<mfem::CrouzeixRaviartFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::CrouzeixRaviartFECollection
// signature to use in the veto file: mfem::CrouzeixRaviartFECollection
struct Jlmfem_CrouzeixRaviartFECollection: public Wrapper {

  Jlmfem_CrouzeixRaviartFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CrouzeixRaviartFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:849:7
    jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>  t = jlModule.add_type<mfem::CrouzeixRaviartFECollection>("mfem!CrouzeixRaviartFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>>(new jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:859:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CrouzeixRaviartFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CrouzeixRaviartFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:861:8
    t.method("DofForGeometry", static_cast<int (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CrouzeixRaviartFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CrouzeixRaviartFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CrouzeixRaviartFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:863:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CrouzeixRaviartFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CrouzeixRaviartFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CrouzeixRaviartFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:866:16
    t.method("Name", [](mfem::CrouzeixRaviartFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::CrouzeixRaviartFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::CrouzeixRaviartFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CrouzeixRaviartFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:868:8
    t.method("GetContType", static_cast<int (mfem::CrouzeixRaviartFECollection::*)()  const>(&mfem::CrouzeixRaviartFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CrouzeixRaviartFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CrouzeixRaviartFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearNonConf3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearNonConf3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearNonConf3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::LinearNonConf3DFECollection
// signature to use in the veto file: mfem::LinearNonConf3DFECollection
struct Jlmfem_LinearNonConf3DFECollection: public Wrapper {

  Jlmfem_LinearNonConf3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearNonConf3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:872:7
    jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>  t = jlModule.add_type<mfem::LinearNonConf3DFECollection>("mfem!LinearNonConf3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearNonConf3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearNonConf3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:884:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearNonConf3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearNonConf3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearNonConf3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:886:8
    t.method("DofForGeometry", static_cast<int (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearNonConf3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearNonConf3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearNonConf3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:888:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearNonConf3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearNonConf3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearNonConf3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:891:16
    t.method("Name", [](mfem::LinearNonConf3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::LinearNonConf3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::LinearNonConf3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearNonConf3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:893:8
    t.method("GetContType", static_cast<int (mfem::LinearNonConf3DFECollection::*)()  const>(&mfem::LinearNonConf3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearNonConf3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearNonConf3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT0_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT0_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT0_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT0_2DFECollection
// signature to use in the veto file: mfem::RT0_2DFECollection
struct Jlmfem_RT0_2DFECollection: public Wrapper {

  Jlmfem_RT0_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT0_2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:898:7
    jlcxx::TypeWrapper<mfem::RT0_2DFECollection>  t = jlModule.add_type<mfem::RT0_2DFECollection>("mfem!RT0_2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT0_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT0_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT0_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:908:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT0_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:910:8
    t.method("DofForGeometry", static_cast<int (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT0_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT0_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:912:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT0_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT0_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT0_2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:915:16
    t.method("Name", [](mfem::RT0_2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT0_2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT0_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:917:8
    t.method("GetContType", static_cast<int (mfem::RT0_2DFECollection::*)()  const>(&mfem::RT0_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT0_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT0_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT1_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT1_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT1_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT1_2DFECollection
// signature to use in the veto file: mfem::RT1_2DFECollection
struct Jlmfem_RT1_2DFECollection: public Wrapper {

  Jlmfem_RT1_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT1_2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:922:7
    jlcxx::TypeWrapper<mfem::RT1_2DFECollection>  t = jlModule.add_type<mfem::RT1_2DFECollection>("mfem!RT1_2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT1_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT1_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT1_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:932:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT1_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:934:8
    t.method("DofForGeometry", static_cast<int (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT1_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT1_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:936:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT1_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT1_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT1_2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:939:16
    t.method("Name", [](mfem::RT1_2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT1_2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT1_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:941:8
    t.method("GetContType", static_cast<int (mfem::RT1_2DFECollection::*)()  const>(&mfem::RT1_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT1_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT1_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT2_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT2_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT2_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT2_2DFECollection
// signature to use in the veto file: mfem::RT2_2DFECollection
struct Jlmfem_RT2_2DFECollection: public Wrapper {

  Jlmfem_RT2_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT2_2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:946:7
    jlcxx::TypeWrapper<mfem::RT2_2DFECollection>  t = jlModule.add_type<mfem::RT2_2DFECollection>("mfem!RT2_2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT2_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT2_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT2_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT2_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:956:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT2_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT2_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT2_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:958:8
    t.method("DofForGeometry", static_cast<int (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT2_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT2_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT2_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:960:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT2_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT2_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT2_2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:963:16
    t.method("Name", [](mfem::RT2_2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT2_2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT2_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT2_2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:965:8
    t.method("GetContType", static_cast<int (mfem::RT2_2DFECollection::*)()  const>(&mfem::RT2_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT2_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT2_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT2_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Const2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Const2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::Const2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::Const2DFECollection
// signature to use in the veto file: mfem::Const2DFECollection
struct Jlmfem_Const2DFECollection: public Wrapper {

  Jlmfem_Const2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Const2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:971:7
    jlcxx::TypeWrapper<mfem::Const2DFECollection>  t = jlModule.add_type<mfem::Const2DFECollection>("mfem!Const2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Const2DFECollection>>(new jlcxx::TypeWrapper<mfem::Const2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Const2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Const2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:980:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Const2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Const2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:982:8
    t.method("DofForGeometry", static_cast<int (mfem::Const2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Const2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Const2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:984:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Const2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Const2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Const2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Const2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:987:16
    t.method("Name", [](mfem::Const2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::Const2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::Const2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:989:8
    t.method("GetContType", static_cast<int (mfem::Const2DFECollection::*)()  const>(&mfem::Const2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Const2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Const2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Const2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::LinearDiscont2DFECollection
// signature to use in the veto file: mfem::LinearDiscont2DFECollection
struct Jlmfem_LinearDiscont2DFECollection: public Wrapper {

  Jlmfem_LinearDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:995:7
    jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>  t = jlModule.add_type<mfem::LinearDiscont2DFECollection>("mfem!LinearDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1005:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1007:8
    t.method("DofForGeometry", static_cast<int (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1009:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1012:16
    t.method("Name", [](mfem::LinearDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::LinearDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1014:8
    t.method("GetContType", static_cast<int (mfem::LinearDiscont2DFECollection::*)()  const>(&mfem::LinearDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GaussLinearDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GaussLinearDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::GaussLinearDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::GaussLinearDiscont2DFECollection
// signature to use in the veto file: mfem::GaussLinearDiscont2DFECollection
struct Jlmfem_GaussLinearDiscont2DFECollection: public Wrapper {

  Jlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GaussLinearDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1018:7
    jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>  t = jlModule.add_type<mfem::GaussLinearDiscont2DFECollection>("mfem!GaussLinearDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1029:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::GaussLinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussLinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1031:8
    t.method("DofForGeometry", static_cast<int (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussLinearDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1033:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::GaussLinearDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::GaussLinearDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1036:16
    t.method("Name", [](mfem::GaussLinearDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::GaussLinearDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::GaussLinearDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussLinearDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1038:8
    t.method("GetContType", static_cast<int (mfem::GaussLinearDiscont2DFECollection::*)()  const>(&mfem::GaussLinearDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GaussLinearDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::P1OnQuadFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::P1OnQuadFECollection> : std::false_type { };
template<> struct SuperType<mfem::P1OnQuadFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::P1OnQuadFECollection
// signature to use in the veto file: mfem::P1OnQuadFECollection
struct Jlmfem_P1OnQuadFECollection: public Wrapper {

  Jlmfem_P1OnQuadFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::P1OnQuadFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1042:7
    jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>  t = jlModule.add_type<mfem::P1OnQuadFECollection>("mfem!P1OnQuadFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>>(new jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::P1OnQuadFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::P1OnQuadFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1050:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type)  const>(&mfem::P1OnQuadFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::P1OnQuadFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::P1OnQuadFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1052:8
    t.method("DofForGeometry", static_cast<int (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type)  const>(&mfem::P1OnQuadFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::P1OnQuadFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::P1OnQuadFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1054:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::P1OnQuadFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::P1OnQuadFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::P1OnQuadFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1057:16
    t.method("Name", [](mfem::P1OnQuadFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::P1OnQuadFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::P1OnQuadFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::P1OnQuadFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1059:8
    t.method("GetContType", static_cast<int (mfem::P1OnQuadFECollection::*)()  const>(&mfem::P1OnQuadFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_P1OnQuadFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_P1OnQuadFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticDiscont2DFECollection
// signature to use in the veto file: mfem::QuadraticDiscont2DFECollection
struct Jlmfem_QuadraticDiscont2DFECollection: public Wrapper {

  Jlmfem_QuadraticDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1065:7
    jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>  t = jlModule.add_type<mfem::QuadraticDiscont2DFECollection>("mfem!QuadraticDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1075:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1077:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1079:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1082:16
    t.method("Name", [](mfem::QuadraticDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1084:8
    t.method("GetContType", static_cast<int (mfem::QuadraticDiscont2DFECollection::*)()  const>(&mfem::QuadraticDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticPosDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticPosDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticPosDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticPosDiscont2DFECollection
// signature to use in the veto file: mfem::QuadraticPosDiscont2DFECollection
struct Jlmfem_QuadraticPosDiscont2DFECollection: public Wrapper {

  Jlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticPosDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1088:7
    jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>  t = jlModule.add_type<mfem::QuadraticPosDiscont2DFECollection>("mfem!QuadraticPosDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1097:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1099:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1101:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticPosDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticPosDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1105:16
    t.method("Name", [](mfem::QuadraticPosDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticPosDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1107:8
    t.method("GetContType", static_cast<int (mfem::QuadraticPosDiscont2DFECollection::*)()  const>(&mfem::QuadraticPosDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticPosDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GaussQuadraticDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GaussQuadraticDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::GaussQuadraticDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::GaussQuadraticDiscont2DFECollection
// signature to use in the veto file: mfem::GaussQuadraticDiscont2DFECollection
struct Jlmfem_GaussQuadraticDiscont2DFECollection: public Wrapper {

  Jlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GaussQuadraticDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1111:7
    jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>  t = jlModule.add_type<mfem::GaussQuadraticDiscont2DFECollection>("mfem!GaussQuadraticDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1122:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1124:8
    t.method("DofForGeometry", static_cast<int (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1126:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::GaussQuadraticDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::GaussQuadraticDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1129:16
    t.method("Name", [](mfem::GaussQuadraticDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::GaussQuadraticDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::GaussQuadraticDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussQuadraticDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1131:8
    t.method("GetContType", static_cast<int (mfem::GaussQuadraticDiscont2DFECollection::*)()  const>(&mfem::GaussQuadraticDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GaussQuadraticDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CubicDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CubicDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::CubicDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::CubicDiscont2DFECollection
// signature to use in the veto file: mfem::CubicDiscont2DFECollection
struct Jlmfem_CubicDiscont2DFECollection: public Wrapper {

  Jlmfem_CubicDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CubicDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1137:7
    jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>  t = jlModule.add_type<mfem::CubicDiscont2DFECollection>("mfem!CubicDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CubicDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CubicDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1147:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CubicDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1149:8
    t.method("DofForGeometry", static_cast<int (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CubicDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CubicDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1151:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CubicDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CubicDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CubicDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1154:16
    t.method("Name", [](mfem::CubicDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::CubicDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::CubicDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1156:8
    t.method("GetContType", static_cast<int (mfem::CubicDiscont2DFECollection::*)()  const>(&mfem::CubicDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CubicDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CubicDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Const3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Const3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::Const3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::Const3DFECollection
// signature to use in the veto file: mfem::Const3DFECollection
struct Jlmfem_Const3DFECollection: public Wrapper {

  Jlmfem_Const3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Const3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1162:7
    jlcxx::TypeWrapper<mfem::Const3DFECollection>  t = jlModule.add_type<mfem::Const3DFECollection>("mfem!Const3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Const3DFECollection>>(new jlcxx::TypeWrapper<mfem::Const3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Const3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Const3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1174:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Const3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Const3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1176:8
    t.method("DofForGeometry", static_cast<int (mfem::Const3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Const3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Const3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1178:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Const3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Const3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Const3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Const3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1181:16
    t.method("Name", [](mfem::Const3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::Const3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::Const3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1183:8
    t.method("GetContType", static_cast<int (mfem::Const3DFECollection::*)()  const>(&mfem::Const3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Const3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Const3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Const3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearDiscont3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearDiscont3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearDiscont3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::LinearDiscont3DFECollection
// signature to use in the veto file: mfem::LinearDiscont3DFECollection
struct Jlmfem_LinearDiscont3DFECollection: public Wrapper {

  Jlmfem_LinearDiscont3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearDiscont3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1189:7
    jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>  t = jlModule.add_type<mfem::LinearDiscont3DFECollection>("mfem!LinearDiscont3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1201:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1203:8
    t.method("DofForGeometry", static_cast<int (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1205:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearDiscont3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearDiscont3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearDiscont3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1208:16
    t.method("Name", [](mfem::LinearDiscont3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::LinearDiscont3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1210:8
    t.method("GetContType", static_cast<int (mfem::LinearDiscont3DFECollection::*)()  const>(&mfem::LinearDiscont3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearDiscont3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticDiscont3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticDiscont3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticDiscont3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticDiscont3DFECollection
// signature to use in the veto file: mfem::QuadraticDiscont3DFECollection
struct Jlmfem_QuadraticDiscont3DFECollection: public Wrapper {

  Jlmfem_QuadraticDiscont3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticDiscont3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1216:7
    jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>  t = jlModule.add_type<mfem::QuadraticDiscont3DFECollection>("mfem!QuadraticDiscont3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1227:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1229:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1231:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticDiscont3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticDiscont3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1234:16
    t.method("Name", [](mfem::QuadraticDiscont3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticDiscont3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1236:8
    t.method("GetContType", static_cast<int (mfem::QuadraticDiscont3DFECollection::*)()  const>(&mfem::QuadraticDiscont3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticDiscont3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RefinedLinearFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RefinedLinearFECollection> : std::false_type { };
template<> struct SuperType<mfem::RefinedLinearFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RefinedLinearFECollection
// signature to use in the veto file: mfem::RefinedLinearFECollection
struct Jlmfem_RefinedLinearFECollection: public Wrapper {

  Jlmfem_RefinedLinearFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RefinedLinearFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1240:7
    jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>  t = jlModule.add_type<mfem::RefinedLinearFECollection>("mfem!RefinedLinearFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>>(new jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RefinedLinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RefinedLinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1254:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RefinedLinearFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RefinedLinearFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RefinedLinearFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1256:8
    t.method("DofForGeometry", static_cast<int (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RefinedLinearFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RefinedLinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RefinedLinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1258:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RefinedLinearFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RefinedLinearFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RefinedLinearFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1261:16
    t.method("Name", [](mfem::RefinedLinearFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RefinedLinearFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RefinedLinearFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RefinedLinearFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1263:8
    t.method("GetContType", static_cast<int (mfem::RefinedLinearFECollection::*)()  const>(&mfem::RefinedLinearFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RefinedLinearFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RefinedLinearFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND1_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND1_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::ND1_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::ND1_3DFECollection
// signature to use in the veto file: mfem::ND1_3DFECollection
struct Jlmfem_ND1_3DFECollection: public Wrapper {

  Jlmfem_ND1_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND1_3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1269:7
    jlcxx::TypeWrapper<mfem::ND1_3DFECollection>  t = jlModule.add_type<mfem::ND1_3DFECollection>("mfem!ND1_3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND1_3DFECollection>>(new jlcxx::TypeWrapper<mfem::ND1_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1281:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND1_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND1_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND1_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1283:8
    t.method("DofForGeometry", static_cast<int (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND1_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1285:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND1_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND1_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND1_3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1288:16
    t.method("Name", [](mfem::ND1_3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::ND1_3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::ND1_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND1_3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1290:8
    t.method("GetContType", static_cast<int (mfem::ND1_3DFECollection::*)()  const>(&mfem::ND1_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND1_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND1_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND1_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT0_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT0_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT0_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT0_3DFECollection
// signature to use in the veto file: mfem::RT0_3DFECollection
struct Jlmfem_RT0_3DFECollection: public Wrapper {

  Jlmfem_RT0_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT0_3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1295:7
    jlcxx::TypeWrapper<mfem::RT0_3DFECollection>  t = jlModule.add_type<mfem::RT0_3DFECollection>("mfem!RT0_3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_3DFECollection>>(new jlcxx::TypeWrapper<mfem::RT0_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT0_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT0_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1308:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT0_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1310:8
    t.method("DofForGeometry", static_cast<int (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT0_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT0_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1312:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT0_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT0_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT0_3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1315:16
    t.method("Name", [](mfem::RT0_3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT0_3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT0_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1317:8
    t.method("GetContType", static_cast<int (mfem::RT0_3DFECollection::*)()  const>(&mfem::RT0_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT0_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT0_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT1_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT1_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT1_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT1_3DFECollection
// signature to use in the veto file: mfem::RT1_3DFECollection
struct Jlmfem_RT1_3DFECollection: public Wrapper {

  Jlmfem_RT1_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT1_3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1322:7
    jlcxx::TypeWrapper<mfem::RT1_3DFECollection>  t = jlModule.add_type<mfem::RT1_3DFECollection>("mfem!RT1_3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_3DFECollection>>(new jlcxx::TypeWrapper<mfem::RT1_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1332:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT1_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1334:8
    t.method("DofForGeometry", static_cast<int (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1336:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT1_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT1_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT1_3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1339:16
    t.method("Name", [](mfem::RT1_3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT1_3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT1_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1341:8
    t.method("GetContType", static_cast<int (mfem::RT1_3DFECollection::*)()  const>(&mfem::RT1_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT1_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT1_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Local_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Local_FECollection> : std::false_type { };
template<> struct SuperType<mfem::Local_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::Local_FECollection
// signature to use in the veto file: mfem::Local_FECollection
struct Jlmfem_Local_FECollection: public Wrapper {

  Jlmfem_Local_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Local_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1345:7
    jlcxx::TypeWrapper<mfem::Local_FECollection>  t = jlModule.add_type<mfem::Local_FECollection>("mfem!Local_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Local_FECollection>>(new jlcxx::TypeWrapper<mfem::Local_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::Local_FECollection::Local_FECollection(const char *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1353:4
    t.constructor<const char *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Local_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Local_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1356:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Local_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::Local_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Local_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Local_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1359:8
    t.method("DofForGeometry", static_cast<int (mfem::Local_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::Local_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Local_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Local_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1362:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Local_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Local_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Local_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Local_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1366:16
    t.method("Name", [](mfem::Local_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::Local_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::Local_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Local_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1368:8
    t.method("GetContType", static_cast<int (mfem::Local_FECollection::*)()  const>(&mfem::Local_FECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Local_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Local_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Local_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Ordering> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Ordering> : std::false_type { };
}

// Class generating the wrapper for type mfem::Ordering
// signature to use in the veto file: mfem::Ordering
struct Jlmfem_Ordering: public Wrapper {

  Jlmfem_Ordering(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Ordering (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:29:7
    jlcxx::TypeWrapper<mfem::Ordering>  t = jlModule.add_type<mfem::Ordering>("mfem!Ordering");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Ordering>>(new jlcxx::TypeWrapper<mfem::Ordering>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Ordering>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Ordering(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Ordering(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ElementRestrictionOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ElementRestrictionOperator> : std::false_type { };
template<> struct SuperType<mfem::ElementRestrictionOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::ElementRestrictionOperator
// signature to use in the veto file: mfem::ElementRestrictionOperator
struct Jlmfem_ElementRestrictionOperator: public Wrapper {

  Jlmfem_ElementRestrictionOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ElementRestrictionOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/restriction.hpp:25:7
    jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>  t = jlModule.add_type<mfem::ElementRestrictionOperator>("mfem!ElementRestrictionOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>>(new jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ElementRestrictionOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ElementRestrictionOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceRestriction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceRestriction> : std::false_type { };
template<> struct SuperType<mfem::FaceRestriction> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::FaceRestriction
// signature to use in the veto file: mfem::FaceRestriction
struct Jlmfem_FaceRestriction: public Wrapper {

  Jlmfem_FaceRestriction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceRestriction (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/restriction.hpp:159:7
    jlcxx::TypeWrapper<mfem::FaceRestriction>  t = jlModule.add_type<mfem::FaceRestriction>("mfem!FaceRestriction",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceRestriction>>(new jlcxx::TypeWrapper<mfem::FaceRestriction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceRestriction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceRestriction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceRestriction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureInterpolator> : std::false_type { };
}

// Class generating the wrapper for type mfem::QuadratureInterpolator
// signature to use in the veto file: mfem::QuadratureInterpolator
struct Jlmfem_QuadratureInterpolator: public Wrapper {

  Jlmfem_QuadratureInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/quadinterpolator.hpp:29:7
    jlcxx::TypeWrapper<mfem::QuadratureInterpolator>  t = jlModule.add_type<mfem::QuadratureInterpolator>("mfem!QuadratureInterpolator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureInterpolator>>(new jlcxx::TypeWrapper<mfem::QuadratureInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureSpace> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureSpace> : std::false_type { };
template<> struct SuperType<mfem::QuadratureSpace> { typedef mfem::QuadratureSpaceBase type; };
}

// Class generating the wrapper for type mfem::QuadratureSpace
// signature to use in the veto file: mfem::QuadratureSpace
struct Jlmfem_QuadratureSpace: public Wrapper {

  Jlmfem_QuadratureSpace(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureSpace (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/qspace.hpp:102:7
    jlcxx::TypeWrapper<mfem::QuadratureSpace>  t = jlModule.add_type<mfem::QuadratureSpace>("mfem!QuadratureSpace",
      jlcxx::julia_base_type<mfem::QuadratureSpaceBase>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpace>>(new jlcxx::TypeWrapper<mfem::QuadratureSpace>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpace>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpace(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureSpace(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceQuadratureInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceQuadratureInterpolator> : std::false_type { };
}

// Class generating the wrapper for type mfem::FaceQuadratureInterpolator
// signature to use in the veto file: mfem::FaceQuadratureInterpolator
struct Jlmfem_FaceQuadratureInterpolator: public Wrapper {

  Jlmfem_FaceQuadratureInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceQuadratureInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/quadinterpolator_face.hpp:25:7
    jlcxx::TypeWrapper<mfem::FaceQuadratureInterpolator>  t = jlModule.add_type<mfem::FaceQuadratureInterpolator>("mfem!FaceQuadratureInterpolator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceQuadratureInterpolator>>(new jlcxx::TypeWrapper<mfem::FaceQuadratureInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceQuadratureInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceQuadratureInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceQuadratureInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DofTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DofTransformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::DofTransformation
// signature to use in the veto file: mfem::DofTransformation
struct Jlmfem_DofTransformation: public Wrapper {

  Jlmfem_DofTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DofTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/doftrans.hpp:141:7
    jlcxx::TypeWrapper<mfem::DofTransformation>  t = jlModule.add_type<mfem::DofTransformation>("mfem!DofTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DofTransformation>>(new jlcxx::TypeWrapper<mfem::DofTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DofTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DofTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DofTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NonlinearFormIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NonlinearFormIntegrator> : std::false_type { };
}

// Class generating the wrapper for type mfem::NonlinearFormIntegrator
// signature to use in the veto file: mfem::NonlinearFormIntegrator
struct Jlmfem_NonlinearFormIntegrator: public Wrapper {

  Jlmfem_NonlinearFormIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NonlinearFormIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:27:7
    jlcxx::TypeWrapper<mfem::NonlinearFormIntegrator>  t = jlModule.add_type<mfem::NonlinearFormIntegrator>("mfem!NonlinearFormIntegrator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NonlinearFormIntegrator>>(new jlcxx::TypeWrapper<mfem::NonlinearFormIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::SetIntRule(const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::SetIntRule(const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:57:17
    t.method("SetIntRule", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::IntegrationRule *) >(&mfem::NonlinearFormIntegrator::SetIntRule));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::SetIntegrationMode(mfem::NonlinearFormIntegrator::Mode) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::SetIntegrationMode(mfem::NonlinearFormIntegrator::Mode)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:59:9
    t.method("SetIntegrationMode", static_cast<void (mfem::NonlinearFormIntegrator::*)(mfem::NonlinearFormIntegrator::Mode) >(&mfem::NonlinearFormIntegrator::SetIntegrationMode));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::SetNURBSPatchIntRule(mfem::NURBSMeshRules *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::SetNURBSPatchIntRule(mfem::NURBSMeshRules *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:62:9
    t.method("SetNURBSPatchIntRule", static_cast<void (mfem::NonlinearFormIntegrator::*)(mfem::NURBSMeshRules *) >(&mfem::NonlinearFormIntegrator::SetNURBSPatchIntRule));

    DEBUG_MSG("Adding wrapper for bool mfem::NonlinearFormIntegrator::HasNURBSPatchIntRule() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::NonlinearFormIntegrator::HasNURBSPatchIntRule()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:63:9
    t.method("HasNURBSPatchIntRule", static_cast<bool (mfem::NonlinearFormIntegrator::*)()  const>(&mfem::NonlinearFormIntegrator::HasNURBSPatchIntRule));

    DEBUG_MSG("Adding wrapper for bool mfem::NonlinearFormIntegrator::Patchwise() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::NonlinearFormIntegrator::Patchwise()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:65:9
    t.method("Patchwise", static_cast<bool (mfem::NonlinearFormIntegrator::*)()  const>(&mfem::NonlinearFormIntegrator::Patchwise));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::SetIntegrationRule(const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::SetIntegrationRule(const mfem::IntegrationRule &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:68:9
    t.method("SetIntegrationRule", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::IntegrationRule &) >(&mfem::NonlinearFormIntegrator::SetIntegrationRule));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::SetPAMemoryType(mfem::MemoryType) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::SetPAMemoryType(mfem::MemoryType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:72:9
    t.method("SetPAMemoryType", static_cast<void (mfem::NonlinearFormIntegrator::*)(mfem::MemoryType) >(&mfem::NonlinearFormIntegrator::SetPAMemoryType));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule * mfem::NonlinearFormIntegrator::GetIntegrationRule() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule * mfem::NonlinearFormIntegrator::GetIntegrationRule()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:75:27
    t.method("GetIntegrationRule", static_cast<const mfem::IntegrationRule * (mfem::NonlinearFormIntegrator::*)()  const>(&mfem::NonlinearFormIntegrator::GetIntegrationRule));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:78:17
    t.method("AssembleElementVector", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) >(&mfem::NonlinearFormIntegrator::AssembleElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssembleFaceVector(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssembleFaceVector(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:84:17
    t.method("AssembleFaceVector", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::Vector &) >(&mfem::NonlinearFormIntegrator::AssembleFaceVector));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:90:17
    t.method("AssembleElementGrad", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) >(&mfem::NonlinearFormIntegrator::AssembleElementGrad));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssembleFaceGrad(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssembleFaceGrad(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:96:17
    t.method("AssembleFaceGrad", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::DenseMatrix &) >(&mfem::NonlinearFormIntegrator::AssembleFaceGrad));

    DEBUG_MSG("Adding wrapper for double mfem::NonlinearFormIntegrator::GetElementEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::NonlinearFormIntegrator::GetElementEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:102:19
    t.method("GetElementEnergy", static_cast<double (mfem::NonlinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &) >(&mfem::NonlinearFormIntegrator::GetElementEnergy));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:109:17
    t.method("AssemblePA", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::NonlinearFormIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:114:17
    t.method("AssemblePA", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) >(&mfem::NonlinearFormIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssembleGradPA(const mfem::Vector &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssembleGradPA(const mfem::Vector &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:122:17
    t.method("AssembleGradPA", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::Vector &, const mfem::FiniteElementSpace &) >(&mfem::NonlinearFormIntegrator::AssembleGradPA));

    DEBUG_MSG("Adding wrapper for double mfem::NonlinearFormIntegrator::GetLocalStateEnergyPA(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::NonlinearFormIntegrator::GetLocalStateEnergyPA(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:127:19
    t.method("GetLocalStateEnergyPA", static_cast<double (mfem::NonlinearFormIntegrator::*)(const mfem::Vector &)  const>(&mfem::NonlinearFormIntegrator::GetLocalStateEnergyPA));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:136:17
    t.method("AddMultPA", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::NonlinearFormIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AddMultGradPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AddMultGradPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:144:17
    t.method("AddMultGradPA", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::NonlinearFormIntegrator::AddMultGradPA));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssembleGradDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssembleGradDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:151:17
    t.method("AssembleGradDiagonalPA", static_cast<void (mfem::NonlinearFormIntegrator::*)(mfem::Vector &)  const>(&mfem::NonlinearFormIntegrator::AssembleGradDiagonalPA));

    DEBUG_MSG("Adding wrapper for bool mfem::NonlinearFormIntegrator::SupportsCeed() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::NonlinearFormIntegrator::SupportsCeed()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:154:17
    t.method("SupportsCeed", static_cast<bool (mfem::NonlinearFormIntegrator::*)()  const>(&mfem::NonlinearFormIntegrator::SupportsCeed));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:157:17
    t.method("AssembleMF", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::NonlinearFormIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearFormIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearFormIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:165:17
    t.method("AddMultMF", static_cast<void (mfem::NonlinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::NonlinearFormIntegrator::AddMultMF));

    DEBUG_MSG("Adding wrapper for mfem::ceed::Operator & mfem::NonlinearFormIntegrator::GetCeedOp() (" __HERE__ ")");
    // signature to use in the veto list: mfem::ceed::Operator & mfem::NonlinearFormIntegrator::GetCeedOp()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:167:20
    t.method("GetCeedOp", static_cast<mfem::ceed::Operator & (mfem::NonlinearFormIntegrator::*)() >(&mfem::NonlinearFormIntegrator::GetCeedOp));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NonlinearFormIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NonlinearFormIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NonlinearFormIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ceed::Operator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ceed::Operator> : std::false_type { };
template<> struct SuperType<mfem::ceed::Operator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::ceed::Operator
// signature to use in the veto file: mfem::ceed::Operator
struct Jlmfem_ceed_Operator: public Wrapper {

  Jlmfem_ceed_Operator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ceed::Operator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/solvers/../interface/operator.hpp:25:7
    jlcxx::TypeWrapper<mfem::ceed::Operator>  t = jlModule.add_type<mfem::ceed::Operator>("mfem!ceed!Operator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ceed::Operator>>(new jlcxx::TypeWrapper<mfem::ceed::Operator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ceed::Operator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ceed_Operator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ceed_Operator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BlockNonlinearFormIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BlockNonlinearFormIntegrator> : std::false_type { };
}

// Class generating the wrapper for type mfem::BlockNonlinearFormIntegrator
// signature to use in the veto file: mfem::BlockNonlinearFormIntegrator
struct Jlmfem_BlockNonlinearFormIntegrator: public Wrapper {

  Jlmfem_BlockNonlinearFormIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BlockNonlinearFormIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:178:7
    jlcxx::TypeWrapper<mfem::BlockNonlinearFormIntegrator>  t = jlModule.add_type<mfem::BlockNonlinearFormIntegrator>("mfem!BlockNonlinearFormIntegrator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BlockNonlinearFormIntegrator>>(new jlcxx::TypeWrapper<mfem::BlockNonlinearFormIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BlockNonlinearFormIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BlockNonlinearFormIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BlockNonlinearFormIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::HyperelasticModel> : std::false_type { };
  template<> struct DefaultConstructible<mfem::HyperelasticModel> : std::false_type { };
}

// Class generating the wrapper for type mfem::HyperelasticModel
// signature to use in the veto file: mfem::HyperelasticModel
struct Jlmfem_HyperelasticModel: public Wrapper {

  Jlmfem_HyperelasticModel(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::HyperelasticModel (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:215:7
    jlcxx::TypeWrapper<mfem::HyperelasticModel>  t = jlModule.add_type<mfem::HyperelasticModel>("mfem!HyperelasticModel");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::HyperelasticModel>>(new jlcxx::TypeWrapper<mfem::HyperelasticModel>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::HyperelasticModel::SetTransformation(mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::HyperelasticModel::SetTransformation(mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:229:9
    t.method("SetTransformation", static_cast<void (mfem::HyperelasticModel::*)(mfem::ElementTransformation &) >(&mfem::HyperelasticModel::SetTransformation));

    DEBUG_MSG("Adding wrapper for double mfem::HyperelasticModel::EvalW(const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::HyperelasticModel::EvalW(const mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:234:19
    t.method("EvalW", static_cast<double (mfem::HyperelasticModel::*)(const mfem::DenseMatrix &)  const>(&mfem::HyperelasticModel::EvalW));

    DEBUG_MSG("Adding wrapper for void mfem::HyperelasticModel::EvalP(const mfem::DenseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::HyperelasticModel::EvalP(const mfem::DenseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:240:17
    t.method("EvalP", static_cast<void (mfem::HyperelasticModel::*)(const mfem::DenseMatrix &, mfem::DenseMatrix &)  const>(&mfem::HyperelasticModel::EvalP));

    DEBUG_MSG("Adding wrapper for void mfem::HyperelasticModel::AssembleH(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::HyperelasticModel::AssembleH(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:255:17
    t.method("AssembleH", static_cast<void (mfem::HyperelasticModel::*)(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &)  const>(&mfem::HyperelasticModel::AssembleH));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::HyperelasticModel>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_HyperelasticModel(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_HyperelasticModel(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InverseHarmonicModel> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InverseHarmonicModel> : std::false_type { };
template<> struct SuperType<mfem::InverseHarmonicModel> { typedef mfem::HyperelasticModel type; };
}

// Class generating the wrapper for type mfem::InverseHarmonicModel
// signature to use in the veto file: mfem::InverseHarmonicModel
struct Jlmfem_InverseHarmonicModel: public Wrapper {

  Jlmfem_InverseHarmonicModel(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InverseHarmonicModel (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:263:7
    jlcxx::TypeWrapper<mfem::InverseHarmonicModel>  t = jlModule.add_type<mfem::InverseHarmonicModel>("mfem!InverseHarmonicModel",
      jlcxx::julia_base_type<mfem::HyperelasticModel>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseHarmonicModel>>(new jlcxx::TypeWrapper<mfem::InverseHarmonicModel>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::InverseHarmonicModel::EvalW(const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::InverseHarmonicModel::EvalW(const mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:270:19
    t.method("EvalW", static_cast<double (mfem::InverseHarmonicModel::*)(const mfem::DenseMatrix &)  const>(&mfem::InverseHarmonicModel::EvalW));

    DEBUG_MSG("Adding wrapper for void mfem::InverseHarmonicModel::EvalP(const mfem::DenseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseHarmonicModel::EvalP(const mfem::DenseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:272:17
    t.method("EvalP", static_cast<void (mfem::InverseHarmonicModel::*)(const mfem::DenseMatrix &, mfem::DenseMatrix &)  const>(&mfem::InverseHarmonicModel::EvalP));

    DEBUG_MSG("Adding wrapper for void mfem::InverseHarmonicModel::AssembleH(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseHarmonicModel::AssembleH(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:274:17
    t.method("AssembleH", static_cast<void (mfem::InverseHarmonicModel::*)(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &)  const>(&mfem::InverseHarmonicModel::AssembleH));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseHarmonicModel>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InverseHarmonicModel(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InverseHarmonicModel(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NeoHookeanModel> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NeoHookeanModel> : std::false_type { };
template<> struct SuperType<mfem::NeoHookeanModel> { typedef mfem::HyperelasticModel type; };
}

// Class generating the wrapper for type mfem::NeoHookeanModel
// signature to use in the veto file: mfem::NeoHookeanModel
struct Jlmfem_NeoHookeanModel: public Wrapper {

  Jlmfem_NeoHookeanModel(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NeoHookeanModel (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:284:7
    jlcxx::TypeWrapper<mfem::NeoHookeanModel>  t = jlModule.add_type<mfem::NeoHookeanModel>("mfem!NeoHookeanModel",
      jlcxx::julia_base_type<mfem::HyperelasticModel>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NeoHookeanModel>>(new jlcxx::TypeWrapper<mfem::NeoHookeanModel>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NeoHookeanModel::NeoHookeanModel(double, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:297:4
    t.constructor<double, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<double, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NeoHookeanModel::NeoHookeanModel(mfem::Coefficient &, mfem::Coefficient &, mfem::Coefficient *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:300:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, mfem::Coefficient &, mfem::Coefficient *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::NeoHookeanModel::EvalW(const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::NeoHookeanModel::EvalW(const mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:304:19
    t.method("EvalW", static_cast<double (mfem::NeoHookeanModel::*)(const mfem::DenseMatrix &)  const>(&mfem::NeoHookeanModel::EvalW));

    DEBUG_MSG("Adding wrapper for void mfem::NeoHookeanModel::EvalP(const mfem::DenseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NeoHookeanModel::EvalP(const mfem::DenseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:306:17
    t.method("EvalP", static_cast<void (mfem::NeoHookeanModel::*)(const mfem::DenseMatrix &, mfem::DenseMatrix &)  const>(&mfem::NeoHookeanModel::EvalP));

    DEBUG_MSG("Adding wrapper for void mfem::NeoHookeanModel::AssembleH(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NeoHookeanModel::AssembleH(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:308:17
    t.method("AssembleH", static_cast<void (mfem::NeoHookeanModel::*)(const mfem::DenseMatrix &, const mfem::DenseMatrix &, const double, mfem::DenseMatrix &)  const>(&mfem::NeoHookeanModel::AssembleH));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NeoHookeanModel>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NeoHookeanModel(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NeoHookeanModel(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::HyperelasticNLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::HyperelasticNLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::HyperelasticNLFIntegrator> { typedef mfem::NonlinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::HyperelasticNLFIntegrator
// signature to use in the veto file: mfem::HyperelasticNLFIntegrator
struct Jlmfem_HyperelasticNLFIntegrator: public Wrapper {

  Jlmfem_HyperelasticNLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::HyperelasticNLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:320:7
    jlcxx::TypeWrapper<mfem::HyperelasticNLFIntegrator>  t = jlModule.add_type<mfem::HyperelasticNLFIntegrator>("mfem!HyperelasticNLFIntegrator",
      jlcxx::julia_base_type<mfem::NonlinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::HyperelasticNLFIntegrator>>(new jlcxx::TypeWrapper<mfem::HyperelasticNLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::HyperelasticNLFIntegrator::HyperelasticNLFIntegrator(mfem::HyperelasticModel *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:339:4
    t.constructor<mfem::HyperelasticModel *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::HyperelasticNLFIntegrator::GetElementEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::HyperelasticNLFIntegrator::GetElementEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:345:19
    t.method("GetElementEnergy", static_cast<double (mfem::HyperelasticNLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &) >(&mfem::HyperelasticNLFIntegrator::GetElementEnergy));

    DEBUG_MSG("Adding wrapper for void mfem::HyperelasticNLFIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::HyperelasticNLFIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:349:17
    t.method("AssembleElementVector", static_cast<void (mfem::HyperelasticNLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) >(&mfem::HyperelasticNLFIntegrator::AssembleElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::HyperelasticNLFIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::HyperelasticNLFIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:353:17
    t.method("AssembleElementGrad", static_cast<void (mfem::HyperelasticNLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) >(&mfem::HyperelasticNLFIntegrator::AssembleElementGrad));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::HyperelasticNLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_HyperelasticNLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_HyperelasticNLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IncompressibleNeoHookeanIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IncompressibleNeoHookeanIntegrator> : std::false_type { };
template<> struct SuperType<mfem::IncompressibleNeoHookeanIntegrator> { typedef mfem::BlockNonlinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::IncompressibleNeoHookeanIntegrator
// signature to use in the veto file: mfem::IncompressibleNeoHookeanIntegrator
struct Jlmfem_IncompressibleNeoHookeanIntegrator: public Wrapper {

  Jlmfem_IncompressibleNeoHookeanIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IncompressibleNeoHookeanIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:361:7
    jlcxx::TypeWrapper<mfem::IncompressibleNeoHookeanIntegrator>  t = jlModule.add_type<mfem::IncompressibleNeoHookeanIntegrator>("mfem!IncompressibleNeoHookeanIntegrator",
      jlcxx::julia_base_type<mfem::BlockNonlinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IncompressibleNeoHookeanIntegrator>>(new jlcxx::TypeWrapper<mfem::IncompressibleNeoHookeanIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::IncompressibleNeoHookeanIntegrator::IncompressibleNeoHookeanIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:370:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IncompressibleNeoHookeanIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IncompressibleNeoHookeanIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IncompressibleNeoHookeanIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorConvectionNLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorConvectionNLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorConvectionNLFIntegrator> { typedef mfem::NonlinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorConvectionNLFIntegrator
// signature to use in the veto file: mfem::VectorConvectionNLFIntegrator
struct Jlmfem_VectorConvectionNLFIntegrator: public Wrapper {

  Jlmfem_VectorConvectionNLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorConvectionNLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:390:7
    jlcxx::TypeWrapper<mfem::VectorConvectionNLFIntegrator>  t = jlModule.add_type<mfem::VectorConvectionNLFIntegrator>("mfem!VectorConvectionNLFIntegrator",
      jlcxx::julia_base_type<mfem::NonlinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorConvectionNLFIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorConvectionNLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorConvectionNLFIntegrator::VectorConvectionNLFIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:403:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::VectorConvectionNLFIntegrator::GetRule(const mfem::FiniteElement &, mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::VectorConvectionNLFIntegrator::GetRule(const mfem::FiniteElement &, mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:407:34
    module_.method("mfem!VectorConvectionNLFIntegrator!GetRule", static_cast<const mfem::IntegrationRule & (*)(const mfem::FiniteElement &, mfem::ElementTransformation &) >(&mfem::VectorConvectionNLFIntegrator::GetRule));

    DEBUG_MSG("Adding wrapper for void mfem::VectorConvectionNLFIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorConvectionNLFIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:410:17
    t.method("AssembleElementVector", static_cast<void (mfem::VectorConvectionNLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) >(&mfem::VectorConvectionNLFIntegrator::AssembleElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::VectorConvectionNLFIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorConvectionNLFIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:415:17
    t.method("AssembleElementGrad", static_cast<void (mfem::VectorConvectionNLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) >(&mfem::VectorConvectionNLFIntegrator::AssembleElementGrad));

    DEBUG_MSG("Adding wrapper for void mfem::VectorConvectionNLFIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorConvectionNLFIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:422:17
    t.method("AssemblePA", static_cast<void (mfem::VectorConvectionNLFIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::VectorConvectionNLFIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorConvectionNLFIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorConvectionNLFIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:424:17
    t.method("AssembleMF", static_cast<void (mfem::VectorConvectionNLFIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::VectorConvectionNLFIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::VectorConvectionNLFIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorConvectionNLFIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:426:17
    t.method("AddMultPA", static_cast<void (mfem::VectorConvectionNLFIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorConvectionNLFIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorConvectionNLFIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorConvectionNLFIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:428:17
    t.method("AddMultMF", static_cast<void (mfem::VectorConvectionNLFIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorConvectionNLFIntegrator::AddMultMF));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorConvectionNLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorConvectionNLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorConvectionNLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ConvectiveVectorConvectionNLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ConvectiveVectorConvectionNLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::ConvectiveVectorConvectionNLFIntegrator> { typedef mfem::VectorConvectionNLFIntegrator type; };
}

// Class generating the wrapper for type mfem::ConvectiveVectorConvectionNLFIntegrator
// signature to use in the veto file: mfem::ConvectiveVectorConvectionNLFIntegrator
struct Jlmfem_ConvectiveVectorConvectionNLFIntegrator: public Wrapper {

  Jlmfem_ConvectiveVectorConvectionNLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ConvectiveVectorConvectionNLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:434:7
    jlcxx::TypeWrapper<mfem::ConvectiveVectorConvectionNLFIntegrator>  t = jlModule.add_type<mfem::ConvectiveVectorConvectionNLFIntegrator>("mfem!ConvectiveVectorConvectionNLFIntegrator",
      jlcxx::julia_base_type<mfem::VectorConvectionNLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ConvectiveVectorConvectionNLFIntegrator>>(new jlcxx::TypeWrapper<mfem::ConvectiveVectorConvectionNLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::ConvectiveVectorConvectionNLFIntegrator::ConvectiveVectorConvectionNLFIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:443:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:447:17
    t.method("AssembleElementGrad", static_cast<void (mfem::ConvectiveVectorConvectionNLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) >(&mfem::ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ConvectiveVectorConvectionNLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ConvectiveVectorConvectionNLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ConvectiveVectorConvectionNLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SkewSymmetricVectorConvectionNLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SkewSymmetricVectorConvectionNLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::SkewSymmetricVectorConvectionNLFIntegrator> { typedef mfem::VectorConvectionNLFIntegrator type; };
}

// Class generating the wrapper for type mfem::SkewSymmetricVectorConvectionNLFIntegrator
// signature to use in the veto file: mfem::SkewSymmetricVectorConvectionNLFIntegrator
struct Jlmfem_SkewSymmetricVectorConvectionNLFIntegrator: public Wrapper {

  Jlmfem_SkewSymmetricVectorConvectionNLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SkewSymmetricVectorConvectionNLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:457:7
    jlcxx::TypeWrapper<mfem::SkewSymmetricVectorConvectionNLFIntegrator>  t = jlModule.add_type<mfem::SkewSymmetricVectorConvectionNLFIntegrator>("mfem!SkewSymmetricVectorConvectionNLFIntegrator",
      jlcxx::julia_base_type<mfem::VectorConvectionNLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SkewSymmetricVectorConvectionNLFIntegrator>>(new jlcxx::TypeWrapper<mfem::SkewSymmetricVectorConvectionNLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SkewSymmetricVectorConvectionNLFIntegrator::SkewSymmetricVectorConvectionNLFIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:466:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::SkewSymmetricVectorConvectionNLFIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SkewSymmetricVectorConvectionNLFIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:470:17
    t.method("AssembleElementGrad", static_cast<void (mfem::SkewSymmetricVectorConvectionNLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) >(&mfem::SkewSymmetricVectorConvectionNLFIntegrator::AssembleElementGrad));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SkewSymmetricVectorConvectionNLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SkewSymmetricVectorConvectionNLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SkewSymmetricVectorConvectionNLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BilinearFormIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BilinearFormIntegrator> : std::false_type { };
template<> struct SuperType<mfem::BilinearFormIntegrator> { typedef mfem::NonlinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::BilinearFormIntegrator
// signature to use in the veto file: mfem::BilinearFormIntegrator
struct Jlmfem_BilinearFormIntegrator: public Wrapper {

  Jlmfem_BilinearFormIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BilinearFormIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:26:7
    jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>  t = jlModule.add_type<mfem::BilinearFormIntegrator>("mfem!BilinearFormIntegrator",
      jlcxx::julia_base_type<mfem::NonlinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>>(new jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:50:17
    t.method("AssemblePA", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::BilinearFormIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:52:17
    t.method("AssemblePA", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) >(&mfem::BilinearFormIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleNURBSPA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleNURBSPA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:58:17
    t.method("AssembleNURBSPA", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::BilinearFormIntegrator::AssembleNURBSPA));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssemblePABoundary(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssemblePABoundary(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:60:17
    t.method("AssemblePABoundary", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::BilinearFormIntegrator::AssemblePABoundary));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssemblePAInteriorFaces(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssemblePAInteriorFaces(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:62:17
    t.method("AssemblePAInteriorFaces", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::BilinearFormIntegrator::AssemblePAInteriorFaces));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssemblePABoundaryFaces(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssemblePABoundaryFaces(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:64:17
    t.method("AssemblePABoundaryFaces", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::BilinearFormIntegrator::AssemblePABoundaryFaces));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:67:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::BilinearFormIntegrator::*)(mfem::Vector &) >(&mfem::BilinearFormIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:70:17
    t.method("AssembleDiagonalPA_ADAt", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &) >(&mfem::BilinearFormIntegrator::AssembleDiagonalPA_ADAt));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:79:17
    t.method("AddMultPA", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearFormIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AddMultNURBSPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AddMultNURBSPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:82:17
    t.method("AddMultNURBSPA", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearFormIntegrator::AddMultNURBSPA));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:91:17
    t.method("AddMultTransposePA", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearFormIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:96:17
    t.method("AssembleEA", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::BilinearFormIntegrator::AssembleEA));
    t.method("AssembleEA", [](mfem::BilinearFormIntegrator& a, const mfem::FiniteElementSpace & arg0, mfem::Vector & arg1)->void { a.AssembleEA(arg0, arg1); });
    t.method("AssembleEA", [](mfem::BilinearFormIntegrator* a, const mfem::FiniteElementSpace & arg0, mfem::Vector & arg1)->void { a->AssembleEA(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:106:17
    t.method("AssembleMF", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::BilinearFormIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:114:17
    t.method("AddMultMF", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearFormIntegrator::AddMultMF));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AddMultTransposeMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AddMultTransposeMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:122:17
    t.method("AddMultTransposeMF", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BilinearFormIntegrator::AddMultTransposeMF));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleDiagonalMF(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleDiagonalMF(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:125:17
    t.method("AssembleDiagonalMF", static_cast<void (mfem::BilinearFormIntegrator::*)(mfem::Vector &) >(&mfem::BilinearFormIntegrator::AssembleDiagonalMF));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleEAInteriorFaces(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleEAInteriorFaces(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:127:17
    t.method("AssembleEAInteriorFaces", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool) >(&mfem::BilinearFormIntegrator::AssembleEAInteriorFaces));
    t.method("AssembleEAInteriorFaces", [](mfem::BilinearFormIntegrator& a, const mfem::FiniteElementSpace & arg0, mfem::Vector & arg1, mfem::Vector & arg2)->void { a.AssembleEAInteriorFaces(arg0, arg1, arg2); });
    t.method("AssembleEAInteriorFaces", [](mfem::BilinearFormIntegrator* a, const mfem::FiniteElementSpace & arg0, mfem::Vector & arg1, mfem::Vector & arg2)->void { a->AssembleEAInteriorFaces(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleEABoundaryFaces(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleEABoundaryFaces(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:132:17
    t.method("AssembleEABoundaryFaces", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::BilinearFormIntegrator::AssembleEABoundaryFaces));
    t.method("AssembleEABoundaryFaces", [](mfem::BilinearFormIntegrator& a, const mfem::FiniteElementSpace & arg0, mfem::Vector & arg1)->void { a.AssembleEABoundaryFaces(arg0, arg1); });
    t.method("AssembleEABoundaryFaces", [](mfem::BilinearFormIntegrator* a, const mfem::FiniteElementSpace & arg0, mfem::Vector & arg1)->void { a->AssembleEABoundaryFaces(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:137:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::BilinearFormIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:145:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::BilinearFormIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssemblePatchMatrix(const int, const mfem::FiniteElementSpace &, mfem::SparseMatrix *&) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssemblePatchMatrix(const int, const mfem::FiniteElementSpace &, mfem::SparseMatrix *&)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:153:17
    t.method("AssemblePatchMatrix", static_cast<void (mfem::BilinearFormIntegrator::*)(const int, const mfem::FiniteElementSpace &, mfem::SparseMatrix *&) >(&mfem::BilinearFormIntegrator::AssemblePatchMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:157:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::BilinearFormIntegrator::AssembleFaceMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:164:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::BilinearFormIntegrator::AssembleFaceMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleTraceFaceMatrix(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleTraceFaceMatrix(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:172:17
    t.method("AssembleTraceFaceMatrix", static_cast<void (mfem::BilinearFormIntegrator::*)(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::BilinearFormIntegrator::AssembleTraceFaceMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:182:17
    t.method("AssembleElementVector", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) >(&mfem::BilinearFormIntegrator::AssembleElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleFaceVector(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleFaceVector(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:190:17
    t.method("AssembleFaceVector", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::Vector &) >(&mfem::BilinearFormIntegrator::AssembleFaceVector));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleElementGrad(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:195:17
    t.method("AssembleElementGrad", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::DenseMatrix &) >(&mfem::BilinearFormIntegrator::AssembleElementGrad));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::AssembleFaceGrad(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::AssembleFaceGrad(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:200:17
    t.method("AssembleFaceGrad", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, const mfem::Vector &, mfem::DenseMatrix &) >(&mfem::BilinearFormIntegrator::AssembleFaceGrad));

    DEBUG_MSG("Adding wrapper for void mfem::BilinearFormIntegrator::ComputeElementFlux(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BilinearFormIntegrator::ComputeElementFlux(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:240:17
    t.method("ComputeElementFlux", static_cast<void (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *) >(&mfem::BilinearFormIntegrator::ComputeElementFlux));
    t.method("ComputeElementFlux", [](mfem::BilinearFormIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4)->void { a.ComputeElementFlux(arg0, arg1, arg2, arg3, arg4); });
    t.method("ComputeElementFlux", [](mfem::BilinearFormIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4, bool arg5)->void { a.ComputeElementFlux(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("ComputeElementFlux", [](mfem::BilinearFormIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4)->void { a->ComputeElementFlux(arg0, arg1, arg2, arg3, arg4); });
    t.method("ComputeElementFlux", [](mfem::BilinearFormIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4, bool arg5)->void { a->ComputeElementFlux(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for double mfem::BilinearFormIntegrator::ComputeFluxEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::BilinearFormIntegrator::ComputeFluxEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:266:19
    t.method("ComputeFluxEnergy", static_cast<double (mfem::BilinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *) >(&mfem::BilinearFormIntegrator::ComputeFluxEnergy));
    t.method("ComputeFluxEnergy", [](mfem::BilinearFormIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2)->double { return a.ComputeFluxEnergy(arg0, arg1, arg2); });
    t.method("ComputeFluxEnergy", [](mfem::BilinearFormIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2)->double { return a->ComputeFluxEnergy(arg0, arg1, arg2); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BilinearFormIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BilinearFormIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TransposeIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TransposeIntegrator> : std::false_type { };
template<> struct SuperType<mfem::TransposeIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::TransposeIntegrator
// signature to use in the veto file: mfem::TransposeIntegrator
struct Jlmfem_TransposeIntegrator: public Wrapper {

  Jlmfem_TransposeIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TransposeIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:276:7
    jlcxx::TypeWrapper<mfem::TransposeIntegrator>  t = jlModule.add_type<mfem::TransposeIntegrator>("mfem!TransposeIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TransposeIntegrator>>(new jlcxx::TypeWrapper<mfem::TransposeIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::TransposeIntegrator(mfem::BilinearFormIntegrator *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:285:4
    t.constructor<mfem::BilinearFormIntegrator *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::BilinearFormIntegrator *, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::SetIntRule(const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::SetIntRule(const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:288:17
    t.method("SetIntRule", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::IntegrationRule *) >(&mfem::TransposeIntegrator::SetIntRule));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:290:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::TransposeIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:294:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::TransposeIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:300:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::TransposeIntegrator::AssembleFaceMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:307:17
    t.method("AssemblePA", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::TransposeIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:312:17
    t.method("AssemblePA", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) >(&mfem::TransposeIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssemblePAInteriorFaces(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssemblePAInteriorFaces(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:318:17
    t.method("AssemblePAInteriorFaces", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::TransposeIntegrator::AssemblePAInteriorFaces));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssemblePABoundaryFaces(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssemblePABoundaryFaces(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:323:17
    t.method("AssemblePABoundaryFaces", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::TransposeIntegrator::AssemblePABoundaryFaces));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:328:17
    t.method("AddMultTransposePA", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TransposeIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:333:17
    t.method("AddMultPA", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::TransposeIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:338:17
    t.method("AssembleEA", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::TransposeIntegrator::AssembleEA));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssembleEAInteriorFaces(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssembleEAInteriorFaces(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:341:17
    t.method("AssembleEAInteriorFaces", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool) >(&mfem::TransposeIntegrator::AssembleEAInteriorFaces));

    DEBUG_MSG("Adding wrapper for void mfem::TransposeIntegrator::AssembleEABoundaryFaces(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TransposeIntegrator::AssembleEABoundaryFaces(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:346:17
    t.method("AssembleEABoundaryFaces", static_cast<void (mfem::TransposeIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::TransposeIntegrator::AssembleEABoundaryFaces));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TransposeIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TransposeIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TransposeIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LumpedIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LumpedIntegrator> : std::false_type { };
template<> struct SuperType<mfem::LumpedIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::LumpedIntegrator
// signature to use in the veto file: mfem::LumpedIntegrator
struct Jlmfem_LumpedIntegrator: public Wrapper {

  Jlmfem_LumpedIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LumpedIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:353:7
    jlcxx::TypeWrapper<mfem::LumpedIntegrator>  t = jlModule.add_type<mfem::LumpedIntegrator>("mfem!LumpedIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LumpedIntegrator>>(new jlcxx::TypeWrapper<mfem::LumpedIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::LumpedIntegrator::LumpedIntegrator(mfem::BilinearFormIntegrator *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:360:4
    t.constructor<mfem::BilinearFormIntegrator *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::BilinearFormIntegrator *, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::LumpedIntegrator::SetIntRule(const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LumpedIntegrator::SetIntRule(const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:363:17
    t.method("SetIntRule", static_cast<void (mfem::LumpedIntegrator::*)(const mfem::IntegrationRule *) >(&mfem::LumpedIntegrator::SetIntRule));

    DEBUG_MSG("Adding wrapper for void mfem::LumpedIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LumpedIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:365:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::LumpedIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::LumpedIntegrator::AssembleElementMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LumpedIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LumpedIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LumpedIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InverseIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InverseIntegrator> : std::false_type { };
template<> struct SuperType<mfem::InverseIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::InverseIntegrator
// signature to use in the veto file: mfem::InverseIntegrator
struct Jlmfem_InverseIntegrator: public Wrapper {

  Jlmfem_InverseIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InverseIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:373:7
    jlcxx::TypeWrapper<mfem::InverseIntegrator>  t = jlModule.add_type<mfem::InverseIntegrator>("mfem!InverseIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseIntegrator>>(new jlcxx::TypeWrapper<mfem::InverseIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::InverseIntegrator::InverseIntegrator(mfem::BilinearFormIntegrator *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:380:4
    t.constructor<mfem::BilinearFormIntegrator *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::BilinearFormIntegrator *, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::InverseIntegrator::SetIntRule(const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseIntegrator::SetIntRule(const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:383:17
    t.method("SetIntRule", static_cast<void (mfem::InverseIntegrator::*)(const mfem::IntegrationRule *) >(&mfem::InverseIntegrator::SetIntRule));

    DEBUG_MSG("Adding wrapper for void mfem::InverseIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::InverseIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:385:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::InverseIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::InverseIntegrator::AssembleElementMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InverseIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InverseIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SumIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SumIntegrator> : std::false_type { };
template<> struct SuperType<mfem::SumIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::SumIntegrator
// signature to use in the veto file: mfem::SumIntegrator
struct Jlmfem_SumIntegrator: public Wrapper {

  Jlmfem_SumIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SumIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:393:7
    jlcxx::TypeWrapper<mfem::SumIntegrator>  t = jlModule.add_type<mfem::SumIntegrator>("mfem!SumIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SumIntegrator>>(new jlcxx::TypeWrapper<mfem::SumIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::SumIntegrator(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:401:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::SetIntRule(const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::SetIntRule(const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:403:17
    t.method("SetIntRule", static_cast<void (mfem::SumIntegrator::*)(const mfem::IntegrationRule *) >(&mfem::SumIntegrator::SetIntRule));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AddIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AddIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:405:9
    t.method("AddIntegrator", static_cast<void (mfem::SumIntegrator::*)(mfem::BilinearFormIntegrator *) >(&mfem::SumIntegrator::AddIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:408:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::SumIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:411:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::SumIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:417:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::SumIntegrator::AssembleFaceMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:422:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::SumIntegrator::AssembleFaceMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:429:17
    t.method("AssemblePA", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::SumIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:431:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::SumIntegrator::*)(mfem::Vector &) >(&mfem::SumIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssemblePAInteriorFaces(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssemblePAInteriorFaces(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:433:17
    t.method("AssemblePAInteriorFaces", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::SumIntegrator::AssemblePAInteriorFaces));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssemblePABoundaryFaces(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssemblePABoundaryFaces(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:435:17
    t.method("AssemblePABoundaryFaces", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::SumIntegrator::AssemblePABoundaryFaces));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:437:17
    t.method("AddMultTransposePA", static_cast<void (mfem::SumIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SumIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:439:17
    t.method("AddMultPA", static_cast<void (mfem::SumIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SumIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:441:17
    t.method("AssembleMF", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::SumIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:443:17
    t.method("AddMultMF", static_cast<void (mfem::SumIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SumIntegrator::AddMultMF));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AddMultTransposeMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AddMultTransposeMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:445:17
    t.method("AddMultTransposeMF", static_cast<void (mfem::SumIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::SumIntegrator::AddMultTransposeMF));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleDiagonalMF(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleDiagonalMF(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:447:17
    t.method("AssembleDiagonalMF", static_cast<void (mfem::SumIntegrator::*)(mfem::Vector &) >(&mfem::SumIntegrator::AssembleDiagonalMF));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:449:17
    t.method("AssembleEA", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::SumIntegrator::AssembleEA));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleEAInteriorFaces(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleEAInteriorFaces(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:452:17
    t.method("AssembleEAInteriorFaces", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool) >(&mfem::SumIntegrator::AssembleEAInteriorFaces));

    DEBUG_MSG("Adding wrapper for void mfem::SumIntegrator::AssembleEABoundaryFaces(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SumIntegrator::AssembleEABoundaryFaces(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:457:17
    t.method("AssembleEABoundaryFaces", static_cast<void (mfem::SumIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::SumIntegrator::AssembleEABoundaryFaces));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SumIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SumIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SumIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarIntegrator
// signature to use in the veto file: mfem::MixedScalarIntegrator
struct Jlmfem_MixedScalarIntegrator: public Wrapper {

  Jlmfem_MixedScalarIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:466:7
    jlcxx::TypeWrapper<mfem::MixedScalarIntegrator>  t = jlModule.add_type<mfem::MixedScalarIntegrator>("mfem!MixedScalarIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:470:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::MixedScalarIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedScalarIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:476:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::MixedScalarIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedScalarIntegrator::AssembleElementMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedVectorIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedVectorIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedVectorIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedVectorIntegrator
// signature to use in the veto file: mfem::MixedVectorIntegrator
struct Jlmfem_MixedVectorIntegrator: public Wrapper {

  Jlmfem_MixedVectorIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedVectorIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:533:7
    jlcxx::TypeWrapper<mfem::MixedVectorIntegrator>  t = jlModule.add_type<mfem::MixedVectorIntegrator>("mfem!MixedVectorIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedVectorIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedVectorIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:537:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::MixedVectorIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedVectorIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedVectorIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:543:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::MixedVectorIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedVectorIntegrator::AssembleElementMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedVectorIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedVectorIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarVectorIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarVectorIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarVectorIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarVectorIntegrator
// signature to use in the veto file: mfem::MixedScalarVectorIntegrator
struct Jlmfem_MixedScalarVectorIntegrator: public Wrapper {

  Jlmfem_MixedScalarVectorIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarVectorIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:622:7
    jlcxx::TypeWrapper<mfem::MixedScalarVectorIntegrator>  t = jlModule.add_type<mfem::MixedScalarVectorIntegrator>("mfem!MixedScalarVectorIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarVectorIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarVectorIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarVectorIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarVectorIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:626:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::MixedScalarVectorIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedScalarVectorIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarVectorIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarVectorIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:636:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::MixedScalarVectorIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedScalarVectorIntegrator::AssembleElementMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarVectorIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarVectorIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarVectorIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarMassIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarMassIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarMassIntegrator> { typedef mfem::MixedScalarIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarMassIntegrator
// signature to use in the veto file: mfem::MixedScalarMassIntegrator
struct Jlmfem_MixedScalarMassIntegrator: public Wrapper {

  Jlmfem_MixedScalarMassIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarMassIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:714:7
    jlcxx::TypeWrapper<mfem::MixedScalarMassIntegrator>  t = jlModule.add_type<mfem::MixedScalarMassIntegrator>("mfem!MixedScalarMassIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarMassIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarMassIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarMassIntegrator::MixedScalarMassIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:718:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarMassIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarMassIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarMassIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedVectorProductIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedVectorProductIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedVectorProductIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedVectorProductIntegrator
// signature to use in the veto file: mfem::MixedVectorProductIntegrator
struct Jlmfem_MixedVectorProductIntegrator: public Wrapper {

  Jlmfem_MixedVectorProductIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedVectorProductIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:725:7
    jlcxx::TypeWrapper<mfem::MixedVectorProductIntegrator>  t = jlModule.add_type<mfem::MixedVectorProductIntegrator>("mfem!MixedVectorProductIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorProductIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedVectorProductIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorProductIntegrator::MixedVectorProductIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:728:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorProductIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedVectorProductIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedVectorProductIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarDerivativeIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarDerivativeIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarDerivativeIntegrator> { typedef mfem::MixedScalarIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarDerivativeIntegrator
// signature to use in the veto file: mfem::MixedScalarDerivativeIntegrator
struct Jlmfem_MixedScalarDerivativeIntegrator: public Wrapper {

  Jlmfem_MixedScalarDerivativeIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarDerivativeIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:734:7
    jlcxx::TypeWrapper<mfem::MixedScalarDerivativeIntegrator>  t = jlModule.add_type<mfem::MixedScalarDerivativeIntegrator>("mfem!MixedScalarDerivativeIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarDerivativeIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarDerivativeIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarDerivativeIntegrator::MixedScalarDerivativeIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:738:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarDerivativeIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarDerivativeIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarDerivativeIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarWeakDerivativeIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarWeakDerivativeIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarWeakDerivativeIntegrator> { typedef mfem::MixedScalarIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarWeakDerivativeIntegrator
// signature to use in the veto file: mfem::MixedScalarWeakDerivativeIntegrator
struct Jlmfem_MixedScalarWeakDerivativeIntegrator: public Wrapper {

  Jlmfem_MixedScalarWeakDerivativeIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarWeakDerivativeIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:769:7
    jlcxx::TypeWrapper<mfem::MixedScalarWeakDerivativeIntegrator>  t = jlModule.add_type<mfem::MixedScalarWeakDerivativeIntegrator>("mfem!MixedScalarWeakDerivativeIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakDerivativeIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarWeakDerivativeIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakDerivativeIntegrator::MixedScalarWeakDerivativeIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:773:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakDerivativeIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakDerivativeIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarWeakDerivativeIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarDivergenceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarDivergenceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarDivergenceIntegrator> { typedef mfem::MixedScalarIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarDivergenceIntegrator
// signature to use in the veto file: mfem::MixedScalarDivergenceIntegrator
struct Jlmfem_MixedScalarDivergenceIntegrator: public Wrapper {

  Jlmfem_MixedScalarDivergenceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarDivergenceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:807:7
    jlcxx::TypeWrapper<mfem::MixedScalarDivergenceIntegrator>  t = jlModule.add_type<mfem::MixedScalarDivergenceIntegrator>("mfem!MixedScalarDivergenceIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarDivergenceIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarDivergenceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarDivergenceIntegrator::MixedScalarDivergenceIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:811:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarDivergenceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarDivergenceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarDivergenceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedVectorDivergenceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedVectorDivergenceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedVectorDivergenceIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedVectorDivergenceIntegrator
// signature to use in the veto file: mfem::MixedVectorDivergenceIntegrator
struct Jlmfem_MixedVectorDivergenceIntegrator: public Wrapper {

  Jlmfem_MixedVectorDivergenceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedVectorDivergenceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:843:7
    jlcxx::TypeWrapper<mfem::MixedVectorDivergenceIntegrator>  t = jlModule.add_type<mfem::MixedVectorDivergenceIntegrator>("mfem!MixedVectorDivergenceIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorDivergenceIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedVectorDivergenceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorDivergenceIntegrator::MixedVectorDivergenceIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:846:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorDivergenceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedVectorDivergenceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedVectorDivergenceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarWeakGradientIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarWeakGradientIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarWeakGradientIntegrator> { typedef mfem::MixedScalarIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarWeakGradientIntegrator
// signature to use in the veto file: mfem::MixedScalarWeakGradientIntegrator
struct Jlmfem_MixedScalarWeakGradientIntegrator: public Wrapper {

  Jlmfem_MixedScalarWeakGradientIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarWeakGradientIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:881:7
    jlcxx::TypeWrapper<mfem::MixedScalarWeakGradientIntegrator>  t = jlModule.add_type<mfem::MixedScalarWeakGradientIntegrator>("mfem!MixedScalarWeakGradientIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakGradientIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarWeakGradientIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakGradientIntegrator::MixedScalarWeakGradientIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:885:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakGradientIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakGradientIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarWeakGradientIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarCurlIntegrator> { typedef mfem::MixedScalarIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarCurlIntegrator
// signature to use in the veto file: mfem::MixedScalarCurlIntegrator
struct Jlmfem_MixedScalarCurlIntegrator: public Wrapper {

  Jlmfem_MixedScalarCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:921:7
    jlcxx::TypeWrapper<mfem::MixedScalarCurlIntegrator>  t = jlModule.add_type<mfem::MixedScalarCurlIntegrator>("mfem!MixedScalarCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarCurlIntegrator::MixedScalarCurlIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:925:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarWeakCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarWeakCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarWeakCurlIntegrator> { typedef mfem::MixedScalarIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarWeakCurlIntegrator
// signature to use in the veto file: mfem::MixedScalarWeakCurlIntegrator
struct Jlmfem_MixedScalarWeakCurlIntegrator: public Wrapper {

  Jlmfem_MixedScalarWeakCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarWeakCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:977:7
    jlcxx::TypeWrapper<mfem::MixedScalarWeakCurlIntegrator>  t = jlModule.add_type<mfem::MixedScalarWeakCurlIntegrator>("mfem!MixedScalarWeakCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarWeakCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakCurlIntegrator::MixedScalarWeakCurlIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:981:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarWeakCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedVectorMassIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedVectorMassIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedVectorMassIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedVectorMassIntegrator
// signature to use in the veto file: mfem::MixedVectorMassIntegrator
struct Jlmfem_MixedVectorMassIntegrator: public Wrapper {

  Jlmfem_MixedVectorMassIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedVectorMassIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1013:7
    jlcxx::TypeWrapper<mfem::MixedVectorMassIntegrator>  t = jlModule.add_type<mfem::MixedVectorMassIntegrator>("mfem!MixedVectorMassIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorMassIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedVectorMassIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorMassIntegrator::MixedVectorMassIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1017:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorMassIntegrator::MixedVectorMassIntegrator(mfem::DiagonalMatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1019:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorMassIntegrator::MixedVectorMassIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1021:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorMassIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedVectorMassIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedVectorMassIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCrossProductIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCrossProductIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCrossProductIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCrossProductIntegrator
// signature to use in the veto file: mfem::MixedCrossProductIntegrator
struct Jlmfem_MixedCrossProductIntegrator: public Wrapper {

  Jlmfem_MixedCrossProductIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCrossProductIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1027:7
    jlcxx::TypeWrapper<mfem::MixedCrossProductIntegrator>  t = jlModule.add_type<mfem::MixedCrossProductIntegrator>("mfem!MixedCrossProductIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossProductIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCrossProductIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossProductIntegrator::MixedCrossProductIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1030:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossProductIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCrossProductIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCrossProductIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedDotProductIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedDotProductIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedDotProductIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedDotProductIntegrator
// signature to use in the veto file: mfem::MixedDotProductIntegrator
struct Jlmfem_MixedDotProductIntegrator: public Wrapper {

  Jlmfem_MixedDotProductIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedDotProductIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1037:7
    jlcxx::TypeWrapper<mfem::MixedDotProductIntegrator>  t = jlModule.add_type<mfem::MixedDotProductIntegrator>("mfem!MixedDotProductIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedDotProductIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedDotProductIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedDotProductIntegrator::MixedDotProductIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1040:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedDotProductIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedDotProductIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1043:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedDotProductIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedDotProductIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedDotProductIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedDotProductIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1051:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedDotProductIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedDotProductIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedDotProductIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedDotProductIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedDotProductIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedWeakGradDotIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedWeakGradDotIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedWeakGradDotIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedWeakGradDotIntegrator
// signature to use in the veto file: mfem::MixedWeakGradDotIntegrator
struct Jlmfem_MixedWeakGradDotIntegrator: public Wrapper {

  Jlmfem_MixedWeakGradDotIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedWeakGradDotIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1062:7
    jlcxx::TypeWrapper<mfem::MixedWeakGradDotIntegrator>  t = jlModule.add_type<mfem::MixedWeakGradDotIntegrator>("mfem!MixedWeakGradDotIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedWeakGradDotIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedWeakGradDotIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedWeakGradDotIntegrator::MixedWeakGradDotIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1065:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedWeakGradDotIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedWeakGradDotIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1068:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedWeakGradDotIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedWeakGradDotIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedWeakGradDotIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedWeakGradDotIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1077:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedWeakGradDotIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedWeakGradDotIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedWeakGradDotIntegrator::GetIntegrationOrder(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedWeakGradDotIntegrator::GetIntegrationOrder(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1086:23
    t.method("GetIntegrationOrder", static_cast<int (mfem::MixedWeakGradDotIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) >(&mfem::MixedWeakGradDotIntegrator::GetIntegrationOrder));

    DEBUG_MSG("Adding wrapper for void mfem::MixedWeakGradDotIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedWeakGradDotIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1091:24
    t.method("CalcShape", static_cast<void (mfem::MixedWeakGradDotIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::MixedWeakGradDotIntegrator::CalcShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedWeakGradDotIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedWeakGradDotIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedWeakGradDotIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedWeakDivCrossIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedWeakDivCrossIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedWeakDivCrossIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedWeakDivCrossIntegrator
// signature to use in the veto file: mfem::MixedWeakDivCrossIntegrator
struct Jlmfem_MixedWeakDivCrossIntegrator: public Wrapper {

  Jlmfem_MixedWeakDivCrossIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedWeakDivCrossIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1099:7
    jlcxx::TypeWrapper<mfem::MixedWeakDivCrossIntegrator>  t = jlModule.add_type<mfem::MixedWeakDivCrossIntegrator>("mfem!MixedWeakDivCrossIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedWeakDivCrossIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedWeakDivCrossIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedWeakDivCrossIntegrator::MixedWeakDivCrossIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1102:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedWeakDivCrossIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedWeakDivCrossIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1105:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedWeakDivCrossIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedWeakDivCrossIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedWeakDivCrossIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedWeakDivCrossIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1115:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedWeakDivCrossIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedWeakDivCrossIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedWeakDivCrossIntegrator::GetTestVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedWeakDivCrossIntegrator::GetTestVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1122:23
    t.method("GetTestVDim", static_cast<int (mfem::MixedWeakDivCrossIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedWeakDivCrossIntegrator::GetTestVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedWeakDivCrossIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedWeakDivCrossIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1125:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedWeakDivCrossIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedWeakDivCrossIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedWeakDivCrossIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedWeakDivCrossIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedWeakDivCrossIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedGradGradIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedGradGradIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedGradGradIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedGradGradIntegrator
// signature to use in the veto file: mfem::MixedGradGradIntegrator
struct Jlmfem_MixedGradGradIntegrator: public Wrapper {

  Jlmfem_MixedGradGradIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedGradGradIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1134:7
    jlcxx::TypeWrapper<mfem::MixedGradGradIntegrator>  t = jlModule.add_type<mfem::MixedGradGradIntegrator>("mfem!MixedGradGradIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedGradGradIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedGradGradIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedGradGradIntegrator::MixedGradGradIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1138:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedGradGradIntegrator::MixedGradGradIntegrator(mfem::DiagonalMatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1140:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedGradGradIntegrator::MixedGradGradIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1142:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedGradGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedGradGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1145:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedGradGradIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedGradGradIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedGradGradIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedGradGradIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1155:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedGradGradIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedGradGradIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedGradGradIntegrator::GetIntegrationOrder(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedGradGradIntegrator::GetIntegrationOrder(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1162:23
    t.method("GetIntegrationOrder", static_cast<int (mfem::MixedGradGradIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) >(&mfem::MixedGradGradIntegrator::GetIntegrationOrder));

    DEBUG_MSG("Adding wrapper for int mfem::MixedGradGradIntegrator::GetTrialVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedGradGradIntegrator::GetTrialVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1172:23
    t.method("GetTrialVDim", static_cast<int (mfem::MixedGradGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedGradGradIntegrator::GetTrialVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedGradGradIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedGradGradIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1175:24
    t.method("CalcTrialShape", static_cast<void (mfem::MixedGradGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedGradGradIntegrator::CalcTrialShape));

    DEBUG_MSG("Adding wrapper for int mfem::MixedGradGradIntegrator::GetTestVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedGradGradIntegrator::GetTestVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1180:23
    t.method("GetTestVDim", static_cast<int (mfem::MixedGradGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedGradGradIntegrator::GetTestVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedGradGradIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedGradGradIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1183:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedGradGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedGradGradIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedGradGradIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedGradGradIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedGradGradIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCrossGradGradIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCrossGradGradIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCrossGradGradIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCrossGradGradIntegrator
// signature to use in the veto file: mfem::MixedCrossGradGradIntegrator
struct Jlmfem_MixedCrossGradGradIntegrator: public Wrapper {

  Jlmfem_MixedCrossGradGradIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCrossGradGradIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1191:7
    jlcxx::TypeWrapper<mfem::MixedCrossGradGradIntegrator>  t = jlModule.add_type<mfem::MixedCrossGradGradIntegrator>("mfem!MixedCrossGradGradIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossGradGradIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCrossGradGradIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradGradIntegrator::MixedCrossGradGradIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1194:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedCrossGradGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedCrossGradGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1197:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedCrossGradGradIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedCrossGradGradIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedCrossGradGradIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedCrossGradGradIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1207:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossGradGradIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossGradGradIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossGradGradIntegrator::GetTrialVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossGradGradIntegrator::GetTrialVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1214:23
    t.method("GetTrialVDim", static_cast<int (mfem::MixedCrossGradGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossGradGradIntegrator::GetTrialVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradGradIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossGradGradIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1217:24
    t.method("CalcTrialShape", static_cast<void (mfem::MixedCrossGradGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossGradGradIntegrator::CalcTrialShape));

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossGradGradIntegrator::GetTestVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossGradGradIntegrator::GetTestVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1222:23
    t.method("GetTestVDim", static_cast<int (mfem::MixedCrossGradGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossGradGradIntegrator::GetTestVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradGradIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossGradGradIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1225:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedCrossGradGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossGradGradIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossGradGradIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCrossGradGradIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCrossGradGradIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCurlCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCurlCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCurlCurlIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCurlCurlIntegrator
// signature to use in the veto file: mfem::MixedCurlCurlIntegrator
struct Jlmfem_MixedCurlCurlIntegrator: public Wrapper {

  Jlmfem_MixedCurlCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCurlCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1234:7
    jlcxx::TypeWrapper<mfem::MixedCurlCurlIntegrator>  t = jlModule.add_type<mfem::MixedCurlCurlIntegrator>("mfem!MixedCurlCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCurlCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCurlCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedCurlCurlIntegrator::MixedCurlCurlIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1238:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedCurlCurlIntegrator::MixedCurlCurlIntegrator(mfem::DiagonalMatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1240:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedCurlCurlIntegrator::MixedCurlCurlIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1242:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedCurlCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedCurlCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1245:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedCurlCurlIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedCurlCurlIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedCurlCurlIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedCurlCurlIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1256:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCurlCurlIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCurlCurlIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedCurlCurlIntegrator::GetTrialVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCurlCurlIntegrator::GetTrialVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1263:23
    t.method("GetTrialVDim", static_cast<int (mfem::MixedCurlCurlIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCurlCurlIntegrator::GetTrialVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCurlCurlIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCurlCurlIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1266:24
    t.method("CalcTrialShape", static_cast<void (mfem::MixedCurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCurlCurlIntegrator::CalcTrialShape));

    DEBUG_MSG("Adding wrapper for int mfem::MixedCurlCurlIntegrator::GetTestVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCurlCurlIntegrator::GetTestVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1271:23
    t.method("GetTestVDim", static_cast<int (mfem::MixedCurlCurlIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCurlCurlIntegrator::GetTestVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCurlCurlIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCurlCurlIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1274:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedCurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCurlCurlIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCurlCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCurlCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCurlCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCrossCurlCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCrossCurlCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCrossCurlCurlIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCrossCurlCurlIntegrator
// signature to use in the veto file: mfem::MixedCrossCurlCurlIntegrator
struct Jlmfem_MixedCrossCurlCurlIntegrator: public Wrapper {

  Jlmfem_MixedCrossCurlCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCrossCurlCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1282:7
    jlcxx::TypeWrapper<mfem::MixedCrossCurlCurlIntegrator>  t = jlModule.add_type<mfem::MixedCrossCurlCurlIntegrator>("mfem!MixedCrossCurlCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossCurlCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCrossCurlCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossCurlCurlIntegrator::MixedCrossCurlCurlIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1285:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedCrossCurlCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedCrossCurlCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1288:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedCrossCurlCurlIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedCrossCurlCurlIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedCrossCurlCurlIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedCrossCurlCurlIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1300:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossCurlCurlIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossCurlCurlIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossCurlCurlIntegrator::GetTrialVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossCurlCurlIntegrator::GetTrialVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1307:23
    t.method("GetTrialVDim", static_cast<int (mfem::MixedCrossCurlCurlIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossCurlCurlIntegrator::GetTrialVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossCurlCurlIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossCurlCurlIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1310:24
    t.method("CalcTrialShape", static_cast<void (mfem::MixedCrossCurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossCurlCurlIntegrator::CalcTrialShape));

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossCurlCurlIntegrator::GetTestVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossCurlCurlIntegrator::GetTestVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1315:23
    t.method("GetTestVDim", static_cast<int (mfem::MixedCrossCurlCurlIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossCurlCurlIntegrator::GetTestVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossCurlCurlIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossCurlCurlIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1318:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedCrossCurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossCurlCurlIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossCurlCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCrossCurlCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCrossCurlCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCrossCurlGradIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCrossCurlGradIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCrossCurlGradIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCrossCurlGradIntegrator
// signature to use in the veto file: mfem::MixedCrossCurlGradIntegrator
struct Jlmfem_MixedCrossCurlGradIntegrator: public Wrapper {

  Jlmfem_MixedCrossCurlGradIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCrossCurlGradIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1326:7
    jlcxx::TypeWrapper<mfem::MixedCrossCurlGradIntegrator>  t = jlModule.add_type<mfem::MixedCrossCurlGradIntegrator>("mfem!MixedCrossCurlGradIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossCurlGradIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCrossCurlGradIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossCurlGradIntegrator::MixedCrossCurlGradIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1329:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedCrossCurlGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedCrossCurlGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1332:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedCrossCurlGradIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedCrossCurlGradIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedCrossCurlGradIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedCrossCurlGradIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1343:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossCurlGradIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossCurlGradIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossCurlGradIntegrator::GetTrialVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossCurlGradIntegrator::GetTrialVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1350:23
    t.method("GetTrialVDim", static_cast<int (mfem::MixedCrossCurlGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossCurlGradIntegrator::GetTrialVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossCurlGradIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossCurlGradIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1353:24
    t.method("CalcTrialShape", static_cast<void (mfem::MixedCrossCurlGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossCurlGradIntegrator::CalcTrialShape));

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossCurlGradIntegrator::GetTestVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossCurlGradIntegrator::GetTestVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1358:23
    t.method("GetTestVDim", static_cast<int (mfem::MixedCrossCurlGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossCurlGradIntegrator::GetTestVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossCurlGradIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossCurlGradIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1361:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedCrossCurlGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossCurlGradIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossCurlGradIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCrossCurlGradIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCrossCurlGradIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCrossGradCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCrossGradCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCrossGradCurlIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCrossGradCurlIntegrator
// signature to use in the veto file: mfem::MixedCrossGradCurlIntegrator
struct Jlmfem_MixedCrossGradCurlIntegrator: public Wrapper {

  Jlmfem_MixedCrossGradCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCrossGradCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1369:7
    jlcxx::TypeWrapper<mfem::MixedCrossGradCurlIntegrator>  t = jlModule.add_type<mfem::MixedCrossGradCurlIntegrator>("mfem!MixedCrossGradCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossGradCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCrossGradCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradCurlIntegrator::MixedCrossGradCurlIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1372:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedCrossGradCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedCrossGradCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1375:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedCrossGradCurlIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedCrossGradCurlIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedCrossGradCurlIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedCrossGradCurlIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1386:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossGradCurlIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossGradCurlIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossGradCurlIntegrator::GetTrialVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossGradCurlIntegrator::GetTrialVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1393:23
    t.method("GetTrialVDim", static_cast<int (mfem::MixedCrossGradCurlIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossGradCurlIntegrator::GetTrialVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradCurlIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossGradCurlIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1396:24
    t.method("CalcTrialShape", static_cast<void (mfem::MixedCrossGradCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossGradCurlIntegrator::CalcTrialShape));

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossGradCurlIntegrator::GetTestVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossGradCurlIntegrator::GetTestVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1401:23
    t.method("GetTestVDim", static_cast<int (mfem::MixedCrossGradCurlIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossGradCurlIntegrator::GetTestVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradCurlIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossGradCurlIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1404:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedCrossGradCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossGradCurlIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossGradCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCrossGradCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCrossGradCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedWeakCurlCrossIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedWeakCurlCrossIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedWeakCurlCrossIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedWeakCurlCrossIntegrator
// signature to use in the veto file: mfem::MixedWeakCurlCrossIntegrator
struct Jlmfem_MixedWeakCurlCrossIntegrator: public Wrapper {

  Jlmfem_MixedWeakCurlCrossIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedWeakCurlCrossIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1413:7
    jlcxx::TypeWrapper<mfem::MixedWeakCurlCrossIntegrator>  t = jlModule.add_type<mfem::MixedWeakCurlCrossIntegrator>("mfem!MixedWeakCurlCrossIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedWeakCurlCrossIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedWeakCurlCrossIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedWeakCurlCrossIntegrator::MixedWeakCurlCrossIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1416:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedWeakCurlCrossIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedWeakCurlCrossIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1419:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedWeakCurlCrossIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedWeakCurlCrossIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedWeakCurlCrossIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedWeakCurlCrossIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1429:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedWeakCurlCrossIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedWeakCurlCrossIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedWeakCurlCrossIntegrator::GetTestVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedWeakCurlCrossIntegrator::GetTestVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1436:23
    t.method("GetTestVDim", static_cast<int (mfem::MixedWeakCurlCrossIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedWeakCurlCrossIntegrator::GetTestVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedWeakCurlCrossIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedWeakCurlCrossIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1439:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedWeakCurlCrossIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedWeakCurlCrossIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedWeakCurlCrossIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedWeakCurlCrossIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedWeakCurlCrossIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarWeakCurlCrossIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarWeakCurlCrossIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarWeakCurlCrossIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarWeakCurlCrossIntegrator
// signature to use in the veto file: mfem::MixedScalarWeakCurlCrossIntegrator
struct Jlmfem_MixedScalarWeakCurlCrossIntegrator: public Wrapper {

  Jlmfem_MixedScalarWeakCurlCrossIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarWeakCurlCrossIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1448:7
    jlcxx::TypeWrapper<mfem::MixedScalarWeakCurlCrossIntegrator>  t = jlModule.add_type<mfem::MixedScalarWeakCurlCrossIntegrator>("mfem!MixedScalarWeakCurlCrossIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakCurlCrossIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarWeakCurlCrossIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakCurlCrossIntegrator::MixedScalarWeakCurlCrossIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1451:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedScalarWeakCurlCrossIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedScalarWeakCurlCrossIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1454:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedScalarWeakCurlCrossIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedScalarWeakCurlCrossIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedScalarWeakCurlCrossIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedScalarWeakCurlCrossIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1464:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarWeakCurlCrossIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarWeakCurlCrossIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakCurlCrossIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarWeakCurlCrossIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1471:24
    t.method("CalcShape", static_cast<void (mfem::MixedScalarWeakCurlCrossIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::MixedScalarWeakCurlCrossIntegrator::CalcShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakCurlCrossIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakCurlCrossIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarWeakCurlCrossIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCrossGradIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCrossGradIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCrossGradIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCrossGradIntegrator
// signature to use in the veto file: mfem::MixedCrossGradIntegrator
struct Jlmfem_MixedCrossGradIntegrator: public Wrapper {

  Jlmfem_MixedCrossGradIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCrossGradIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1483:7
    jlcxx::TypeWrapper<mfem::MixedCrossGradIntegrator>  t = jlModule.add_type<mfem::MixedCrossGradIntegrator>("mfem!MixedCrossGradIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossGradIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCrossGradIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradIntegrator::MixedCrossGradIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1486:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedCrossGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedCrossGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1489:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedCrossGradIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedCrossGradIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedCrossGradIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedCrossGradIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1499:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossGradIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossGradIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossGradIntegrator::GetTrialVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossGradIntegrator::GetTrialVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1506:23
    t.method("GetTrialVDim", static_cast<int (mfem::MixedCrossGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossGradIntegrator::GetTrialVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossGradIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1509:24
    t.method("CalcTrialShape", static_cast<void (mfem::MixedCrossGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossGradIntegrator::CalcTrialShape));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossGradIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossGradIntegrator::CalcTestShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1514:24
    t.method("CalcTestShape", static_cast<void (mfem::MixedCrossGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossGradIntegrator::CalcTestShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossGradIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCrossGradIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCrossGradIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCrossCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCrossCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCrossCurlIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCrossCurlIntegrator
// signature to use in the veto file: mfem::MixedCrossCurlIntegrator
struct Jlmfem_MixedCrossCurlIntegrator: public Wrapper {

  Jlmfem_MixedCrossCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCrossCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1523:7
    jlcxx::TypeWrapper<mfem::MixedCrossCurlIntegrator>  t = jlModule.add_type<mfem::MixedCrossCurlIntegrator>("mfem!MixedCrossCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCrossCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossCurlIntegrator::MixedCrossCurlIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1526:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedCrossCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedCrossCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1529:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedCrossCurlIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedCrossCurlIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedCrossCurlIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedCrossCurlIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1539:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossCurlIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedCrossCurlIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedCrossCurlIntegrator::GetTrialVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedCrossCurlIntegrator::GetTrialVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1546:23
    t.method("GetTrialVDim", static_cast<int (mfem::MixedCrossCurlIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedCrossCurlIntegrator::GetTrialVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedCrossCurlIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCrossCurlIntegrator::CalcTrialShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1549:24
    t.method("CalcTrialShape", static_cast<void (mfem::MixedCrossCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCrossCurlIntegrator::CalcTrialShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCrossCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCrossCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCrossCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarCrossCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarCrossCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarCrossCurlIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarCrossCurlIntegrator
// signature to use in the veto file: mfem::MixedScalarCrossCurlIntegrator
struct Jlmfem_MixedScalarCrossCurlIntegrator: public Wrapper {

  Jlmfem_MixedScalarCrossCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarCrossCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1558:7
    jlcxx::TypeWrapper<mfem::MixedScalarCrossCurlIntegrator>  t = jlModule.add_type<mfem::MixedScalarCrossCurlIntegrator>("mfem!MixedScalarCrossCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarCrossCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarCrossCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarCrossCurlIntegrator::MixedScalarCrossCurlIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1561:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedScalarCrossCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedScalarCrossCurlIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1564:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedScalarCrossCurlIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedScalarCrossCurlIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedScalarCrossCurlIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedScalarCrossCurlIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1574:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarCrossCurlIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarCrossCurlIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarCrossCurlIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarCrossCurlIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1581:24
    t.method("CalcShape", static_cast<void (mfem::MixedScalarCrossCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::MixedScalarCrossCurlIntegrator::CalcShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarCrossCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarCrossCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarCrossCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarCrossGradIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarCrossGradIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarCrossGradIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarCrossGradIntegrator
// signature to use in the veto file: mfem::MixedScalarCrossGradIntegrator
struct Jlmfem_MixedScalarCrossGradIntegrator: public Wrapper {

  Jlmfem_MixedScalarCrossGradIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarCrossGradIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1592:7
    jlcxx::TypeWrapper<mfem::MixedScalarCrossGradIntegrator>  t = jlModule.add_type<mfem::MixedScalarCrossGradIntegrator>("mfem!MixedScalarCrossGradIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarCrossGradIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarCrossGradIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarCrossGradIntegrator::MixedScalarCrossGradIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1595:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedScalarCrossGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedScalarCrossGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1598:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedScalarCrossGradIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedScalarCrossGradIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedScalarCrossGradIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedScalarCrossGradIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1608:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarCrossGradIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarCrossGradIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedScalarCrossGradIntegrator::GetVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedScalarCrossGradIntegrator::GetVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1615:15
    t.method("GetVDim", static_cast<int (mfem::MixedScalarCrossGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedScalarCrossGradIntegrator::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarCrossGradIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarCrossGradIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1618:24
    t.method("CalcVShape", static_cast<void (mfem::MixedScalarCrossGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedScalarCrossGradIntegrator::CalcVShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarCrossGradIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarCrossGradIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarCrossGradIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarCrossProductIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarCrossProductIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarCrossProductIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarCrossProductIntegrator
// signature to use in the veto file: mfem::MixedScalarCrossProductIntegrator
struct Jlmfem_MixedScalarCrossProductIntegrator: public Wrapper {

  Jlmfem_MixedScalarCrossProductIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarCrossProductIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1626:7
    jlcxx::TypeWrapper<mfem::MixedScalarCrossProductIntegrator>  t = jlModule.add_type<mfem::MixedScalarCrossProductIntegrator>("mfem!MixedScalarCrossProductIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarCrossProductIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarCrossProductIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarCrossProductIntegrator::MixedScalarCrossProductIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1629:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedScalarCrossProductIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedScalarCrossProductIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1632:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedScalarCrossProductIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedScalarCrossProductIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedScalarCrossProductIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedScalarCrossProductIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1641:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarCrossProductIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarCrossProductIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarCrossProductIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarCrossProductIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarCrossProductIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarWeakCrossProductIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarWeakCrossProductIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarWeakCrossProductIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarWeakCrossProductIntegrator
// signature to use in the veto file: mfem::MixedScalarWeakCrossProductIntegrator
struct Jlmfem_MixedScalarWeakCrossProductIntegrator: public Wrapper {

  Jlmfem_MixedScalarWeakCrossProductIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarWeakCrossProductIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1654:7
    jlcxx::TypeWrapper<mfem::MixedScalarWeakCrossProductIntegrator>  t = jlModule.add_type<mfem::MixedScalarWeakCrossProductIntegrator>("mfem!MixedScalarWeakCrossProductIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakCrossProductIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarWeakCrossProductIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakCrossProductIntegrator::MixedScalarWeakCrossProductIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1657:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedScalarWeakCrossProductIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedScalarWeakCrossProductIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1660:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedScalarWeakCrossProductIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedScalarWeakCrossProductIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedScalarWeakCrossProductIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedScalarWeakCrossProductIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1669:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarWeakCrossProductIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarWeakCrossProductIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakCrossProductIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarWeakCrossProductIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1676:24
    t.method("CalcShape", static_cast<void (mfem::MixedScalarWeakCrossProductIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::MixedScalarWeakCrossProductIntegrator::CalcShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakCrossProductIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakCrossProductIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarWeakCrossProductIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedDirectionalDerivativeIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedDirectionalDerivativeIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedDirectionalDerivativeIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedDirectionalDerivativeIntegrator
// signature to use in the veto file: mfem::MixedDirectionalDerivativeIntegrator
struct Jlmfem_MixedDirectionalDerivativeIntegrator: public Wrapper {

  Jlmfem_MixedDirectionalDerivativeIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedDirectionalDerivativeIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1684:7
    jlcxx::TypeWrapper<mfem::MixedDirectionalDerivativeIntegrator>  t = jlModule.add_type<mfem::MixedDirectionalDerivativeIntegrator>("mfem!MixedDirectionalDerivativeIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedDirectionalDerivativeIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedDirectionalDerivativeIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedDirectionalDerivativeIntegrator::MixedDirectionalDerivativeIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1687:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedDirectionalDerivativeIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedDirectionalDerivativeIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1690:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedDirectionalDerivativeIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedDirectionalDerivativeIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedDirectionalDerivativeIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedDirectionalDerivativeIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1699:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedDirectionalDerivativeIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedDirectionalDerivativeIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedDirectionalDerivativeIntegrator::GetVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedDirectionalDerivativeIntegrator::GetVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1706:23
    t.method("GetVDim", static_cast<int (mfem::MixedDirectionalDerivativeIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedDirectionalDerivativeIntegrator::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedDirectionalDerivativeIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedDirectionalDerivativeIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1709:24
    t.method("CalcVShape", static_cast<void (mfem::MixedDirectionalDerivativeIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedDirectionalDerivativeIntegrator::CalcVShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedDirectionalDerivativeIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedDirectionalDerivativeIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedDirectionalDerivativeIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedGradDivIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedGradDivIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedGradDivIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedGradDivIntegrator
// signature to use in the veto file: mfem::MixedGradDivIntegrator
struct Jlmfem_MixedGradDivIntegrator: public Wrapper {

  Jlmfem_MixedGradDivIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedGradDivIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1717:7
    jlcxx::TypeWrapper<mfem::MixedGradDivIntegrator>  t = jlModule.add_type<mfem::MixedGradDivIntegrator>("mfem!MixedGradDivIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedGradDivIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedGradDivIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedGradDivIntegrator::MixedGradDivIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1720:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedGradDivIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedGradDivIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1723:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedGradDivIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedGradDivIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedGradDivIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedGradDivIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1733:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedGradDivIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedGradDivIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedGradDivIntegrator::GetVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedGradDivIntegrator::GetVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1740:23
    t.method("GetVDim", static_cast<int (mfem::MixedGradDivIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedGradDivIntegrator::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedGradDivIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedGradDivIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1743:24
    t.method("CalcVShape", static_cast<void (mfem::MixedGradDivIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedGradDivIntegrator::CalcVShape));

    DEBUG_MSG("Adding wrapper for void mfem::MixedGradDivIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedGradDivIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1748:24
    t.method("CalcShape", static_cast<void (mfem::MixedGradDivIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::MixedGradDivIntegrator::CalcShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedGradDivIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedGradDivIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedGradDivIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedDivGradIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedDivGradIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedDivGradIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedDivGradIntegrator
// signature to use in the veto file: mfem::MixedDivGradIntegrator
struct Jlmfem_MixedDivGradIntegrator: public Wrapper {

  Jlmfem_MixedDivGradIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedDivGradIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1756:7
    jlcxx::TypeWrapper<mfem::MixedDivGradIntegrator>  t = jlModule.add_type<mfem::MixedDivGradIntegrator>("mfem!MixedDivGradIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedDivGradIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedDivGradIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedDivGradIntegrator::MixedDivGradIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1759:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedDivGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedDivGradIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1762:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedDivGradIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedDivGradIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedDivGradIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedDivGradIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1773:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedDivGradIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedDivGradIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedDivGradIntegrator::GetVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedDivGradIntegrator::GetVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1780:23
    t.method("GetVDim", static_cast<int (mfem::MixedDivGradIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedDivGradIntegrator::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedDivGradIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedDivGradIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1783:24
    t.method("CalcVShape", static_cast<void (mfem::MixedDivGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedDivGradIntegrator::CalcVShape));

    DEBUG_MSG("Adding wrapper for void mfem::MixedDivGradIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedDivGradIntegrator::CalcShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1788:24
    t.method("CalcShape", static_cast<void (mfem::MixedDivGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::MixedDivGradIntegrator::CalcShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedDivGradIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedDivGradIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedDivGradIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedScalarWeakDivergenceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedScalarWeakDivergenceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedScalarWeakDivergenceIntegrator> { typedef mfem::MixedScalarVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedScalarWeakDivergenceIntegrator
// signature to use in the veto file: mfem::MixedScalarWeakDivergenceIntegrator
struct Jlmfem_MixedScalarWeakDivergenceIntegrator: public Wrapper {

  Jlmfem_MixedScalarWeakDivergenceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedScalarWeakDivergenceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1796:7
    jlcxx::TypeWrapper<mfem::MixedScalarWeakDivergenceIntegrator>  t = jlModule.add_type<mfem::MixedScalarWeakDivergenceIntegrator>("mfem!MixedScalarWeakDivergenceIntegrator",
      jlcxx::julia_base_type<mfem::MixedScalarVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakDivergenceIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedScalarWeakDivergenceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakDivergenceIntegrator::MixedScalarWeakDivergenceIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1799:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::MixedScalarWeakDivergenceIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MixedScalarWeakDivergenceIntegrator::VerifyFiniteElementTypes(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1802:24
    t.method("VerifyFiniteElementTypes", static_cast<bool (mfem::MixedScalarWeakDivergenceIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &)  const>(&mfem::MixedScalarWeakDivergenceIntegrator::VerifyFiniteElementTypes));

    DEBUG_MSG("Adding wrapper for const char * mfem::MixedScalarWeakDivergenceIntegrator::FiniteElementTypeFailureMessage() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::MixedScalarWeakDivergenceIntegrator::FiniteElementTypeFailureMessage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1811:32
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarWeakDivergenceIntegrator const& a) { return (std::string)a.FiniteElementTypeFailureMessage(); });
    t.method("FiniteElementTypeFailureMessage", [](mfem::MixedScalarWeakDivergenceIntegrator const* a) { return (std::string)a->FiniteElementTypeFailureMessage(); });

    DEBUG_MSG("Adding wrapper for int mfem::MixedScalarWeakDivergenceIntegrator::GetVDim(const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::MixedScalarWeakDivergenceIntegrator::GetVDim(const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1818:15
    t.method("GetVDim", static_cast<int (mfem::MixedScalarWeakDivergenceIntegrator::*)(const mfem::FiniteElement &) >(&mfem::MixedScalarWeakDivergenceIntegrator::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::MixedScalarWeakDivergenceIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedScalarWeakDivergenceIntegrator::CalcVShape(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1821:24
    t.method("CalcVShape", static_cast<void (mfem::MixedScalarWeakDivergenceIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedScalarWeakDivergenceIntegrator::CalcVShape));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedScalarWeakDivergenceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakDivergenceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedScalarWeakDivergenceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedVectorGradientIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedVectorGradientIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedVectorGradientIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedVectorGradientIntegrator
// signature to use in the veto file: mfem::MixedVectorGradientIntegrator
struct Jlmfem_MixedVectorGradientIntegrator: public Wrapper {

  Jlmfem_MixedVectorGradientIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedVectorGradientIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1833:7
    jlcxx::TypeWrapper<mfem::MixedVectorGradientIntegrator>  t = jlModule.add_type<mfem::MixedVectorGradientIntegrator>("mfem!MixedVectorGradientIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorGradientIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedVectorGradientIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorGradientIntegrator::MixedVectorGradientIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1837:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorGradientIntegrator::MixedVectorGradientIntegrator(mfem::DiagonalMatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1839:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorGradientIntegrator::MixedVectorGradientIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1841:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorGradientIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedVectorGradientIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedVectorGradientIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedVectorCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedVectorCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedVectorCurlIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedVectorCurlIntegrator
// signature to use in the veto file: mfem::MixedVectorCurlIntegrator
struct Jlmfem_MixedVectorCurlIntegrator: public Wrapper {

  Jlmfem_MixedVectorCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedVectorCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1891:7
    jlcxx::TypeWrapper<mfem::MixedVectorCurlIntegrator>  t = jlModule.add_type<mfem::MixedVectorCurlIntegrator>("mfem!MixedVectorCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedVectorCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorCurlIntegrator::MixedVectorCurlIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1895:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorCurlIntegrator::MixedVectorCurlIntegrator(mfem::DiagonalMatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1897:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorCurlIntegrator::MixedVectorCurlIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1899:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedVectorCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedVectorCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedVectorWeakCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedVectorWeakCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedVectorWeakCurlIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedVectorWeakCurlIntegrator
// signature to use in the veto file: mfem::MixedVectorWeakCurlIntegrator
struct Jlmfem_MixedVectorWeakCurlIntegrator: public Wrapper {

  Jlmfem_MixedVectorWeakCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedVectorWeakCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1950:7
    jlcxx::TypeWrapper<mfem::MixedVectorWeakCurlIntegrator>  t = jlModule.add_type<mfem::MixedVectorWeakCurlIntegrator>("mfem!MixedVectorWeakCurlIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorWeakCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedVectorWeakCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorWeakCurlIntegrator::MixedVectorWeakCurlIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1954:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorWeakCurlIntegrator::MixedVectorWeakCurlIntegrator(mfem::DiagonalMatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1956:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorWeakCurlIntegrator::MixedVectorWeakCurlIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:1958:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorWeakCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedVectorWeakCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedVectorWeakCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedVectorWeakDivergenceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedVectorWeakDivergenceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedVectorWeakDivergenceIntegrator> { typedef mfem::MixedVectorIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedVectorWeakDivergenceIntegrator
// signature to use in the veto file: mfem::MixedVectorWeakDivergenceIntegrator
struct Jlmfem_MixedVectorWeakDivergenceIntegrator: public Wrapper {

  Jlmfem_MixedVectorWeakDivergenceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedVectorWeakDivergenceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2007:7
    jlcxx::TypeWrapper<mfem::MixedVectorWeakDivergenceIntegrator>  t = jlModule.add_type<mfem::MixedVectorWeakDivergenceIntegrator>("mfem!MixedVectorWeakDivergenceIntegrator",
      jlcxx::julia_base_type<mfem::MixedVectorIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorWeakDivergenceIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedVectorWeakDivergenceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorWeakDivergenceIntegrator::MixedVectorWeakDivergenceIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2011:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorWeakDivergenceIntegrator::MixedVectorWeakDivergenceIntegrator(mfem::DiagonalMatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2013:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedVectorWeakDivergenceIntegrator::MixedVectorWeakDivergenceIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2015:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedVectorWeakDivergenceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedVectorWeakDivergenceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedVectorWeakDivergenceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GradientIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GradientIntegrator> : std::false_type { };
template<> struct SuperType<mfem::GradientIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::GradientIntegrator
// signature to use in the veto file: mfem::GradientIntegrator
struct Jlmfem_GradientIntegrator: public Wrapper {

  Jlmfem_GradientIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GradientIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2051:7
    jlcxx::TypeWrapper<mfem::GradientIntegrator>  t = jlModule.add_type<mfem::GradientIntegrator>("mfem!GradientIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GradientIntegrator>>(new jlcxx::TypeWrapper<mfem::GradientIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GradientIntegrator::GradientIntegrator(mfem::Coefficient *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2073:4
    t.constructor<mfem::Coefficient *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GradientIntegrator::GradientIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2076:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::GradientIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2080:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::GradientIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::GradientIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::GradientIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2086:17
    t.method("AssemblePA", static_cast<void (mfem::GradientIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) >(&mfem::GradientIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::GradientIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2089:17
    t.method("AddMultPA", static_cast<void (mfem::GradientIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::GradientIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::GradientIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2090:17
    t.method("AddMultTransposePA", static_cast<void (mfem::GradientIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::GradientIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::GradientIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::GradientIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2092:34
    module_.method("mfem!GradientIntegrator!GetRule", static_cast<const mfem::IntegrationRule & (*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) >(&mfem::GradientIntegrator::GetRule));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GradientIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GradientIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GradientIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DiffusionIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DiffusionIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DiffusionIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DiffusionIntegrator
// signature to use in the veto file: mfem::DiffusionIntegrator
struct Jlmfem_DiffusionIntegrator: public Wrapper {

  Jlmfem_DiffusionIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DiffusionIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2099:7
    jlcxx::TypeWrapper<mfem::DiffusionIntegrator>  t = jlModule.add_type<mfem::DiffusionIntegrator>("mfem!DiffusionIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DiffusionIntegrator>>(new jlcxx::TypeWrapper<mfem::DiffusionIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::DiffusionIntegrator(const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2177:4
    t.constructor<const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::DiffusionIntegrator(mfem::Coefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2182:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::DiffusionIntegrator(mfem::VectorCoefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2187:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::DiffusionIntegrator(mfem::MatrixCoefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2193:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::MatrixCoefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2200:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::DiffusionIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2205:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::DiffusionIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssemblePatchMatrix(const int, const mfem::FiniteElementSpace &, mfem::SparseMatrix *&) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssemblePatchMatrix(const int, const mfem::FiniteElementSpace &, mfem::SparseMatrix *&)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2210:17
    t.method("AssemblePatchMatrix", static_cast<void (mfem::DiffusionIntegrator::*)(const int, const mfem::FiniteElementSpace &, mfem::SparseMatrix *&) >(&mfem::DiffusionIntegrator::AssemblePatchMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssembleNURBSPA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssembleNURBSPA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2214:17
    t.method("AssembleNURBSPA", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::DiffusionIntegrator::AssembleNURBSPA));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssemblePatchPA(const int, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssemblePatchPA(const int, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2216:9
    t.method("AssemblePatchPA", static_cast<void (mfem::DiffusionIntegrator::*)(const int, const mfem::FiniteElementSpace &) >(&mfem::DiffusionIntegrator::AssemblePatchPA));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2219:17
    t.method("AssembleElementVector", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) >(&mfem::DiffusionIntegrator::AssembleElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::ComputeElementFlux(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::ComputeElementFlux(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2223:17
    t.method("ComputeElementFlux", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *) >(&mfem::DiffusionIntegrator::ComputeElementFlux));
    t.method("ComputeElementFlux", [](mfem::DiffusionIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4)->void { a.ComputeElementFlux(arg0, arg1, arg2, arg3, arg4); });
    t.method("ComputeElementFlux", [](mfem::DiffusionIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4, bool arg5)->void { a.ComputeElementFlux(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("ComputeElementFlux", [](mfem::DiffusionIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4)->void { a->ComputeElementFlux(arg0, arg1, arg2, arg3, arg4); });
    t.method("ComputeElementFlux", [](mfem::DiffusionIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4, bool arg5)->void { a->ComputeElementFlux(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for double mfem::DiffusionIntegrator::ComputeFluxEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DiffusionIntegrator::ComputeFluxEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2229:19
    t.method("ComputeFluxEnergy", static_cast<double (mfem::DiffusionIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *) >(&mfem::DiffusionIntegrator::ComputeFluxEnergy));
    t.method("ComputeFluxEnergy", [](mfem::DiffusionIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2)->double { return a.ComputeFluxEnergy(arg0, arg1, arg2); });
    t.method("ComputeFluxEnergy", [](mfem::DiffusionIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2)->double { return a->ComputeFluxEnergy(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2235:17
    t.method("AssembleMF", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::DiffusionIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2237:17
    t.method("AssemblePA", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::DiffusionIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2239:17
    t.method("AssembleEA", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::DiffusionIntegrator::AssembleEA));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2242:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::DiffusionIntegrator::*)(mfem::Vector &) >(&mfem::DiffusionIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AssembleDiagonalMF(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AssembleDiagonalMF(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2244:17
    t.method("AssembleDiagonalMF", static_cast<void (mfem::DiffusionIntegrator::*)(mfem::Vector &) >(&mfem::DiffusionIntegrator::AssembleDiagonalMF));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2246:17
    t.method("AddMultMF", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DiffusionIntegrator::AddMultMF));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2248:17
    t.method("AddMultPA", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DiffusionIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2250:17
    t.method("AddMultTransposePA", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DiffusionIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AddMultNURBSPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AddMultNURBSPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2252:17
    t.method("AddMultNURBSPA", static_cast<void (mfem::DiffusionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DiffusionIntegrator::AddMultNURBSPA));

    DEBUG_MSG("Adding wrapper for void mfem::DiffusionIntegrator::AddMultPatchPA(const int, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiffusionIntegrator::AddMultPatchPA(const int, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2254:9
    t.method("AddMultPatchPA", static_cast<void (mfem::DiffusionIntegrator::*)(const int, const mfem::Vector &, mfem::Vector &)  const>(&mfem::DiffusionIntegrator::AddMultPatchPA));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::DiffusionIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::DiffusionIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2256:34
    module_.method("mfem!DiffusionIntegrator!GetRule", static_cast<const mfem::IntegrationRule & (*)(const mfem::FiniteElement &, const mfem::FiniteElement &) >(&mfem::DiffusionIntegrator::GetRule));

    DEBUG_MSG("Adding wrapper for bool mfem::DiffusionIntegrator::SupportsCeed() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::DiffusionIntegrator::SupportsCeed()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2259:9
    t.method("SupportsCeed", static_cast<bool (mfem::DiffusionIntegrator::*)()  const>(&mfem::DiffusionIntegrator::SupportsCeed));

    DEBUG_MSG("Adding wrapper for mfem::Coefficient * mfem::DiffusionIntegrator::GetCoefficient() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Coefficient * mfem::DiffusionIntegrator::GetCoefficient()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2261:17
    t.method("GetCoefficient", static_cast<mfem::Coefficient * (mfem::DiffusionIntegrator::*)()  const>(&mfem::DiffusionIntegrator::GetCoefficient));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DiffusionIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DiffusionIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DiffusionIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MassIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MassIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MassIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::MassIntegrator
// signature to use in the veto file: mfem::MassIntegrator
struct Jlmfem_MassIntegrator: public Wrapper {

  Jlmfem_MassIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MassIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2265:7
    jlcxx::TypeWrapper<mfem::MassIntegrator>  t = jlModule.add_type<mfem::MassIntegrator>("mfem!MassIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MassIntegrator>>(new jlcxx::TypeWrapper<mfem::MassIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::MassIntegrator(const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2282:4
    t.constructor<const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::MassIntegrator(mfem::Coefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2286:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2291:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::MassIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MassIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2294:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::MassIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MassIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2301:17
    t.method("AssembleMF", static_cast<void (mfem::MassIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::MassIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2303:17
    t.method("AssemblePA", static_cast<void (mfem::MassIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::MassIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AssemblePABoundary(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AssemblePABoundary(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2305:17
    t.method("AssemblePABoundary", static_cast<void (mfem::MassIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::MassIntegrator::AssemblePABoundary));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2307:17
    t.method("AssembleEA", static_cast<void (mfem::MassIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::MassIntegrator::AssembleEA));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2310:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::MassIntegrator::*)(mfem::Vector &) >(&mfem::MassIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AssembleDiagonalMF(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AssembleDiagonalMF(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2312:17
    t.method("AssembleDiagonalMF", static_cast<void (mfem::MassIntegrator::*)(mfem::Vector &) >(&mfem::MassIntegrator::AssembleDiagonalMF));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2314:17
    t.method("AddMultMF", static_cast<void (mfem::MassIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MassIntegrator::AddMultMF));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2316:17
    t.method("AddMultPA", static_cast<void (mfem::MassIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MassIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::MassIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MassIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2318:17
    t.method("AddMultTransposePA", static_cast<void (mfem::MassIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MassIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::MassIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::MassIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2320:34
    module_.method("mfem!MassIntegrator!GetRule", static_cast<const mfem::IntegrationRule & (*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) >(&mfem::MassIntegrator::GetRule));

    DEBUG_MSG("Adding wrapper for bool mfem::MassIntegrator::SupportsCeed() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::MassIntegrator::SupportsCeed()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2324:9
    t.method("SupportsCeed", static_cast<bool (mfem::MassIntegrator::*)()  const>(&mfem::MassIntegrator::SupportsCeed));

    DEBUG_MSG("Adding wrapper for const mfem::Coefficient * mfem::MassIntegrator::GetCoefficient() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Coefficient * mfem::MassIntegrator::GetCoefficient()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2326:23
    t.method("GetCoefficient", static_cast<const mfem::Coefficient * (mfem::MassIntegrator::*)()  const>(&mfem::MassIntegrator::GetCoefficient));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MassIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MassIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MassIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BoundaryMassIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BoundaryMassIntegrator> : std::false_type { };
template<> struct SuperType<mfem::BoundaryMassIntegrator> { typedef mfem::MassIntegrator type; };
}

// Class generating the wrapper for type mfem::BoundaryMassIntegrator
// signature to use in the veto file: mfem::BoundaryMassIntegrator
struct Jlmfem_BoundaryMassIntegrator: public Wrapper {

  Jlmfem_BoundaryMassIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BoundaryMassIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2330:7
    jlcxx::TypeWrapper<mfem::BoundaryMassIntegrator>  t = jlModule.add_type<mfem::BoundaryMassIntegrator>("mfem!BoundaryMassIntegrator",
      jlcxx::julia_base_type<mfem::MassIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryMassIntegrator>>(new jlcxx::TypeWrapper<mfem::BoundaryMassIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BoundaryMassIntegrator::BoundaryMassIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2333:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryMassIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryMassIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2337:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::BoundaryMassIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::BoundaryMassIntegrator::AssembleFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryMassIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BoundaryMassIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BoundaryMassIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ConvectionIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ConvectionIntegrator> : std::false_type { };
template<> struct SuperType<mfem::ConvectionIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::ConvectionIntegrator
// signature to use in the veto file: mfem::ConvectionIntegrator
struct Jlmfem_ConvectionIntegrator: public Wrapper {

  Jlmfem_ConvectionIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ConvectionIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2344:7
    jlcxx::TypeWrapper<mfem::ConvectionIntegrator>  t = jlModule.add_type<mfem::ConvectionIntegrator>("mfem!ConvectionIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ConvectionIntegrator>>(new jlcxx::TypeWrapper<mfem::ConvectionIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::ConvectionIntegrator(mfem::VectorCoefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2362:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2365:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::ConvectionIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::ConvectionIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2371:17
    t.method("AssembleMF", static_cast<void (mfem::ConvectionIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::ConvectionIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2373:17
    t.method("AssemblePA", static_cast<void (mfem::ConvectionIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::ConvectionIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2375:17
    t.method("AssembleEA", static_cast<void (mfem::ConvectionIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::ConvectionIntegrator::AssembleEA));

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2378:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::ConvectionIntegrator::*)(mfem::Vector &) >(&mfem::ConvectionIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AssembleDiagonalMF(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AssembleDiagonalMF(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2380:17
    t.method("AssembleDiagonalMF", static_cast<void (mfem::ConvectionIntegrator::*)(mfem::Vector &) >(&mfem::ConvectionIntegrator::AssembleDiagonalMF));

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2382:17
    t.method("AddMultMF", static_cast<void (mfem::ConvectionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ConvectionIntegrator::AddMultMF));

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2384:17
    t.method("AddMultPA", static_cast<void (mfem::ConvectionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ConvectionIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::ConvectionIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ConvectionIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2386:17
    t.method("AddMultTransposePA", static_cast<void (mfem::ConvectionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ConvectionIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::ConvectionIntegrator::GetRule(const mfem::FiniteElement &, mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::ConvectionIntegrator::GetRule(const mfem::FiniteElement &, mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2388:34
    module_.method("mfem!ConvectionIntegrator!GetRule", static_cast<const mfem::IntegrationRule & (*)(const mfem::FiniteElement &, mfem::ElementTransformation &) >(&mfem::ConvectionIntegrator::GetRule));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::ConvectionIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::ConvectionIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2391:34
    module_.method("mfem!ConvectionIntegrator!GetRule", static_cast<const mfem::IntegrationRule & (*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) >(&mfem::ConvectionIntegrator::GetRule));

    DEBUG_MSG("Adding wrapper for bool mfem::ConvectionIntegrator::SupportsCeed() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::ConvectionIntegrator::SupportsCeed()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2395:9
    t.method("SupportsCeed", static_cast<bool (mfem::ConvectionIntegrator::*)()  const>(&mfem::ConvectionIntegrator::SupportsCeed));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ConvectionIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ConvectionIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ConvectionIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ConservativeConvectionIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ConservativeConvectionIntegrator> : std::false_type { };
template<> struct SuperType<mfem::ConservativeConvectionIntegrator> { typedef mfem::TransposeIntegrator type; };
}

// Class generating the wrapper for type mfem::ConservativeConvectionIntegrator
// signature to use in the veto file: mfem::ConservativeConvectionIntegrator
struct Jlmfem_ConservativeConvectionIntegrator: public Wrapper {

  Jlmfem_ConservativeConvectionIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ConservativeConvectionIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2402:7
    jlcxx::TypeWrapper<mfem::ConservativeConvectionIntegrator>  t = jlModule.add_type<mfem::ConservativeConvectionIntegrator>("mfem!ConservativeConvectionIntegrator",
      jlcxx::julia_base_type<mfem::TransposeIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ConservativeConvectionIntegrator>>(new jlcxx::TypeWrapper<mfem::ConservativeConvectionIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ConservativeConvectionIntegrator::ConservativeConvectionIntegrator(mfem::VectorCoefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2405:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ConservativeConvectionIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ConservativeConvectionIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ConservativeConvectionIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GroupConvectionIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GroupConvectionIntegrator> : std::false_type { };
template<> struct SuperType<mfem::GroupConvectionIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::GroupConvectionIntegrator
// signature to use in the veto file: mfem::GroupConvectionIntegrator
struct Jlmfem_GroupConvectionIntegrator: public Wrapper {

  Jlmfem_GroupConvectionIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GroupConvectionIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2410:7
    jlcxx::TypeWrapper<mfem::GroupConvectionIntegrator>  t = jlModule.add_type<mfem::GroupConvectionIntegrator>("mfem!GroupConvectionIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GroupConvectionIntegrator>>(new jlcxx::TypeWrapper<mfem::GroupConvectionIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::GroupConvectionIntegrator::GroupConvectionIntegrator(mfem::VectorCoefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2421:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::GroupConvectionIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GroupConvectionIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2423:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::GroupConvectionIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::GroupConvectionIntegrator::AssembleElementMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GroupConvectionIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GroupConvectionIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GroupConvectionIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorMassIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorMassIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorMassIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorMassIntegrator
// signature to use in the veto file: mfem::VectorMassIntegrator
struct Jlmfem_VectorMassIntegrator: public Wrapper {

  Jlmfem_VectorMassIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorMassIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2431:7
    jlcxx::TypeWrapper<mfem::VectorMassIntegrator>  t = jlModule.add_type<mfem::VectorMassIntegrator>("mfem!VectorMassIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorMassIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorMassIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::VectorMassIntegrator(mfem::Coefficient &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2457:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::VectorMassIntegrator(mfem::Coefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2459:4
    t.constructor<mfem::Coefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::VectorMassIntegrator(mfem::VectorCoefficient &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2463:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::VectorMassIntegrator(mfem::MatrixCoefficient &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2466:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::MatrixCoefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::VectorMassIntegrator::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::VectorMassIntegrator::GetVDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2469:8
    t.method("GetVDim", static_cast<int (mfem::VectorMassIntegrator::*)()  const>(&mfem::VectorMassIntegrator::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::SetVDim(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::SetVDim(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2470:9
    t.method("SetVDim", static_cast<void (mfem::VectorMassIntegrator::*)(int) >(&mfem::VectorMassIntegrator::SetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2472:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::VectorMassIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorMassIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2475:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorMassIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorMassIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2480:17
    t.method("AssemblePA", static_cast<void (mfem::VectorMassIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::VectorMassIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2481:17
    t.method("AssembleMF", static_cast<void (mfem::VectorMassIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::VectorMassIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2482:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::VectorMassIntegrator::*)(mfem::Vector &) >(&mfem::VectorMassIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::AssembleDiagonalMF(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::AssembleDiagonalMF(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2483:17
    t.method("AssembleDiagonalMF", static_cast<void (mfem::VectorMassIntegrator::*)(mfem::Vector &) >(&mfem::VectorMassIntegrator::AssembleDiagonalMF));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2484:17
    t.method("AddMultPA", static_cast<void (mfem::VectorMassIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorMassIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorMassIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorMassIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2485:17
    t.method("AddMultMF", static_cast<void (mfem::VectorMassIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorMassIntegrator::AddMultMF));

    DEBUG_MSG("Adding wrapper for bool mfem::VectorMassIntegrator::SupportsCeed() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::VectorMassIntegrator::SupportsCeed()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2486:9
    t.method("SupportsCeed", static_cast<bool (mfem::VectorMassIntegrator::*)()  const>(&mfem::VectorMassIntegrator::SupportsCeed));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorMassIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorMassIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorMassIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFEDivergenceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFEDivergenceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFEDivergenceIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFEDivergenceIntegrator
// signature to use in the veto file: mfem::VectorFEDivergenceIntegrator
struct Jlmfem_VectorFEDivergenceIntegrator: public Wrapper {

  Jlmfem_VectorFEDivergenceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFEDivergenceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2498:7
    jlcxx::TypeWrapper<mfem::VectorFEDivergenceIntegrator>  t = jlModule.add_type<mfem::VectorFEDivergenceIntegrator>("mfem!VectorFEDivergenceIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEDivergenceIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFEDivergenceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDivergenceIntegrator::VectorFEDivergenceIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2524:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDivergenceIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDivergenceIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2525:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::VectorFEDivergenceIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorFEDivergenceIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDivergenceIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDivergenceIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2528:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorFEDivergenceIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorFEDivergenceIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDivergenceIntegrator::AssembleDiagonalPA_ADAt(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDivergenceIntegrator::AssembleDiagonalPA_ADAt(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2533:17
    t.method("AssembleDiagonalPA_ADAt", static_cast<void (mfem::VectorFEDivergenceIntegrator::*)(const mfem::Vector &, mfem::Vector &) >(&mfem::VectorFEDivergenceIntegrator::AssembleDiagonalPA_ADAt));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEDivergenceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFEDivergenceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFEDivergenceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFEWeakDivergenceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFEWeakDivergenceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFEWeakDivergenceIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFEWeakDivergenceIntegrator
// signature to use in the veto file: mfem::VectorFEWeakDivergenceIntegrator
struct Jlmfem_VectorFEWeakDivergenceIntegrator: public Wrapper {

  Jlmfem_VectorFEWeakDivergenceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFEWeakDivergenceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2539:7
    jlcxx::TypeWrapper<mfem::VectorFEWeakDivergenceIntegrator>  t = jlModule.add_type<mfem::VectorFEWeakDivergenceIntegrator>("mfem!VectorFEWeakDivergenceIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEWeakDivergenceIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFEWeakDivergenceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEWeakDivergenceIntegrator::VectorFEWeakDivergenceIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2554:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEWeakDivergenceIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEWeakDivergenceIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2555:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::VectorFEWeakDivergenceIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorFEWeakDivergenceIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2558:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorFEWeakDivergenceIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEWeakDivergenceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFEWeakDivergenceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFEWeakDivergenceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFECurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFECurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFECurlIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFECurlIntegrator
// signature to use in the veto file: mfem::VectorFECurlIntegrator
struct Jlmfem_VectorFECurlIntegrator: public Wrapper {

  Jlmfem_VectorFECurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFECurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2566:7
    jlcxx::TypeWrapper<mfem::VectorFECurlIntegrator>  t = jlModule.add_type<mfem::VectorFECurlIntegrator>("mfem!VectorFECurlIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFECurlIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFECurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFECurlIntegrator::VectorFECurlIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2580:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFECurlIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFECurlIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2581:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::VectorFECurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorFECurlIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFECurlIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFECurlIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2584:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorFECurlIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorFECurlIntegrator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFECurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFECurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFECurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DerivativeIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DerivativeIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DerivativeIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DerivativeIntegrator
// signature to use in the veto file: mfem::DerivativeIntegrator
struct Jlmfem_DerivativeIntegrator: public Wrapper {

  Jlmfem_DerivativeIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DerivativeIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2591:7
    jlcxx::TypeWrapper<mfem::DerivativeIntegrator>  t = jlModule.add_type<mfem::DerivativeIntegrator>("mfem!DerivativeIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DerivativeIntegrator>>(new jlcxx::TypeWrapper<mfem::DerivativeIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DerivativeIntegrator::DerivativeIntegrator(mfem::Coefficient &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2602:4
    t.constructor<mfem::Coefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DerivativeIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DerivativeIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2603:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::DerivativeIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::DerivativeIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::DerivativeIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DerivativeIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2607:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::DerivativeIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::DerivativeIntegrator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DerivativeIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DerivativeIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DerivativeIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CurlCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CurlCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::CurlCurlIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::CurlCurlIntegrator
// signature to use in the veto file: mfem::CurlCurlIntegrator
struct Jlmfem_CurlCurlIntegrator: public Wrapper {

  Jlmfem_CurlCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CurlCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2614:7
    jlcxx::TypeWrapper<mfem::CurlCurlIntegrator>  t = jlModule.add_type<mfem::CurlCurlIntegrator>("mfem!CurlCurlIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CurlCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::CurlCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::CurlCurlIntegrator(mfem::Coefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2641:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::CurlCurlIntegrator(mfem::DiagonalMatrixCoefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2643:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::DiagonalMatrixCoefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::CurlCurlIntegrator(mfem::MatrixCoefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2646:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::MatrixCoefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlCurlIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2651:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::CurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::CurlCurlIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlCurlIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2655:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::CurlCurlIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::CurlCurlIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::ComputeElementFlux(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlCurlIntegrator::ComputeElementFlux(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2660:17
    t.method("ComputeElementFlux", static_cast<void (mfem::CurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *) >(&mfem::CurlCurlIntegrator::ComputeElementFlux));
    t.method("ComputeElementFlux", [](mfem::CurlCurlIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4, bool arg5)->void { a.ComputeElementFlux(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("ComputeElementFlux", [](mfem::CurlCurlIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4, bool arg5)->void { a->ComputeElementFlux(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for double mfem::CurlCurlIntegrator::ComputeFluxEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::CurlCurlIntegrator::ComputeFluxEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2666:19
    t.method("ComputeFluxEnergy", static_cast<double (mfem::CurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *) >(&mfem::CurlCurlIntegrator::ComputeFluxEnergy));
    t.method("ComputeFluxEnergy", [](mfem::CurlCurlIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2)->double { return a.ComputeFluxEnergy(arg0, arg1, arg2); });
    t.method("ComputeFluxEnergy", [](mfem::CurlCurlIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2)->double { return a->ComputeFluxEnergy(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlCurlIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2671:17
    t.method("AssemblePA", static_cast<void (mfem::CurlCurlIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::CurlCurlIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlCurlIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2672:17
    t.method("AddMultPA", static_cast<void (mfem::CurlCurlIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::CurlCurlIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::CurlCurlIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlCurlIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2673:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::CurlCurlIntegrator::*)(mfem::Vector &) >(&mfem::CurlCurlIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for const mfem::Coefficient * mfem::CurlCurlIntegrator::GetCoefficient() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Coefficient * mfem::CurlCurlIntegrator::GetCoefficient()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2675:23
    t.method("GetCoefficient", static_cast<const mfem::Coefficient * (mfem::CurlCurlIntegrator::*)()  const>(&mfem::CurlCurlIntegrator::GetCoefficient));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CurlCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CurlCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CurlCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorCurlCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorCurlCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorCurlCurlIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorCurlCurlIntegrator
// signature to use in the veto file: mfem::VectorCurlCurlIntegrator
struct Jlmfem_VectorCurlCurlIntegrator: public Wrapper {

  Jlmfem_VectorCurlCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorCurlCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2680:7
    jlcxx::TypeWrapper<mfem::VectorCurlCurlIntegrator>  t = jlModule.add_type<mfem::VectorCurlCurlIntegrator>("mfem!VectorCurlCurlIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCurlCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorCurlCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorCurlCurlIntegrator::VectorCurlCurlIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2693:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorCurlCurlIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCurlCurlIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2696:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::VectorCurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorCurlCurlIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for double mfem::VectorCurlCurlIntegrator::GetElementEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::VectorCurlCurlIntegrator::GetElementEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2700:19
    t.method("GetElementEnergy", static_cast<double (mfem::VectorCurlCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &) >(&mfem::VectorCurlCurlIntegrator::GetElementEnergy));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCurlCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorCurlCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorCurlCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::MixedCurlIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::MixedCurlIntegrator
// signature to use in the veto file: mfem::MixedCurlIntegrator
struct Jlmfem_MixedCurlIntegrator: public Wrapper {

  Jlmfem_MixedCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2714:7
    jlcxx::TypeWrapper<mfem::MixedCurlIntegrator>  t = jlModule.add_type<mfem::MixedCurlIntegrator>("mfem!MixedCurlIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::MixedCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedCurlIntegrator::MixedCurlIntegrator(mfem::Coefficient *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2726:4
    t.constructor<mfem::Coefficient *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedCurlIntegrator::MixedCurlIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2727:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::MixedCurlIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedCurlIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2729:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::MixedCurlIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::MixedCurlIntegrator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFEMassIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFEMassIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFEMassIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFEMassIntegrator
// signature to use in the veto file: mfem::VectorFEMassIntegrator
struct Jlmfem_VectorFEMassIntegrator: public Wrapper {

  Jlmfem_VectorFEMassIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFEMassIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2739:7
    jlcxx::TypeWrapper<mfem::VectorFEMassIntegrator>  t = jlModule.add_type<mfem::VectorFEMassIntegrator>("mfem!VectorFEMassIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEMassIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFEMassIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::VectorFEMassIntegrator(mfem::Coefficient *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2771:4
    t.constructor<mfem::Coefficient *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::VectorFEMassIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2772:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::VectorFEMassIntegrator(mfem::DiagonalMatrixCoefficient *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2773:4
    t.constructor<mfem::DiagonalMatrixCoefficient *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::VectorFEMassIntegrator(mfem::DiagonalMatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2774:4
    t.constructor<mfem::DiagonalMatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::VectorFEMassIntegrator(mfem::MatrixCoefficient *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2775:4
    t.constructor<mfem::MatrixCoefficient *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::VectorFEMassIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2776:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEMassIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2778:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::VectorFEMassIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorFEMassIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEMassIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2781:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorFEMassIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorFEMassIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEMassIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2787:17
    t.method("AssemblePA", static_cast<void (mfem::VectorFEMassIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::VectorFEMassIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEMassIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2788:17
    t.method("AssemblePA", static_cast<void (mfem::VectorFEMassIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) >(&mfem::VectorFEMassIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEMassIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2790:17
    t.method("AddMultPA", static_cast<void (mfem::VectorFEMassIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorFEMassIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEMassIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2791:17
    t.method("AddMultTransposePA", static_cast<void (mfem::VectorFEMassIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorFEMassIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEMassIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEMassIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2792:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::VectorFEMassIntegrator::*)(mfem::Vector &) >(&mfem::VectorFEMassIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for const mfem::Coefficient * mfem::VectorFEMassIntegrator::GetCoefficient() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Coefficient * mfem::VectorFEMassIntegrator::GetCoefficient()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2794:23
    t.method("GetCoefficient", static_cast<const mfem::Coefficient * (mfem::VectorFEMassIntegrator::*)()  const>(&mfem::VectorFEMassIntegrator::GetCoefficient));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEMassIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFEMassIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFEMassIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorDivergenceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorDivergenceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorDivergenceIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorDivergenceIntegrator
// signature to use in the veto file: mfem::VectorDivergenceIntegrator
struct Jlmfem_VectorDivergenceIntegrator: public Wrapper {

  Jlmfem_VectorDivergenceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorDivergenceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2799:7
    jlcxx::TypeWrapper<mfem::VectorDivergenceIntegrator>  t = jlModule.add_type<mfem::VectorDivergenceIntegrator>("mfem!VectorDivergenceIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDivergenceIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorDivergenceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDivergenceIntegrator::VectorDivergenceIntegrator(mfem::Coefficient *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2821:4
    t.constructor<mfem::Coefficient *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDivergenceIntegrator::VectorDivergenceIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2824:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorDivergenceIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDivergenceIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2828:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorDivergenceIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorDivergenceIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDivergenceIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDivergenceIntegrator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2834:17
    t.method("AssemblePA", static_cast<void (mfem::VectorDivergenceIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) >(&mfem::VectorDivergenceIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDivergenceIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDivergenceIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2837:17
    t.method("AddMultPA", static_cast<void (mfem::VectorDivergenceIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorDivergenceIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDivergenceIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDivergenceIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2838:17
    t.method("AddMultTransposePA", static_cast<void (mfem::VectorDivergenceIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorDivergenceIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::VectorDivergenceIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::VectorDivergenceIntegrator::GetRule(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2840:34
    module_.method("mfem!VectorDivergenceIntegrator!GetRule", static_cast<const mfem::IntegrationRule & (*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &) >(&mfem::VectorDivergenceIntegrator::GetRule));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDivergenceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorDivergenceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorDivergenceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DivDivIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DivDivIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DivDivIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DivDivIntegrator
// signature to use in the veto file: mfem::DivDivIntegrator
struct Jlmfem_DivDivIntegrator: public Wrapper {

  Jlmfem_DivDivIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DivDivIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2846:7
    jlcxx::TypeWrapper<mfem::DivDivIntegrator>  t = jlModule.add_type<mfem::DivDivIntegrator>("mfem!DivDivIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DivDivIntegrator>>(new jlcxx::TypeWrapper<mfem::DivDivIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DivDivIntegrator::DivDivIntegrator(mfem::Coefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2870:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DivDivIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DivDivIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2873:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::DivDivIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::DivDivIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::DivDivIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DivDivIntegrator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2877:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::DivDivIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::DivDivIntegrator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for const mfem::Coefficient * mfem::DivDivIntegrator::GetCoefficient() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Coefficient * mfem::DivDivIntegrator::GetCoefficient()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2882:23
    t.method("GetCoefficient", static_cast<const mfem::Coefficient * (mfem::DivDivIntegrator::*)()  const>(&mfem::DivDivIntegrator::GetCoefficient));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DivDivIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DivDivIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DivDivIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorDiffusionIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorDiffusionIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorDiffusionIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorDiffusionIntegrator
// signature to use in the veto file: mfem::VectorDiffusionIntegrator
struct Jlmfem_VectorDiffusionIntegrator: public Wrapper {

  Jlmfem_VectorDiffusionIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorDiffusionIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2898:7
    jlcxx::TypeWrapper<mfem::VectorDiffusionIntegrator>  t = jlModule.add_type<mfem::VectorDiffusionIntegrator>("mfem!VectorDiffusionIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDiffusionIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorDiffusionIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::VectorDiffusionIntegrator(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2925:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::VectorDiffusionIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2928:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::VectorDiffusionIntegrator(mfem::Coefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2931:4
    t.constructor<mfem::Coefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::VectorDiffusionIntegrator(mfem::Coefficient &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2942:4
    t.constructor<mfem::Coefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::VectorDiffusionIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2954:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::VectorDiffusionIntegrator(mfem::MatrixCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2966:4
    t.constructor<mfem::MatrixCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDiffusionIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2969:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::VectorDiffusionIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorDiffusionIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDiffusionIntegrator::AssembleElementVector(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2972:17
    t.method("AssembleElementVector", static_cast<void (mfem::VectorDiffusionIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, const mfem::Vector &, mfem::Vector &) >(&mfem::VectorDiffusionIntegrator::AssembleElementVector));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDiffusionIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2976:17
    t.method("AssemblePA", static_cast<void (mfem::VectorDiffusionIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::VectorDiffusionIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::AssembleMF(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDiffusionIntegrator::AssembleMF(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2977:17
    t.method("AssembleMF", static_cast<void (mfem::VectorDiffusionIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::VectorDiffusionIntegrator::AssembleMF));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDiffusionIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2978:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::VectorDiffusionIntegrator::*)(mfem::Vector &) >(&mfem::VectorDiffusionIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::AssembleDiagonalMF(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDiffusionIntegrator::AssembleDiagonalMF(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2979:17
    t.method("AssembleDiagonalMF", static_cast<void (mfem::VectorDiffusionIntegrator::*)(mfem::Vector &) >(&mfem::VectorDiffusionIntegrator::AssembleDiagonalMF));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDiffusionIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2980:17
    t.method("AddMultPA", static_cast<void (mfem::VectorDiffusionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorDiffusionIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDiffusionIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDiffusionIntegrator::AddMultMF(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2981:17
    t.method("AddMultMF", static_cast<void (mfem::VectorDiffusionIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::VectorDiffusionIntegrator::AddMultMF));

    DEBUG_MSG("Adding wrapper for bool mfem::VectorDiffusionIntegrator::SupportsCeed() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::VectorDiffusionIntegrator::SupportsCeed()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2982:9
    t.method("SupportsCeed", static_cast<bool (mfem::VectorDiffusionIntegrator::*)()  const>(&mfem::VectorDiffusionIntegrator::SupportsCeed));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDiffusionIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorDiffusionIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorDiffusionIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ElasticityIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ElasticityIntegrator> : std::false_type { };
template<> struct SuperType<mfem::ElasticityIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::ElasticityIntegrator
// signature to use in the veto file: mfem::ElasticityIntegrator
struct Jlmfem_ElasticityIntegrator: public Wrapper {

  Jlmfem_ElasticityIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ElasticityIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:2992:7
    jlcxx::TypeWrapper<mfem::ElasticityIntegrator>  t = jlModule.add_type<mfem::ElasticityIntegrator>("mfem!ElasticityIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ElasticityIntegrator>>(new jlcxx::TypeWrapper<mfem::ElasticityIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ElasticityIntegrator::ElasticityIntegrator(mfem::Coefficient &, mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3024:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::ElasticityIntegrator::ElasticityIntegrator(mfem::Coefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3028:4
    t.constructor<mfem::Coefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityIntegrator::AssembleElementMatrix(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3031:17
    t.method("AssembleElementMatrix", static_cast<void (mfem::ElasticityIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::ElasticityIntegrator::AssembleElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3035:17
    t.method("AssemblePA", static_cast<void (mfem::ElasticityIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::ElasticityIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityIntegrator::AssembleDiagonalPA(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityIntegrator::AssembleDiagonalPA(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3037:17
    t.method("AssembleDiagonalPA", static_cast<void (mfem::ElasticityIntegrator::*)(mfem::Vector &) >(&mfem::ElasticityIntegrator::AssembleDiagonalPA));

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3039:17
    t.method("AddMultPA", static_cast<void (mfem::ElasticityIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ElasticityIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3041:17
    t.method("AddMultTransposePA", static_cast<void (mfem::ElasticityIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ElasticityIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityIntegrator::ComputeElementFlux(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityIntegrator::ComputeElementFlux(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3052:17
    t.method("ComputeElementFlux", static_cast<void (mfem::ElasticityIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, const mfem::FiniteElement &, mfem::Vector &, bool, const mfem::IntegrationRule *) >(&mfem::ElasticityIntegrator::ComputeElementFlux));
    t.method("ComputeElementFlux", [](mfem::ElasticityIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4)->void { a.ComputeElementFlux(arg0, arg1, arg2, arg3, arg4); });
    t.method("ComputeElementFlux", [](mfem::ElasticityIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4, bool arg5)->void { a.ComputeElementFlux(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("ComputeElementFlux", [](mfem::ElasticityIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4)->void { a->ComputeElementFlux(arg0, arg1, arg2, arg3, arg4); });
    t.method("ComputeElementFlux", [](mfem::ElasticityIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2, const mfem::FiniteElement & arg3, mfem::Vector & arg4, bool arg5)->void { a->ComputeElementFlux(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for double mfem::ElasticityIntegrator::ComputeFluxEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ElasticityIntegrator::ComputeFluxEnergy(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3068:19
    t.method("ComputeFluxEnergy", static_cast<double (mfem::ElasticityIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &, mfem::Vector *) >(&mfem::ElasticityIntegrator::ComputeFluxEnergy));
    t.method("ComputeFluxEnergy", [](mfem::ElasticityIntegrator& a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2)->double { return a.ComputeFluxEnergy(arg0, arg1, arg2); });
    t.method("ComputeFluxEnergy", [](mfem::ElasticityIntegrator* a, const mfem::FiniteElement & arg0, mfem::ElementTransformation & arg1, mfem::Vector & arg2)->double { return a->ComputeFluxEnergy(arg0, arg1, arg2); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ElasticityIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ElasticityIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ElasticityIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ElasticityComponentIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ElasticityComponentIntegrator> : std::false_type { };
template<> struct SuperType<mfem::ElasticityComponentIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::ElasticityComponentIntegrator
// signature to use in the veto file: mfem::ElasticityComponentIntegrator
struct Jlmfem_ElasticityComponentIntegrator: public Wrapper {

  Jlmfem_ElasticityComponentIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ElasticityComponentIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3076:7
    jlcxx::TypeWrapper<mfem::ElasticityComponentIntegrator>  t = jlModule.add_type<mfem::ElasticityComponentIntegrator>("mfem!ElasticityComponentIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ElasticityComponentIntegrator>>(new jlcxx::TypeWrapper<mfem::ElasticityComponentIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ElasticityComponentIntegrator::ElasticityComponentIntegrator(mfem::ElasticityIntegrator &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3092:4
    t.constructor<mfem::ElasticityIntegrator &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityComponentIntegrator::AssemblePA(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityComponentIntegrator::AssemblePA(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3094:17
    t.method("AssemblePA", static_cast<void (mfem::ElasticityComponentIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::ElasticityComponentIntegrator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityComponentIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityComponentIntegrator::AssembleEA(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3096:17
    t.method("AssembleEA", static_cast<void (mfem::ElasticityComponentIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::ElasticityComponentIntegrator::AssembleEA));
    t.method("AssembleEA", [](mfem::ElasticityComponentIntegrator& a, const mfem::FiniteElementSpace & arg0, mfem::Vector & arg1)->void { a.AssembleEA(arg0, arg1); });
    t.method("AssembleEA", [](mfem::ElasticityComponentIntegrator* a, const mfem::FiniteElementSpace & arg0, mfem::Vector & arg1)->void { a->AssembleEA(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityComponentIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityComponentIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3099:17
    t.method("AddMultPA", static_cast<void (mfem::ElasticityComponentIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ElasticityComponentIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::ElasticityComponentIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ElasticityComponentIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3101:17
    t.method("AddMultTransposePA", static_cast<void (mfem::ElasticityComponentIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::ElasticityComponentIntegrator::AddMultTransposePA));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ElasticityComponentIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ElasticityComponentIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ElasticityComponentIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DGTraceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DGTraceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DGTraceIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DGTraceIntegrator
// signature to use in the veto file: mfem::DGTraceIntegrator
struct Jlmfem_DGTraceIntegrator: public Wrapper {

  Jlmfem_DGTraceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DGTraceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3131:7
    jlcxx::TypeWrapper<mfem::DGTraceIntegrator>  t = jlModule.add_type<mfem::DGTraceIntegrator>("mfem!DGTraceIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DGTraceIntegrator>>(new jlcxx::TypeWrapper<mfem::DGTraceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::DGTraceIntegrator(mfem::VectorCoefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3148:4
    t.constructor<mfem::VectorCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::DGTraceIntegrator(mfem::VectorCoefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3152:4
    t.constructor<mfem::VectorCoefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::DGTraceIntegrator(mfem::Coefficient &, mfem::VectorCoefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3155:4
    t.constructor<mfem::Coefficient &, mfem::VectorCoefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGTraceIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3160:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::DGTraceIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::DGTraceIntegrator::AssembleFaceMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::AssemblePAInteriorFaces(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGTraceIntegrator::AssemblePAInteriorFaces(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3167:17
    t.method("AssemblePAInteriorFaces", static_cast<void (mfem::DGTraceIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::DGTraceIntegrator::AssemblePAInteriorFaces));

    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::AssemblePABoundaryFaces(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGTraceIntegrator::AssemblePABoundaryFaces(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3169:17
    t.method("AssemblePABoundaryFaces", static_cast<void (mfem::DGTraceIntegrator::*)(const mfem::FiniteElementSpace &) >(&mfem::DGTraceIntegrator::AssemblePABoundaryFaces));

    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGTraceIntegrator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3171:17
    t.method("AddMultTransposePA", static_cast<void (mfem::DGTraceIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DGTraceIntegrator::AddMultTransposePA));

    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGTraceIntegrator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3173:17
    t.method("AddMultPA", static_cast<void (mfem::DGTraceIntegrator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::DGTraceIntegrator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::AssembleEAInteriorFaces(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGTraceIntegrator::AssembleEAInteriorFaces(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3175:17
    t.method("AssembleEAInteriorFaces", static_cast<void (mfem::DGTraceIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, mfem::Vector &, const bool) >(&mfem::DGTraceIntegrator::AssembleEAInteriorFaces));

    DEBUG_MSG("Adding wrapper for void mfem::DGTraceIntegrator::AssembleEABoundaryFaces(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGTraceIntegrator::AssembleEABoundaryFaces(const mfem::FiniteElementSpace &, mfem::Vector &, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3180:17
    t.method("AssembleEABoundaryFaces", static_cast<void (mfem::DGTraceIntegrator::*)(const mfem::FiniteElementSpace &, mfem::Vector &, const bool) >(&mfem::DGTraceIntegrator::AssembleEABoundaryFaces));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::DGTraceIntegrator::GetRule(mfem::Geometry::Type, int, mfem::FaceElementTransformations &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::DGTraceIntegrator::GetRule(mfem::Geometry::Type, int, mfem::FaceElementTransformations &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3184:34
    module_.method("mfem!DGTraceIntegrator!GetRule", static_cast<const mfem::IntegrationRule & (*)(mfem::Geometry::Type, int, mfem::FaceElementTransformations &) >(&mfem::DGTraceIntegrator::GetRule));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DGTraceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DGTraceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DGTraceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NonconservativeDGTraceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NonconservativeDGTraceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::NonconservativeDGTraceIntegrator> { typedef mfem::TransposeIntegrator type; };
}

// Class generating the wrapper for type mfem::NonconservativeDGTraceIntegrator
// signature to use in the veto file: mfem::NonconservativeDGTraceIntegrator
struct Jlmfem_NonconservativeDGTraceIntegrator: public Wrapper {

  Jlmfem_NonconservativeDGTraceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NonconservativeDGTraceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3202:7
    jlcxx::TypeWrapper<mfem::NonconservativeDGTraceIntegrator>  t = jlModule.add_type<mfem::NonconservativeDGTraceIntegrator>("mfem!NonconservativeDGTraceIntegrator",
      jlcxx::julia_base_type<mfem::TransposeIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NonconservativeDGTraceIntegrator>>(new jlcxx::TypeWrapper<mfem::NonconservativeDGTraceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NonconservativeDGTraceIntegrator::NonconservativeDGTraceIntegrator(mfem::VectorCoefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3205:4
    t.constructor<mfem::VectorCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NonconservativeDGTraceIntegrator::NonconservativeDGTraceIntegrator(mfem::VectorCoefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3208:4
    t.constructor<mfem::VectorCoefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NonconservativeDGTraceIntegrator::NonconservativeDGTraceIntegrator(mfem::Coefficient &, mfem::VectorCoefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3211:4
    t.constructor<mfem::Coefficient &, mfem::VectorCoefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NonconservativeDGTraceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NonconservativeDGTraceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NonconservativeDGTraceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DGDiffusionIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DGDiffusionIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DGDiffusionIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DGDiffusionIntegrator
// signature to use in the veto file: mfem::DGDiffusionIntegrator
struct Jlmfem_DGDiffusionIntegrator: public Wrapper {

  Jlmfem_DGDiffusionIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DGDiffusionIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3230:7
    jlcxx::TypeWrapper<mfem::DGDiffusionIntegrator>  t = jlModule.add_type<mfem::DGDiffusionIntegrator>("mfem!DGDiffusionIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DGDiffusionIntegrator>>(new jlcxx::TypeWrapper<mfem::DGDiffusionIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DGDiffusionIntegrator::DGDiffusionIntegrator(const double, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3242:4
    t.constructor<const double, const double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGDiffusionIntegrator::DGDiffusionIntegrator(mfem::Coefficient &, const double, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3244:4
    t.constructor<mfem::Coefficient &, const double, const double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGDiffusionIntegrator::DGDiffusionIntegrator(mfem::MatrixCoefficient &, const double, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3246:4
    t.constructor<mfem::MatrixCoefficient &, const double, const double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DGDiffusionIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGDiffusionIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3249:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::DGDiffusionIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::DGDiffusionIntegrator::AssembleFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DGDiffusionIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DGDiffusionIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DGDiffusionIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DGDiffusionBR2Integrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DGDiffusionBR2Integrator> : std::false_type { };
template<> struct SuperType<mfem::DGDiffusionBR2Integrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DGDiffusionBR2Integrator
// signature to use in the veto file: mfem::DGDiffusionBR2Integrator
struct Jlmfem_DGDiffusionBR2Integrator: public Wrapper {

  Jlmfem_DGDiffusionBR2Integrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DGDiffusionBR2Integrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3275:7
    jlcxx::TypeWrapper<mfem::DGDiffusionBR2Integrator>  t = jlModule.add_type<mfem::DGDiffusionBR2Integrator>("mfem!DGDiffusionBR2Integrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DGDiffusionBR2Integrator>>(new jlcxx::TypeWrapper<mfem::DGDiffusionBR2Integrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DGDiffusionBR2Integrator::DGDiffusionBR2Integrator(mfem::FiniteElementSpace &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3302:4
    t.constructor<mfem::FiniteElementSpace &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::FiniteElementSpace &, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGDiffusionBR2Integrator::DGDiffusionBR2Integrator(mfem::FiniteElementSpace &, mfem::Coefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3303:4
    t.constructor<mfem::FiniteElementSpace &, mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::FiniteElementSpace &, mfem::Coefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGDiffusionBR2Integrator::DGDiffusionBR2Integrator(mfem::FiniteElementSpace *, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3305:20
    t.constructor<mfem::FiniteElementSpace *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::FiniteElementSpace *, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DGDiffusionBR2Integrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGDiffusionBR2Integrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3309:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::DGDiffusionBR2Integrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::DGDiffusionBR2Integrator::AssembleFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DGDiffusionBR2Integrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DGDiffusionBR2Integrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DGDiffusionBR2Integrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DGElasticityIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DGElasticityIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DGElasticityIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DGElasticityIntegrator
// signature to use in the veto file: mfem::DGElasticityIntegrator
struct Jlmfem_DGElasticityIntegrator: public Wrapper {

  Jlmfem_DGElasticityIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DGElasticityIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3375:7
    jlcxx::TypeWrapper<mfem::DGElasticityIntegrator>  t = jlModule.add_type<mfem::DGElasticityIntegrator>("mfem!DGElasticityIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DGElasticityIntegrator>>(new jlcxx::TypeWrapper<mfem::DGElasticityIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DGElasticityIntegrator::DGElasticityIntegrator(double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3378:4
    t.constructor<double, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGElasticityIntegrator::DGElasticityIntegrator(mfem::Coefficient &, mfem::Coefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3381:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DGElasticityIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGElasticityIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3386:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::DGElasticityIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::DGElasticityIntegrator::AssembleFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DGElasticityIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DGElasticityIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DGElasticityIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TraceJumpIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TraceJumpIntegrator> : std::false_type { };
template<> struct SuperType<mfem::TraceJumpIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::TraceJumpIntegrator
// signature to use in the veto file: mfem::TraceJumpIntegrator
struct Jlmfem_TraceJumpIntegrator: public Wrapper {

  Jlmfem_TraceJumpIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TraceJumpIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3428:7
    jlcxx::TypeWrapper<mfem::TraceJumpIntegrator>  t = jlModule.add_type<mfem::TraceJumpIntegrator>("mfem!TraceJumpIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TraceJumpIntegrator>>(new jlcxx::TypeWrapper<mfem::TraceJumpIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::TraceJumpIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TraceJumpIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3436:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::TraceJumpIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::TraceJumpIntegrator::AssembleFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TraceJumpIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TraceJumpIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TraceJumpIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NormalTraceJumpIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NormalTraceJumpIntegrator> : std::false_type { };
template<> struct SuperType<mfem::NormalTraceJumpIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::NormalTraceJumpIntegrator
// signature to use in the veto file: mfem::NormalTraceJumpIntegrator
struct Jlmfem_NormalTraceJumpIntegrator: public Wrapper {

  Jlmfem_NormalTraceJumpIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NormalTraceJumpIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3446:7
    jlcxx::TypeWrapper<mfem::NormalTraceJumpIntegrator>  t = jlModule.add_type<mfem::NormalTraceJumpIntegrator>("mfem!NormalTraceJumpIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalTraceJumpIntegrator>>(new jlcxx::TypeWrapper<mfem::NormalTraceJumpIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NormalTraceJumpIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalTraceJumpIntegrator::AssembleFaceMatrix(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3455:17
    t.method("AssembleFaceMatrix", static_cast<void (mfem::NormalTraceJumpIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::NormalTraceJumpIntegrator::AssembleFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalTraceJumpIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NormalTraceJumpIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NormalTraceJumpIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TraceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TraceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::TraceIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::TraceIntegrator
// signature to use in the veto file: mfem::TraceIntegrator
struct Jlmfem_TraceIntegrator: public Wrapper {

  Jlmfem_TraceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TraceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3466:7
    jlcxx::TypeWrapper<mfem::TraceIntegrator>  t = jlModule.add_type<mfem::TraceIntegrator>("mfem!TraceIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TraceIntegrator>>(new jlcxx::TypeWrapper<mfem::TraceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::TraceIntegrator::AssembleTraceFaceMatrix(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TraceIntegrator::AssembleTraceFaceMatrix(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3472:9
    t.method("AssembleTraceFaceMatrix", static_cast<void (mfem::TraceIntegrator::*)(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::TraceIntegrator::AssembleTraceFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TraceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TraceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TraceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NormalTraceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NormalTraceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::NormalTraceIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::NormalTraceIntegrator
// signature to use in the veto file: mfem::NormalTraceIntegrator
struct Jlmfem_NormalTraceIntegrator: public Wrapper {

  Jlmfem_NormalTraceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NormalTraceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3482:7
    jlcxx::TypeWrapper<mfem::NormalTraceIntegrator>  t = jlModule.add_type<mfem::NormalTraceIntegrator>("mfem!NormalTraceIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalTraceIntegrator>>(new jlcxx::TypeWrapper<mfem::NormalTraceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NormalTraceIntegrator::AssembleTraceFaceMatrix(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalTraceIntegrator::AssembleTraceFaceMatrix(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3490:17
    t.method("AssembleTraceFaceMatrix", static_cast<void (mfem::NormalTraceIntegrator::*)(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::NormalTraceIntegrator::AssembleTraceFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalTraceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NormalTraceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NormalTraceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::TangentTraceIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::TangentTraceIntegrator> : std::false_type { };
template<> struct SuperType<mfem::TangentTraceIntegrator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::TangentTraceIntegrator
// signature to use in the veto file: mfem::TangentTraceIntegrator
struct Jlmfem_TangentTraceIntegrator: public Wrapper {

  Jlmfem_TangentTraceIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::TangentTraceIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3502:7
    jlcxx::TypeWrapper<mfem::TangentTraceIntegrator>  t = jlModule.add_type<mfem::TangentTraceIntegrator>("mfem!TangentTraceIntegrator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::TangentTraceIntegrator>>(new jlcxx::TypeWrapper<mfem::TangentTraceIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::TangentTraceIntegrator::AssembleTraceFaceMatrix(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TangentTraceIntegrator::AssembleTraceFaceMatrix(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3536:9
    t.method("AssembleTraceFaceMatrix", static_cast<void (mfem::TangentTraceIntegrator::*)(int, const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::DenseMatrix &) >(&mfem::TangentTraceIntegrator::AssembleTraceFaceMatrix));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::TangentTraceIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_TangentTraceIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_TangentTraceIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DiscreteInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DiscreteInterpolator> : std::false_type { };
template<> struct SuperType<mfem::DiscreteInterpolator> { typedef mfem::BilinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DiscreteInterpolator
// signature to use in the veto file: mfem::DiscreteInterpolator
struct Jlmfem_DiscreteInterpolator: public Wrapper {

  Jlmfem_DiscreteInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DiscreteInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3545:7
    jlcxx::TypeWrapper<mfem::DiscreteInterpolator>  t = jlModule.add_type<mfem::DiscreteInterpolator>("mfem!DiscreteInterpolator",
      jlcxx::julia_base_type<mfem::BilinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DiscreteInterpolator>>(new jlcxx::TypeWrapper<mfem::DiscreteInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DiscreteInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DiscreteInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DiscreteInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GradientInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GradientInterpolator> : std::false_type { };
template<> struct SuperType<mfem::GradientInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::GradientInterpolator
// signature to use in the veto file: mfem::GradientInterpolator
struct Jlmfem_GradientInterpolator: public Wrapper {

  Jlmfem_GradientInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GradientInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3551:7
    jlcxx::TypeWrapper<mfem::GradientInterpolator>  t = jlModule.add_type<mfem::GradientInterpolator>("mfem!GradientInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GradientInterpolator>>(new jlcxx::TypeWrapper<mfem::GradientInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::GradientInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3557:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::GradientInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::GradientInterpolator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::GradientInterpolator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientInterpolator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3570:17
    t.method("AssemblePA", static_cast<void (mfem::GradientInterpolator::*)(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) >(&mfem::GradientInterpolator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::GradientInterpolator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientInterpolator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3573:17
    t.method("AddMultPA", static_cast<void (mfem::GradientInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::GradientInterpolator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::GradientInterpolator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GradientInterpolator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3574:17
    t.method("AddMultTransposePA", static_cast<void (mfem::GradientInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::GradientInterpolator::AddMultTransposePA));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GradientInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GradientInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GradientInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IdentityInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IdentityInterpolator> : std::false_type { };
template<> struct SuperType<mfem::IdentityInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::IdentityInterpolator
// signature to use in the veto file: mfem::IdentityInterpolator
struct Jlmfem_IdentityInterpolator: public Wrapper {

  Jlmfem_IdentityInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IdentityInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3590:7
    jlcxx::TypeWrapper<mfem::IdentityInterpolator>  t = jlModule.add_type<mfem::IdentityInterpolator>("mfem!IdentityInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IdentityInterpolator>>(new jlcxx::TypeWrapper<mfem::IdentityInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::IdentityInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IdentityInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3595:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::IdentityInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::IdentityInterpolator::AssembleElementMatrix2));

    DEBUG_MSG("Adding wrapper for void mfem::IdentityInterpolator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IdentityInterpolator::AssemblePA(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3603:17
    t.method("AssemblePA", static_cast<void (mfem::IdentityInterpolator::*)(const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &) >(&mfem::IdentityInterpolator::AssemblePA));

    DEBUG_MSG("Adding wrapper for void mfem::IdentityInterpolator::AddMultPA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IdentityInterpolator::AddMultPA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3606:17
    t.method("AddMultPA", static_cast<void (mfem::IdentityInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::IdentityInterpolator::AddMultPA));

    DEBUG_MSG("Adding wrapper for void mfem::IdentityInterpolator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::IdentityInterpolator::AddMultTransposePA(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3607:17
    t.method("AddMultTransposePA", static_cast<void (mfem::IdentityInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::IdentityInterpolator::AddMultTransposePA));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IdentityInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IdentityInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IdentityInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CurlInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CurlInterpolator> : std::false_type { };
template<> struct SuperType<mfem::CurlInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::CurlInterpolator
// signature to use in the veto file: mfem::CurlInterpolator
struct Jlmfem_CurlInterpolator: public Wrapper {

  Jlmfem_CurlInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CurlInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3626:7
    jlcxx::TypeWrapper<mfem::CurlInterpolator>  t = jlModule.add_type<mfem::CurlInterpolator>("mfem!CurlInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CurlInterpolator>>(new jlcxx::TypeWrapper<mfem::CurlInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::CurlInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CurlInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3629:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::CurlInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::CurlInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CurlInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CurlInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CurlInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DivergenceInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DivergenceInterpolator> : std::false_type { };
template<> struct SuperType<mfem::DivergenceInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::DivergenceInterpolator
// signature to use in the veto file: mfem::DivergenceInterpolator
struct Jlmfem_DivergenceInterpolator: public Wrapper {

  Jlmfem_DivergenceInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DivergenceInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3645:7
    jlcxx::TypeWrapper<mfem::DivergenceInterpolator>  t = jlModule.add_type<mfem::DivergenceInterpolator>("mfem!DivergenceInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DivergenceInterpolator>>(new jlcxx::TypeWrapper<mfem::DivergenceInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DivergenceInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DivergenceInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3648:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::DivergenceInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::DivergenceInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DivergenceInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DivergenceInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DivergenceInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NormalInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NormalInterpolator> : std::false_type { };
template<> struct SuperType<mfem::NormalInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::NormalInterpolator
// signature to use in the veto file: mfem::NormalInterpolator
struct Jlmfem_NormalInterpolator: public Wrapper {

  Jlmfem_NormalInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NormalInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3659:7
    jlcxx::TypeWrapper<mfem::NormalInterpolator>  t = jlModule.add_type<mfem::NormalInterpolator>("mfem!NormalInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalInterpolator>>(new jlcxx::TypeWrapper<mfem::NormalInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NormalInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NormalInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3662:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::NormalInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::NormalInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NormalInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NormalInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NormalInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ScalarProductInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ScalarProductInterpolator> : std::false_type { };
template<> struct SuperType<mfem::ScalarProductInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::ScalarProductInterpolator
// signature to use in the veto file: mfem::ScalarProductInterpolator
struct Jlmfem_ScalarProductInterpolator: public Wrapper {

  Jlmfem_ScalarProductInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ScalarProductInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3671:7
    jlcxx::TypeWrapper<mfem::ScalarProductInterpolator>  t = jlModule.add_type<mfem::ScalarProductInterpolator>("mfem!ScalarProductInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarProductInterpolator>>(new jlcxx::TypeWrapper<mfem::ScalarProductInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ScalarProductInterpolator::ScalarProductInterpolator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3674:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ScalarProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3676:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::ScalarProductInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::ScalarProductInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarProductInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ScalarProductInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ScalarProductInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ScalarVectorProductInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ScalarVectorProductInterpolator> : std::false_type { };
template<> struct SuperType<mfem::ScalarVectorProductInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::ScalarVectorProductInterpolator
// signature to use in the veto file: mfem::ScalarVectorProductInterpolator
struct Jlmfem_ScalarVectorProductInterpolator: public Wrapper {

  Jlmfem_ScalarVectorProductInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ScalarVectorProductInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3688:7
    jlcxx::TypeWrapper<mfem::ScalarVectorProductInterpolator>  t = jlModule.add_type<mfem::ScalarVectorProductInterpolator>("mfem!ScalarVectorProductInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarVectorProductInterpolator>>(new jlcxx::TypeWrapper<mfem::ScalarVectorProductInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductInterpolator::ScalarVectorProductInterpolator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3691:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ScalarVectorProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarVectorProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3694:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::ScalarVectorProductInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::ScalarVectorProductInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarVectorProductInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ScalarVectorProductInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ScalarVectorProductInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorScalarProductInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorScalarProductInterpolator> : std::false_type { };
template<> struct SuperType<mfem::VectorScalarProductInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::VectorScalarProductInterpolator
// signature to use in the veto file: mfem::VectorScalarProductInterpolator
struct Jlmfem_VectorScalarProductInterpolator: public Wrapper {

  Jlmfem_VectorScalarProductInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorScalarProductInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3705:7
    jlcxx::TypeWrapper<mfem::VectorScalarProductInterpolator>  t = jlModule.add_type<mfem::VectorScalarProductInterpolator>("mfem!VectorScalarProductInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorScalarProductInterpolator>>(new jlcxx::TypeWrapper<mfem::VectorScalarProductInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorScalarProductInterpolator::VectorScalarProductInterpolator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3708:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorScalarProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorScalarProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3711:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorScalarProductInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorScalarProductInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorScalarProductInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorScalarProductInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorScalarProductInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ScalarCrossProductInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ScalarCrossProductInterpolator> : std::false_type { };
template<> struct SuperType<mfem::ScalarCrossProductInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::ScalarCrossProductInterpolator
// signature to use in the veto file: mfem::ScalarCrossProductInterpolator
struct Jlmfem_ScalarCrossProductInterpolator: public Wrapper {

  Jlmfem_ScalarCrossProductInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ScalarCrossProductInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3721:7
    jlcxx::TypeWrapper<mfem::ScalarCrossProductInterpolator>  t = jlModule.add_type<mfem::ScalarCrossProductInterpolator>("mfem!ScalarCrossProductInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarCrossProductInterpolator>>(new jlcxx::TypeWrapper<mfem::ScalarCrossProductInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ScalarCrossProductInterpolator::ScalarCrossProductInterpolator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3724:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ScalarCrossProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ScalarCrossProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3727:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::ScalarCrossProductInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::ScalarCrossProductInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ScalarCrossProductInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ScalarCrossProductInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ScalarCrossProductInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorCrossProductInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorCrossProductInterpolator> : std::false_type { };
template<> struct SuperType<mfem::VectorCrossProductInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::VectorCrossProductInterpolator
// signature to use in the veto file: mfem::VectorCrossProductInterpolator
struct Jlmfem_VectorCrossProductInterpolator: public Wrapper {

  Jlmfem_VectorCrossProductInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorCrossProductInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3738:7
    jlcxx::TypeWrapper<mfem::VectorCrossProductInterpolator>  t = jlModule.add_type<mfem::VectorCrossProductInterpolator>("mfem!VectorCrossProductInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCrossProductInterpolator>>(new jlcxx::TypeWrapper<mfem::VectorCrossProductInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductInterpolator::VectorCrossProductInterpolator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3741:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorCrossProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorCrossProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3744:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorCrossProductInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorCrossProductInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCrossProductInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorCrossProductInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorCrossProductInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorInnerProductInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorInnerProductInterpolator> : std::false_type { };
template<> struct SuperType<mfem::VectorInnerProductInterpolator> { typedef mfem::DiscreteInterpolator type; };
}

// Class generating the wrapper for type mfem::VectorInnerProductInterpolator
// signature to use in the veto file: mfem::VectorInnerProductInterpolator
struct Jlmfem_VectorInnerProductInterpolator: public Wrapper {

  Jlmfem_VectorInnerProductInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorInnerProductInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3755:7
    jlcxx::TypeWrapper<mfem::VectorInnerProductInterpolator>  t = jlModule.add_type<mfem::VectorInnerProductInterpolator>("mfem!VectorInnerProductInterpolator",
      jlcxx::julia_base_type<mfem::DiscreteInterpolator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorInnerProductInterpolator>>(new jlcxx::TypeWrapper<mfem::VectorInnerProductInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorInnerProductInterpolator::VectorInnerProductInterpolator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3758:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorInnerProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorInnerProductInterpolator::AssembleElementMatrix2(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilininteg.hpp:3760:17
    t.method("AssembleElementMatrix2", static_cast<void (mfem::VectorInnerProductInterpolator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::DenseMatrix &) >(&mfem::VectorInnerProductInterpolator::AssembleElementMatrix2));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorInnerProductInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorInnerProductInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorInnerProductInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::JumpScaling> : std::false_type { };
  template<> struct DefaultConstructible<mfem::JumpScaling> : std::false_type { };
}

// Class generating the wrapper for type mfem::JumpScaling
// signature to use in the veto file: mfem::JumpScaling
struct Jlmfem_JumpScaling: public Wrapper {

  Jlmfem_JumpScaling(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::JumpScaling (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:772:7
    jlcxx::TypeWrapper<mfem::JumpScaling>  t = jlModule.add_type<mfem::JumpScaling>("mfem!JumpScaling");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::JumpScaling>>(new jlcxx::TypeWrapper<mfem::JumpScaling>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::JumpScaling::JumpScaling(double, mfem::JumpScaling::JumpScalingType) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:785:4
    t.constructor<double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<double, mfem::JumpScaling::JumpScalingType>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::JumpScaling::Eval(double, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::JumpScaling::Eval(double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:787:11
    t.method("Eval", static_cast<double (mfem::JumpScaling::*)(double, int)  const>(&mfem::JumpScaling::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::JumpScaling>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_JumpScaling(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_JumpScaling(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ExtrudeCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ExtrudeCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ExtrudeCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::ExtrudeCoefficient
// signature to use in the veto file: mfem::ExtrudeCoefficient
struct Jlmfem_ExtrudeCoefficient: public Wrapper {

  Jlmfem_ExtrudeCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ExtrudeCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:866:7
    jlcxx::TypeWrapper<mfem::ExtrudeCoefficient>  t = jlModule.add_type<mfem::ExtrudeCoefficient>("mfem!ExtrudeCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ExtrudeCoefficient>>(new jlcxx::TypeWrapper<mfem::ExtrudeCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ExtrudeCoefficient::ExtrudeCoefficient(mfem::Mesh *, mfem::Coefficient &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:873:4
    t.constructor<mfem::Mesh *, mfem::Coefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::ExtrudeCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ExtrudeCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:875:19
    t.method("Eval", static_cast<double (mfem::ExtrudeCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ExtrudeCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ExtrudeCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ExtrudeCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ExtrudeCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearFormIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearFormIntegrator> : std::false_type { };
}

// Class generating the wrapper for type mfem::LinearFormIntegrator
// signature to use in the veto file: mfem::LinearFormIntegrator
struct Jlmfem_LinearFormIntegrator: public Wrapper {

  Jlmfem_LinearFormIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearFormIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:24:7
    jlcxx::TypeWrapper<mfem::LinearFormIntegrator>  t = jlModule.add_type<mfem::LinearFormIntegrator>("mfem!LinearFormIntegrator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFormIntegrator>>(new jlcxx::TypeWrapper<mfem::LinearFormIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for bool mfem::LinearFormIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::LinearFormIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:34:17
    t.method("SupportsDevice", static_cast<bool (mfem::LinearFormIntegrator::*)()  const>(&mfem::LinearFormIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::LinearFormIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearFormIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:37:17
    t.method("AssembleDevice", static_cast<void (mfem::LinearFormIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::LinearFormIntegrator::AssembleDevice));

    DEBUG_MSG("Adding wrapper for void mfem::LinearFormIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearFormIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:43:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::LinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::LinearFormIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::LinearFormIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearFormIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:46:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::LinearFormIntegrator::*)(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) >(&mfem::LinearFormIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::LinearFormIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearFormIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:49:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::LinearFormIntegrator::*)(const mfem::FiniteElement &, const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) >(&mfem::LinearFormIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::LinearFormIntegrator::SetIntRule(const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearFormIntegrator::SetIntRule(const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:54:17
    t.method("SetIntRule", static_cast<void (mfem::LinearFormIntegrator::*)(const mfem::IntegrationRule *) >(&mfem::LinearFormIntegrator::SetIntRule));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule * mfem::LinearFormIntegrator::GetIntRule() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule * mfem::LinearFormIntegrator::GetIntRule()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:55:27
    t.method("GetIntRule", static_cast<const mfem::IntegrationRule * (mfem::LinearFormIntegrator::*)() >(&mfem::LinearFormIntegrator::GetIntRule));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFormIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearFormIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearFormIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DeltaLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DeltaLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DeltaLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DeltaLFIntegrator
// signature to use in the veto file: mfem::DeltaLFIntegrator
struct Jlmfem_DeltaLFIntegrator: public Wrapper {

  Jlmfem_DeltaLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DeltaLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:62:7
    jlcxx::TypeWrapper<mfem::DeltaLFIntegrator>  t = jlModule.add_type<mfem::DeltaLFIntegrator>("mfem!DeltaLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DeltaLFIntegrator>>(new jlcxx::TypeWrapper<mfem::DeltaLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for bool mfem::DeltaLFIntegrator::IsDelta() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::DeltaLFIntegrator::IsDelta()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:85:9
    t.method("IsDelta", static_cast<bool (mfem::DeltaLFIntegrator::*)()  const>(&mfem::DeltaLFIntegrator::IsDelta));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaLFIntegrator::GetDeltaCenter(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaLFIntegrator::GetDeltaCenter(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:88:9
    t.method("GetDeltaCenter", static_cast<void (mfem::DeltaLFIntegrator::*)(mfem::Vector &) >(&mfem::DeltaLFIntegrator::GetDeltaCenter));

    DEBUG_MSG("Adding wrapper for void mfem::DeltaLFIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DeltaLFIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:101:17
    t.method("AssembleDeltaElementVect", static_cast<void (mfem::DeltaLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::DeltaLFIntegrator::AssembleDeltaElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DeltaLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DeltaLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DeltaLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DomainLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DomainLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DomainLFIntegrator> { typedef mfem::DeltaLFIntegrator type; };
}

// Class generating the wrapper for type mfem::DomainLFIntegrator
// signature to use in the veto file: mfem::DomainLFIntegrator
struct Jlmfem_DomainLFIntegrator: public Wrapper {

  Jlmfem_DomainLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DomainLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:108:7
    jlcxx::TypeWrapper<mfem::DomainLFIntegrator>  t = jlModule.add_type<mfem::DomainLFIntegrator>("mfem!DomainLFIntegrator",
      jlcxx::julia_base_type<mfem::DeltaLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DomainLFIntegrator>>(new jlcxx::TypeWrapper<mfem::DomainLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DomainLFIntegrator::DomainLFIntegrator(mfem::Coefficient &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:115:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DomainLFIntegrator::DomainLFIntegrator(mfem::Coefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:121:4
    t.constructor<mfem::Coefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::DomainLFIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::DomainLFIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:124:17
    t.method("SupportsDevice", static_cast<bool (mfem::DomainLFIntegrator::*)()  const>(&mfem::DomainLFIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::DomainLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DomainLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:127:17
    t.method("AssembleDevice", static_cast<void (mfem::DomainLFIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::DomainLFIntegrator::AssembleDevice));

    DEBUG_MSG("Adding wrapper for void mfem::DomainLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DomainLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:133:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::DomainLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::DomainLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::DomainLFIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DomainLFIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:137:17
    t.method("AssembleDeltaElementVect", static_cast<void (mfem::DomainLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::DomainLFIntegrator::AssembleDeltaElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DomainLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DomainLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DomainLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DomainLFGradIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DomainLFGradIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DomainLFGradIntegrator> { typedef mfem::DeltaLFIntegrator type; };
}

// Class generating the wrapper for type mfem::DomainLFGradIntegrator
// signature to use in the veto file: mfem::DomainLFGradIntegrator
struct Jlmfem_DomainLFGradIntegrator: public Wrapper {

  Jlmfem_DomainLFGradIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DomainLFGradIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:145:7
    jlcxx::TypeWrapper<mfem::DomainLFGradIntegrator>  t = jlModule.add_type<mfem::DomainLFGradIntegrator>("mfem!DomainLFGradIntegrator",
      jlcxx::julia_base_type<mfem::DeltaLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DomainLFGradIntegrator>>(new jlcxx::TypeWrapper<mfem::DomainLFGradIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DomainLFGradIntegrator::DomainLFGradIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:154:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::DomainLFGradIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::DomainLFGradIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:157:17
    t.method("SupportsDevice", static_cast<bool (mfem::DomainLFGradIntegrator::*)()  const>(&mfem::DomainLFGradIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::DomainLFGradIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DomainLFGradIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:160:17
    t.method("AssembleDevice", static_cast<void (mfem::DomainLFGradIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::DomainLFGradIntegrator::AssembleDevice));

    DEBUG_MSG("Adding wrapper for void mfem::DomainLFGradIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DomainLFGradIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:166:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::DomainLFGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::DomainLFGradIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::DomainLFGradIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DomainLFGradIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:170:17
    t.method("AssembleDeltaElementVect", static_cast<void (mfem::DomainLFGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::DomainLFGradIntegrator::AssembleDeltaElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DomainLFGradIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DomainLFGradIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DomainLFGradIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BoundaryLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BoundaryLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::BoundaryLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::BoundaryLFIntegrator
// signature to use in the veto file: mfem::BoundaryLFIntegrator
struct Jlmfem_BoundaryLFIntegrator: public Wrapper {

  Jlmfem_BoundaryLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BoundaryLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:179:7
    jlcxx::TypeWrapper<mfem::BoundaryLFIntegrator>  t = jlModule.add_type<mfem::BoundaryLFIntegrator>("mfem!BoundaryLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryLFIntegrator>>(new jlcxx::TypeWrapper<mfem::BoundaryLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BoundaryLFIntegrator::BoundaryLFIntegrator(mfem::Coefficient &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:187:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::BoundaryLFIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::BoundaryLFIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:190:17
    t.method("SupportsDevice", static_cast<bool (mfem::BoundaryLFIntegrator::*)()  const>(&mfem::BoundaryLFIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:193:17
    t.method("AssembleDevice", static_cast<void (mfem::BoundaryLFIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::BoundaryLFIntegrator::AssembleDevice));

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:199:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::BoundaryLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::BoundaryLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:202:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::BoundaryLFIntegrator::*)(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) >(&mfem::BoundaryLFIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BoundaryLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BoundaryLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BoundaryNormalLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BoundaryNormalLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::BoundaryNormalLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::BoundaryNormalLFIntegrator
// signature to use in the veto file: mfem::BoundaryNormalLFIntegrator
struct Jlmfem_BoundaryNormalLFIntegrator: public Wrapper {

  Jlmfem_BoundaryNormalLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BoundaryNormalLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:210:7
    jlcxx::TypeWrapper<mfem::BoundaryNormalLFIntegrator>  t = jlModule.add_type<mfem::BoundaryNormalLFIntegrator>("mfem!BoundaryNormalLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryNormalLFIntegrator>>(new jlcxx::TypeWrapper<mfem::BoundaryNormalLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BoundaryNormalLFIntegrator::BoundaryNormalLFIntegrator(mfem::VectorCoefficient &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:217:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::BoundaryNormalLFIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::BoundaryNormalLFIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:220:17
    t.method("SupportsDevice", static_cast<bool (mfem::BoundaryNormalLFIntegrator::*)()  const>(&mfem::BoundaryNormalLFIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryNormalLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryNormalLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:223:17
    t.method("AssembleDevice", static_cast<void (mfem::BoundaryNormalLFIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::BoundaryNormalLFIntegrator::AssembleDevice));

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryNormalLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryNormalLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:227:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::BoundaryNormalLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::BoundaryNormalLFIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryNormalLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BoundaryNormalLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BoundaryNormalLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BoundaryTangentialLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BoundaryTangentialLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::BoundaryTangentialLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::BoundaryTangentialLFIntegrator
// signature to use in the veto file: mfem::BoundaryTangentialLFIntegrator
struct Jlmfem_BoundaryTangentialLFIntegrator: public Wrapper {

  Jlmfem_BoundaryTangentialLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BoundaryTangentialLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:235:7
    jlcxx::TypeWrapper<mfem::BoundaryTangentialLFIntegrator>  t = jlModule.add_type<mfem::BoundaryTangentialLFIntegrator>("mfem!BoundaryTangentialLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryTangentialLFIntegrator>>(new jlcxx::TypeWrapper<mfem::BoundaryTangentialLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BoundaryTangentialLFIntegrator::BoundaryTangentialLFIntegrator(mfem::VectorCoefficient &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:242:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryTangentialLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryTangentialLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:245:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::BoundaryTangentialLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::BoundaryTangentialLFIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryTangentialLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BoundaryTangentialLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BoundaryTangentialLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorDomainLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorDomainLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorDomainLFIntegrator> { typedef mfem::DeltaLFIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorDomainLFIntegrator
// signature to use in the veto file: mfem::VectorDomainLFIntegrator
struct Jlmfem_VectorDomainLFIntegrator: public Wrapper {

  Jlmfem_VectorDomainLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorDomainLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:254:7
    jlcxx::TypeWrapper<mfem::VectorDomainLFIntegrator>  t = jlModule.add_type<mfem::VectorDomainLFIntegrator>("mfem!VectorDomainLFIntegrator",
      jlcxx::julia_base_type<mfem::DeltaLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDomainLFIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorDomainLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorDomainLFIntegrator::VectorDomainLFIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:262:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::VectorDomainLFIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::VectorDomainLFIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:265:17
    t.method("SupportsDevice", static_cast<bool (mfem::VectorDomainLFIntegrator::*)()  const>(&mfem::VectorDomainLFIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDomainLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDomainLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:268:17
    t.method("AssembleDevice", static_cast<void (mfem::VectorDomainLFIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::VectorDomainLFIntegrator::AssembleDevice));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDomainLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDomainLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:274:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorDomainLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorDomainLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDomainLFIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDomainLFIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:278:17
    t.method("AssembleDeltaElementVect", static_cast<void (mfem::VectorDomainLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorDomainLFIntegrator::AssembleDeltaElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDomainLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorDomainLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorDomainLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorDomainLFGradIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorDomainLFGradIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorDomainLFGradIntegrator> { typedef mfem::DeltaLFIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorDomainLFGradIntegrator
// signature to use in the veto file: mfem::VectorDomainLFGradIntegrator
struct Jlmfem_VectorDomainLFGradIntegrator: public Wrapper {

  Jlmfem_VectorDomainLFGradIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorDomainLFGradIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:287:7
    jlcxx::TypeWrapper<mfem::VectorDomainLFGradIntegrator>  t = jlModule.add_type<mfem::VectorDomainLFGradIntegrator>("mfem!VectorDomainLFGradIntegrator",
      jlcxx::julia_base_type<mfem::DeltaLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDomainLFGradIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorDomainLFGradIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorDomainLFGradIntegrator::VectorDomainLFGradIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:296:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::VectorDomainLFGradIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::VectorDomainLFGradIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:299:17
    t.method("SupportsDevice", static_cast<bool (mfem::VectorDomainLFGradIntegrator::*)()  const>(&mfem::VectorDomainLFGradIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDomainLFGradIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDomainLFGradIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:302:17
    t.method("AssembleDevice", static_cast<void (mfem::VectorDomainLFGradIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::VectorDomainLFGradIntegrator::AssembleDevice));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDomainLFGradIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDomainLFGradIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:308:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorDomainLFGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorDomainLFGradIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::VectorDomainLFGradIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorDomainLFGradIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:312:17
    t.method("AssembleDeltaElementVect", static_cast<void (mfem::VectorDomainLFGradIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorDomainLFGradIntegrator::AssembleDeltaElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorDomainLFGradIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorDomainLFGradIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorDomainLFGradIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorBoundaryLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorBoundaryLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorBoundaryLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorBoundaryLFIntegrator
// signature to use in the veto file: mfem::VectorBoundaryLFIntegrator
struct Jlmfem_VectorBoundaryLFIntegrator: public Wrapper {

  Jlmfem_VectorBoundaryLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorBoundaryLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:321:7
    jlcxx::TypeWrapper<mfem::VectorBoundaryLFIntegrator>  t = jlModule.add_type<mfem::VectorBoundaryLFIntegrator>("mfem!VectorBoundaryLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorBoundaryLFIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorBoundaryLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorBoundaryLFIntegrator::VectorBoundaryLFIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:329:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorBoundaryLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorBoundaryLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:333:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorBoundaryLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorBoundaryLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::VectorBoundaryLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorBoundaryLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:338:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorBoundaryLFIntegrator::*)(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) >(&mfem::VectorBoundaryLFIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorBoundaryLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorBoundaryLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorBoundaryLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFEDomainLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFEDomainLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFEDomainLFIntegrator> { typedef mfem::DeltaLFIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFEDomainLFIntegrator
// signature to use in the veto file: mfem::VectorFEDomainLFIntegrator
struct Jlmfem_VectorFEDomainLFIntegrator: public Wrapper {

  Jlmfem_VectorFEDomainLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFEDomainLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:346:7
    jlcxx::TypeWrapper<mfem::VectorFEDomainLFIntegrator>  t = jlModule.add_type<mfem::VectorFEDomainLFIntegrator>("mfem!VectorFEDomainLFIntegrator",
      jlcxx::julia_base_type<mfem::DeltaLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEDomainLFIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFEDomainLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFIntegrator::VectorFEDomainLFIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:354:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDomainLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:357:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorFEDomainLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorFEDomainLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDomainLFIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:361:17
    t.method("AssembleDeltaElementVect", static_cast<void (mfem::VectorFEDomainLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorFEDomainLFIntegrator::AssembleDeltaElementVect));

    DEBUG_MSG("Adding wrapper for bool mfem::VectorFEDomainLFIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::VectorFEDomainLFIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:365:17
    t.method("SupportsDevice", static_cast<bool (mfem::VectorFEDomainLFIntegrator::*)()  const>(&mfem::VectorFEDomainLFIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDomainLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:367:17
    t.method("AssembleDevice", static_cast<void (mfem::VectorFEDomainLFIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::VectorFEDomainLFIntegrator::AssembleDevice));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEDomainLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFEDomainLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFEDomainLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFEDomainLFCurlIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFEDomainLFCurlIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFEDomainLFCurlIntegrator> { typedef mfem::DeltaLFIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFEDomainLFCurlIntegrator
// signature to use in the veto file: mfem::VectorFEDomainLFCurlIntegrator
struct Jlmfem_VectorFEDomainLFCurlIntegrator: public Wrapper {

  Jlmfem_VectorFEDomainLFCurlIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFEDomainLFCurlIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:375:7
    jlcxx::TypeWrapper<mfem::VectorFEDomainLFCurlIntegrator>  t = jlModule.add_type<mfem::VectorFEDomainLFCurlIntegrator>("mfem!VectorFEDomainLFCurlIntegrator",
      jlcxx::julia_base_type<mfem::DeltaLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEDomainLFCurlIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFEDomainLFCurlIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFCurlIntegrator::VectorFEDomainLFCurlIntegrator(mfem::VectorCoefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:384:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFCurlIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDomainLFCurlIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:387:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorFEDomainLFCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorFEDomainLFCurlIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFCurlIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDomainLFCurlIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:391:17
    t.method("AssembleDeltaElementVect", static_cast<void (mfem::VectorFEDomainLFCurlIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorFEDomainLFCurlIntegrator::AssembleDeltaElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEDomainLFCurlIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFEDomainLFCurlIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFEDomainLFCurlIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFEDomainLFDivIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFEDomainLFDivIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFEDomainLFDivIntegrator> { typedef mfem::DeltaLFIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFEDomainLFDivIntegrator
// signature to use in the veto file: mfem::VectorFEDomainLFDivIntegrator
struct Jlmfem_VectorFEDomainLFDivIntegrator: public Wrapper {

  Jlmfem_VectorFEDomainLFDivIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFEDomainLFDivIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:399:7
    jlcxx::TypeWrapper<mfem::VectorFEDomainLFDivIntegrator>  t = jlModule.add_type<mfem::VectorFEDomainLFDivIntegrator>("mfem!VectorFEDomainLFDivIntegrator",
      jlcxx::julia_base_type<mfem::DeltaLFIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEDomainLFDivIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFEDomainLFDivIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFDivIntegrator::VectorFEDomainLFDivIntegrator(mfem::Coefficient &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:406:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFDivIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDomainLFDivIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:411:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorFEDomainLFDivIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorFEDomainLFDivIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEDomainLFDivIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEDomainLFDivIntegrator::AssembleDeltaElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:415:17
    t.method("AssembleDeltaElementVect", static_cast<void (mfem::VectorFEDomainLFDivIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorFEDomainLFDivIntegrator::AssembleDeltaElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEDomainLFDivIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFEDomainLFDivIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFEDomainLFDivIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorBoundaryFluxLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorBoundaryFluxLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorBoundaryFluxLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorBoundaryFluxLFIntegrator
// signature to use in the veto file: mfem::VectorBoundaryFluxLFIntegrator
struct Jlmfem_VectorBoundaryFluxLFIntegrator: public Wrapper {

  Jlmfem_VectorBoundaryFluxLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorBoundaryFluxLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:425:7
    jlcxx::TypeWrapper<mfem::VectorBoundaryFluxLFIntegrator>  t = jlModule.add_type<mfem::VectorBoundaryFluxLFIntegrator>("mfem!VectorBoundaryFluxLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorBoundaryFluxLFIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorBoundaryFluxLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorBoundaryFluxLFIntegrator::VectorBoundaryFluxLFIntegrator(mfem::Coefficient &, double, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:433:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, double, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:437:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorBoundaryFluxLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorBoundaryFluxLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorBoundaryFluxLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorBoundaryFluxLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFEBoundaryFluxLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFEBoundaryFluxLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFEBoundaryFluxLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFEBoundaryFluxLFIntegrator
// signature to use in the veto file: mfem::VectorFEBoundaryFluxLFIntegrator
struct Jlmfem_VectorFEBoundaryFluxLFIntegrator: public Wrapper {

  Jlmfem_VectorFEBoundaryFluxLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFEBoundaryFluxLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:447:7
    jlcxx::TypeWrapper<mfem::VectorFEBoundaryFluxLFIntegrator>  t = jlModule.add_type<mfem::VectorFEBoundaryFluxLFIntegrator>("mfem!VectorFEBoundaryFluxLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEBoundaryFluxLFIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFEBoundaryFluxLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEBoundaryFluxLFIntegrator::VectorFEBoundaryFluxLFIntegrator(int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:455:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEBoundaryFluxLFIntegrator::VectorFEBoundaryFluxLFIntegrator(mfem::Coefficient &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:457:4
    t.constructor<mfem::Coefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Coefficient &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:460:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorFEBoundaryFluxLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for bool mfem::VectorFEBoundaryFluxLFIntegrator::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::VectorFEBoundaryFluxLFIntegrator::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:466:17
    t.method("SupportsDevice", static_cast<bool (mfem::VectorFEBoundaryFluxLFIntegrator::*)()  const>(&mfem::VectorFEBoundaryFluxLFIntegrator::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEBoundaryFluxLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEBoundaryFluxLFIntegrator::AssembleDevice(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:468:17
    t.method("AssembleDevice", static_cast<void (mfem::VectorFEBoundaryFluxLFIntegrator::*)(const mfem::FiniteElementSpace &, const mfem::Array<int> &, mfem::Vector &) >(&mfem::VectorFEBoundaryFluxLFIntegrator::AssembleDevice));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEBoundaryFluxLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFEBoundaryFluxLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFEBoundaryFluxLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorFEBoundaryTangentLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorFEBoundaryTangentLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorFEBoundaryTangentLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorFEBoundaryTangentLFIntegrator
// signature to use in the veto file: mfem::VectorFEBoundaryTangentLFIntegrator
struct Jlmfem_VectorFEBoundaryTangentLFIntegrator: public Wrapper {

  Jlmfem_VectorFEBoundaryTangentLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorFEBoundaryTangentLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:474:7
    jlcxx::TypeWrapper<mfem::VectorFEBoundaryTangentLFIntegrator>  t = jlModule.add_type<mfem::VectorFEBoundaryTangentLFIntegrator>("mfem!VectorFEBoundaryTangentLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEBoundaryTangentLFIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorFEBoundaryTangentLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorFEBoundaryTangentLFIntegrator::VectorFEBoundaryTangentLFIntegrator(mfem::VectorCoefficient &, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:481:4
    t.constructor<mfem::VectorCoefficient &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::VectorCoefficient &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:485:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorFEBoundaryTangentLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorFEBoundaryTangentLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorFEBoundaryTangentLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorFEBoundaryTangentLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BoundaryFlowIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BoundaryFlowIntegrator> : std::false_type { };
template<> struct SuperType<mfem::BoundaryFlowIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::BoundaryFlowIntegrator
// signature to use in the veto file: mfem::BoundaryFlowIntegrator
struct Jlmfem_BoundaryFlowIntegrator: public Wrapper {

  Jlmfem_BoundaryFlowIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BoundaryFlowIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:497:7
    jlcxx::TypeWrapper<mfem::BoundaryFlowIntegrator>  t = jlModule.add_type<mfem::BoundaryFlowIntegrator>("mfem!BoundaryFlowIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryFlowIntegrator>>(new jlcxx::TypeWrapper<mfem::BoundaryFlowIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::BoundaryFlowIntegrator::BoundaryFlowIntegrator(mfem::Coefficient &, mfem::VectorCoefficient &, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:507:4
    t.constructor<mfem::Coefficient &, mfem::VectorCoefficient &, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::BoundaryFlowIntegrator::BoundaryFlowIntegrator(mfem::Coefficient &, mfem::VectorCoefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:511:4
    t.constructor<mfem::Coefficient &, mfem::VectorCoefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryFlowIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryFlowIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:515:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::BoundaryFlowIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::BoundaryFlowIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::BoundaryFlowIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundaryFlowIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:518:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::BoundaryFlowIntegrator::*)(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) >(&mfem::BoundaryFlowIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BoundaryFlowIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BoundaryFlowIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BoundaryFlowIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DGDirichletLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DGDirichletLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DGDirichletLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DGDirichletLFIntegrator
// signature to use in the veto file: mfem::DGDirichletLFIntegrator
struct Jlmfem_DGDirichletLFIntegrator: public Wrapper {

  Jlmfem_DGDirichletLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DGDirichletLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:536:7
    jlcxx::TypeWrapper<mfem::DGDirichletLFIntegrator>  t = jlModule.add_type<mfem::DGDirichletLFIntegrator>("mfem!DGDirichletLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DGDirichletLFIntegrator>>(new jlcxx::TypeWrapper<mfem::DGDirichletLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DGDirichletLFIntegrator::DGDirichletLFIntegrator(mfem::Coefficient &, const double, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:548:4
    t.constructor<mfem::Coefficient &, const double, const double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGDirichletLFIntegrator::DGDirichletLFIntegrator(mfem::Coefficient &, mfem::Coefficient &, const double, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:550:4
    t.constructor<mfem::Coefficient &, mfem::Coefficient &, const double, const double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::DGDirichletLFIntegrator::DGDirichletLFIntegrator(mfem::Coefficient &, mfem::MatrixCoefficient &, const double, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:553:4
    t.constructor<mfem::Coefficient &, mfem::MatrixCoefficient &, const double, const double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DGDirichletLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGDirichletLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:557:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::DGDirichletLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::DGDirichletLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::DGDirichletLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGDirichletLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:560:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::DGDirichletLFIntegrator::*)(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) >(&mfem::DGDirichletLFIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DGDirichletLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DGDirichletLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DGDirichletLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DGElasticityDirichletLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DGElasticityDirichletLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::DGElasticityDirichletLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::DGElasticityDirichletLFIntegrator
// signature to use in the veto file: mfem::DGElasticityDirichletLFIntegrator
struct Jlmfem_DGElasticityDirichletLFIntegrator: public Wrapper {

  Jlmfem_DGElasticityDirichletLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DGElasticityDirichletLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:578:7
    jlcxx::TypeWrapper<mfem::DGElasticityDirichletLFIntegrator>  t = jlModule.add_type<mfem::DGElasticityDirichletLFIntegrator>("mfem!DGElasticityDirichletLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DGElasticityDirichletLFIntegrator>>(new jlcxx::TypeWrapper<mfem::DGElasticityDirichletLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DGElasticityDirichletLFIntegrator::DGElasticityDirichletLFIntegrator(mfem::VectorCoefficient &, mfem::Coefficient &, mfem::Coefficient &, double, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:597:4
    t.constructor<mfem::VectorCoefficient &, mfem::Coefficient &, mfem::Coefficient &, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:602:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::DGElasticityDirichletLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::DGElasticityDirichletLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:605:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::DGElasticityDirichletLFIntegrator::*)(const mfem::FiniteElement &, mfem::FaceElementTransformations &, mfem::Vector &) >(&mfem::DGElasticityDirichletLFIntegrator::AssembleRHSElementVect));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DGElasticityDirichletLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DGElasticityDirichletLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DGElasticityDirichletLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::WhiteGaussianNoiseDomainLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::WhiteGaussianNoiseDomainLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::WhiteGaussianNoiseDomainLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::WhiteGaussianNoiseDomainLFIntegrator
// signature to use in the veto file: mfem::WhiteGaussianNoiseDomainLFIntegrator
struct Jlmfem_WhiteGaussianNoiseDomainLFIntegrator: public Wrapper {

  Jlmfem_WhiteGaussianNoiseDomainLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::WhiteGaussianNoiseDomainLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:627:7
    jlcxx::TypeWrapper<mfem::WhiteGaussianNoiseDomainLFIntegrator>  t = jlModule.add_type<mfem::WhiteGaussianNoiseDomainLFIntegrator>("mfem!WhiteGaussianNoiseDomainLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::WhiteGaussianNoiseDomainLFIntegrator>>(new jlcxx::TypeWrapper<mfem::WhiteGaussianNoiseDomainLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::WhiteGaussianNoiseDomainLFIntegrator::WhiteGaussianNoiseDomainLFIntegrator(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:666:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::WhiteGaussianNoiseDomainLFIntegrator::SetSeed(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::WhiteGaussianNoiseDomainLFIntegrator::SetSeed(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:673:9
    t.method("SetSeed", static_cast<void (mfem::WhiteGaussianNoiseDomainLFIntegrator::*)(int) >(&mfem::WhiteGaussianNoiseDomainLFIntegrator::SetSeed));

    DEBUG_MSG("Adding wrapper for void mfem::WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:679:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::WhiteGaussianNoiseDomainLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::WhiteGaussianNoiseDomainLFIntegrator::SaveFactors(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::WhiteGaussianNoiseDomainLFIntegrator::SaveFactors(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:686:9
    t.method("SaveFactors", static_cast<void (mfem::WhiteGaussianNoiseDomainLFIntegrator::*)(int) >(&mfem::WhiteGaussianNoiseDomainLFIntegrator::SaveFactors));

    DEBUG_MSG("Adding wrapper for void mfem::WhiteGaussianNoiseDomainLFIntegrator::ResetFactors(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::WhiteGaussianNoiseDomainLFIntegrator::ResetFactors(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:695:9
    t.method("ResetFactors", static_cast<void (mfem::WhiteGaussianNoiseDomainLFIntegrator::*)(int) >(&mfem::WhiteGaussianNoiseDomainLFIntegrator::ResetFactors));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::WhiteGaussianNoiseDomainLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_WhiteGaussianNoiseDomainLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_WhiteGaussianNoiseDomainLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorQuadratureLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorQuadratureLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::VectorQuadratureLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::VectorQuadratureLFIntegrator
// signature to use in the veto file: mfem::VectorQuadratureLFIntegrator
struct Jlmfem_VectorQuadratureLFIntegrator: public Wrapper {

  Jlmfem_VectorQuadratureLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorQuadratureLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:724:7
    jlcxx::TypeWrapper<mfem::VectorQuadratureLFIntegrator>  t = jlModule.add_type<mfem::VectorQuadratureLFIntegrator>("mfem!VectorQuadratureLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorQuadratureLFIntegrator>>(new jlcxx::TypeWrapper<mfem::VectorQuadratureLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureLFIntegrator::VectorQuadratureLFIntegrator(mfem::VectorQuadratureFunctionCoefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:730:4
    t.constructor<mfem::VectorQuadratureFunctionCoefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorQuadratureLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:742:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::VectorQuadratureLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::VectorQuadratureLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::VectorQuadratureLFIntegrator::SetIntRule(const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VectorQuadratureLFIntegrator::SetIntRule(const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:746:17
    t.method("SetIntRule", static_cast<void (mfem::VectorQuadratureLFIntegrator::*)(const mfem::IntegrationRule *) >(&mfem::VectorQuadratureLFIntegrator::SetIntRule));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorQuadratureLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorQuadratureLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorQuadratureLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureLFIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureLFIntegrator> : std::false_type { };
template<> struct SuperType<mfem::QuadratureLFIntegrator> { typedef mfem::LinearFormIntegrator type; };
}

// Class generating the wrapper for type mfem::QuadratureLFIntegrator
// signature to use in the veto file: mfem::QuadratureLFIntegrator
struct Jlmfem_QuadratureLFIntegrator: public Wrapper {

  Jlmfem_QuadratureLFIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureLFIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:756:7
    jlcxx::TypeWrapper<mfem::QuadratureLFIntegrator>  t = jlModule.add_type<mfem::QuadratureLFIntegrator>("mfem!QuadratureLFIntegrator",
      jlcxx::julia_base_type<mfem::LinearFormIntegrator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureLFIntegrator>>(new jlcxx::TypeWrapper<mfem::QuadratureLFIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureLFIntegrator::QuadratureLFIntegrator(mfem::QuadratureFunctionCoefficient &, const mfem::IntegrationRule *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:762:4
    t.constructor<mfem::QuadratureFunctionCoefficient &, const mfem::IntegrationRule *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureLFIntegrator::AssembleRHSElementVect(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:774:17
    t.method("AssembleRHSElementVect", static_cast<void (mfem::QuadratureLFIntegrator::*)(const mfem::FiniteElement &, mfem::ElementTransformation &, mfem::Vector &) >(&mfem::QuadratureLFIntegrator::AssembleRHSElementVect));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureLFIntegrator::SetIntRule(const mfem::IntegrationRule *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureLFIntegrator::SetIntRule(const mfem::IntegrationRule *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/lininteg.hpp:778:17
    t.method("SetIntRule", static_cast<void (mfem::QuadratureLFIntegrator::*)(const mfem::IntegrationRule *) >(&mfem::QuadratureLFIntegrator::SetIntRule));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureLFIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureLFIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureLFIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearForm> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearForm> : std::false_type { };
template<> struct SuperType<mfem::LinearForm> { typedef mfem::Vector type; };
}

// Class generating the wrapper for type mfem::LinearForm
// signature to use in the veto file: mfem::LinearForm
struct Jlmfem_LinearForm: public Wrapper {

  Jlmfem_LinearForm(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearForm (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:24:7
    jlcxx::TypeWrapper<mfem::LinearForm>  t = jlModule.add_type<mfem::LinearForm>("mfem!LinearForm",
      jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearForm>>(new jlcxx::TypeWrapper<mfem::LinearForm>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::LinearForm(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:88:4
    t.constructor<mfem::FiniteElementSpace *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::LinearForm(mfem::FiniteElementSpace *, mfem::LinearForm *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:98:4
    t.constructor<mfem::FiniteElementSpace *, mfem::LinearForm *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::LinearForm(mfem::FiniteElementSpace *, double *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:112:4
    t.constructor<mfem::FiniteElementSpace *, double *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::LinearForm & mfem::LinearForm::operator=(const mfem::LinearForm &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::LinearForm & mfem::LinearForm::operator=(const mfem::LinearForm &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:121:16
    t.method("assign", static_cast<mfem::LinearForm & (mfem::LinearForm::*)(const mfem::LinearForm &) >(&mfem::LinearForm::operator=));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::LinearForm::GetFES() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::LinearForm::GetFES()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:126:40
    t.method("GetFES", static_cast<mfem::FiniteElementSpace * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetFES));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::LinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::LinearForm::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:129:24
    t.method("FESpace", static_cast<mfem::FiniteElementSpace * (mfem::LinearForm::*)() >(&mfem::LinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::LinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::LinearForm::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:131:30
    t.method("FESpace", static_cast<const mfem::FiniteElementSpace * (mfem::LinearForm::*)()  const>(&mfem::LinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddDomainIntegrator(mfem::LinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddDomainIntegrator(mfem::LinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:134:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *) >(&mfem::LinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddDomainIntegrator(mfem::LinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddDomainIntegrator(mfem::LinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:137:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *, mfem::Array<int> &) >(&mfem::LinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddBoundaryIntegrator(mfem::LinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddBoundaryIntegrator(mfem::LinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:141:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *) >(&mfem::LinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddBoundaryIntegrator(mfem::LinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddBoundaryIntegrator(mfem::LinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:148:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *, mfem::Array<int> &) >(&mfem::LinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddBdrFaceIntegrator(mfem::LinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddBdrFaceIntegrator(mfem::LinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:152:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *) >(&mfem::LinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddBdrFaceIntegrator(mfem::LinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddBdrFaceIntegrator(mfem::LinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:159:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *, mfem::Array<int> &) >(&mfem::LinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AddInteriorFaceIntegrator(mfem::LinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AddInteriorFaceIntegrator(mfem::LinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:163:9
    t.method("AddInteriorFaceIntegrator", static_cast<void (mfem::LinearForm::*)(mfem::LinearFormIntegrator *) >(&mfem::LinearForm::AddInteriorFaceIntegrator));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::LinearFormIntegrator *> * mfem::LinearForm::GetDLFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::LinearFormIntegrator *> * mfem::LinearForm::GetDLFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:168:34
    t.method("GetDLFI", static_cast<mfem::Array<mfem::LinearFormIntegrator *> * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetDLFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::LinearForm::GetDLFI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::LinearForm::GetDLFI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:173:24
    t.method("GetDLFI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetDLFI_Marker));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::DeltaLFIntegrator *> * mfem::LinearForm::GetDLFI_Delta() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::DeltaLFIntegrator *> * mfem::LinearForm::GetDLFI_Delta()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:177:31
    t.method("GetDLFI_Delta", static_cast<mfem::Array<mfem::DeltaLFIntegrator *> * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetDLFI_Delta));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::LinearFormIntegrator *> * mfem::LinearForm::GetBLFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::LinearFormIntegrator *> * mfem::LinearForm::GetBLFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:180:34
    t.method("GetBLFI", static_cast<mfem::Array<mfem::LinearFormIntegrator *> * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetBLFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::LinearFormIntegrator *> * mfem::LinearForm::GetFLFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::LinearFormIntegrator *> * mfem::LinearForm::GetFLFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:183:34
    t.method("GetFLFI", static_cast<mfem::Array<mfem::LinearFormIntegrator *> * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetFLFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::LinearFormIntegrator *> * mfem::LinearForm::GetIFLFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::LinearFormIntegrator *> * mfem::LinearForm::GetIFLFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:186:34
    t.method("GetIFLFI", static_cast<mfem::Array<mfem::LinearFormIntegrator *> * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetIFLFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::LinearForm::GetFLFI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::LinearForm::GetFLFI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:191:24
    t.method("GetFLFI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::LinearForm::*)() >(&mfem::LinearForm::GetFLFI_Marker));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::UseFastAssembly(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::UseFastAssembly(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:197:9
    t.method("UseFastAssembly", static_cast<void (mfem::LinearForm::*)(bool) >(&mfem::LinearForm::UseFastAssembly));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::Assemble() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::Assemble()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:203:9
    t.method("Assemble", static_cast<void (mfem::LinearForm::*)() >(&mfem::LinearForm::Assemble));

    DEBUG_MSG("Adding wrapper for bool mfem::LinearForm::SupportsDevice() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::LinearForm::SupportsDevice()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:206:17
    t.method("SupportsDevice", static_cast<bool (mfem::LinearForm::*)()  const>(&mfem::LinearForm::SupportsDevice));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::AssembleDelta() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::AssembleDelta()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:209:9
    t.method("AssembleDelta", static_cast<void (mfem::LinearForm::*)() >(&mfem::LinearForm::AssembleDelta));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::Update() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::Update()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:216:9
    t.method("Update", static_cast<void (mfem::LinearForm::*)() >(&mfem::LinearForm::Update));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::Update(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::Update(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:219:9
    t.method("Update", static_cast<void (mfem::LinearForm::*)(mfem::FiniteElementSpace *) >(&mfem::LinearForm::Update));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::Update(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::Update(mfem::FiniteElementSpace *, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:225:9
    t.method("Update", static_cast<void (mfem::LinearForm::*)(mfem::FiniteElementSpace *, mfem::Vector &, int) >(&mfem::LinearForm::Update));

    DEBUG_MSG("Adding wrapper for void mfem::LinearForm::MakeRef(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::LinearForm::MakeRef(mfem::FiniteElementSpace *, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:235:17
    t.method("MakeRef", static_cast<void (mfem::LinearForm::*)(mfem::FiniteElementSpace *, mfem::Vector &, int) >(&mfem::LinearForm::MakeRef));

    DEBUG_MSG("Adding wrapper for double mfem::LinearForm::operator()(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::LinearForm::operator()(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:242:11
    t.method("paren", static_cast<double (mfem::LinearForm::*)(const mfem::GridFunction &)  const>(&mfem::LinearForm::operator()));

    DEBUG_MSG("Adding wrapper for mfem::LinearForm & mfem::LinearForm::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::LinearForm & mfem::LinearForm::operator=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:245:16
    t.method("assign", static_cast<mfem::LinearForm & (mfem::LinearForm::*)(double) >(&mfem::LinearForm::operator=));

    DEBUG_MSG("Adding wrapper for mfem::LinearForm & mfem::LinearForm::operator=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::LinearForm & mfem::LinearForm::operator=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/linearform.hpp:250:16
    t.method("assign", static_cast<mfem::LinearForm & (mfem::LinearForm::*)(const mfem::Vector &) >(&mfem::LinearForm::operator=));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearForm>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearForm(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearForm(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Hybridization> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Hybridization> : std::false_type { };
}

// Class generating the wrapper for type mfem::Hybridization
// signature to use in the veto file: mfem::Hybridization
struct Jlmfem_Hybridization: public Wrapper {

  Jlmfem_Hybridization(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Hybridization (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/hybridization.hpp:60:7
    jlcxx::TypeWrapper<mfem::Hybridization>  t = jlModule.add_type<mfem::Hybridization>("mfem!Hybridization");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Hybridization>>(new jlcxx::TypeWrapper<mfem::Hybridization>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Hybridization>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Hybridization(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Hybridization(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::MixedBilinearForm> : std::false_type { };
  template<> struct DefaultConstructible<mfem::MixedBilinearForm> : std::false_type { };
template<> struct SuperType<mfem::MixedBilinearForm> { typedef mfem::Matrix type; };
}

// Class generating the wrapper for type mfem::MixedBilinearForm
// signature to use in the veto file: mfem::MixedBilinearForm
struct Jlmfem_MixedBilinearForm: public Wrapper {

  Jlmfem_MixedBilinearForm(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::MixedBilinearForm (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:733:7
    jlcxx::TypeWrapper<mfem::MixedBilinearForm>  t = jlModule.add_type<mfem::MixedBilinearForm>("mfem!MixedBilinearForm",
      jlcxx::julia_base_type<mfem::Matrix>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedBilinearForm>>(new jlcxx::TypeWrapper<mfem::MixedBilinearForm>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::MixedBilinearForm(mfem::FiniteElementSpace *, mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:789:4
    t.constructor<mfem::FiniteElementSpace *, mfem::FiniteElementSpace *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::MixedBilinearForm(mfem::FiniteElementSpace *, mfem::FiniteElementSpace *, mfem::MixedBilinearForm *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:801:4
    t.constructor<mfem::FiniteElementSpace *, mfem::FiniteElementSpace *, mfem::MixedBilinearForm *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double & mfem::MixedBilinearForm::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::MixedBilinearForm::Elem(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:806:20
    t.method("Elem", static_cast<double & (mfem::MixedBilinearForm::*)(int, int) >(&mfem::MixedBilinearForm::Elem));

    DEBUG_MSG("Adding wrapper for const double & mfem::MixedBilinearForm::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::MixedBilinearForm::Elem(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:809:26
    t.method("Elem", static_cast<const double & (mfem::MixedBilinearForm::*)(int, int)  const>(&mfem::MixedBilinearForm::Elem));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:812:17
    t.method("Mult", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MixedBilinearForm::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddMult(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddMult(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:815:17
    t.method("AddMult", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::MixedBilinearForm::AddMult));
    t.method("AddMult", [](mfem::MixedBilinearForm const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMult(arg0, arg1); });
    t.method("AddMult", [](mfem::MixedBilinearForm const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::MultTranspose(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::MultTranspose(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:819:17
    t.method("MultTranspose", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MixedBilinearForm::MultTranspose));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddMultTranspose(const mfem::Vector &, mfem::Vector &, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:822:17
    t.method("AddMultTranspose", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &, const double)  const>(&mfem::MixedBilinearForm::AddMultTranspose));
    t.method("AddMultTranspose", [](mfem::MixedBilinearForm const& a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a.AddMultTranspose(arg0, arg1); });
    t.method("AddMultTranspose", [](mfem::MixedBilinearForm const* a, const mfem::Vector & arg0, mfem::Vector & arg1)->void { a->AddMultTranspose(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::MatrixInverse * mfem::MixedBilinearForm::Inverse() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixInverse * mfem::MixedBilinearForm::Inverse()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:827:27
    t.method("Inverse", static_cast<mfem::MatrixInverse * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::Inverse));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::Finalize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::Finalize(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:831:17
    t.method("Finalize", static_cast<void (mfem::MixedBilinearForm::*)(int) >(&mfem::MixedBilinearForm::Finalize));
    t.method("Finalize", [](mfem::MixedBilinearForm& a)->void { a.Finalize(); });
    t.method("Finalize", [](mfem::MixedBilinearForm* a)->void { a->Finalize(); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::GetBlocks(mfem::Array2D<mfem::SparseMatrix *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::GetBlocks(mfem::Array2D<mfem::SparseMatrix *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:836:9
    t.method("GetBlocks", static_cast<void (mfem::MixedBilinearForm::*)(mfem::Array2D<mfem::SparseMatrix *> &)  const>(&mfem::MixedBilinearForm::GetBlocks));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix & mfem::MixedBilinearForm::SpMat() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix & mfem::MixedBilinearForm::SpMat()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:842:24
    t.method("SpMat", static_cast<const mfem::SparseMatrix & (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::SpMat));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix & mfem::MixedBilinearForm::SpMat() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix & mfem::MixedBilinearForm::SpMat()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:845:18
    t.method("SpMat", static_cast<mfem::SparseMatrix & (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::SpMat));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::MixedBilinearForm::LoseMat() (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::MixedBilinearForm::LoseMat()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:849:18
    t.method("LoseMat", static_cast<mfem::SparseMatrix * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::LoseMat));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:852:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::MixedBilinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddDomainIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:855:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *, mfem::Array<int> &) >(&mfem::MixedBilinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:859:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::MixedBilinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddBoundaryIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:862:9
    t.method("AddBoundaryIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *, mfem::Array<int> &) >(&mfem::MixedBilinearForm::AddBoundaryIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddTraceFaceIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddTraceFaceIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:870:9
    t.method("AddTraceFaceIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::MixedBilinearForm::AddTraceFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator(mfem::BilinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator(mfem::BilinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:873:9
    t.method("AddBdrTraceFaceIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *) >(&mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator(mfem::BilinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:876:9
    t.method("AddBdrTraceFaceIntegrator", static_cast<void (mfem::MixedBilinearForm::*)(mfem::BilinearFormIntegrator *, mfem::Array<int> &) >(&mfem::MixedBilinearForm::AddBdrTraceFaceIntegrator));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::MixedBilinearForm::GetDBFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::MixedBilinearForm::GetDBFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:880:36
    t.method("GetDBFI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::GetDBFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::MixedBilinearForm::GetDBFI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::MixedBilinearForm::GetDBFI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:884:24
    t.method("GetDBFI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::GetDBFI_Marker));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::MixedBilinearForm::GetBBFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::MixedBilinearForm::GetBBFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:887:36
    t.method("GetBBFI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::GetBBFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::MixedBilinearForm::GetBBFI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::MixedBilinearForm::GetBBFI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:893:24
    t.method("GetBBFI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::GetBBFI_Marker));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::MixedBilinearForm::GetTFBFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::MixedBilinearForm::GetTFBFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:896:36
    t.method("GetTFBFI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::GetTFBFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::MixedBilinearForm::GetBTFBFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::MixedBilinearForm::GetBTFBFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:899:36
    t.method("GetBTFBFI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::GetBTFBFI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::MixedBilinearForm::GetBTFBFI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::MixedBilinearForm::GetBTFBFI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:906:24
    t.method("GetBTFBFI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::GetBTFBFI_Marker));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::operator=(const double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::operator=(const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:910:9
    t.method("assign", static_cast<void (mfem::MixedBilinearForm::*)(const double) >(&mfem::MixedBilinearForm::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::SetAssemblyLevel(mfem::AssemblyLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::SetAssemblyLevel(mfem::AssemblyLevel)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:914:9
    t.method("SetAssemblyLevel", static_cast<void (mfem::MixedBilinearForm::*)(mfem::AssemblyLevel) >(&mfem::MixedBilinearForm::SetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::Assemble(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::Assemble(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:916:9
    t.method("Assemble", static_cast<void (mfem::MixedBilinearForm::*)(int) >(&mfem::MixedBilinearForm::Assemble));
    t.method("Assemble", [](mfem::MixedBilinearForm& a)->void { a.Assemble(); });
    t.method("Assemble", [](mfem::MixedBilinearForm* a)->void { a->Assemble(); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AssembleDiagonal_ADAt(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AssembleDiagonal_ADAt(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:920:9
    t.method("AssembleDiagonal_ADAt", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::MixedBilinearForm::AssembleDiagonal_ADAt));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::MixedBilinearForm::GetProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::MixedBilinearForm::GetProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:923:28
    t.method("GetProlongation", static_cast<const mfem::Operator * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::GetProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::MixedBilinearForm::GetRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::MixedBilinearForm::GetRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:927:28
    t.method("GetRestriction", static_cast<const mfem::Operator * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::GetRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::MixedBilinearForm::GetOutputProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::MixedBilinearForm::GetOutputProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:931:28
    t.method("GetOutputProlongation", static_cast<const mfem::Operator * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::GetOutputProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::MixedBilinearForm::GetOutputRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::MixedBilinearForm::GetOutputRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:935:28
    t.method("GetOutputRestriction", static_cast<const mfem::Operator * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::GetOutputRestriction));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::ConformingAssemble() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::ConformingAssemble()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:944:9
    t.method("ConformingAssemble", static_cast<void (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::ConformingAssemble));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::ComputeElementMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::ComputeElementMatrix(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:947:9
    t.method("ComputeElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, mfem::DenseMatrix &) >(&mfem::MixedBilinearForm::ComputeElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::ComputeBdrElementMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::ComputeBdrElementMatrix(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:950:9
    t.method("ComputeBdrElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, mfem::DenseMatrix &) >(&mfem::MixedBilinearForm::ComputeBdrElementMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:958:9
    t.method("AssembleElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, const mfem::DenseMatrix &, int) >(&mfem::MixedBilinearForm::AssembleElementMatrix));
    t.method("AssembleElementMatrix", [](mfem::MixedBilinearForm& a, int arg0, const mfem::DenseMatrix & arg1)->void { a.AssembleElementMatrix(arg0, arg1); });
    t.method("AssembleElementMatrix", [](mfem::MixedBilinearForm* a, int arg0, const mfem::DenseMatrix & arg1)->void { a->AssembleElementMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AssembleElementMatrix(int, const mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:968:9
    t.method("AssembleElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, const mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<int> &, int) >(&mfem::MixedBilinearForm::AssembleElementMatrix));
    t.method("AssembleElementMatrix", [](mfem::MixedBilinearForm& a, int arg0, const mfem::DenseMatrix & arg1, mfem::Array<int> & arg2, mfem::Array<int> & arg3)->void { a.AssembleElementMatrix(arg0, arg1, arg2, arg3); });
    t.method("AssembleElementMatrix", [](mfem::MixedBilinearForm* a, int arg0, const mfem::DenseMatrix & arg1, mfem::Array<int> & arg2, mfem::Array<int> & arg3)->void { a->AssembleElementMatrix(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:978:9
    t.method("AssembleBdrElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, const mfem::DenseMatrix &, int) >(&mfem::MixedBilinearForm::AssembleBdrElementMatrix));
    t.method("AssembleBdrElementMatrix", [](mfem::MixedBilinearForm& a, int arg0, const mfem::DenseMatrix & arg1)->void { a.AssembleBdrElementMatrix(arg0, arg1); });
    t.method("AssembleBdrElementMatrix", [](mfem::MixedBilinearForm* a, int arg0, const mfem::DenseMatrix & arg1)->void { a->AssembleBdrElementMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::AssembleBdrElementMatrix(int, const mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:987:9
    t.method("AssembleBdrElementMatrix", static_cast<void (mfem::MixedBilinearForm::*)(int, const mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<int> &, int) >(&mfem::MixedBilinearForm::AssembleBdrElementMatrix));
    t.method("AssembleBdrElementMatrix", [](mfem::MixedBilinearForm& a, int arg0, const mfem::DenseMatrix & arg1, mfem::Array<int> & arg2, mfem::Array<int> & arg3)->void { a.AssembleBdrElementMatrix(arg0, arg1, arg2, arg3); });
    t.method("AssembleBdrElementMatrix", [](mfem::MixedBilinearForm* a, int arg0, const mfem::DenseMatrix & arg1, mfem::Array<int> & arg2, mfem::Array<int> & arg3)->void { a->AssembleBdrElementMatrix(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::EliminateTrialDofs(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::EliminateTrialDofs(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:996:9
    t.method("EliminateTrialDofs", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &) >(&mfem::MixedBilinearForm::EliminateTrialDofs));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::EliminateEssentialBCFromTrialDofs(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::EliminateEssentialBCFromTrialDofs(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1002:9
    t.method("EliminateEssentialBCFromTrialDofs", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Array<int> &, const mfem::Vector &, mfem::Vector &) >(&mfem::MixedBilinearForm::EliminateEssentialBCFromTrialDofs));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::EliminateTestDofs(const mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::EliminateTestDofs(const mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1009:17
    t.method("EliminateTestDofs", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Array<int> &) >(&mfem::MixedBilinearForm::EliminateTestDofs));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::FormRectangularSystemMatrix(const mfem::Array<int> &, const mfem::Array<int> &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::FormRectangularSystemMatrix(const mfem::Array<int> &, const mfem::Array<int> &, mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1015:17
    t.method("FormRectangularSystemMatrix", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Array<int> &, const mfem::Array<int> &, mfem::OperatorHandle &) >(&mfem::MixedBilinearForm::FormRectangularSystemMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::FormRectangularLinearSystem(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::OperatorHandle &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::FormRectangularLinearSystem(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::OperatorHandle &, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1043:17
    t.method("FormRectangularLinearSystem", static_cast<void (mfem::MixedBilinearForm::*)(const mfem::Array<int> &, const mfem::Array<int> &, mfem::Vector &, mfem::Vector &, mfem::OperatorHandle &, mfem::Vector &, mfem::Vector &) >(&mfem::MixedBilinearForm::FormRectangularLinearSystem));

    DEBUG_MSG("Adding wrapper for void mfem::MixedBilinearForm::Update() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MixedBilinearForm::Update()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1072:9
    t.method("Update", static_cast<void (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::Update));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::MixedBilinearForm::TrialFESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::MixedBilinearForm::TrialFESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1075:24
    t.method("TrialFESpace", static_cast<mfem::FiniteElementSpace * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::TrialFESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::MixedBilinearForm::TrialFESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::MixedBilinearForm::TrialFESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1078:30
    t.method("TrialFESpace", static_cast<const mfem::FiniteElementSpace * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::TrialFESpace));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::MixedBilinearForm::TestFESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::MixedBilinearForm::TestFESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1081:24
    t.method("TestFESpace", static_cast<mfem::FiniteElementSpace * (mfem::MixedBilinearForm::*)() >(&mfem::MixedBilinearForm::TestFESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::MixedBilinearForm::TestFESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::MixedBilinearForm::TestFESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1084:30
    t.method("TestFESpace", static_cast<const mfem::FiniteElementSpace * (mfem::MixedBilinearForm::*)()  const>(&mfem::MixedBilinearForm::TestFESpace));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::MixedBilinearForm>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_MixedBilinearForm(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_MixedBilinearForm(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DiscreteLinearOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DiscreteLinearOperator> : std::false_type { };
template<> struct SuperType<mfem::DiscreteLinearOperator> { typedef mfem::MixedBilinearForm type; };
}

// Class generating the wrapper for type mfem::DiscreteLinearOperator
// signature to use in the veto file: mfem::DiscreteLinearOperator
struct Jlmfem_DiscreteLinearOperator: public Wrapper {

  Jlmfem_DiscreteLinearOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DiscreteLinearOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1122:7
    jlcxx::TypeWrapper<mfem::DiscreteLinearOperator>  t = jlModule.add_type<mfem::DiscreteLinearOperator>("mfem!DiscreteLinearOperator",
      jlcxx::julia_base_type<mfem::MixedBilinearForm>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DiscreteLinearOperator>>(new jlcxx::TypeWrapper<mfem::DiscreteLinearOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::DiscreteLinearOperator(mfem::FiniteElementSpace *, mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1136:4
    t.constructor<mfem::FiniteElementSpace *, mfem::FiniteElementSpace *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::AddDomainInterpolator(mfem::DiscreteInterpolator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::AddDomainInterpolator(mfem::DiscreteInterpolator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1141:9
    t.method("AddDomainInterpolator", static_cast<void (mfem::DiscreteLinearOperator::*)(mfem::DiscreteInterpolator *) >(&mfem::DiscreteLinearOperator::AddDomainInterpolator));

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::AddDomainInterpolator(mfem::DiscreteInterpolator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::AddDomainInterpolator(mfem::DiscreteInterpolator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1143:9
    t.method("AddDomainInterpolator", static_cast<void (mfem::DiscreteLinearOperator::*)(mfem::DiscreteInterpolator *, mfem::Array<int> &) >(&mfem::DiscreteLinearOperator::AddDomainInterpolator));

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::AddTraceFaceInterpolator(mfem::DiscreteInterpolator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::AddTraceFaceInterpolator(mfem::DiscreteInterpolator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1148:9
    t.method("AddTraceFaceInterpolator", static_cast<void (mfem::DiscreteLinearOperator::*)(mfem::DiscreteInterpolator *) >(&mfem::DiscreteLinearOperator::AddTraceFaceInterpolator));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::BilinearFormIntegrator *> * mfem::DiscreteLinearOperator::GetDI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::BilinearFormIntegrator *> * mfem::DiscreteLinearOperator::GetDI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1152:36
    t.method("GetDI", static_cast<mfem::Array<mfem::BilinearFormIntegrator *> * (mfem::DiscreteLinearOperator::*)() >(&mfem::DiscreteLinearOperator::GetDI));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::Array<int> *> * mfem::DiscreteLinearOperator::GetDI_Marker() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::Array<int> *> * mfem::DiscreteLinearOperator::GetDI_Marker()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1153:24
    t.method("GetDI_Marker", static_cast<mfem::Array<mfem::Array<int> *> * (mfem::DiscreteLinearOperator::*)() >(&mfem::DiscreteLinearOperator::GetDI_Marker));

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::SetAssemblyLevel(mfem::AssemblyLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::SetAssemblyLevel(mfem::AssemblyLevel)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1157:9
    t.method("SetAssemblyLevel", static_cast<void (mfem::DiscreteLinearOperator::*)(mfem::AssemblyLevel) >(&mfem::DiscreteLinearOperator::SetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for void mfem::DiscreteLinearOperator::Assemble(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DiscreteLinearOperator::Assemble(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1161:17
    t.method("Assemble", static_cast<void (mfem::DiscreteLinearOperator::*)(int) >(&mfem::DiscreteLinearOperator::Assemble));
    t.method("Assemble", [](mfem::DiscreteLinearOperator& a)->void { a.Assemble(); });
    t.method("Assemble", [](mfem::DiscreteLinearOperator* a)->void { a->Assemble(); });

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::DiscreteLinearOperator::GetOutputRestrictionTranspose() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::DiscreteLinearOperator::GetOutputRestrictionTranspose()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:1165:28
    t.method("GetOutputRestrictionTranspose", static_cast<const mfem::Operator * (mfem::DiscreteLinearOperator::*)()  const>(&mfem::DiscreteLinearOperator::GetOutputRestrictionTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DiscreteLinearOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DiscreteLinearOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DiscreteLinearOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NonlinearForm> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NonlinearForm> : std::false_type { };
template<> struct SuperType<mfem::NonlinearForm> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::NonlinearForm
// signature to use in the veto file: mfem::NonlinearForm
struct Jlmfem_NonlinearForm: public Wrapper {

  Jlmfem_NonlinearForm(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NonlinearForm (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:24:7
    jlcxx::TypeWrapper<mfem::NonlinearForm>  t = jlModule.add_type<mfem::NonlinearForm>("mfem!NonlinearForm",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NonlinearForm>>(new jlcxx::TypeWrapper<mfem::NonlinearForm>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::NonlinearForm(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:74:4
    t.constructor<mfem::FiniteElementSpace *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::SetAssemblyLevel(mfem::AssemblyLevel) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::SetAssemblyLevel(mfem::AssemblyLevel)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:105:9
    t.method("SetAssemblyLevel", static_cast<void (mfem::NonlinearForm::*)(mfem::AssemblyLevel) >(&mfem::NonlinearForm::SetAssemblyLevel));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::NonlinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::NonlinearForm::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:107:24
    t.method("FESpace", static_cast<mfem::FiniteElementSpace * (mfem::NonlinearForm::*)() >(&mfem::NonlinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::NonlinearForm::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::NonlinearForm::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:108:30
    t.method("FESpace", static_cast<const mfem::FiniteElementSpace * (mfem::NonlinearForm::*)()  const>(&mfem::NonlinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::AddDomainIntegrator(mfem::NonlinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::AddDomainIntegrator(mfem::NonlinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:111:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::NonlinearForm::*)(mfem::NonlinearFormIntegrator *) >(&mfem::NonlinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::AddDomainIntegrator(mfem::NonlinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::AddDomainIntegrator(mfem::NonlinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:115:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::NonlinearForm::*)(mfem::NonlinearFormIntegrator *, mfem::Array<int> &) >(&mfem::NonlinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for mfem::Array<mfem::NonlinearFormIntegrator *> * mfem::NonlinearForm::GetDNFI() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<mfem::NonlinearFormIntegrator *> * mfem::NonlinearForm::GetDNFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:120:37
    t.method("GetDNFI", static_cast<mfem::Array<mfem::NonlinearFormIntegrator *> * (mfem::NonlinearForm::*)() >(&mfem::NonlinearForm::GetDNFI));

    DEBUG_MSG("Adding wrapper for const mfem::Array<mfem::NonlinearFormIntegrator *> * mfem::NonlinearForm::GetDNFI() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<mfem::NonlinearFormIntegrator *> * mfem::NonlinearForm::GetDNFI()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:121:43
    t.method("GetDNFI", static_cast<const mfem::Array<mfem::NonlinearFormIntegrator *> * (mfem::NonlinearForm::*)()  const>(&mfem::NonlinearForm::GetDNFI));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::AddInteriorFaceIntegrator(mfem::NonlinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::AddInteriorFaceIntegrator(mfem::NonlinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:124:9
    t.method("AddInteriorFaceIntegrator", static_cast<void (mfem::NonlinearForm::*)(mfem::NonlinearFormIntegrator *) >(&mfem::NonlinearForm::AddInteriorFaceIntegrator));

    DEBUG_MSG("Adding wrapper for const mfem::Array<mfem::NonlinearFormIntegrator *> & mfem::NonlinearForm::GetInteriorFaceIntegrators() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<mfem::NonlinearFormIntegrator *> & mfem::NonlinearForm::GetInteriorFaceIntegrators()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:129:43
    t.method("GetInteriorFaceIntegrators", static_cast<const mfem::Array<mfem::NonlinearFormIntegrator *> & (mfem::NonlinearForm::*)()  const>(&mfem::NonlinearForm::GetInteriorFaceIntegrators));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::AddBdrFaceIntegrator(mfem::NonlinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::AddBdrFaceIntegrator(mfem::NonlinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:133:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::NonlinearForm::*)(mfem::NonlinearFormIntegrator *) >(&mfem::NonlinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::AddBdrFaceIntegrator(mfem::NonlinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::AddBdrFaceIntegrator(mfem::NonlinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:138:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::NonlinearForm::*)(mfem::NonlinearFormIntegrator *, mfem::Array<int> &) >(&mfem::NonlinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for const mfem::Array<mfem::NonlinearFormIntegrator *> & mfem::NonlinearForm::GetBdrFaceIntegrators() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<mfem::NonlinearFormIntegrator *> & mfem::NonlinearForm::GetBdrFaceIntegrators()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:144:43
    t.method("GetBdrFaceIntegrators", static_cast<const mfem::Array<mfem::NonlinearFormIntegrator *> & (mfem::NonlinearForm::*)()  const>(&mfem::NonlinearForm::GetBdrFaceIntegrators));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::SetEssentialBC(const mfem::Array<int> &, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::SetEssentialBC(const mfem::Array<int> &, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:153:9
    t.method("SetEssentialBC", static_cast<void (mfem::NonlinearForm::*)(const mfem::Array<int> &, mfem::Vector *) >(&mfem::NonlinearForm::SetEssentialBC));
    t.method("SetEssentialBC", [](mfem::NonlinearForm& a, const mfem::Array<int> & arg0)->void { a.SetEssentialBC(arg0); });
    t.method("SetEssentialBC", [](mfem::NonlinearForm* a, const mfem::Array<int> & arg0)->void { a->SetEssentialBC(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::SetEssentialVDofs(const mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::SetEssentialVDofs(const mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:157:9
    t.method("SetEssentialVDofs", static_cast<void (mfem::NonlinearForm::*)(const mfem::Array<int> &) >(&mfem::NonlinearForm::SetEssentialVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::SetEssentialTrueDofs(const mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::SetEssentialTrueDofs(const mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:160:9
    t.method("SetEssentialTrueDofs", static_cast<void (mfem::NonlinearForm::*)(const mfem::Array<int> &) >(&mfem::NonlinearForm::SetEssentialTrueDofs));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::NonlinearForm::GetEssentialTrueDofs() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::NonlinearForm::GetEssentialTrueDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:164:22
    t.method("GetEssentialTrueDofs", static_cast<const mfem::Array<int> & (mfem::NonlinearForm::*)()  const>(&mfem::NonlinearForm::GetEssentialTrueDofs));

    DEBUG_MSG("Adding wrapper for double mfem::NonlinearForm::GetGridFunctionEnergy(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::NonlinearForm::GetGridFunctionEnergy(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:171:11
    t.method("GetGridFunctionEnergy", static_cast<double (mfem::NonlinearForm::*)(const mfem::Vector &)  const>(&mfem::NonlinearForm::GetGridFunctionEnergy));

    DEBUG_MSG("Adding wrapper for double mfem::NonlinearForm::GetEnergy(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::NonlinearForm::GetEnergy(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:177:19
    t.method("GetEnergy", static_cast<double (mfem::NonlinearForm::*)(const mfem::Vector &)  const>(&mfem::NonlinearForm::GetEnergy));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:186:17
    t.method("Mult", static_cast<void (mfem::NonlinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::NonlinearForm::Mult));

    DEBUG_MSG("Adding wrapper for mfem::Operator & mfem::NonlinearForm::GetGradient(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator & mfem::NonlinearForm::GetGradient(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:199:22
    t.method("GetGradient", static_cast<mfem::Operator & (mfem::NonlinearForm::*)(const mfem::Vector &)  const>(&mfem::NonlinearForm::GetGradient));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::Update() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::Update()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:204:17
    t.method("Update", static_cast<void (mfem::NonlinearForm::*)() >(&mfem::NonlinearForm::Update));

    DEBUG_MSG("Adding wrapper for void mfem::NonlinearForm::Setup() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NonlinearForm::Setup()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:212:17
    t.method("Setup", static_cast<void (mfem::NonlinearForm::*)() >(&mfem::NonlinearForm::Setup));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::NonlinearForm::GetProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::NonlinearForm::GetProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:215:28
    t.method("GetProlongation", static_cast<const mfem::Operator * (mfem::NonlinearForm::*)()  const>(&mfem::NonlinearForm::GetProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::NonlinearForm::GetRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::NonlinearForm::GetRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:217:28
    t.method("GetRestriction", static_cast<const mfem::Operator * (mfem::NonlinearForm::*)()  const>(&mfem::NonlinearForm::GetRestriction));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NonlinearForm>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NonlinearForm(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NonlinearForm(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BlockNonlinearForm> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BlockNonlinearForm> : std::false_type { };
template<> struct SuperType<mfem::BlockNonlinearForm> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::BlockNonlinearForm
// signature to use in the veto file: mfem::BlockNonlinearForm
struct Jlmfem_BlockNonlinearForm: public Wrapper {

  Jlmfem_BlockNonlinearForm(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BlockNonlinearForm (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:228:7
    jlcxx::TypeWrapper<mfem::BlockNonlinearForm>  t = jlModule.add_type<mfem::BlockNonlinearForm>("mfem!BlockNonlinearForm",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BlockNonlinearForm>>(new jlcxx::TypeWrapper<mfem::BlockNonlinearForm>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::BlockNonlinearForm(mfem::Array<mfem::FiniteElementSpace *> &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:290:4
    t.constructor<mfem::Array<mfem::FiniteElementSpace *> &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::BlockNonlinearForm::FESpace(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::BlockNonlinearForm::FESpace(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:293:24
    t.method("FESpace", static_cast<mfem::FiniteElementSpace * (mfem::BlockNonlinearForm::*)(int) >(&mfem::BlockNonlinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::BlockNonlinearForm::FESpace(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::BlockNonlinearForm::FESpace(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:295:30
    t.method("FESpace", static_cast<const mfem::FiniteElementSpace * (mfem::BlockNonlinearForm::*)(int)  const>(&mfem::BlockNonlinearForm::FESpace));

    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::SetSpaces(mfem::Array<mfem::FiniteElementSpace *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockNonlinearForm::SetSpaces(mfem::Array<mfem::FiniteElementSpace *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:299:9
    t.method("SetSpaces", static_cast<void (mfem::BlockNonlinearForm::*)(mfem::Array<mfem::FiniteElementSpace *> &) >(&mfem::BlockNonlinearForm::SetSpaces));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::BlockNonlinearForm::GetBlockOffsets() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::BlockNonlinearForm::GetBlockOffsets()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:302:22
    t.method("GetBlockOffsets", static_cast<const mfem::Array<int> & (mfem::BlockNonlinearForm::*)()  const>(&mfem::BlockNonlinearForm::GetBlockOffsets));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::BlockNonlinearForm::GetBlockTrueOffsets() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::BlockNonlinearForm::GetBlockTrueOffsets()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:304:22
    t.method("GetBlockTrueOffsets", static_cast<const mfem::Array<int> & (mfem::BlockNonlinearForm::*)()  const>(&mfem::BlockNonlinearForm::GetBlockTrueOffsets));

    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::AddDomainIntegrator(mfem::BlockNonlinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockNonlinearForm::AddDomainIntegrator(mfem::BlockNonlinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:307:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::BlockNonlinearForm::*)(mfem::BlockNonlinearFormIntegrator *) >(&mfem::BlockNonlinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::AddDomainIntegrator(mfem::BlockNonlinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockNonlinearForm::AddDomainIntegrator(mfem::BlockNonlinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:311:9
    t.method("AddDomainIntegrator", static_cast<void (mfem::BlockNonlinearForm::*)(mfem::BlockNonlinearFormIntegrator *, mfem::Array<int> &) >(&mfem::BlockNonlinearForm::AddDomainIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::AddInteriorFaceIntegrator(mfem::BlockNonlinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockNonlinearForm::AddInteriorFaceIntegrator(mfem::BlockNonlinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:316:9
    t.method("AddInteriorFaceIntegrator", static_cast<void (mfem::BlockNonlinearForm::*)(mfem::BlockNonlinearFormIntegrator *) >(&mfem::BlockNonlinearForm::AddInteriorFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::AddBdrFaceIntegrator(mfem::BlockNonlinearFormIntegrator *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockNonlinearForm::AddBdrFaceIntegrator(mfem::BlockNonlinearFormIntegrator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:320:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::BlockNonlinearForm::*)(mfem::BlockNonlinearFormIntegrator *) >(&mfem::BlockNonlinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::AddBdrFaceIntegrator(mfem::BlockNonlinearFormIntegrator *, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockNonlinearForm::AddBdrFaceIntegrator(mfem::BlockNonlinearFormIntegrator *, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:325:9
    t.method("AddBdrFaceIntegrator", static_cast<void (mfem::BlockNonlinearForm::*)(mfem::BlockNonlinearFormIntegrator *, mfem::Array<int> &) >(&mfem::BlockNonlinearForm::AddBdrFaceIntegrator));

    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::SetEssentialBC(const mfem::Array<mfem::Array<int> *> &, mfem::Array<mfem::Vector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockNonlinearForm::SetEssentialBC(const mfem::Array<mfem::Array<int> *> &, mfem::Array<mfem::Vector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:329:17
    t.method("SetEssentialBC", static_cast<void (mfem::BlockNonlinearForm::*)(const mfem::Array<mfem::Array<int> *> &, mfem::Array<mfem::Vector *> &) >(&mfem::BlockNonlinearForm::SetEssentialBC));

    DEBUG_MSG("Adding wrapper for double mfem::BlockNonlinearForm::GetEnergy(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::BlockNonlinearForm::GetEnergy(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:332:19
    t.method("GetEnergy", static_cast<double (mfem::BlockNonlinearForm::*)(const mfem::Vector &)  const>(&mfem::BlockNonlinearForm::GetEnergy));

    DEBUG_MSG("Adding wrapper for void mfem::BlockNonlinearForm::Mult(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BlockNonlinearForm::Mult(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:336:17
    t.method("Mult", static_cast<void (mfem::BlockNonlinearForm::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::BlockNonlinearForm::Mult));

    DEBUG_MSG("Adding wrapper for mfem::Operator & mfem::BlockNonlinearForm::GetGradient(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Operator & mfem::BlockNonlinearForm::GetGradient(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlinearform.hpp:340:22
    t.method("GetGradient", static_cast<mfem::Operator & (mfem::BlockNonlinearForm::*)(const mfem::Vector &)  const>(&mfem::BlockNonlinearForm::GetGradient));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BlockNonlinearForm>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BlockNonlinearForm(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BlockNonlinearForm(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DataCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DataCollection> : std::false_type { };
}

// Class generating the wrapper for type mfem::DataCollection
// signature to use in the veto file: mfem::DataCollection
struct Jlmfem_DataCollection: public Wrapper {

  Jlmfem_DataCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DataCollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:128:7
    jlcxx::TypeWrapper<mfem::DataCollection>  t = jlModule.add_type<mfem::DataCollection>("mfem!DataCollection");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DataCollection>>(new jlcxx::TypeWrapper<mfem::DataCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::DataCollection(const std::string &, mfem::Mesh *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:240:13
    t.constructor<const std::string &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, mfem::Mesh *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::RegisterField(const std::string &, mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::RegisterField(const std::string &, mfem::GridFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:244:17
    t.method("RegisterField", static_cast<void (mfem::DataCollection::*)(const std::string &, mfem::GridFunction *) >(&mfem::DataCollection::RegisterField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::DeregisterField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::DeregisterField(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:248:17
    t.method("DeregisterField", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::DeregisterField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::RegisterQField(const std::string &, mfem::QuadratureFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::RegisterQField(const std::string &, mfem::QuadratureFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:252:17
    t.method("RegisterQField", static_cast<void (mfem::DataCollection::*)(const std::string &, mfem::QuadratureFunction *) >(&mfem::DataCollection::RegisterQField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::DeregisterQField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::DeregisterQField(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:258:17
    t.method("DeregisterQField", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::DeregisterQField));

    DEBUG_MSG("Adding wrapper for bool mfem::DataCollection::HasField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::DataCollection::HasField(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:262:9
    t.method("HasField", static_cast<bool (mfem::DataCollection::*)(const std::string &)  const>(&mfem::DataCollection::HasField));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction * mfem::DataCollection::GetField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction * mfem::DataCollection::GetField(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:267:18
    t.method("GetField", static_cast<mfem::GridFunction * (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::GetField));

    DEBUG_MSG("Adding wrapper for bool mfem::DataCollection::HasQField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::DataCollection::HasQField(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:283:9
    t.method("HasQField", static_cast<bool (mfem::DataCollection::*)(const std::string &)  const>(&mfem::DataCollection::HasQField));

    DEBUG_MSG("Adding wrapper for mfem::QuadratureFunction * mfem::DataCollection::GetQField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::QuadratureFunction * mfem::DataCollection::GetQField(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:288:24
    t.method("GetQField", static_cast<mfem::QuadratureFunction * (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::GetQField));

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::DataCollection::GetMesh() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::DataCollection::GetMesh()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:304:10
    t.method("GetMesh", static_cast<mfem::Mesh * (mfem::DataCollection::*)() >(&mfem::DataCollection::GetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetMesh(mfem::Mesh *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetMesh(mfem::Mesh *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:309:17
    t.method("SetMesh", static_cast<void (mfem::DataCollection::*)(mfem::Mesh *) >(&mfem::DataCollection::SetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetCycle(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetCycle(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:319:9
    t.method("SetCycle", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetCycle));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetTime(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetTime(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:321:9
    t.method("SetTime", static_cast<void (mfem::DataCollection::*)(double) >(&mfem::DataCollection::SetTime));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetTimeStep(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetTimeStep(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:324:9
    t.method("SetTimeStep", static_cast<void (mfem::DataCollection::*)(double) >(&mfem::DataCollection::SetTimeStep));

    DEBUG_MSG("Adding wrapper for int mfem::DataCollection::GetCycle() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::DataCollection::GetCycle()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:327:8
    t.method("GetCycle", static_cast<int (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetCycle));

    DEBUG_MSG("Adding wrapper for double mfem::DataCollection::GetTime() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DataCollection::GetTime()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:329:11
    t.method("GetTime", static_cast<double (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetTime));

    DEBUG_MSG("Adding wrapper for double mfem::DataCollection::GetTimeStep() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DataCollection::GetTimeStep()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:331:11
    t.method("GetTimeStep", static_cast<double (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetTimeStep));

    DEBUG_MSG("Adding wrapper for const std::string & mfem::DataCollection::GetCollectionName() (" __HERE__ ")");
    // signature to use in the veto list: const std::string & mfem::DataCollection::GetCollectionName()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:334:23
    t.method("GetCollectionName", static_cast<const std::string & (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetCollectionName));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetOwnData(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetOwnData(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:336:9
    t.method("SetOwnData", static_cast<void (mfem::DataCollection::*)(bool) >(&mfem::DataCollection::SetOwnData));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPrecision(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPrecision(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:339:9
    t.method("SetPrecision", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetPrecision));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPadDigits(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPadDigits(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:341:17
    t.method("SetPadDigits", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetPadDigits));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPadDigitsCycle(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPadDigitsCycle(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:344:17
    t.method("SetPadDigitsCycle", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetPadDigitsCycle));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPadDigitsRank(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPadDigitsRank(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:346:17
    t.method("SetPadDigitsRank", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetPadDigitsRank));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetFormat(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetFormat(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:351:17
    t.method("SetFormat", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::SetFormat));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetCompression(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetCompression(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:354:17
    t.method("SetCompression", static_cast<void (mfem::DataCollection::*)(bool) >(&mfem::DataCollection::SetCompression));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SetPrefixPath(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SetPrefixPath(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:357:9
    t.method("SetPrefixPath", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::SetPrefixPath));

    DEBUG_MSG("Adding wrapper for const std::string & mfem::DataCollection::GetPrefixPath() (" __HERE__ ")");
    // signature to use in the veto list: const std::string & mfem::DataCollection::GetPrefixPath()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:360:23
    t.method("GetPrefixPath", static_cast<const std::string & (mfem::DataCollection::*)()  const>(&mfem::DataCollection::GetPrefixPath));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::Save() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::Save()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:366:17
    t.method("Save", static_cast<void (mfem::DataCollection::*)() >(&mfem::DataCollection::Save));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SaveMesh() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SaveMesh()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:368:17
    t.method("SaveMesh", static_cast<void (mfem::DataCollection::*)() >(&mfem::DataCollection::SaveMesh));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SaveField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SaveField(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:370:17
    t.method("SaveField", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::SaveField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::SaveQField(const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::SaveQField(const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:372:17
    t.method("SaveQField", static_cast<void (mfem::DataCollection::*)(const std::string &) >(&mfem::DataCollection::SaveQField));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::Load(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::Load(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:375:17
    t.method("Load", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::Load));
    t.method("Load", [](mfem::DataCollection& a)->void { a.Load(); });
    t.method("Load", [](mfem::DataCollection* a)->void { a->Load(); });

    DEBUG_MSG("Adding wrapper for int mfem::DataCollection::Error() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::DataCollection::Error()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:396:8
    t.method("Error", static_cast<int (mfem::DataCollection::*)()  const>(&mfem::DataCollection::Error));

    DEBUG_MSG("Adding wrapper for void mfem::DataCollection::ResetError(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::DataCollection::ResetError(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:398:9
    t.method("ResetError", static_cast<void (mfem::DataCollection::*)(int) >(&mfem::DataCollection::ResetError));
    t.method("ResetError", [](mfem::DataCollection& a)->void { a.ResetError(); });
    t.method("ResetError", [](mfem::DataCollection* a)->void { a->ResetError(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DataCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DataCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DataCollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VisItFieldInfo> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VisItFieldInfo> : std::false_type { };
}

// Class generating the wrapper for type mfem::VisItFieldInfo
// signature to use in the veto file: mfem::VisItFieldInfo
struct Jlmfem_VisItFieldInfo: public Wrapper {

  Jlmfem_VisItFieldInfo(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VisItFieldInfo (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:407:7
    jlcxx::TypeWrapper<mfem::VisItFieldInfo>  t = jlModule.add_type<mfem::VisItFieldInfo>("mfem!VisItFieldInfo");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VisItFieldInfo>>(new jlcxx::TypeWrapper<mfem::VisItFieldInfo>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::VisItFieldInfo::VisItFieldInfo(std::string, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:414:4
    t.constructor<std::string, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<std::string, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding association methods  to provide read access to the field association (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:410:16
    // signature to use in the veto list: mfem::VisItFieldInfo::association
    t.method("association", [](const mfem::VisItFieldInfo& a) -> const std::string& { return a.association; });
    t.method("association", [](mfem::VisItFieldInfo& a) -> std::string& { return a.association; });
    t.method("association", [](const mfem::VisItFieldInfo* a) -> const std::string& { return a->association; });
    t.method("association", [](mfem::VisItFieldInfo* a) -> std::string& { return a->association; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:410:16
    // signature to use in the veto list: mfem::VisItFieldInfo::association
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding association! methods to provide write access to the field association (" __HERE__ ")");
    t.method("association!", [](mfem::VisItFieldInfo& a, const std::string& val) -> std::string& { return a.association = val; });

    DEBUG_MSG("Adding association! methods to provide write access to the field association (" __HERE__ ")");
    t.method("association!", [](mfem::VisItFieldInfo* a, const std::string& val) -> std::string& { return a->association = val; });

    DEBUG_MSG("Adding num_components methods  to provide read access to the field num_components (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:411:8
    // signature to use in the veto list: mfem::VisItFieldInfo::num_components
    t.method("num_components", [](const mfem::VisItFieldInfo& a) -> int { return a.num_components; });
    t.method("num_components", [](mfem::VisItFieldInfo& a) -> int { return a.num_components; });
    t.method("num_components", [](const mfem::VisItFieldInfo* a) -> int { return a->num_components; });
    t.method("num_components", [](mfem::VisItFieldInfo* a) -> int { return a->num_components; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:411:8
    // signature to use in the veto list: mfem::VisItFieldInfo::num_components
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding num_components! methods to provide write access to the field num_components (" __HERE__ ")");
    t.method("num_components!", [](mfem::VisItFieldInfo& a, int val) -> int { return a.num_components = val; });

    DEBUG_MSG("Adding num_components! methods to provide write access to the field num_components (" __HERE__ ")");
    t.method("num_components!", [](mfem::VisItFieldInfo* a, int val) -> int { return a->num_components = val; });

    DEBUG_MSG("Adding lod methods  to provide read access to the field lod (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:412:8
    // signature to use in the veto list: mfem::VisItFieldInfo::lod
    t.method("lod", [](const mfem::VisItFieldInfo& a) -> int { return a.lod; });
    t.method("lod", [](mfem::VisItFieldInfo& a) -> int { return a.lod; });
    t.method("lod", [](const mfem::VisItFieldInfo* a) -> int { return a->lod; });
    t.method("lod", [](mfem::VisItFieldInfo* a) -> int { return a->lod; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:412:8
    // signature to use in the veto list: mfem::VisItFieldInfo::lod
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding lod! methods to provide write access to the field lod (" __HERE__ ")");
    t.method("lod!", [](mfem::VisItFieldInfo& a, int val) -> int { return a.lod = val; });

    DEBUG_MSG("Adding lod! methods to provide write access to the field lod (" __HERE__ ")");
    t.method("lod!", [](mfem::VisItFieldInfo* a, int val) -> int { return a->lod = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VisItFieldInfo>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VisItFieldInfo(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VisItFieldInfo(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VisItDataCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VisItDataCollection> : std::false_type { };
template<> struct SuperType<mfem::VisItDataCollection> { typedef mfem::DataCollection type; };
}

// Class generating the wrapper for type mfem::VisItDataCollection
// signature to use in the veto file: mfem::VisItDataCollection
struct Jlmfem_VisItDataCollection: public Wrapper {

  Jlmfem_VisItDataCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VisItDataCollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:419:7
    jlcxx::TypeWrapper<mfem::VisItDataCollection>  t = jlModule.add_type<mfem::VisItDataCollection>("mfem!VisItDataCollection",
      jlcxx::julia_base_type<mfem::DataCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VisItDataCollection>>(new jlcxx::TypeWrapper<mfem::VisItDataCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::VisItDataCollection(const std::string &, mfem::Mesh *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:446:4
    t.constructor<const std::string &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, mfem::Mesh *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SetMesh(mfem::Mesh *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SetMesh(mfem::Mesh *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:457:17
    t.method("SetMesh", static_cast<void (mfem::VisItDataCollection::*)(mfem::Mesh *) >(&mfem::VisItDataCollection::SetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::RegisterField(const std::string &, mfem::GridFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::RegisterField(const std::string &, mfem::GridFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:465:17
    t.method("RegisterField", static_cast<void (mfem::VisItDataCollection::*)(const std::string &, mfem::GridFunction *) >(&mfem::VisItDataCollection::RegisterField));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::RegisterQField(const std::string &, mfem::QuadratureFunction *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::RegisterQField(const std::string &, mfem::QuadratureFunction *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:471:17
    t.method("RegisterQField", static_cast<void (mfem::VisItDataCollection::*)(const std::string &, mfem::QuadratureFunction *) >(&mfem::VisItDataCollection::RegisterQField));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SetPadDigits(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SetPadDigits(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:478:17
    t.method("SetPadDigits", static_cast<void (mfem::VisItDataCollection::*)(int) >(&mfem::VisItDataCollection::SetPadDigits));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SetLevelsOfDetail(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SetLevelsOfDetail(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:482:9
    t.method("SetLevelsOfDetail", static_cast<void (mfem::VisItDataCollection::*)(int) >(&mfem::VisItDataCollection::SetLevelsOfDetail));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SetMaxLevelsOfDetail(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SetMaxLevelsOfDetail(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:485:9
    t.method("SetMaxLevelsOfDetail", static_cast<void (mfem::VisItDataCollection::*)(int) >(&mfem::VisItDataCollection::SetMaxLevelsOfDetail));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::DeleteAll() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::DeleteAll()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:489:9
    t.method("DeleteAll", static_cast<void (mfem::VisItDataCollection::*)() >(&mfem::VisItDataCollection::DeleteAll));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::Save() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::Save()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:492:17
    t.method("Save", static_cast<void (mfem::VisItDataCollection::*)() >(&mfem::VisItDataCollection::Save));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::SaveRootFile() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::SaveRootFile()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:495:9
    t.method("SaveRootFile", static_cast<void (mfem::VisItDataCollection::*)() >(&mfem::VisItDataCollection::SaveRootFile));

    DEBUG_MSG("Adding wrapper for void mfem::VisItDataCollection::Load(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::VisItDataCollection::Load(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:498:17
    t.method("Load", static_cast<void (mfem::VisItDataCollection::*)(int) >(&mfem::VisItDataCollection::Load));
    t.method("Load", [](mfem::VisItDataCollection& a)->void { a.Load(); });
    t.method("Load", [](mfem::VisItDataCollection* a)->void { a->Load(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VisItDataCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VisItDataCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VisItDataCollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ParaViewDataCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ParaViewDataCollection> : std::false_type { };
template<> struct SuperType<mfem::ParaViewDataCollection> { typedef mfem::DataCollection type; };
}

// Class generating the wrapper for type mfem::ParaViewDataCollection
// signature to use in the veto file: mfem::ParaViewDataCollection
struct Jlmfem_ParaViewDataCollection: public Wrapper {

  Jlmfem_ParaViewDataCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ParaViewDataCollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:506:7
    jlcxx::TypeWrapper<mfem::ParaViewDataCollection>  t = jlModule.add_type<mfem::ParaViewDataCollection>("mfem!ParaViewDataCollection",
      jlcxx::julia_base_type<mfem::DataCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ParaViewDataCollection>>(new jlcxx::TypeWrapper<mfem::ParaViewDataCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::ParaViewDataCollection(const std::string &, mfem::Mesh *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:540:4
    t.constructor<const std::string &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, mfem::Mesh *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetLevelsOfDetail(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetLevelsOfDetail(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:545:9
    t.method("SetLevelsOfDetail", static_cast<void (mfem::ParaViewDataCollection::*)(int) >(&mfem::ParaViewDataCollection::SetLevelsOfDetail));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::Save() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::Save()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:549:17
    t.method("Save", static_cast<void (mfem::ParaViewDataCollection::*)() >(&mfem::ParaViewDataCollection::Save));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetDataFormat(mfem::VTKFormat) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetDataFormat(mfem::VTKFormat)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:557:9
    t.method("SetDataFormat", static_cast<void (mfem::ParaViewDataCollection::*)(mfem::VTKFormat) >(&mfem::ParaViewDataCollection::SetDataFormat));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetCompressionLevel(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetCompressionLevel(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:571:9
    t.method("SetCompressionLevel", static_cast<void (mfem::ParaViewDataCollection::*)(int) >(&mfem::ParaViewDataCollection::SetCompressionLevel));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetCompression(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetCompression(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:576:9
    t.method("SetCompression", static_cast<void (mfem::ParaViewDataCollection::*)(bool) >(&mfem::ParaViewDataCollection::SetCompression));

    DEBUG_MSG("Adding wrapper for bool mfem::ParaViewDataCollection::IsBinaryFormat() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::ParaViewDataCollection::IsBinaryFormat()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:579:9
    t.method("IsBinaryFormat", static_cast<bool (mfem::ParaViewDataCollection::*)()  const>(&mfem::ParaViewDataCollection::IsBinaryFormat));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::SetHighOrderOutput(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::SetHighOrderOutput(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:583:9
    t.method("SetHighOrderOutput", static_cast<void (mfem::ParaViewDataCollection::*)(bool) >(&mfem::ParaViewDataCollection::SetHighOrderOutput));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::UseRestartMode(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::UseRestartMode(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:590:9
    t.method("UseRestartMode", static_cast<void (mfem::ParaViewDataCollection::*)(bool) >(&mfem::ParaViewDataCollection::UseRestartMode));

    DEBUG_MSG("Adding wrapper for void mfem::ParaViewDataCollection::Load(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ParaViewDataCollection::Load(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:593:17
    t.method("Load", static_cast<void (mfem::ParaViewDataCollection::*)(int) >(&mfem::ParaViewDataCollection::Load));
    t.method("Load", [](mfem::ParaViewDataCollection& a)->void { a.Load(); });
    t.method("Load", [](mfem::ParaViewDataCollection* a)->void { a->Load(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ParaViewDataCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ParaViewDataCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ParaViewDataCollection(module));
}
// Class generating the wrapper for type 
// signature to use in the veto file: 
struct JlGlobal: public Wrapper {

  JlGlobal(jlcxx::Module& jlModule): Wrapper(jlModule){
  }

  void add_methods() const{
    auto& t = module_;

    DEBUG_MSG("Adding wrapper for double mfem::infinity() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::infinity()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:44:15
    t.method("mfem!infinity", static_cast<double (*)() >(&mfem::infinity));

    DEBUG_MSG("Adding wrapper for bool mfem::IsFinite(const double &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::IsFinite(const double &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:486:13
    t.method("mfem!IsFinite", static_cast<bool (*)(const double &) >(&mfem::IsFinite));

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:626:24
    t.method("mfem!Swap", static_cast<void (*)(mfem::Vector &, mfem::Vector &) >(&mfem::Swap));

    DEBUG_MSG("Adding wrapper for double mfem::DistanceSquared(const double *, const double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DistanceSquared(const double *, const double *, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:636:15
    t.method("mfem!DistanceSquared", static_cast<double (*)(const double *, const double *, const int) >(&mfem::DistanceSquared));

    DEBUG_MSG("Adding wrapper for double mfem::Distance(const double *, const double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Distance(const double *, const double *, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:648:15
    t.method("mfem!Distance", static_cast<double (*)(const double *, const double *, const int) >(&mfem::Distance));

    DEBUG_MSG("Adding wrapper for double mfem::Distance(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Distance(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:653:15
    t.method("mfem!Distance", static_cast<double (*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::Distance));

    DEBUG_MSG("Adding wrapper for double mfem::InnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::InnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:684:15
    t.method("mfem!InnerProduct", static_cast<double (*)(const mfem::Vector &, const mfem::Vector &) >(&mfem::InnerProduct));

    DEBUG_MSG("Adding wrapper for bool mfem::IsIdentityProlongation(const mfem::Operator *) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::IsIdentityProlongation(const mfem::Operator *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:720:13
    t.method("mfem!IsIdentityProlongation", static_cast<bool (*)(const mfem::Operator *) >(&mfem::IsIdentityProlongation));

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrixFunction(mfem::SparseMatrix &, double (*)(double)) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrixFunction(mfem::SparseMatrix &, double (*)(double))
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:718:6
    t.method("mfem!SparseMatrixFunction", static_cast<void (*)(mfem::SparseMatrix &, double (*)(double)) >(&mfem::SparseMatrixFunction));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Transpose(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Transpose(const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:722:15
    t.method("mfem!Transpose", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &) >(&mfem::Transpose));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::TransposeAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::TransposeAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:724:15
    t.method("mfem!TransposeAbstractSparseMatrix", static_cast<mfem::SparseMatrix * (*)(const mfem::AbstractSparseMatrix &, int) >(&mfem::TransposeAbstractSparseMatrix));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Mult(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Mult(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:733:15
    t.method("mfem!Mult", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) >(&mfem::Mult));
    t.method("mfem!Mult", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::Mult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::TransposeMult(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::TransposeMult(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:737:15
    t.method("mfem!TransposeMult", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &) >(&mfem::TransposeMult));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::MultAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, const mfem::AbstractSparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::MultAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, const mfem::AbstractSparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:740:15
    t.method("mfem!MultAbstractSparseMatrix", static_cast<mfem::SparseMatrix * (*)(const mfem::AbstractSparseMatrix &, const mfem::AbstractSparseMatrix &) >(&mfem::MultAbstractSparseMatrix));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::Mult(const mfem::SparseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::Mult(const mfem::SparseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:744:14
    t.method("mfem!Mult", static_cast<mfem::DenseMatrix * (*)(const mfem::SparseMatrix &, mfem::DenseMatrix &) >(&mfem::Mult));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::RAP(const mfem::SparseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::RAP(const mfem::SparseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:747:14
    t.method("mfem!RAP", static_cast<mfem::DenseMatrix * (*)(const mfem::SparseMatrix &, mfem::DenseMatrix &) >(&mfem::RAP));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::RAP(mfem::DenseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::RAP(mfem::DenseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:750:14
    t.method("mfem!RAP", static_cast<mfem::DenseMatrix * (*)(mfem::DenseMatrix &, const mfem::SparseMatrix &) >(&mfem::RAP));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:754:15
    t.method("mfem!RAP", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) >(&mfem::RAP));
    t.method("mfem!RAP", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::RAP(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:758:15
    t.method("mfem!RAP", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &, const mfem::SparseMatrix &) >(&mfem::RAP));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Mult_AtDA(const mfem::SparseMatrix &, const mfem::Vector &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Mult_AtDA(const mfem::SparseMatrix &, const mfem::Vector &, mfem::SparseMatrix *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:762:15
    t.method("mfem!Mult_AtDA", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::Vector &, mfem::SparseMatrix *) >(&mfem::Mult_AtDA));
    t.method("mfem!Mult_AtDA", [](const mfem::SparseMatrix & arg0, const mfem::Vector & arg1)->mfem::SparseMatrix * { return mfem::Mult_AtDA(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Add(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Add(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:767:16
    t.method("mfem!Add", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &) >(&mfem::Add));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Add(double, const mfem::SparseMatrix &, double, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Add(double, const mfem::SparseMatrix &, double, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:769:16
    t.method("mfem!Add", static_cast<mfem::SparseMatrix * (*)(double, const mfem::SparseMatrix &, double, const mfem::SparseMatrix &) >(&mfem::Add));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Add(mfem::Array<mfem::SparseMatrix *> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Add(mfem::Array<mfem::SparseMatrix *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:772:16
    t.method("mfem!Add", static_cast<mfem::SparseMatrix * (*)(mfem::Array<mfem::SparseMatrix *> &) >(&mfem::Add));

    DEBUG_MSG("Adding wrapper for void mfem::Add(const mfem::SparseMatrix &, double, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Add(const mfem::SparseMatrix &, double, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:775:6
    t.method("mfem!Add", static_cast<void (*)(const mfem::SparseMatrix &, double, mfem::DenseMatrix &) >(&mfem::Add));

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:778:14
    t.method("mfem!OuterProduct", static_cast<mfem::DenseMatrix * (*)(const mfem::DenseMatrix &, const mfem::DenseMatrix &) >(&mfem::OuterProduct));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:781:15
    t.method("mfem!OuterProduct", static_cast<mfem::SparseMatrix * (*)(const mfem::DenseMatrix &, const mfem::SparseMatrix &) >(&mfem::OuterProduct));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:784:15
    t.method("mfem!OuterProduct", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::DenseMatrix &) >(&mfem::OuterProduct));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:787:15
    t.method("mfem!OuterProduct", static_cast<mfem::SparseMatrix * (*)(const mfem::SparseMatrix &, const mfem::SparseMatrix &) >(&mfem::OuterProduct));

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::SparseMatrix &, mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::SparseMatrix &, mfem::SparseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:931:24
    t.method("mfem!Swap", static_cast<void (*)(mfem::SparseMatrix &, mfem::SparseMatrix &) >(&mfem::Swap));

    DEBUG_MSG("Adding wrapper for void mfem::SLI(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLI(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:482:6
    t.method("mfem!SLI", static_cast<void (*)(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::SLI));
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { mfem::SLI(arg0, arg1, arg2); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void { mfem::SLI(arg0, arg1, arg2, arg3); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::SLI(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLI(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:487:6
    t.method("mfem!SLI", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::SLI));
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::SLI(arg0, arg1, arg2, arg3); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::CG(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CG(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:514:6
    t.method("mfem!CG", static_cast<void (*)(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::CG));
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { mfem::CG(arg0, arg1, arg2); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void { mfem::CG(arg0, arg1, arg2, arg3); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void { mfem::CG(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void { mfem::CG(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::PCG(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PCG(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:519:6
    t.method("mfem!PCG", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::PCG));
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::PCG(arg0, arg1, arg2, arg3); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::PCG(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::PCG(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void { mfem::PCG(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for int mfem::GMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, int, double &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, int, double &, double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:562:5
    t.method("mfem!GMRES", static_cast<int (*)(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, int, double &, double, int) >(&mfem::GMRES));

    DEBUG_MSG("Adding wrapper for void mfem::GMRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GMRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:566:6
    t.method("mfem!GMRES", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, int, double, double) >(&mfem::GMRES));
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::GMRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, int arg6)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, int arg6, double arg7)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for int mfem::BiCGSTAB(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, double &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::BiCGSTAB(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, double &, double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:593:5
    t.method("mfem!BiCGSTAB", static_cast<int (*)(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, double &, double, int) >(&mfem::BiCGSTAB));

    DEBUG_MSG("Adding wrapper for void mfem::BiCGSTAB(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BiCGSTAB(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:597:6
    t.method("mfem!BiCGSTAB", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::BiCGSTAB));
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::MINRES(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRES(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:628:6
    t.method("mfem!MINRES", static_cast<void (*)(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::MINRES));
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { mfem::MINRES(arg0, arg1, arg2); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void { mfem::MINRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::MINRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:632:6
    t.method("mfem!MINRES", static_cast<void (*)(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) >(&mfem::MINRES));
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::MINRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for int mfem::aGMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, const mfem::Operator &, int &, int, int, int, double, double &, double &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::aGMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, const mfem::Operator &, int &, int, int, int, double, double &, double &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:791:5
    t.method("mfem!aGMRES", static_cast<int (*)(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, const mfem::Operator &, int &, int, int, int, double, double &, double &, int) >(&mfem::aGMRES));

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::CoarseFineTransformations &, mfem::CoarseFineTransformations &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::CoarseFineTransformations &, mfem::CoarseFineTransformations &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:95:6
    t.method("mfem!Swap", static_cast<void (*)(mfem::CoarseFineTransformations &, mfem::CoarseFineTransformations &) >(&mfem::Swap));

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::Extrude1D(mfem::Mesh *, const int, const double, const bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::Extrude1D(mfem::Mesh *, const int, const double, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2503:7
    t.method("mfem!Extrude1D", static_cast<mfem::Mesh * (*)(mfem::Mesh *, const int, const double, const bool) >(&mfem::Extrude1D));
    t.method("mfem!Extrude1D", [](mfem::Mesh * arg0, const int arg1, const double arg2)->mfem::Mesh * { return mfem::Extrude1D(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::Extrude2D(mfem::Mesh *, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::Extrude2D(mfem::Mesh *, const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2507:7
    t.method("mfem!Extrude2D", static_cast<mfem::Mesh * (*)(mfem::Mesh *, const int, const double) >(&mfem::Extrude2D));

    DEBUG_MSG("Adding wrapper for void mfem::ShiftRight(int &, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ShiftRight(int &, int &, int &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2510:13
    t.method("mfem!ShiftRight", static_cast<void (*)(int &, int &, int &) >(&mfem::ShiftRight));

    DEBUG_MSG("Adding wrapper for bool mfem::UsesTensorBasis(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::UsesTensorBasis(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1345:13
    t.method("mfem!UsesTensorBasis", static_cast<bool (*)(const mfem::FiniteElementSpace &) >(&mfem::UsesTensorBasis));

    DEBUG_MSG("Adding wrapper for mfem::ElementDofOrdering mfem::GetEVectorOrdering(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementDofOrdering mfem::GetEVectorOrdering(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1356:20
    t.method("mfem!GetEVectorOrdering", static_cast<mfem::ElementDofOrdering (*)(const mfem::FiniteElementSpace &) >(&mfem::GetEVectorOrdering));

    DEBUG_MSG("Adding wrapper for double mfem::ZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::GridFunction &, mfem::Vector &, mfem::Array<int> *, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::GridFunction &, mfem::Vector &, mfem::Array<int> *, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:800:8
    t.method("mfem!ZZErrorEstimator", static_cast<double (*)(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::GridFunction &, mfem::Vector &, mfem::Array<int> *, int, bool) >(&mfem::ZZErrorEstimator));
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3); });
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3, mfem::Array<int> * arg4)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3, mfem::Array<int> * arg4, int arg5)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::TensorProductLegendre(int, int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, const mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TensorProductLegendre(int, int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, const mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:812:6
    t.method("mfem!TensorProductLegendre", static_cast<void (*)(int, int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, const mfem::Vector *) >(&mfem::TensorProductLegendre));
    t.method("mfem!TensorProductLegendre", [](int arg0, int arg1, const mfem::Vector & arg2, const mfem::Vector & arg3, const mfem::Vector & arg4, mfem::Vector & arg5)->void { mfem::TensorProductLegendre(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!TensorProductLegendre", [](int arg0, int arg1, const mfem::Vector & arg2, const mfem::Vector & arg3, const mfem::Vector & arg4, mfem::Vector & arg5, double arg6)->void { mfem::TensorProductLegendre(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::BoundingBox(const mfem::Array<int> &, mfem::FiniteElementSpace *, int, mfem::Vector &, mfem::Vector &, double &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundingBox(const mfem::Array<int> &, mfem::FiniteElementSpace *, int, mfem::Vector &, mfem::Vector &, double &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:836:6
    t.method("mfem!BoundingBox", static_cast<void (*)(const mfem::Array<int> &, mfem::FiniteElementSpace *, int, mfem::Vector &, mfem::Vector &, double &, mfem::Vector &, int) >(&mfem::BoundingBox));
    t.method("mfem!BoundingBox", [](const mfem::Array<int> & arg0, mfem::FiniteElementSpace * arg1, int arg2, mfem::Vector & arg3, mfem::Vector & arg4, double & arg5, mfem::Vector & arg6)->void { mfem::BoundingBox(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for double mfem::LSZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::Vector &, bool, bool, double) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::LSZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::Vector &, bool, bool, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:853:8
    t.method("mfem!LSZZErrorEstimator", static_cast<double (*)(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::Vector &, bool, bool, double) >(&mfem::LSZZErrorEstimator));
    t.method("mfem!LSZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::Vector & arg2)->double { return mfem::LSZZErrorEstimator(arg0, arg1, arg2); });
    t.method("mfem!LSZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::Vector & arg2, bool arg3)->double { return mfem::LSZZErrorEstimator(arg0, arg1, arg2, arg3); });
    t.method("mfem!LSZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::Vector & arg2, bool arg3, bool arg4)->double { return mfem::LSZZErrorEstimator(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for double mfem::ComputeElementLpDistance(double, int, mfem::GridFunction &, mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ComputeElementLpDistance(double, int, mfem::GridFunction &, mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:861:8
    t.method("mfem!ComputeElementLpDistance", static_cast<double (*)(double, int, mfem::GridFunction &, mfem::GridFunction &) >(&mfem::ComputeElementLpDistance));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction * mfem::Extrude1DGridFunction(mfem::Mesh *, mfem::Mesh *, mfem::GridFunction *, const int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction * mfem::Extrude1DGridFunction(mfem::Mesh *, mfem::Mesh *, mfem::GridFunction *, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:880:15
    t.method("mfem!Extrude1DGridFunction", static_cast<mfem::GridFunction * (*)(mfem::Mesh *, mfem::Mesh *, mfem::GridFunction *, const int) >(&mfem::Extrude1DGridFunction));

    DEBUG_MSG("Adding mfem!IntRules methods to provide access to the global variable mfem::IntRules (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:486:37
    t.method("mfem!IntRules", []()-> mfem::IntegrationRules& { return mfem::IntRules; });
    // t.method("mfem!IntRules!", [](const mfem::IntegrationRules& val)-> mfem::IntegrationRules& { return mfem::IntRules = val; });

    DEBUG_MSG("Adding mfem!RefinedIntRules methods to provide access to the global variable mfem::RefinedIntRules (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:489:37
    t.method("mfem!RefinedIntRules", []()-> mfem::IntegrationRules& { return mfem::RefinedIntRules; });
    // t.method("mfem!RefinedIntRules!", [](const mfem::IntegrationRules& val)-> mfem::IntegrationRules& { return mfem::RefinedIntRules = val; });

    DEBUG_MSG("Adding mfem!Mesh!remove_unused_vertices methods to provide access to the global variable mfem::Mesh::remove_unused_vertices (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:286:16
    module_.method("mfem!Mesh!remove_unused_vertices", []()-> bool { return mfem::Mesh::remove_unused_vertices; });
    module_.method("mfem!Mesh!remove_unused_vertices!", [](bool val)-> bool { return mfem::Mesh::remove_unused_vertices = val; });
  }
};
std::shared_ptr<Wrapper> newJlGlobal(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlGlobal(module));
}

class Jlmfem_Array;
class Jlmfem_Embedding;
class Jlmfem_Refinement;
class Jlmfem_IntegrationPoint;
class Jlmfem_Array;
class Jlmfem_Array2D;
class Jlmfem_Vector;
class Jlmfem_Memory;
class Jlmfem_Operator;
class Jlmfem_TimeDependentOperator;
class Jlmfem_TimeDependentAdjointOperator;
class Jlmfem_SecondOrderTimeDependentOperator;
class Jlmfem_Solver;
class Jlmfem_IdentityOperator;
class Jlmfem_ScaledOperator;
class Jlmfem_TransposeOperator;
class Jlmfem_ProductOperator;
class Jlmfem_RAPOperator;
class Jlmfem_TripleProductOperator;
class Jlmfem_ConstrainedOperator;
class Jlmfem_RectangularConstrainedOperator;
class Jlmfem_PowerMethod;
class Jlmfem_Matrix;
class Jlmfem_MatrixInverse;
class Jlmfem_AbstractSparseMatrix;
class Jlmfem_RowNode;
class Jlmfem_SparseMatrix;
class Jlmfem_DenseMatrix;
class Jlmfem_SparseSmoother;
class Jlmfem_GSSmoother;
class Jlmfem_DSmoother;
class Jlmfem_OperatorHandle;
class Jlmfem_IterativeSolverMonitor;
class Jlmfem_IterativeSolver;
class Jlmfem_IterativeSolver_PrintLevel;
class Jlmfem_OperatorJacobiSmoother;
class Jlmfem_BilinearForm;
class Jlmfem_OperatorChebyshevSmoother;
class Jlmfem_SLISolver;
class Jlmfem_CGSolver;
class Jlmfem_GMRESSolver;
class Jlmfem_FGMRESSolver;
class Jlmfem_BiCGSTABSolver;
class Jlmfem_MINRESSolver;
class Jlmfem_NewtonSolver;
class Jlmfem_LBFGSSolver;
class Jlmfem_OptimizationProblem;
class Jlmfem_OptimizationSolver;
class Jlmfem_SLBQPOptimizer;
class Jlmfem_BlockILU;
class Jlmfem_ResidualBCMonitor;
class Jlmfem_DirectSubBlockSolver;
class Jlmfem_ProductSolver;
class Jlmfem_OrthoSolver;
class Jlmfem_IntegrationRule;
class Jlmfem_KnotVector;
class Jlmfem_NURBSMeshRules;
class Jlmfem_Mesh;
class Jlmfem_QuadratureFunctions1D;
class Jlmfem_Quadrature1D;
class Jlmfem_IntegrationRules;
class Jlmfem_CoarseFineTransformations;
class Jlmfem_Table;
class Jlmfem_Coefficient;
class Jlmfem_ElementTransformation;
class Jlmfem_QuadratureFunction;
class Jlmfem_ConstantCoefficient;
class Jlmfem_PWConstCoefficient;
class Jlmfem_PWCoefficient;
class Jlmfem_CartesianCoefficient;
class Jlmfem_CartesianXCoefficient;
class Jlmfem_CartesianYCoefficient;
class Jlmfem_CartesianZCoefficient;
class Jlmfem_CylindricalRadialCoefficient;
class Jlmfem_CylindricalAzimuthalCoefficient;
class Jlmfem_SphericalRadialCoefficient;
class Jlmfem_SphericalAzimuthalCoefficient;
class Jlmfem_SphericalPolarCoefficient;
class Jlmfem_GridFunctionCoefficient;
class Jlmfem_GridFunction;
class Jlmfem_TransformedCoefficient;
class Jlmfem_DeltaCoefficient;
class Jlmfem_RestrictedCoefficient;
class Jlmfem_VectorCoefficient;
class Jlmfem_VectorConstantCoefficient;
class Jlmfem_PWVectorCoefficient;
class Jlmfem_PositionVectorCoefficient;
class Jlmfem_VectorArrayCoefficient;
class Jlmfem_VectorGridFunctionCoefficient;
class Jlmfem_GradientGridFunctionCoefficient;
class Jlmfem_CurlGridFunctionCoefficient;
class Jlmfem_DivergenceGridFunctionCoefficient;
class Jlmfem_VectorDeltaCoefficient;
class Jlmfem_VectorRestrictedCoefficient;
class Jlmfem_MatrixCoefficient;
class Jlmfem_MatrixConstantCoefficient;
class Jlmfem_PWMatrixCoefficient;
class Jlmfem_MatrixArrayCoefficient;
class Jlmfem_MatrixRestrictedCoefficient;
class Jlmfem_SumCoefficient;
class Jlmfem_SymmetricMatrixCoefficient;
class Jlmfem_DenseSymmetricMatrix;
class Jlmfem_SymmetricMatrixConstantCoefficient;
class Jlmfem_ProductCoefficient;
class Jlmfem_RatioCoefficient;
class Jlmfem_PowerCoefficient;
class Jlmfem_InnerProductCoefficient;
class Jlmfem_VectorRotProductCoefficient;
class Jlmfem_DeterminantCoefficient;
class Jlmfem_VectorSumCoefficient;
class Jlmfem_ScalarVectorProductCoefficient;
class Jlmfem_NormalizedVectorCoefficient;
class Jlmfem_VectorCrossProductCoefficient;
class Jlmfem_MatrixVectorProductCoefficient;
class Jlmfem_IdentityMatrixCoefficient;
class Jlmfem_MatrixSumCoefficient;
class Jlmfem_MatrixProductCoefficient;
class Jlmfem_ScalarMatrixProductCoefficient;
class Jlmfem_TransposeMatrixCoefficient;
class Jlmfem_InverseMatrixCoefficient;
class Jlmfem_OuterProductCoefficient;
class Jlmfem_CrossCrossCoefficient;
class Jlmfem_VectorQuadratureFunctionCoefficient;
class Jlmfem_QuadratureFunctionCoefficient;
class Jlmfem_CoefficientVector;
class Jlmfem_QuadratureSpaceBase;
class Jlmfem_NURBSExtension;
class Jlmfem_Element;
class Jlmfem_Mesh_GeometryList;
class Jlmfem_DSTable;
class Jlmfem_FiniteElement;
class Jlmfem_IsoparametricTransformation;
class Jlmfem_FaceElementTransformations;
class Jlmfem_Mesh_FaceInformation;
class Jlmfem_FiniteElementSpace;
class Jlmfem_Vertex;
class Jlmfem_InverseElementTransformation;
class Jlmfem_NodeExtrudeCoefficient;
class Jlmfem_FiniteElementCollection;
class Jlmfem_StatelessDofTransformation;
class Jlmfem_H1_FECollection;
class Jlmfem_H1Pos_FECollection;
class Jlmfem_H1Ser_FECollection;
class Jlmfem_H1_Trace_FECollection;
class Jlmfem_L2_FECollection;
class Jlmfem_RT_FECollection;
class Jlmfem_RT_Trace_FECollection;
class Jlmfem_DG_Interface_FECollection;
class Jlmfem_ND_FECollection;
class Jlmfem_ND_Trace_FECollection;
class Jlmfem_ND_R1D_FECollection;
class Jlmfem_RT_R1D_FECollection;
class Jlmfem_ND_R2D_FECollection;
class Jlmfem_ND_R2D_Trace_FECollection;
class Jlmfem_RT_R2D_FECollection;
class Jlmfem_RT_R2D_Trace_FECollection;
class Jlmfem_NURBSFECollection;
class Jlmfem_LinearFECollection;
class Jlmfem_QuadraticFECollection;
class Jlmfem_QuadraticPosFECollection;
class Jlmfem_CubicFECollection;
class Jlmfem_CrouzeixRaviartFECollection;
class Jlmfem_LinearNonConf3DFECollection;
class Jlmfem_RT0_2DFECollection;
class Jlmfem_RT1_2DFECollection;
class Jlmfem_RT2_2DFECollection;
class Jlmfem_Const2DFECollection;
class Jlmfem_LinearDiscont2DFECollection;
class Jlmfem_GaussLinearDiscont2DFECollection;
class Jlmfem_P1OnQuadFECollection;
class Jlmfem_QuadraticDiscont2DFECollection;
class Jlmfem_QuadraticPosDiscont2DFECollection;
class Jlmfem_GaussQuadraticDiscont2DFECollection;
class Jlmfem_CubicDiscont2DFECollection;
class Jlmfem_Const3DFECollection;
class Jlmfem_LinearDiscont3DFECollection;
class Jlmfem_QuadraticDiscont3DFECollection;
class Jlmfem_RefinedLinearFECollection;
class Jlmfem_ND1_3DFECollection;
class Jlmfem_RT0_3DFECollection;
class Jlmfem_RT1_3DFECollection;
class Jlmfem_Local_FECollection;
class Jlmfem_Ordering;
class Jlmfem_ElementRestrictionOperator;
class Jlmfem_FaceRestriction;
class Jlmfem_QuadratureInterpolator;
class Jlmfem_QuadratureSpace;
class Jlmfem_FaceQuadratureInterpolator;
class Jlmfem_DofTransformation;
class Jlmfem_NonlinearFormIntegrator;
class Jlmfem_ceed_Operator;
class Jlmfem_BlockNonlinearFormIntegrator;
class Jlmfem_HyperelasticModel;
class Jlmfem_InverseHarmonicModel;
class Jlmfem_NeoHookeanModel;
class Jlmfem_HyperelasticNLFIntegrator;
class Jlmfem_IncompressibleNeoHookeanIntegrator;
class Jlmfem_VectorConvectionNLFIntegrator;
class Jlmfem_ConvectiveVectorConvectionNLFIntegrator;
class Jlmfem_SkewSymmetricVectorConvectionNLFIntegrator;
class Jlmfem_BilinearFormIntegrator;
class Jlmfem_TransposeIntegrator;
class Jlmfem_LumpedIntegrator;
class Jlmfem_InverseIntegrator;
class Jlmfem_SumIntegrator;
class Jlmfem_MixedScalarIntegrator;
class Jlmfem_MixedVectorIntegrator;
class Jlmfem_MixedScalarVectorIntegrator;
class Jlmfem_MixedScalarMassIntegrator;
class Jlmfem_MixedVectorProductIntegrator;
class Jlmfem_MixedScalarDerivativeIntegrator;
class Jlmfem_MixedScalarWeakDerivativeIntegrator;
class Jlmfem_MixedScalarDivergenceIntegrator;
class Jlmfem_MixedVectorDivergenceIntegrator;
class Jlmfem_MixedScalarWeakGradientIntegrator;
class Jlmfem_MixedScalarCurlIntegrator;
class Jlmfem_MixedScalarWeakCurlIntegrator;
class Jlmfem_MixedVectorMassIntegrator;
class Jlmfem_MixedCrossProductIntegrator;
class Jlmfem_MixedDotProductIntegrator;
class Jlmfem_MixedWeakGradDotIntegrator;
class Jlmfem_MixedWeakDivCrossIntegrator;
class Jlmfem_MixedGradGradIntegrator;
class Jlmfem_MixedCrossGradGradIntegrator;
class Jlmfem_MixedCurlCurlIntegrator;
class Jlmfem_MixedCrossCurlCurlIntegrator;
class Jlmfem_MixedCrossCurlGradIntegrator;
class Jlmfem_MixedCrossGradCurlIntegrator;
class Jlmfem_MixedWeakCurlCrossIntegrator;
class Jlmfem_MixedScalarWeakCurlCrossIntegrator;
class Jlmfem_MixedCrossGradIntegrator;
class Jlmfem_MixedCrossCurlIntegrator;
class Jlmfem_MixedScalarCrossCurlIntegrator;
class Jlmfem_MixedScalarCrossGradIntegrator;
class Jlmfem_MixedScalarCrossProductIntegrator;
class Jlmfem_MixedScalarWeakCrossProductIntegrator;
class Jlmfem_MixedDirectionalDerivativeIntegrator;
class Jlmfem_MixedGradDivIntegrator;
class Jlmfem_MixedDivGradIntegrator;
class Jlmfem_MixedScalarWeakDivergenceIntegrator;
class Jlmfem_MixedVectorGradientIntegrator;
class Jlmfem_MixedVectorCurlIntegrator;
class Jlmfem_MixedVectorWeakCurlIntegrator;
class Jlmfem_MixedVectorWeakDivergenceIntegrator;
class Jlmfem_GradientIntegrator;
class Jlmfem_DiffusionIntegrator;
class Jlmfem_MassIntegrator;
class Jlmfem_BoundaryMassIntegrator;
class Jlmfem_ConvectionIntegrator;
class Jlmfem_ConservativeConvectionIntegrator;
class Jlmfem_GroupConvectionIntegrator;
class Jlmfem_VectorMassIntegrator;
class Jlmfem_VectorFEDivergenceIntegrator;
class Jlmfem_VectorFEWeakDivergenceIntegrator;
class Jlmfem_VectorFECurlIntegrator;
class Jlmfem_DerivativeIntegrator;
class Jlmfem_CurlCurlIntegrator;
class Jlmfem_VectorCurlCurlIntegrator;
class Jlmfem_MixedCurlIntegrator;
class Jlmfem_VectorFEMassIntegrator;
class Jlmfem_VectorDivergenceIntegrator;
class Jlmfem_DivDivIntegrator;
class Jlmfem_VectorDiffusionIntegrator;
class Jlmfem_ElasticityIntegrator;
class Jlmfem_ElasticityComponentIntegrator;
class Jlmfem_DGTraceIntegrator;
class Jlmfem_NonconservativeDGTraceIntegrator;
class Jlmfem_DGDiffusionIntegrator;
class Jlmfem_DGDiffusionBR2Integrator;
class Jlmfem_DGElasticityIntegrator;
class Jlmfem_TraceJumpIntegrator;
class Jlmfem_NormalTraceJumpIntegrator;
class Jlmfem_TraceIntegrator;
class Jlmfem_NormalTraceIntegrator;
class Jlmfem_TangentTraceIntegrator;
class Jlmfem_DiscreteInterpolator;
class Jlmfem_GradientInterpolator;
class Jlmfem_IdentityInterpolator;
class Jlmfem_CurlInterpolator;
class Jlmfem_DivergenceInterpolator;
class Jlmfem_NormalInterpolator;
class Jlmfem_ScalarProductInterpolator;
class Jlmfem_ScalarVectorProductInterpolator;
class Jlmfem_VectorScalarProductInterpolator;
class Jlmfem_ScalarCrossProductInterpolator;
class Jlmfem_VectorCrossProductInterpolator;
class Jlmfem_VectorInnerProductInterpolator;
class Jlmfem_JumpScaling;
class Jlmfem_ExtrudeCoefficient;
class Jlmfem_LinearFormIntegrator;
class Jlmfem_DeltaLFIntegrator;
class Jlmfem_DomainLFIntegrator;
class Jlmfem_DomainLFGradIntegrator;
class Jlmfem_BoundaryLFIntegrator;
class Jlmfem_BoundaryNormalLFIntegrator;
class Jlmfem_BoundaryTangentialLFIntegrator;
class Jlmfem_VectorDomainLFIntegrator;
class Jlmfem_VectorDomainLFGradIntegrator;
class Jlmfem_VectorBoundaryLFIntegrator;
class Jlmfem_VectorFEDomainLFIntegrator;
class Jlmfem_VectorFEDomainLFCurlIntegrator;
class Jlmfem_VectorFEDomainLFDivIntegrator;
class Jlmfem_VectorBoundaryFluxLFIntegrator;
class Jlmfem_VectorFEBoundaryFluxLFIntegrator;
class Jlmfem_VectorFEBoundaryTangentLFIntegrator;
class Jlmfem_BoundaryFlowIntegrator;
class Jlmfem_DGDirichletLFIntegrator;
class Jlmfem_DGElasticityDirichletLFIntegrator;
class Jlmfem_WhiteGaussianNoiseDomainLFIntegrator;
class Jlmfem_VectorQuadratureLFIntegrator;
class Jlmfem_QuadratureLFIntegrator;
class Jlmfem_LinearForm;
class Jlmfem_Hybridization;
class Jlmfem_MixedBilinearForm;
class Jlmfem_DiscreteLinearOperator;
class Jlmfem_NonlinearForm;
class Jlmfem_BlockNonlinearForm;
class Jlmfem_DataCollection;
class Jlmfem_VisItFieldInfo;
class Jlmfem_VisItDataCollection;
class Jlmfem_ParaViewDataCollection;
class JlGlobal;

std::shared_ptr<Wrapper> newJlmfem_Array(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Embedding(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Refinement(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IntegrationPoint(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Array(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Array2D(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Vector(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Memory(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Operator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TimeDependentOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TimeDependentAdjointOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SecondOrderTimeDependentOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Solver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IdentityOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ScaledOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TransposeOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ProductOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RAPOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TripleProductOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ConstrainedOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RectangularConstrainedOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PowerMethod(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Matrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixInverse(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_AbstractSparseMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RowNode(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SparseMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DenseMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SparseSmoother(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GSSmoother(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DSmoother(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OperatorHandle(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IterativeSolverMonitor(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IterativeSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IterativeSolver_PrintLevel(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OperatorJacobiSmoother(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BilinearForm(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OperatorChebyshevSmoother(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SLISolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CGSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GMRESSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FGMRESSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BiCGSTABSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MINRESSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NewtonSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LBFGSSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OptimizationProblem(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OptimizationSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SLBQPOptimizer(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BlockILU(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ResidualBCMonitor(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DirectSubBlockSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ProductSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OrthoSolver(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IntegrationRule(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_KnotVector(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSMeshRules(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunctions1D(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Quadrature1D(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IntegrationRules(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CoarseFineTransformations(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Table(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Coefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ElementTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ConstantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PWConstCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PWCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CartesianCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CartesianXCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CartesianYCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CartesianZCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CylindricalRadialCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CylindricalAzimuthalCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SphericalRadialCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SphericalAzimuthalCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SphericalPolarCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GridFunction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TransformedCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DeltaCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RestrictedCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorConstantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PWVectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PositionVectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorArrayCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorGridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GradientGridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CurlGridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DivergenceGridFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorDeltaCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorRestrictedCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixConstantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PWMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixArrayCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixRestrictedCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SumCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SymmetricMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DenseSymmetricMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SymmetricMatrixConstantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RatioCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_PowerCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InnerProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorRotProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DeterminantCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorSumCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ScalarVectorProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NormalizedVectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorCrossProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixVectorProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IdentityMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixSumCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MatrixProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ScalarMatrixProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TransposeMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InverseMatrixCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OuterProductCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CrossCrossCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorQuadratureFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunctionCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CoefficientVector(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpaceBase(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSExtension(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Element(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh_GeometryList(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DSTable(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElement(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IsoparametricTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceElementTransformations(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh_FaceInformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElementSpace(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Vertex(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InverseElementTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NodeExtrudeCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElementCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_StatelessDofTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1Pos_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1Ser_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_L2_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DG_Interface_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R1D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R1D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CubicFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CrouzeixRaviartFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearNonConf3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT0_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT1_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT2_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Const2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_P1OnQuadFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CubicDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Const3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RefinedLinearFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND1_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT0_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT1_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Local_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Ordering(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ElementRestrictionOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceRestriction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpace(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceQuadratureInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DofTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NonlinearFormIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ceed_Operator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BlockNonlinearFormIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_HyperelasticModel(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InverseHarmonicModel(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NeoHookeanModel(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_HyperelasticNLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IncompressibleNeoHookeanIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorConvectionNLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ConvectiveVectorConvectionNLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SkewSymmetricVectorConvectionNLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BilinearFormIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TransposeIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LumpedIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InverseIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SumIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedVectorIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarVectorIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarMassIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedVectorProductIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarDerivativeIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakDerivativeIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarDivergenceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedVectorDivergenceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakGradientIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedVectorMassIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCrossProductIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedDotProductIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedWeakGradDotIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedWeakDivCrossIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedGradGradIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCrossGradGradIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCurlCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCrossCurlCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCrossCurlGradIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCrossGradCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedWeakCurlCrossIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakCurlCrossIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCrossGradIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCrossCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarCrossCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarCrossGradIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarCrossProductIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakCrossProductIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedDirectionalDerivativeIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedGradDivIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedDivGradIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedScalarWeakDivergenceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedVectorGradientIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedVectorCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedVectorWeakCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedVectorWeakDivergenceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GradientIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DiffusionIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MassIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BoundaryMassIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ConvectionIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ConservativeConvectionIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GroupConvectionIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorMassIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFEDivergenceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFEWeakDivergenceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFECurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DerivativeIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CurlCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorCurlCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFEMassIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorDivergenceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DivDivIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorDiffusionIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ElasticityIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ElasticityComponentIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DGTraceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NonconservativeDGTraceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DGDiffusionIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DGDiffusionBR2Integrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DGElasticityIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TraceJumpIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NormalTraceJumpIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TraceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NormalTraceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_TangentTraceIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DiscreteInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GradientInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IdentityInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CurlInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DivergenceInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NormalInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ScalarProductInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ScalarVectorProductInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorScalarProductInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ScalarCrossProductInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorCrossProductInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorInnerProductInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_JumpScaling(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ExtrudeCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearFormIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DeltaLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DomainLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DomainLFGradIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BoundaryLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BoundaryNormalLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BoundaryTangentialLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorDomainLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorDomainLFGradIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorBoundaryLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFEDomainLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFEDomainLFCurlIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFEDomainLFDivIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorBoundaryFluxLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFEBoundaryFluxLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorFEBoundaryTangentLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BoundaryFlowIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DGDirichletLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DGElasticityDirichletLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_WhiteGaussianNoiseDomainLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorQuadratureLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureLFIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearForm(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Hybridization(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_MixedBilinearForm(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DiscreteLinearOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NonlinearForm(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BlockNonlinearForm(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DataCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VisItFieldInfo(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VisItDataCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ParaViewDataCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlGlobal(jlcxx::Module&);
//method from libcxxwrap returning its version
extern "C" JLCXX_API const char* cxxwrap_version_string();

//Check the code is compiled with a compatible version of libcxxwrap:
static_assert(1000*1000*JLCXX_VERSION_MAJOR  + 1000 * JLCXX_VERSION_MINOR + JLCXX_VERSION_PATCH >= 12000
  && 1000 * 1000 * JLCXX_VERSION_MAJOR  + 1000 * JLCXX_VERSION_MINOR + JLCXX_VERSION_PATCH < 14000,
  "The code was generated with WrapIt! for "
  "a different CxxWrap version (controlled with the cxxwrap_version parameter).");

//Check the version of loaded libcxxwrap library:
void throw_if_version_incompatibility(){
  std::string version_str = cxxwrap_version_string();
  static std::regex r("([[:digit:]]{1,3})\\.([[:digit:]]{1,3})\\.([[:digit:]]{1,3})");
  std::smatch matches;
  if(!std::regex_match(version_str, matches, r)){
    std::cerr << "Warning: Failed to check libcxxwrap version.";
  } else{    long version_int =   1000*1000*strtol(matches[1].str().c_str(), 0, 10)
                       +      1000*strtol(matches[2].str().c_str(), 0, 10)
                       +           strtol(matches[3].str().c_str(), 0, 10);
    if(version_int < 12000 || version_int >= 14000){
      throw std::runtime_error(std::string("Found libcxxwrap_jll version ")
       + version_str + ", while module MFEM requires a version in "
      "[0.12.0, 0.14.0)."
      " Note: if the module was installed with the package manager, the Project.toml file "
      "of the package is probably missing a compat specification that would have prevented "
      "the inconsistency.");
    }
  }
}


JLCXX_MODULE define_julia_module(jlcxx::Module& jlModule){
  
throw_if_version_incompatibility();
  DEBUG_MSG("Adding wrapper for enum mfem::MemoryType (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/../general/mem_manager.hpp:31:12
  jlModule.add_bits<mfem::MemoryType>("mfem!MemoryType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!MemoryType!HOST", mfem::MemoryType::HOST);
  jlModule.set_const("mfem!MemoryType!HOST_32", mfem::MemoryType::HOST_32);
  jlModule.set_const("mfem!MemoryType!HOST_64", mfem::MemoryType::HOST_64);
  jlModule.set_const("mfem!MemoryType!HOST_DEBUG", mfem::MemoryType::HOST_DEBUG);
  jlModule.set_const("mfem!MemoryType!HOST_UMPIRE", mfem::MemoryType::HOST_UMPIRE);
  jlModule.set_const("mfem!MemoryType!HOST_PINNED", mfem::MemoryType::HOST_PINNED);
  jlModule.set_const("mfem!MemoryType!MANAGED", mfem::MemoryType::MANAGED);
  jlModule.set_const("mfem!MemoryType!DEVICE", mfem::MemoryType::DEVICE);
  jlModule.set_const("mfem!MemoryType!DEVICE_DEBUG", mfem::MemoryType::DEVICE_DEBUG);
  jlModule.set_const("mfem!MemoryType!DEVICE_UMPIRE", mfem::MemoryType::DEVICE_UMPIRE);
  jlModule.set_const("mfem!MemoryType!DEVICE_UMPIRE_2", mfem::MemoryType::DEVICE_UMPIRE_2);
  jlModule.set_const("mfem!MemoryType!SIZE", mfem::MemoryType::SIZE);
  jlModule.set_const("mfem!MemoryType!PRESERVE", mfem::MemoryType::PRESERVE);
  jlModule.set_const("mfem!MemoryType!DEFAULT", mfem::MemoryType::DEFAULT);

  DEBUG_MSG("Adding wrapper for enum mfem::Operator::DiagonalPolicy (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:47:9
  jlModule.add_bits<mfem::Operator::DiagonalPolicy>("mfem!Operator!DiagonalPolicy", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Operator!DIAG_ZERO", mfem::Operator::DIAG_ZERO);
  jlModule.set_const("mfem!Operator!DIAG_ONE", mfem::Operator::DIAG_ONE);
  jlModule.set_const("mfem!Operator!DIAG_KEEP", mfem::Operator::DIAG_KEEP);

  DEBUG_MSG("Adding wrapper for enum mfem::MemoryClass (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/../general/mem_manager.hpp:73:12
  jlModule.add_bits<mfem::MemoryClass>("mfem!MemoryClass", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!MemoryClass!HOST", mfem::MemoryClass::HOST);
  jlModule.set_const("mfem!MemoryClass!HOST_32", mfem::MemoryClass::HOST_32);
  jlModule.set_const("mfem!MemoryClass!HOST_64", mfem::MemoryClass::HOST_64);
  jlModule.set_const("mfem!MemoryClass!DEVICE", mfem::MemoryClass::DEVICE);
  jlModule.set_const("mfem!MemoryClass!MANAGED", mfem::MemoryClass::MANAGED);

  DEBUG_MSG("Adding wrapper for enum mfem::Operator::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:283:9
  jlModule.add_bits<mfem::Operator::Type>("mfem!Operator!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Operator!ANY_TYPE", mfem::Operator::ANY_TYPE);
  jlModule.set_const("mfem!Operator!MFEM_SPARSEMAT", mfem::Operator::MFEM_SPARSEMAT);
  jlModule.set_const("mfem!Operator!Hypre_ParCSR", mfem::Operator::Hypre_ParCSR);
  jlModule.set_const("mfem!Operator!PETSC_MATAIJ", mfem::Operator::PETSC_MATAIJ);
  jlModule.set_const("mfem!Operator!PETSC_MATIS", mfem::Operator::PETSC_MATIS);
  jlModule.set_const("mfem!Operator!PETSC_MATSHELL", mfem::Operator::PETSC_MATSHELL);
  jlModule.set_const("mfem!Operator!PETSC_MATNEST", mfem::Operator::PETSC_MATNEST);
  jlModule.set_const("mfem!Operator!PETSC_MATHYPRE", mfem::Operator::PETSC_MATHYPRE);
  jlModule.set_const("mfem!Operator!PETSC_MATGENERIC", mfem::Operator::PETSC_MATGENERIC);
  jlModule.set_const("mfem!Operator!Complex_Operator", mfem::Operator::Complex_Operator);
  jlModule.set_const("mfem!Operator!MFEM_ComplexSparseMat", mfem::Operator::MFEM_ComplexSparseMat);
  jlModule.set_const("mfem!Operator!Complex_Hypre_ParCSR", mfem::Operator::Complex_Hypre_ParCSR);
  jlModule.set_const("mfem!Operator!Complex_DenseMat", mfem::Operator::Complex_DenseMat);
  jlModule.set_const("mfem!Operator!MFEM_Block_Matrix", mfem::Operator::MFEM_Block_Matrix);
  jlModule.set_const("mfem!Operator!MFEM_Block_Operator", mfem::Operator::MFEM_Block_Operator);

  DEBUG_MSG("Adding wrapper for enum mfem::TimeDependentOperator::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:319:9
  jlModule.add_bits<mfem::TimeDependentOperator::Type>("mfem!TimeDependentOperator!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!TimeDependentOperator!EXPLICIT", mfem::TimeDependentOperator::EXPLICIT);
  jlModule.set_const("mfem!TimeDependentOperator!IMPLICIT", mfem::TimeDependentOperator::IMPLICIT);
  jlModule.set_const("mfem!TimeDependentOperator!HOMOGENEOUS", mfem::TimeDependentOperator::HOMOGENEOUS);

  DEBUG_MSG("Adding wrapper for enum mfem::TimeDependentOperator::EvalMode (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:327:9
  jlModule.add_bits<mfem::TimeDependentOperator::EvalMode>("mfem!TimeDependentOperator!EvalMode", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!TimeDependentOperator!NORMAL", mfem::TimeDependentOperator::NORMAL);
  jlModule.set_const("mfem!TimeDependentOperator!ADDITIVE_TERM_1", mfem::TimeDependentOperator::ADDITIVE_TERM_1);
  jlModule.set_const("mfem!TimeDependentOperator!ADDITIVE_TERM_2", mfem::TimeDependentOperator::ADDITIVE_TERM_2);

  DEBUG_MSG("Adding wrapper for enum mfem::BlockILU::Reordering (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/solvers.hpp:968:15
  jlModule.add_bits<mfem::BlockILU::Reordering>("mfem!BlockILU!Reordering", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!BlockILU!Reordering!MINIMUM_DISCARDED_FILL", mfem::BlockILU::Reordering::MINIMUM_DISCARDED_FILL);
  jlModule.set_const("mfem!BlockILU!Reordering!NONE", mfem::BlockILU::Reordering::NONE);

  DEBUG_MSG("Adding anonymous enum defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:396:4 (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/intrules.hpp:396:4
  jlModule.set_const("mfem!Quadrature1D!Invalid", static_cast<int>(mfem::Quadrature1D::Invalid));
  jlModule.set_const("mfem!Quadrature1D!GaussLegendre", static_cast<int>(mfem::Quadrature1D::GaussLegendre));
  jlModule.set_const("mfem!Quadrature1D!GaussLobatto", static_cast<int>(mfem::Quadrature1D::GaussLobatto));
  jlModule.set_const("mfem!Quadrature1D!OpenUniform", static_cast<int>(mfem::Quadrature1D::OpenUniform));
  jlModule.set_const("mfem!Quadrature1D!ClosedUniform", static_cast<int>(mfem::Quadrature1D::ClosedUniform));
  jlModule.set_const("mfem!Quadrature1D!OpenHalfUniform", static_cast<int>(mfem::Quadrature1D::OpenHalfUniform));
  jlModule.set_const("mfem!Quadrature1D!ClosedGL", static_cast<int>(mfem::Quadrature1D::ClosedGL));

  DEBUG_MSG("Adding anonymous enum defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:38:4 (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:38:4
  jlModule.set_const("mfem!Refinement!X", static_cast<int>(mfem::Refinement::X));
  jlModule.set_const("mfem!Refinement!Y", static_cast<int>(mfem::Refinement::Y));
  jlModule.set_const("mfem!Refinement!Z", static_cast<int>(mfem::Refinement::Z));
  jlModule.set_const("mfem!Refinement!XY", static_cast<int>(mfem::Refinement::XY));
  jlModule.set_const("mfem!Refinement!XZ", static_cast<int>(mfem::Refinement::XZ));
  jlModule.set_const("mfem!Refinement!YZ", static_cast<int>(mfem::Refinement::YZ));
  jlModule.set_const("mfem!Refinement!XYZ", static_cast<int>(mfem::Refinement::XYZ));

  DEBUG_MSG("Adding wrapper for enum mfem::Geometry::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/fe/../geom.hpp:35:9
  jlModule.add_bits<mfem::Geometry::Type>("mfem!Geometry!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Geometry!INVALID", mfem::Geometry::INVALID);
  jlModule.set_const("mfem!Geometry!POINT", mfem::Geometry::POINT);
  jlModule.set_const("mfem!Geometry!SEGMENT", mfem::Geometry::SEGMENT);
  jlModule.set_const("mfem!Geometry!TRIANGLE", mfem::Geometry::TRIANGLE);
  jlModule.set_const("mfem!Geometry!SQUARE", mfem::Geometry::SQUARE);
  jlModule.set_const("mfem!Geometry!TETRAHEDRON", mfem::Geometry::TETRAHEDRON);
  jlModule.set_const("mfem!Geometry!CUBE", mfem::Geometry::CUBE);
  jlModule.set_const("mfem!Geometry!PRISM", mfem::Geometry::PRISM);
  jlModule.set_const("mfem!Geometry!PYRAMID", mfem::Geometry::PYRAMID);
  jlModule.set_const("mfem!Geometry!NUM_GEOMETRIES", mfem::Geometry::NUM_GEOMETRIES);

  DEBUG_MSG("Adding wrapper for enum mfem::CoefficientStorage (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/coefficient.hpp:2288:12
  jlModule.add_bits<mfem::CoefficientStorage>("mfem!CoefficientStorage", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!CoefficientStorage!FULL", mfem::CoefficientStorage::FULL);
  jlModule.set_const("mfem!CoefficientStorage!CONSTANTS", mfem::CoefficientStorage::CONSTANTS);
  jlModule.set_const("mfem!CoefficientStorage!SYMMETRIC", mfem::CoefficientStorage::SYMMETRIC);
  jlModule.set_const("mfem!CoefficientStorage!COMPRESSED", mfem::CoefficientStorage::COMPRESSED);

  DEBUG_MSG("Adding wrapper for enum mfem::FaceType (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:45:12
  jlModule.add_bits<mfem::FaceType>("mfem!FaceType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!FaceType!Interior", mfem::FaceType::Interior);
  jlModule.set_const("mfem!FaceType!Boundary", mfem::FaceType::Boundary);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::Operation (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:270:9
  jlModule.add_bits<mfem::Mesh::Operation>("mfem!Mesh!Operation", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!NONE", mfem::Mesh::NONE);
  jlModule.set_const("mfem!Mesh!REFINE", mfem::Mesh::REFINE);
  jlModule.set_const("mfem!Mesh!DEREFINE", mfem::Mesh::DEREFINE);
  jlModule.set_const("mfem!Mesh!REBALANCE", mfem::Mesh::REBALANCE);

  DEBUG_MSG("Adding wrapper for enum mfem::Element::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/element.hpp:41:9
  jlModule.add_bits<mfem::Element::Type>("mfem!Element!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Element!POINT", mfem::Element::POINT);
  jlModule.set_const("mfem!Element!SEGMENT", mfem::Element::SEGMENT);
  jlModule.set_const("mfem!Element!TRIANGLE", mfem::Element::TRIANGLE);
  jlModule.set_const("mfem!Element!QUADRILATERAL", mfem::Element::QUADRILATERAL);
  jlModule.set_const("mfem!Element!TETRAHEDRON", mfem::Element::TETRAHEDRON);
  jlModule.set_const("mfem!Element!HEXAHEDRON", mfem::Element::HEXAHEDRON);
  jlModule.set_const("mfem!Element!WEDGE", mfem::Element::WEDGE);
  jlModule.set_const("mfem!Element!PYRAMID", mfem::Element::PYRAMID);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::FaceTopology (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1792:15
  jlModule.add_bits<mfem::Mesh::FaceTopology>("mfem!Mesh!FaceTopology", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!FaceTopology!Boundary", mfem::Mesh::FaceTopology::Boundary);
  jlModule.set_const("mfem!Mesh!FaceTopology!Conforming", mfem::Mesh::FaceTopology::Conforming);
  jlModule.set_const("mfem!Mesh!FaceTopology!Nonconforming", mfem::Mesh::FaceTopology::Nonconforming);
  jlModule.set_const("mfem!Mesh!FaceTopology!NA", mfem::Mesh::FaceTopology::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::ElementLocation (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1804:15
  jlModule.add_bits<mfem::Mesh::ElementLocation>("mfem!Mesh!ElementLocation", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!ElementLocation!Local", mfem::Mesh::ElementLocation::Local);
  jlModule.set_const("mfem!Mesh!ElementLocation!FaceNbr", mfem::Mesh::ElementLocation::FaceNbr);
  jlModule.set_const("mfem!Mesh!ElementLocation!NA", mfem::Mesh::ElementLocation::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::ElementConformity (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1819:15
  jlModule.add_bits<mfem::Mesh::ElementConformity>("mfem!Mesh!ElementConformity", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!ElementConformity!Coincident", mfem::Mesh::ElementConformity::Coincident);
  jlModule.set_const("mfem!Mesh!ElementConformity!Superset", mfem::Mesh::ElementConformity::Superset);
  jlModule.set_const("mfem!Mesh!ElementConformity!Subset", mfem::Mesh::ElementConformity::Subset);
  jlModule.set_const("mfem!Mesh!ElementConformity!NA", mfem::Mesh::ElementConformity::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::FaceInfoTag (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1838:15
  jlModule.add_bits<mfem::Mesh::FaceInfoTag>("mfem!Mesh!FaceInfoTag", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!FaceInfoTag!Boundary", mfem::Mesh::FaceInfoTag::Boundary);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!LocalConforming", mfem::Mesh::FaceInfoTag::LocalConforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!LocalSlaveNonconforming", mfem::Mesh::FaceInfoTag::LocalSlaveNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!SharedConforming", mfem::Mesh::FaceInfoTag::SharedConforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!SharedSlaveNonconforming", mfem::Mesh::FaceInfoTag::SharedSlaveNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!MasterNonconforming", mfem::Mesh::FaceInfoTag::MasterNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!GhostSlave", mfem::Mesh::FaceInfoTag::GhostSlave);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!GhostMaster", mfem::Mesh::FaceInfoTag::GhostMaster);

  DEBUG_MSG("Adding wrapper for enum mfem::VTKFormat (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/vtk.hpp:98:12
  jlModule.add_bits<mfem::VTKFormat>("mfem!VTKFormat", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!VTKFormat!ASCII", mfem::VTKFormat::ASCII);
  jlModule.set_const("mfem!VTKFormat!BINARY", mfem::VTKFormat::BINARY);
  jlModule.set_const("mfem!VTKFormat!BINARY32", mfem::VTKFormat::BINARY32);

  DEBUG_MSG("Adding anonymous enum defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:45:4 (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:45:4
  jlModule.set_const("mfem!FiniteElementCollection!CONTINUOUS", static_cast<int>(mfem::FiniteElementCollection::CONTINUOUS));
  jlModule.set_const("mfem!FiniteElementCollection!TANGENTIAL", static_cast<int>(mfem::FiniteElementCollection::TANGENTIAL));
  jlModule.set_const("mfem!FiniteElementCollection!NORMAL", static_cast<int>(mfem::FiniteElementCollection::NORMAL));
  jlModule.set_const("mfem!FiniteElementCollection!DISCONTINUOUS", static_cast<int>(mfem::FiniteElementCollection::DISCONTINUOUS));

  DEBUG_MSG("Adding anonymous enum defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:698:4 (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:698:4
  jlModule.set_const("mfem!NURBSFECollection!VariableOrder", static_cast<int>(mfem::NURBSFECollection::VariableOrder));

  DEBUG_MSG("Adding wrapper for enum mfem::Ordering::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:33:9
  jlModule.add_bits<mfem::Ordering::Type>("mfem!Ordering!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Ordering!byNODES", mfem::Ordering::byNODES);
  jlModule.set_const("mfem!Ordering!byVDIM", mfem::Ordering::byVDIM);

  DEBUG_MSG("Adding wrapper for enum mfem::QVectorLayout (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:52:12
  jlModule.add_bits<mfem::QVectorLayout>("mfem!QVectorLayout", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!QVectorLayout!byNODES", mfem::QVectorLayout::byNODES);
  jlModule.set_const("mfem!QVectorLayout!byVDIM", mfem::QVectorLayout::byVDIM);

  DEBUG_MSG("Adding wrapper for enum mfem::ElementDofOrdering (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:74:12
  jlModule.add_bits<mfem::ElementDofOrdering>("mfem!ElementDofOrdering", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!ElementDofOrdering!NATIVE", mfem::ElementDofOrdering::NATIVE);
  jlModule.set_const("mfem!ElementDofOrdering!LEXICOGRAPHIC", mfem::ElementDofOrdering::LEXICOGRAPHIC);

  DEBUG_MSG("Adding wrapper for enum mfem::L2FaceValues (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/restriction.hpp:136:12
  jlModule.add_bits<mfem::L2FaceValues>("mfem!L2FaceValues", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!L2FaceValues!SingleValued", mfem::L2FaceValues::SingleValued);
  jlModule.set_const("mfem!L2FaceValues!DoubleValued", mfem::L2FaceValues::DoubleValued);

  DEBUG_MSG("Adding wrapper for enum mfem::NonlinearFormIntegrator::Mode (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/nonlininteg.hpp:30:9
  jlModule.add_bits<mfem::NonlinearFormIntegrator::Mode>("mfem!NonlinearFormIntegrator!Mode", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!NonlinearFormIntegrator!ELEMENTWISE", mfem::NonlinearFormIntegrator::ELEMENTWISE);
  jlModule.set_const("mfem!NonlinearFormIntegrator!PATCHWISE", mfem::NonlinearFormIntegrator::PATCHWISE);
  jlModule.set_const("mfem!NonlinearFormIntegrator!PATCHWISE_REDUCED", mfem::NonlinearFormIntegrator::PATCHWISE_REDUCED);

  DEBUG_MSG("Adding wrapper for enum mfem::GridFunction::AvgType (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:422:9
  jlModule.add_bits<mfem::GridFunction::AvgType>("mfem!GridFunction!AvgType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!GridFunction!ARITHMETIC", mfem::GridFunction::ARITHMETIC);
  jlModule.set_const("mfem!GridFunction!HARMONIC", mfem::GridFunction::HARMONIC);

  DEBUG_MSG("Adding wrapper for enum mfem::JumpScaling::JumpScalingType (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:775:9
  jlModule.add_bits<mfem::JumpScaling::JumpScalingType>("mfem!JumpScaling!JumpScalingType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!JumpScaling!CONSTANT", mfem::JumpScaling::CONSTANT);
  jlModule.set_const("mfem!JumpScaling!ONE_OVER_H", mfem::JumpScaling::ONE_OVER_H);
  jlModule.set_const("mfem!JumpScaling!P_SQUARED_OVER_H", mfem::JumpScaling::P_SQUARED_OVER_H);

  DEBUG_MSG("Adding wrapper for enum mfem::AssemblyLevel (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/bilinearform.hpp:31:12
  jlModule.add_bits<mfem::AssemblyLevel>("mfem!AssemblyLevel", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!AssemblyLevel!LEGACY", mfem::AssemblyLevel::LEGACY);
  jlModule.set_const("mfem!AssemblyLevel!LEGACYFULL", mfem::AssemblyLevel::LEGACYFULL);
  jlModule.set_const("mfem!AssemblyLevel!FULL", mfem::AssemblyLevel::FULL);
  jlModule.set_const("mfem!AssemblyLevel!ELEMENT", mfem::AssemblyLevel::ELEMENT);
  jlModule.set_const("mfem!AssemblyLevel!PARTIAL", mfem::AssemblyLevel::PARTIAL);
  jlModule.set_const("mfem!AssemblyLevel!NONE", mfem::AssemblyLevel::NONE);

  DEBUG_MSG("Adding wrapper for enum mfem::DataCollection::Format (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:148:9
  jlModule.add_bits<mfem::DataCollection::Format>("mfem!DataCollection!Format", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!DataCollection!SERIAL_FORMAT", mfem::DataCollection::SERIAL_FORMAT);
  jlModule.set_const("mfem!DataCollection!PARALLEL_FORMAT", mfem::DataCollection::PARALLEL_FORMAT);

  DEBUG_MSG("Adding anonymous enum defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:381:4 (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/datacollection.hpp:381:4
  jlModule.set_const("mfem!DataCollection!NO_ERROR", static_cast<int>(mfem::DataCollection::NO_ERROR));
  jlModule.set_const("mfem!DataCollection!No_Error", static_cast<int>(mfem::DataCollection::No_Error));
  jlModule.set_const("mfem!DataCollection!READ_ERROR", static_cast<int>(mfem::DataCollection::READ_ERROR));
  jlModule.set_const("mfem!DataCollection!WRITE_ERROR", static_cast<int>(mfem::DataCollection::WRITE_ERROR));

  std::vector<std::shared_ptr<Wrapper>> wrappers = {
    std::shared_ptr<Wrapper>(newJlmfem_Embedding(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Refinement(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IntegrationPoint(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Vector(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Memory(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Operator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TimeDependentOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TimeDependentAdjointOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SecondOrderTimeDependentOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Solver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IdentityOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ScaledOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TransposeOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ProductOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RAPOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TripleProductOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ConstrainedOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RectangularConstrainedOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PowerMethod(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Matrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixInverse(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_AbstractSparseMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RowNode(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SparseMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DenseMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SparseSmoother(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GSSmoother(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DSmoother(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OperatorHandle(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IterativeSolverMonitor(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IterativeSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IterativeSolver_PrintLevel(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OperatorJacobiSmoother(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BilinearForm(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OperatorChebyshevSmoother(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SLISolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CGSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GMRESSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FGMRESSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BiCGSTABSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MINRESSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NewtonSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LBFGSSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OptimizationProblem(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OptimizationSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SLBQPOptimizer(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BlockILU(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ResidualBCMonitor(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DirectSubBlockSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ProductSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OrthoSolver(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IntegrationRule(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_KnotVector(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSMeshRules(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureFunctions1D(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Quadrature1D(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IntegrationRules(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CoarseFineTransformations(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Table(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Coefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ElementTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureFunction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ConstantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PWConstCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PWCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CartesianCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CartesianXCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CartesianYCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CartesianZCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CylindricalRadialCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CylindricalAzimuthalCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SphericalRadialCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SphericalAzimuthalCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SphericalPolarCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GridFunction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TransformedCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DeltaCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RestrictedCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorConstantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PWVectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PositionVectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorArrayCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorGridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GradientGridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CurlGridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DivergenceGridFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorDeltaCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorRestrictedCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixConstantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PWMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixArrayCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixRestrictedCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SumCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SymmetricMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DenseSymmetricMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SymmetricMatrixConstantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RatioCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_PowerCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InnerProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorRotProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DeterminantCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorSumCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ScalarVectorProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NormalizedVectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorCrossProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixVectorProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IdentityMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixSumCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MatrixProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ScalarMatrixProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TransposeMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InverseMatrixCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OuterProductCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CrossCrossCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorQuadratureFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureFunctionCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CoefficientVector(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureSpaceBase(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSExtension(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Element(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh_GeometryList(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DSTable(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElement(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IsoparametricTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceElementTransformations(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh_FaceInformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElementSpace(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Vertex(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InverseElementTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NodeExtrudeCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElementCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_StatelessDofTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1Pos_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1Ser_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_L2_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DG_Interface_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R1D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R1D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R2D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R2D_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R2D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R2D_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticPosFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CubicFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CrouzeixRaviartFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearNonConf3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT0_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT1_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT2_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Const2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GaussLinearDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_P1OnQuadFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticPosDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GaussQuadraticDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CubicDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Const3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearDiscont3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticDiscont3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RefinedLinearFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND1_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT0_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT1_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Local_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Ordering(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ElementRestrictionOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceRestriction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureSpace(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceQuadratureInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DofTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NonlinearFormIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ceed_Operator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BlockNonlinearFormIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_HyperelasticModel(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InverseHarmonicModel(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NeoHookeanModel(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_HyperelasticNLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IncompressibleNeoHookeanIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorConvectionNLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ConvectiveVectorConvectionNLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SkewSymmetricVectorConvectionNLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BilinearFormIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TransposeIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LumpedIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InverseIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SumIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedVectorIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarVectorIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarMassIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedVectorProductIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarDerivativeIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarWeakDerivativeIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarDivergenceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedVectorDivergenceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarWeakGradientIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarWeakCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedVectorMassIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCrossProductIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedDotProductIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedWeakGradDotIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedWeakDivCrossIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedGradGradIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCrossGradGradIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCurlCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCrossCurlCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCrossCurlGradIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCrossGradCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedWeakCurlCrossIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarWeakCurlCrossIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCrossGradIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCrossCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarCrossCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarCrossGradIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarCrossProductIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarWeakCrossProductIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedDirectionalDerivativeIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedGradDivIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedDivGradIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedScalarWeakDivergenceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedVectorGradientIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedVectorCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedVectorWeakCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedVectorWeakDivergenceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GradientIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DiffusionIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MassIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BoundaryMassIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ConvectionIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ConservativeConvectionIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GroupConvectionIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorMassIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFEDivergenceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFEWeakDivergenceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFECurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DerivativeIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CurlCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorCurlCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFEMassIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorDivergenceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DivDivIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorDiffusionIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ElasticityIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ElasticityComponentIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DGTraceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NonconservativeDGTraceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DGDiffusionIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DGDiffusionBR2Integrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DGElasticityIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TraceJumpIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NormalTraceJumpIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TraceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NormalTraceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_TangentTraceIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DiscreteInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GradientInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IdentityInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CurlInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DivergenceInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NormalInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ScalarProductInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ScalarVectorProductInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorScalarProductInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ScalarCrossProductInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorCrossProductInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorInnerProductInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_JumpScaling(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ExtrudeCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearFormIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DeltaLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DomainLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DomainLFGradIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BoundaryLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BoundaryNormalLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BoundaryTangentialLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorDomainLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorDomainLFGradIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorBoundaryLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFEDomainLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFEDomainLFCurlIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFEDomainLFDivIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorBoundaryFluxLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFEBoundaryFluxLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorFEBoundaryTangentLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BoundaryFlowIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DGDirichletLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DGElasticityDirichletLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_WhiteGaussianNoiseDomainLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorQuadratureLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureLFIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearForm(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Hybridization(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_MixedBilinearForm(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DiscreteLinearOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NonlinearForm(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BlockNonlinearForm(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DataCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VisItFieldInfo(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VisItDataCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ParaViewDataCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Array(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Array2D(jlModule)),
    std::shared_ptr<Wrapper>(newJlGlobal(jlModule))
  };
  for(const auto& w: wrappers) w->add_methods();
}
