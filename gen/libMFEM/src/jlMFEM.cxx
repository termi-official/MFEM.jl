// this file was auto-generated by wrapit v1.4.0
#include "jlcxx/jlcxx.hpp"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

#include "jlMFEM.h"

#include <regex>

#include "dbg_msg.h"
#include "Wrapper.h"

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Embedding> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Embedding> : std::false_type { };
}

// Class generating the wrapper for type mfem::Embedding
// signature to use in the veto file: mfem::Embedding
struct Jlmfem_Embedding: public Wrapper {

  Jlmfem_Embedding(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Embedding (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:50:8
    jlcxx::TypeWrapper<mfem::Embedding>  t = jlModule.add_type<mfem::Embedding>("mfem!Embedding");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Embedding>>(new jlcxx::TypeWrapper<mfem::Embedding>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Embedding::Embedding(int, mfem::Geometry::Type, int, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:65:4
    t.constructor<int, mfem::Geometry::Type>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, mfem::Geometry::Type, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, mfem::Geometry::Type, int, bool>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding parent methods  to provide read access to the field parent (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:53:8
    // signature to use in the veto list: mfem::Embedding::parent
    t.method("parent", [](const mfem::Embedding& a) -> int { return a.parent; });
    t.method("parent", [](mfem::Embedding& a) -> int { return a.parent; });
    t.method("parent", [](const mfem::Embedding* a) -> int { return a->parent; });
    t.method("parent", [](mfem::Embedding* a) -> int { return a->parent; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:53:8
    // signature to use in the veto list: mfem::Embedding::parent
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding parent! methods to provide write access to the field parent (" __HERE__ ")");
    t.method("parent!", [](mfem::Embedding& a, int val) -> int { return a.parent = val; });

    DEBUG_MSG("Adding parent! methods to provide write access to the field parent (" __HERE__ ")");
    t.method("parent!", [](mfem::Embedding* a, int val) -> int { return a->parent = val; });

    DEBUG_MSG("Adding geom methods  to provide read access to the field geom (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:58:13
    // signature to use in the veto list: mfem::Embedding::geom
    t.method("geom", [](const mfem::Embedding& a) -> unsigned int { return a.geom; });
    t.method("geom", [](mfem::Embedding& a) -> unsigned int { return a.geom; });
    t.method("geom", [](const mfem::Embedding* a) -> unsigned int { return a->geom; });
    t.method("geom", [](mfem::Embedding* a) -> unsigned int { return a->geom; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:58:13
    // signature to use in the veto list: mfem::Embedding::geom
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding geom! methods to provide write access to the field geom (" __HERE__ ")");
    t.method("geom!", [](mfem::Embedding& a, unsigned int val) -> unsigned int { return a.geom = val; });

    DEBUG_MSG("Adding geom! methods to provide write access to the field geom (" __HERE__ ")");
    t.method("geom!", [](mfem::Embedding* a, unsigned int val) -> unsigned int { return a->geom = val; });

    DEBUG_MSG("Adding matrix methods  to provide read access to the field matrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:59:13
    // signature to use in the veto list: mfem::Embedding::matrix
    t.method("matrix", [](const mfem::Embedding& a) -> unsigned int { return a.matrix; });
    t.method("matrix", [](mfem::Embedding& a) -> unsigned int { return a.matrix; });
    t.method("matrix", [](const mfem::Embedding* a) -> unsigned int { return a->matrix; });
    t.method("matrix", [](mfem::Embedding* a) -> unsigned int { return a->matrix; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:59:13
    // signature to use in the veto list: mfem::Embedding::matrix
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding matrix! methods to provide write access to the field matrix (" __HERE__ ")");
    t.method("matrix!", [](mfem::Embedding& a, unsigned int val) -> unsigned int { return a.matrix = val; });

    DEBUG_MSG("Adding matrix! methods to provide write access to the field matrix (" __HERE__ ")");
    t.method("matrix!", [](mfem::Embedding* a, unsigned int val) -> unsigned int { return a->matrix = val; });

    DEBUG_MSG("Adding ghost methods  to provide read access to the field ghost (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:62:13
    // signature to use in the veto list: mfem::Embedding::ghost
    t.method("ghost", [](const mfem::Embedding& a) -> unsigned int { return a.ghost; });
    t.method("ghost", [](mfem::Embedding& a) -> unsigned int { return a.ghost; });
    t.method("ghost", [](const mfem::Embedding* a) -> unsigned int { return a->ghost; });
    t.method("ghost", [](mfem::Embedding* a) -> unsigned int { return a->ghost; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:62:13
    // signature to use in the veto list: mfem::Embedding::ghost
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding ghost! methods to provide write access to the field ghost (" __HERE__ ")");
    t.method("ghost!", [](mfem::Embedding& a, unsigned int val) -> unsigned int { return a.ghost = val; });

    DEBUG_MSG("Adding ghost! methods to provide write access to the field ghost (" __HERE__ ")");
    t.method("ghost!", [](mfem::Embedding* a, unsigned int val) -> unsigned int { return a->ghost = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Embedding>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Embedding(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Embedding(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Refinement> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Refinement> : std::false_type { };
}

// Class generating the wrapper for type mfem::Refinement
// signature to use in the veto file: mfem::Refinement
struct Jlmfem_Refinement: public Wrapper {

  Jlmfem_Refinement(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Refinement (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:36:8
    jlcxx::TypeWrapper<mfem::Refinement>  t = jlModule.add_type<mfem::Refinement>("mfem!Refinement");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Refinement>>(new jlcxx::TypeWrapper<mfem::Refinement>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Refinement::Refinement(int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:44:4
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding index methods  to provide read access to the field index (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:39:8
    // signature to use in the veto list: mfem::Refinement::index
    t.method("index", [](const mfem::Refinement& a) -> int { return a.index; });
    t.method("index", [](mfem::Refinement& a) -> int { return a.index; });
    t.method("index", [](const mfem::Refinement* a) -> int { return a->index; });
    t.method("index", [](mfem::Refinement* a) -> int { return a->index; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:39:8
    // signature to use in the veto list: mfem::Refinement::index
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding index! methods to provide write access to the field index (" __HERE__ ")");
    t.method("index!", [](mfem::Refinement& a, int val) -> int { return a.index = val; });

    DEBUG_MSG("Adding index! methods to provide write access to the field index (" __HERE__ ")");
    t.method("index!", [](mfem::Refinement* a, int val) -> int { return a->index = val; });

    DEBUG_MSG("Adding ref_type methods  to provide read access to the field ref_type (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:40:9
    // signature to use in the veto list: mfem::Refinement::ref_type
    t.method("ref_type", [](const mfem::Refinement& a) -> char { return a.ref_type; });
    t.method("ref_type", [](mfem::Refinement& a) -> char { return a.ref_type; });
    t.method("ref_type", [](const mfem::Refinement* a) -> char { return a->ref_type; });
    t.method("ref_type", [](mfem::Refinement* a) -> char { return a->ref_type; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:40:9
    // signature to use in the veto list: mfem::Refinement::ref_type
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding ref_type! methods to provide write access to the field ref_type (" __HERE__ ")");
    t.method("ref_type!", [](mfem::Refinement& a, char val) -> char { return a.ref_type = val; });

    DEBUG_MSG("Adding ref_type! methods to provide write access to the field ref_type (" __HERE__ ")");
    t.method("ref_type!", [](mfem::Refinement* a, char val) -> char { return a->ref_type = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Refinement>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Refinement(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Refinement(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IntegrationPoint> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IntegrationPoint> : std::false_type { };
}

// Class generating the wrapper for type mfem::IntegrationPoint
// signature to use in the veto file: mfem::IntegrationPoint
struct Jlmfem_IntegrationPoint: public Wrapper {

  Jlmfem_IntegrationPoint(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IntegrationPoint (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/fe/../intrules.hpp:34:7
    jlcxx::TypeWrapper<mfem::IntegrationPoint>  t = jlModule.add_type<mfem::IntegrationPoint>("mfem!IntegrationPoint");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationPoint>>(new jlcxx::TypeWrapper<mfem::IntegrationPoint>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationPoint>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IntegrationPoint(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IntegrationPoint(module));
}

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<mfem::Array<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<mfem::Array<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<mfem::Array<T>> : std::false_type { };
}

// Class generating the wrapper for type mfem::Array
// signature to use in the veto file: mfem::Array
struct Jlmfem_Array: public Wrapper {

  Jlmfem_Array(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Array (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:45:7
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("mfem!Array");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
    auto t1_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<mfem::Array<T>> wrapped){
      auto module_ = this->module_;
      typedef mfem::Array<T> WrappedType;
      wrapped.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(mfem::MemoryType) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:67:11
      wrapped.template constructor<mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(int) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:70:20
      wrapped.template constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(int, mfem::MemoryType) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:74:11
      wrapped.template constructor<int, mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(T *, int) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:79:11
      wrapped.template constructor<T *, int>(/*finalize=*/jlcxx::finalize_policy::yes);

      DEBUG_MSG("Adding wrapper for T * mfem::Array::GetData() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::GetData()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:114:14
      wrapped.method("GetData", static_cast<T * (WrappedType::*)() >(&WrappedType::GetData));

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::GetData() (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::GetData()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:116:20
      wrapped.method("GetData", static_cast<const T * (WrappedType::*)()  const>(&WrappedType::GetData));

      DEBUG_MSG("Adding wrapper for bool mfem::Array::UseDevice() (" __HERE__ ")");
      // signature to use in the veto list: bool mfem::Array::UseDevice()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:125:9
      wrapped.method("UseDevice", static_cast<bool (WrappedType::*)()  const>(&WrappedType::UseDevice));

      DEBUG_MSG("Adding wrapper for bool mfem::Array::OwnsData() (" __HERE__ ")");
      // signature to use in the veto list: bool mfem::Array::OwnsData()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:128:16
      wrapped.method("OwnsData", static_cast<bool (WrappedType::*)()  const>(&WrappedType::OwnsData));

      DEBUG_MSG("Adding wrapper for void mfem::Array::StealData(T **) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::StealData(T **)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:131:16
      wrapped.method("StealData", static_cast<void (WrappedType::*)(T **) >(&WrappedType::StealData));

      DEBUG_MSG("Adding wrapper for void mfem::Array::LoseData() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::LoseData()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:134:16
      wrapped.method("LoseData", static_cast<void (WrappedType::*)() >(&WrappedType::LoseData));

      DEBUG_MSG("Adding wrapper for void mfem::Array::MakeDataOwner() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::MakeDataOwner()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:137:9
      wrapped.method("MakeDataOwner", static_cast<void (WrappedType::*)()  const>(&WrappedType::MakeDataOwner));

      DEBUG_MSG("Adding wrapper for int mfem::Array::Size() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Size()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:140:15
      wrapped.method("Size", static_cast<int (WrappedType::*)()  const>(&WrappedType::Size));

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:143:16
      wrapped.method("SetSize", static_cast<void (WrappedType::*)(int) >(&WrappedType::SetSize));

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int, const T &) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int, const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:146:16
      wrapped.method("SetSize", static_cast<void (WrappedType::*)(int, const T &) >(&WrappedType::SetSize));

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int, mfem::MemoryType) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int, mfem::MemoryType)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:151:16
      wrapped.method("SetSize", static_cast<void (WrappedType::*)(int, mfem::MemoryType) >(&WrappedType::SetSize));

      DEBUG_MSG("Adding wrapper for int mfem::Array::Capacity() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Capacity()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:155:15
      wrapped.method("Capacity", static_cast<int (WrappedType::*)()  const>(&WrappedType::Capacity));

      DEBUG_MSG("Adding wrapper for void mfem::Array::Reserve(int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::Reserve(int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:158:16
      wrapped.method("Reserve", static_cast<void (WrappedType::*)(int) >(&WrappedType::Reserve));
      module_.set_override_module(jl_base_module);


      DEBUG_MSG("Adding setindex! method  to wrap T & mfem::Array::operator[](int) (" __HERE__ ")");
// defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:162:15
      wrapped.method("setindex!",
        [](WrappedType& a, int i, T const & val){
        return a[i] = val;
      });

      DEBUG_MSG("Adding getindex method to wrap T & mfem::Array::operator[](int) (" __HERE__ ")");
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:162:15
      wrapped.method("getindex",
        [](WrappedType& a, int i){
        return a[i];
      });


      module_.unset_override_module();

      DEBUG_MSG("Adding wrapper for int mfem::Array::Append(const T &) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Append(const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:168:15
      wrapped.method("Append", static_cast<int (WrappedType::*)(const T &) >(&WrappedType::Append));

      DEBUG_MSG("Adding wrapper for int mfem::Array::Append(const T *, int) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Append(const T *, int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:171:15
      wrapped.method("Append", static_cast<int (WrappedType::*)(const T *, int) >(&WrappedType::Append));

      DEBUG_MSG("Adding wrapper for int mfem::Array::Prepend(const T &) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Prepend(const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:177:15
      wrapped.method("Prepend", static_cast<int (WrappedType::*)(const T &) >(&WrappedType::Prepend));

      DEBUG_MSG("Adding wrapper for T & mfem::Array::Last() (" __HERE__ ")");
      // signature to use in the veto list: T & mfem::Array::Last()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:180:14
      wrapped.method("Last", static_cast<T & (WrappedType::*)() >(&WrappedType::Last));

      DEBUG_MSG("Adding wrapper for const T & mfem::Array::Last() (" __HERE__ ")");
      // signature to use in the veto list: const T & mfem::Array::Last()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:183:20
      wrapped.method("Last", static_cast<const T & (WrappedType::*)()  const>(&WrappedType::Last));

      DEBUG_MSG("Adding wrapper for void mfem::Array::DeleteLast() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::DeleteLast()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:195:16
      wrapped.method("DeleteLast", static_cast<void (WrappedType::*)() >(&WrappedType::DeleteLast));

      DEBUG_MSG("Adding wrapper for void mfem::Array::DeleteAll() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::DeleteAll()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:201:16
      wrapped.method("DeleteAll", static_cast<void (WrappedType::*)() >(&WrappedType::DeleteAll));

      DEBUG_MSG("Adding wrapper for void mfem::Array::MakeRef(T *, int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::MakeRef(T *, int)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:208:16
      wrapped.method("MakeRef", static_cast<void (WrappedType::*)(T *, int) >(&WrappedType::MakeRef));

      DEBUG_MSG("Adding wrapper for void mfem::Array::operator=(const T &) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::operator=(const T &)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:274:16
      wrapped.method("assign", static_cast<void (WrappedType::*)(const T &) >(&WrappedType::operator=));

      DEBUG_MSG("Adding wrapper for void mfem::Array::Assign(const T *) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::Assign(const T *)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:277:16
      wrapped.method("Assign", static_cast<void (WrappedType::*)(const T *) >(&WrappedType::Assign));

      DEBUG_MSG("Adding wrapper for std::size_t mfem::Array::MemoryUsage() (" __HERE__ ")");
      // signature to use in the veto list: std::size_t mfem::Array::MemoryUsage()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:303:16
      wrapped.method("MemoryUsage", static_cast<std::size_t (WrappedType::*)()  const>(&WrappedType::MemoryUsage));

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::Read(bool) (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::Read(bool)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:306:13
      wrapped.method("Read", static_cast<const T * (WrappedType::*)(bool)  const>(&WrappedType::Read));
      wrapped.method("Read", [](WrappedType const& a)->const T * { return a.Read(); });
      wrapped.method("Read", [](WrappedType const* a)->const T * { return a->Read(); });

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::HostRead() (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::HostRead()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:310:13
      wrapped.method("HostRead", static_cast<const T * (WrappedType::*)()  const>(&WrappedType::HostRead));

      DEBUG_MSG("Adding wrapper for T * mfem::Array::Write(bool) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::Write(bool)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:314:7
      wrapped.method("Write", static_cast<T * (WrappedType::*)(bool) >(&WrappedType::Write));
      wrapped.method("Write", [](WrappedType& a)->T * { return a.Write(); });
      wrapped.method("Write", [](WrappedType* a)->T * { return a->Write(); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array::HostWrite() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::HostWrite()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:318:7
      wrapped.method("HostWrite", static_cast<T * (WrappedType::*)() >(&WrappedType::HostWrite));

      DEBUG_MSG("Adding wrapper for T * mfem::Array::ReadWrite(bool) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::ReadWrite(bool)
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:322:7
      wrapped.method("ReadWrite", static_cast<T * (WrappedType::*)(bool) >(&WrappedType::ReadWrite));
      wrapped.method("ReadWrite", [](WrappedType& a)->T * { return a.ReadWrite(); });
      wrapped.method("ReadWrite", [](WrappedType* a)->T * { return a->ReadWrite(); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array::HostReadWrite() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::HostReadWrite()
      // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../general/array.hpp:326:7
      wrapped.method("HostReadWrite", static_cast<T * (WrappedType::*)() >(&WrappedType::HostReadWrite));
    };
    t.apply<mfem::Array<mfem::Element *>, mfem::Array<const mfem::KnotVector *>, mfem::Array<mfem::IntegrationPoint>, mfem::Array<mfem::Vector *>, mfem::Array<mfem::KnotVector *>, mfem::Array<mfem::Geometry::Type>, mfem::Array<int>, mfem::Array<double>, mfem::Array<float>, mfem::Array<mfem::Refinement>, mfem::Array<mfem::Embedding>>(t1_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Array(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Array(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CoarseFineTransformations> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CoarseFineTransformations> : std::false_type { };
}

// Class generating the wrapper for type mfem::CoarseFineTransformations
// signature to use in the veto file: mfem::CoarseFineTransformations
struct Jlmfem_CoarseFineTransformations: public Wrapper {

  Jlmfem_CoarseFineTransformations(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CoarseFineTransformations (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:71:8
    jlcxx::TypeWrapper<mfem::CoarseFineTransformations>  t = jlModule.add_type<mfem::CoarseFineTransformations>("mfem!CoarseFineTransformations");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CoarseFineTransformations>>(new jlcxx::TypeWrapper<mfem::CoarseFineTransformations>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::CoarseFineTransformations::MakeCoarseToFineTable(mfem::Table &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoarseFineTransformations::MakeCoarseToFineTable(mfem::Table &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:83:9
    t.method("MakeCoarseToFineTable", static_cast<void (mfem::CoarseFineTransformations::*)(mfem::Table &, bool)  const>(&mfem::CoarseFineTransformations::MakeCoarseToFineTable));
    t.method("MakeCoarseToFineTable", [](mfem::CoarseFineTransformations const& a, mfem::Table & arg0)->void { a.MakeCoarseToFineTable(arg0); });
    t.method("MakeCoarseToFineTable", [](mfem::CoarseFineTransformations const* a, mfem::Table & arg0)->void { a->MakeCoarseToFineTable(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::CoarseFineTransformations::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoarseFineTransformations::Clear()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:86:9
    t.method("Clear", static_cast<void (mfem::CoarseFineTransformations::*)() >(&mfem::CoarseFineTransformations::Clear));

    DEBUG_MSG("Adding wrapper for bool mfem::CoarseFineTransformations::IsInitialized() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::CoarseFineTransformations::IsInitialized()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:87:9
    t.method("IsInitialized", static_cast<bool (mfem::CoarseFineTransformations::*)()  const>(&mfem::CoarseFineTransformations::IsInitialized));

    DEBUG_MSG("Adding wrapper for long mfem::CoarseFineTransformations::MemoryUsage() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::CoarseFineTransformations::MemoryUsage()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:88:9
    t.method("MemoryUsage", static_cast<long (mfem::CoarseFineTransformations::*)()  const>(&mfem::CoarseFineTransformations::MemoryUsage));

    DEBUG_MSG("Adding wrapper for void mfem::CoarseFineTransformations::GetCoarseToFineMap(const mfem::Mesh &, mfem::Table &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CoarseFineTransformations::GetCoarseToFineMap(const mfem::Mesh &, mfem::Table &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:91:9
    t.method("GetCoarseToFineMap", static_cast<void (mfem::CoarseFineTransformations::*)(const mfem::Mesh &, mfem::Table &)  const>(&mfem::CoarseFineTransformations::GetCoarseToFineMap));

    DEBUG_MSG("Adding embeddings methods  to provide read access to the field embeddings (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:74:21
    // signature to use in the veto list: mfem::CoarseFineTransformations::embeddings
    t.method("embeddings", [](const mfem::CoarseFineTransformations& a) -> const mfem::Array<mfem::Embedding>& { return a.embeddings; });
    t.method("embeddings", [](mfem::CoarseFineTransformations& a) -> mfem::Array<mfem::Embedding>& { return a.embeddings; });
    t.method("embeddings", [](const mfem::CoarseFineTransformations* a) -> const mfem::Array<mfem::Embedding>& { return a->embeddings; });
    t.method("embeddings", [](mfem::CoarseFineTransformations* a) -> mfem::Array<mfem::Embedding>& { return a->embeddings; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:74:21
    // signature to use in the veto list: mfem::CoarseFineTransformations::embeddings
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding embeddings! methods to provide write access to the field embeddings (" __HERE__ ")");
    t.method("embeddings!", [](mfem::CoarseFineTransformations& a, const mfem::Array<mfem::Embedding>& val) -> mfem::Array<mfem::Embedding>& { return a.embeddings = val; });

    DEBUG_MSG("Adding embeddings! methods to provide write access to the field embeddings (" __HERE__ ")");
    t.method("embeddings!", [](mfem::CoarseFineTransformations* a, const mfem::Array<mfem::Embedding>& val) -> mfem::Array<mfem::Embedding>& { return a->embeddings = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CoarseFineTransformations>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CoarseFineTransformations(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CoarseFineTransformations(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Table> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Table> : std::false_type { };
}

// Class generating the wrapper for type mfem::Table
// signature to use in the veto file: mfem::Table
struct Jlmfem_Table: public Wrapper {

  Jlmfem_Table(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Table (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../general/table.hpp:43:7
    jlcxx::TypeWrapper<mfem::Table>  t = jlModule.add_type<mfem::Table>("mfem!Table");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Table>>(new jlcxx::TypeWrapper<mfem::Table>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Table>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Table(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Table(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh> : std::false_type { };
}

// Class generating the wrapper for type mfem::Mesh
// signature to use in the veto file: mfem::Mesh
struct Jlmfem_Mesh: public Wrapper {

  Jlmfem_Mesh(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:53:7
    jlcxx::TypeWrapper<mfem::Mesh>  t = jlModule.add_type<mfem::Mesh>("mfem!Mesh");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh>>(new jlcxx::TypeWrapper<mfem::Mesh>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(const mfem::Mesh &, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:631:13
    t.constructor<const mfem::Mesh &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::Mesh &, bool>(/*finalize=*/jlcxx::finalize_policy::yes);




    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:652:4
    t.constructor<double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<double *, int, int *, mfem::Geometry::Type, int *, int, int *, mfem::Geometry::Type, int *, int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, int, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:667:4
    t.constructor<int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(const std::string &, int, int, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:676:13
    t.constructor<const std::string &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const std::string &, int, int, bool>(/*finalize=*/jlcxx::finalize_policy::yes);


    // DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(Mesh *[], int) (" __HERE__ ")");
    // // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:688:4
    // t.constructor<Mesh *[], int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Swap(mfem::Mesh &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Swap(mfem::Mesh &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:705:9
    t.method("Swap", static_cast<void (mfem::Mesh::*)(mfem::Mesh &, bool) >(&mfem::Mesh::Swap));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Clear() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Clear()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:708:9
    t.method("Clear", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::Clear));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::LoadFromFile(const std::string &, int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::LoadFromFile(const std::string &, int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:730:16
    module_.method("mfem!Mesh!LoadFromFile", static_cast<mfem::Mesh (*)(const std::string &, int, int, bool) >(&mfem::Mesh::LoadFromFile));
    module_.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0)->mfem::Mesh { return mfem::Mesh::LoadFromFile(arg0); });
    module_.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0, int arg1)->mfem::Mesh { return mfem::Mesh::LoadFromFile(arg0, arg1); });
    module_.method("mfem!Mesh!LoadFromFile", [](const std::string & arg0, int arg1, int arg2)->mfem::Mesh { return mfem::Mesh::LoadFromFile(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian1D(int, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian1D(int, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:735:16
    module_.method("mfem!Mesh!MakeCartesian1D", static_cast<mfem::Mesh (*)(int, double) >(&mfem::Mesh::MakeCartesian1D));
    module_.method("mfem!Mesh!MakeCartesian1D", [](int arg0)->mfem::Mesh { return mfem::Mesh::MakeCartesian1D(arg0); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian2D(int, int, mfem::Element::Type, bool, double, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian2D(int, int, mfem::Element::Type, bool, double, double, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:745:16
    module_.method("mfem!Mesh!MakeCartesian2D", static_cast<mfem::Mesh (*)(int, int, mfem::Element::Type, bool, double, double, bool) >(&mfem::Mesh::MakeCartesian2D));
    module_.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2)->mfem::Mesh { return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2); });
    module_.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3)->mfem::Mesh { return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3); });
    module_.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3, double arg4)->mfem::Mesh { return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3, arg4); });
    module_.method("mfem!Mesh!MakeCartesian2D", [](int arg0, int arg1, mfem::Element::Type arg2, bool arg3, double arg4, double arg5)->mfem::Mesh { return mfem::Mesh::MakeCartesian2D(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian3D(int, int, int, mfem::Element::Type, double, double, double, bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian3D(int, int, int, mfem::Element::Type, double, double, double, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:756:16
    module_.method("mfem!Mesh!MakeCartesian3D", static_cast<mfem::Mesh (*)(int, int, int, mfem::Element::Type, double, double, double, bool) >(&mfem::Mesh::MakeCartesian3D));
    module_.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3)->mfem::Mesh { return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3); });
    module_.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4)->mfem::Mesh { return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4); });
    module_.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4, double arg5)->mfem::Mesh { return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4, arg5); });
    module_.method("mfem!Mesh!MakeCartesian3D", [](int arg0, int arg1, int arg2, mfem::Element::Type arg3, double arg4, double arg5, double arg6)->mfem::Mesh { return mfem::Mesh::MakeCartesian3D(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian3DWith24TetsPerHex(int, int, int, double, double, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian3DWith24TetsPerHex(int, int, int, double, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:768:16
    module_.method("mfem!Mesh!MakeCartesian3DWith24TetsPerHex", static_cast<mfem::Mesh (*)(int, int, int, double, double, double) >(&mfem::Mesh::MakeCartesian3DWith24TetsPerHex));
    module_.method("mfem!Mesh!MakeCartesian3DWith24TetsPerHex", [](int arg0, int arg1, int arg2)->mfem::Mesh { return mfem::Mesh::MakeCartesian3DWith24TetsPerHex(arg0, arg1, arg2); });
    module_.method("mfem!Mesh!MakeCartesian3DWith24TetsPerHex", [](int arg0, int arg1, int arg2, double arg3)->mfem::Mesh { return mfem::Mesh::MakeCartesian3DWith24TetsPerHex(arg0, arg1, arg2, arg3); });
    module_.method("mfem!Mesh!MakeCartesian3DWith24TetsPerHex", [](int arg0, int arg1, int arg2, double arg3, double arg4)->mfem::Mesh { return mfem::Mesh::MakeCartesian3DWith24TetsPerHex(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian2DWith4TrisPerQuad(int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian2DWith4TrisPerQuad(int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:778:16
    module_.method("mfem!Mesh!MakeCartesian2DWith4TrisPerQuad", static_cast<mfem::Mesh (*)(int, int, double, double) >(&mfem::Mesh::MakeCartesian2DWith4TrisPerQuad));
    module_.method("mfem!Mesh!MakeCartesian2DWith4TrisPerQuad", [](int arg0, int arg1)->mfem::Mesh { return mfem::Mesh::MakeCartesian2DWith4TrisPerQuad(arg0, arg1); });
    module_.method("mfem!Mesh!MakeCartesian2DWith4TrisPerQuad", [](int arg0, int arg1, double arg2)->mfem::Mesh { return mfem::Mesh::MakeCartesian2DWith4TrisPerQuad(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad(int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad(int, int, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:787:16
    module_.method("mfem!Mesh!MakeCartesian2DWith5QuadsPerQuad", static_cast<mfem::Mesh (*)(int, int, double, double) >(&mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad));
    module_.method("mfem!Mesh!MakeCartesian2DWith5QuadsPerQuad", [](int arg0, int arg1)->mfem::Mesh { return mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad(arg0, arg1); });
    module_.method("mfem!Mesh!MakeCartesian2DWith5QuadsPerQuad", [](int arg0, int arg1, double arg2)->mfem::Mesh { return mfem::Mesh::MakeCartesian2DWith5QuadsPerQuad(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:802:16
    module_.method("mfem!Mesh!MakeRefined", static_cast<mfem::Mesh (*)(mfem::Mesh &, int, int) >(&mfem::Mesh::MakeRefined));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, const mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeRefined(mfem::Mesh &, const mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:820:16
    module_.method("mfem!Mesh!MakeRefined", static_cast<mfem::Mesh (*)(mfem::Mesh &, const mfem::Array<int> &, int) >(&mfem::Mesh::MakeRefined));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakeSimplicial(const mfem::Mesh &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakeSimplicial(const mfem::Mesh &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:829:16
    module_.method("mfem!Mesh!MakeSimplicial", static_cast<mfem::Mesh (*)(const mfem::Mesh &) >(&mfem::Mesh::MakeSimplicial));

    DEBUG_MSG("Adding wrapper for mfem::Mesh mfem::Mesh::MakePeriodic(const mfem::Mesh &, const std::vector<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh mfem::Mesh::MakePeriodic(const mfem::Mesh &, const std::vector<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:839:16
    module_.method("mfem!Mesh!MakePeriodic", static_cast<mfem::Mesh (*)(const mfem::Mesh &, const std::vector<int> &) >(&mfem::Mesh::MakePeriodic));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::NewElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::NewElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:851:13
    t.method("NewElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::NewElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(double, double, double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(double, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:853:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(double, double, double) >(&mfem::Mesh::AddVertex));
    t.method("AddVertex", [](mfem::Mesh& a, double arg0)->int { return a.AddVertex(arg0); });
    t.method("AddVertex", [](mfem::Mesh& a, double arg0, double arg1)->int { return a.AddVertex(arg0, arg1); });
    t.method("AddVertex", [](mfem::Mesh* a, double arg0)->int { return a->AddVertex(arg0); });
    t.method("AddVertex", [](mfem::Mesh* a, double arg0, double arg1)->int { return a->AddVertex(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(const double *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:854:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(const double *) >(&mfem::Mesh::AddVertex));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertex(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertex(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:855:8
    t.method("AddVertex", static_cast<int (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::AddVertex));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddVertexParents(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddVertexParents(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:857:9
    t.method("AddVertexParents", static_cast<void (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddVertexParents));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddVertexAtMeanCenter(const int *, const int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddVertexAtMeanCenter(const int *, const int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:860:8
    t.method("AddVertexAtMeanCenter", static_cast<int (mfem::Mesh::*)(const int *, const int, int) >(&mfem::Mesh::AddVertexAtMeanCenter));
    t.method("AddVertexAtMeanCenter", [](mfem::Mesh& a, const int * arg0, const int arg1)->int { return a.AddVertexAtMeanCenter(arg0, arg1); });
    t.method("AddVertexAtMeanCenter", [](mfem::Mesh* a, const int * arg0, const int arg1)->int { return a->AddVertexAtMeanCenter(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddSegment(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddSegment(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:863:8
    t.method("AddSegment", static_cast<int (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddSegment));
    t.method("AddSegment", [](mfem::Mesh& a, int arg0, int arg1)->int { return a.AddSegment(arg0, arg1); });
    t.method("AddSegment", [](mfem::Mesh* a, int arg0, int arg1)->int { return a->AddSegment(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddSegment(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddSegment(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:865:8
    t.method("AddSegment", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddSegment));
    t.method("AddSegment", [](mfem::Mesh& a, const int * arg0)->int { return a.AddSegment(arg0); });
    t.method("AddSegment", [](mfem::Mesh* a, const int * arg0)->int { return a->AddSegment(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTriangle(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTriangle(int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:868:8
    t.method("AddTriangle", static_cast<int (mfem::Mesh::*)(int, int, int, int) >(&mfem::Mesh::AddTriangle));
    t.method("AddTriangle", [](mfem::Mesh& a, int arg0, int arg1, int arg2)->int { return a.AddTriangle(arg0, arg1, arg2); });
    t.method("AddTriangle", [](mfem::Mesh* a, int arg0, int arg1, int arg2)->int { return a->AddTriangle(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTriangle(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTriangle(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:870:8
    t.method("AddTriangle", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTriangle));
    t.method("AddTriangle", [](mfem::Mesh& a, const int * arg0)->int { return a.AddTriangle(arg0); });
    t.method("AddTriangle", [](mfem::Mesh* a, const int * arg0)->int { return a->AddTriangle(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTri(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTri(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:872:8
    t.method("AddTri", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTri));
    t.method("AddTri", [](mfem::Mesh& a, const int * arg0)->int { return a.AddTri(arg0); });
    t.method("AddTri", [](mfem::Mesh* a, const int * arg0)->int { return a->AddTri(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddQuad(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddQuad(int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:875:8
    t.method("AddQuad", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddQuad));
    t.method("AddQuad", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int { return a.AddQuad(arg0, arg1, arg2, arg3); });
    t.method("AddQuad", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int { return a->AddQuad(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddQuad(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddQuad(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:877:8
    t.method("AddQuad", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddQuad));
    t.method("AddQuad", [](mfem::Mesh& a, const int * arg0)->int { return a.AddQuad(arg0); });
    t.method("AddQuad", [](mfem::Mesh* a, const int * arg0)->int { return a->AddQuad(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTet(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTet(int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:880:8
    t.method("AddTet", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddTet));
    t.method("AddTet", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int { return a.AddTet(arg0, arg1, arg2, arg3); });
    t.method("AddTet", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int { return a->AddTet(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddTet(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddTet(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:882:8
    t.method("AddTet", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddTet));
    t.method("AddTet", [](mfem::Mesh& a, const int * arg0)->int { return a.AddTet(arg0); });
    t.method("AddTet", [](mfem::Mesh* a, const int * arg0)->int { return a->AddTet(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddWedge(int, int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddWedge(int, int, int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:885:8
    t.method("AddWedge", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int, int) >(&mfem::Mesh::AddWedge));
    t.method("AddWedge", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)->int { return a.AddWedge(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("AddWedge", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5)->int { return a->AddWedge(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddWedge(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddWedge(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:887:8
    t.method("AddWedge", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddWedge));
    t.method("AddWedge", [](mfem::Mesh& a, const int * arg0)->int { return a.AddWedge(arg0); });
    t.method("AddWedge", [](mfem::Mesh* a, const int * arg0)->int { return a->AddWedge(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddPyramid(int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddPyramid(int, int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:890:8
    t.method("AddPyramid", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int) >(&mfem::Mesh::AddPyramid));
    t.method("AddPyramid", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4)->int { return a.AddPyramid(arg0, arg1, arg2, arg3, arg4); });
    t.method("AddPyramid", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4)->int { return a->AddPyramid(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddPyramid(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddPyramid(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:892:8
    t.method("AddPyramid", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddPyramid));
    t.method("AddPyramid", [](mfem::Mesh& a, const int * arg0)->int { return a.AddPyramid(arg0); });
    t.method("AddPyramid", [](mfem::Mesh* a, const int * arg0)->int { return a->AddPyramid(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddHex(int, int, int, int, int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddHex(int, int, int, int, int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:895:8
    t.method("AddHex", static_cast<int (mfem::Mesh::*)(int, int, int, int, int, int, int, int, int) >(&mfem::Mesh::AddHex));
    t.method("AddHex", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7)->int { return a.AddHex(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });
    t.method("AddHex", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7)->int { return a->AddHex(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddHex(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddHex(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:898:8
    t.method("AddHex", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHex));
    t.method("AddHex", [](mfem::Mesh& a, const int * arg0)->int { return a.AddHex(arg0); });
    t.method("AddHex", [](mfem::Mesh* a, const int * arg0)->int { return a->AddHex(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsTets(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsTets(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:901:9
    t.method("AddHexAsTets", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsTets));
    t.method("AddHexAsTets", [](mfem::Mesh& a, const int * arg0)->void { a.AddHexAsTets(arg0); });
    t.method("AddHexAsTets", [](mfem::Mesh* a, const int * arg0)->void { a->AddHexAsTets(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsWedges(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsWedges(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:904:9
    t.method("AddHexAsWedges", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsWedges));
    t.method("AddHexAsWedges", [](mfem::Mesh& a, const int * arg0)->void { a.AddHexAsWedges(arg0); });
    t.method("AddHexAsWedges", [](mfem::Mesh* a, const int * arg0)->void { a->AddHexAsWedges(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddHexAsPyramids(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddHexAsPyramids(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:907:9
    t.method("AddHexAsPyramids", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddHexAsPyramids));
    t.method("AddHexAsPyramids", [](mfem::Mesh& a, const int * arg0)->void { a.AddHexAsPyramids(arg0); });
    t.method("AddHexAsPyramids", [](mfem::Mesh* a, const int * arg0)->void { a->AddHexAsPyramids(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddQuadAs4TrisWithPoints(int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddQuadAs4TrisWithPoints(int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:925:9
    t.method("AddQuadAs4TrisWithPoints", static_cast<void (mfem::Mesh::*)(int *, int) >(&mfem::Mesh::AddQuadAs4TrisWithPoints));
    t.method("AddQuadAs4TrisWithPoints", [](mfem::Mesh& a, int * arg0)->void { a.AddQuadAs4TrisWithPoints(arg0); });
    t.method("AddQuadAs4TrisWithPoints", [](mfem::Mesh* a, int * arg0)->void { a->AddQuadAs4TrisWithPoints(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddQuadAs5QuadsWithPoints(int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddQuadAs5QuadsWithPoints(int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:932:9
    t.method("AddQuadAs5QuadsWithPoints", static_cast<void (mfem::Mesh::*)(int *, int) >(&mfem::Mesh::AddQuadAs5QuadsWithPoints));
    t.method("AddQuadAs5QuadsWithPoints", [](mfem::Mesh& a, int * arg0)->void { a.AddQuadAs5QuadsWithPoints(arg0); });
    t.method("AddQuadAs5QuadsWithPoints", [](mfem::Mesh* a, int * arg0)->void { a->AddQuadAs5QuadsWithPoints(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddElement(mfem::Element *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddElement(mfem::Element *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:936:8
    t.method("AddElement", static_cast<int (mfem::Mesh::*)(mfem::Element *) >(&mfem::Mesh::AddElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrElement(mfem::Element *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrElement(mfem::Element *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:939:8
    t.method("AddBdrElement", static_cast<int (mfem::Mesh::*)(mfem::Element *) >(&mfem::Mesh::AddBdrElement));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrSegment(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrSegment(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:941:8
    t.method("AddBdrSegment", static_cast<int (mfem::Mesh::*)(int, int, int) >(&mfem::Mesh::AddBdrSegment));
    t.method("AddBdrSegment", [](mfem::Mesh& a, int arg0, int arg1)->int { return a.AddBdrSegment(arg0, arg1); });
    t.method("AddBdrSegment", [](mfem::Mesh* a, int arg0, int arg1)->int { return a->AddBdrSegment(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrSegment(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrSegment(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:942:8
    t.method("AddBdrSegment", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrSegment));
    t.method("AddBdrSegment", [](mfem::Mesh& a, const int * arg0)->int { return a.AddBdrSegment(arg0); });
    t.method("AddBdrSegment", [](mfem::Mesh* a, const int * arg0)->int { return a->AddBdrSegment(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrTriangle(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrTriangle(int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:944:8
    t.method("AddBdrTriangle", static_cast<int (mfem::Mesh::*)(int, int, int, int) >(&mfem::Mesh::AddBdrTriangle));
    t.method("AddBdrTriangle", [](mfem::Mesh& a, int arg0, int arg1, int arg2)->int { return a.AddBdrTriangle(arg0, arg1, arg2); });
    t.method("AddBdrTriangle", [](mfem::Mesh* a, int arg0, int arg1, int arg2)->int { return a->AddBdrTriangle(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrTriangle(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrTriangle(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:945:8
    t.method("AddBdrTriangle", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrTriangle));
    t.method("AddBdrTriangle", [](mfem::Mesh& a, const int * arg0)->int { return a.AddBdrTriangle(arg0); });
    t.method("AddBdrTriangle", [](mfem::Mesh* a, const int * arg0)->int { return a->AddBdrTriangle(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrQuad(int, int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrQuad(int, int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:947:8
    t.method("AddBdrQuad", static_cast<int (mfem::Mesh::*)(int, int, int, int, int) >(&mfem::Mesh::AddBdrQuad));
    t.method("AddBdrQuad", [](mfem::Mesh& a, int arg0, int arg1, int arg2, int arg3)->int { return a.AddBdrQuad(arg0, arg1, arg2, arg3); });
    t.method("AddBdrQuad", [](mfem::Mesh* a, int arg0, int arg1, int arg2, int arg3)->int { return a->AddBdrQuad(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrQuad(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrQuad(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:948:8
    t.method("AddBdrQuad", static_cast<int (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrQuad));
    t.method("AddBdrQuad", [](mfem::Mesh& a, const int * arg0)->int { return a.AddBdrQuad(arg0); });
    t.method("AddBdrQuad", [](mfem::Mesh* a, const int * arg0)->int { return a->AddBdrQuad(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::AddBdrQuadAsTriangles(const int *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::AddBdrQuadAsTriangles(const int *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:949:9
    t.method("AddBdrQuadAsTriangles", static_cast<void (mfem::Mesh::*)(const int *, int) >(&mfem::Mesh::AddBdrQuadAsTriangles));
    t.method("AddBdrQuadAsTriangles", [](mfem::Mesh& a, const int * arg0)->void { a.AddBdrQuadAsTriangles(arg0); });
    t.method("AddBdrQuadAsTriangles", [](mfem::Mesh* a, const int * arg0)->void { a->AddBdrQuadAsTriangles(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::AddBdrPoint(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::AddBdrPoint(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:951:8
    t.method("AddBdrPoint", static_cast<int (mfem::Mesh::*)(int, int) >(&mfem::Mesh::AddBdrPoint));
    t.method("AddBdrPoint", [](mfem::Mesh& a, int arg0)->int { return a.AddBdrPoint(arg0); });
    t.method("AddBdrPoint", [](mfem::Mesh* a, int arg0)->int { return a->AddBdrPoint(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GenerateBoundaryElements() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GenerateBoundaryElements()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:953:9
    t.method("GenerateBoundaryElements", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::GenerateBoundaryElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTriMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTriMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:955:9
    t.method("FinalizeTriMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeTriMesh));
    t.method("FinalizeTriMesh", [](mfem::Mesh& a)->void { a.FinalizeTriMesh(); });
    t.method("FinalizeTriMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeTriMesh(arg0); });
    t.method("FinalizeTriMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeTriMesh(arg0, arg1); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a)->void { a->FinalizeTriMesh(); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeTriMesh(arg0); });
    t.method("FinalizeTriMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeTriMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeQuadMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeQuadMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:958:9
    t.method("FinalizeQuadMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeQuadMesh));
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a)->void { a.FinalizeQuadMesh(); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeQuadMesh(arg0); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeQuadMesh(arg0, arg1); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a)->void { a->FinalizeQuadMesh(); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeQuadMesh(arg0); });
    t.method("FinalizeQuadMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeQuadMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTetMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTetMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:961:9
    t.method("FinalizeTetMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeTetMesh));
    t.method("FinalizeTetMesh", [](mfem::Mesh& a)->void { a.FinalizeTetMesh(); });
    t.method("FinalizeTetMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeTetMesh(arg0); });
    t.method("FinalizeTetMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeTetMesh(arg0, arg1); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a)->void { a->FinalizeTetMesh(); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeTetMesh(arg0); });
    t.method("FinalizeTetMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeTetMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeWedgeMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeWedgeMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:964:9
    t.method("FinalizeWedgeMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeWedgeMesh));
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a)->void { a.FinalizeWedgeMesh(); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeWedgeMesh(arg0); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeWedgeMesh(arg0, arg1); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a)->void { a->FinalizeWedgeMesh(); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeWedgeMesh(arg0); });
    t.method("FinalizeWedgeMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeWedgeMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeHexMesh(int, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeHexMesh(int, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:967:9
    t.method("FinalizeHexMesh", static_cast<void (mfem::Mesh::*)(int, int, bool) >(&mfem::Mesh::FinalizeHexMesh));
    t.method("FinalizeHexMesh", [](mfem::Mesh& a)->void { a.FinalizeHexMesh(); });
    t.method("FinalizeHexMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeHexMesh(arg0); });
    t.method("FinalizeHexMesh", [](mfem::Mesh& a, int arg0, int arg1)->void { a.FinalizeHexMesh(arg0, arg1); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a)->void { a->FinalizeHexMesh(); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeHexMesh(arg0); });
    t.method("FinalizeHexMesh", [](mfem::Mesh* a, int arg0, int arg1)->void { a->FinalizeHexMesh(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeMesh(int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeMesh(int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:971:9
    t.method("FinalizeMesh", static_cast<void (mfem::Mesh::*)(int, bool) >(&mfem::Mesh::FinalizeMesh));
    t.method("FinalizeMesh", [](mfem::Mesh& a)->void { a.FinalizeMesh(); });
    t.method("FinalizeMesh", [](mfem::Mesh& a, int arg0)->void { a.FinalizeMesh(arg0); });
    t.method("FinalizeMesh", [](mfem::Mesh* a)->void { a->FinalizeMesh(); });
    t.method("FinalizeMesh", [](mfem::Mesh* a, int arg0)->void { a->FinalizeMesh(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::FinalizeTopology(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::FinalizeTopology(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:987:9
    t.method("FinalizeTopology", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::FinalizeTopology));
    t.method("FinalizeTopology", [](mfem::Mesh& a)->void { a.FinalizeTopology(); });
    t.method("FinalizeTopology", [](mfem::Mesh* a)->void { a->FinalizeTopology(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Finalize(bool, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Finalize(bool, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1003:17
    t.method("Finalize", static_cast<void (mfem::Mesh::*)(bool, bool) >(&mfem::Mesh::Finalize));
    t.method("Finalize", [](mfem::Mesh& a)->void { a.Finalize(); });
    t.method("Finalize", [](mfem::Mesh& a, bool arg0)->void { a.Finalize(arg0); });
    t.method("Finalize", [](mfem::Mesh* a)->void { a->Finalize(); });
    t.method("Finalize", [](mfem::Mesh* a, bool arg0)->void { a->Finalize(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetAttributes() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetAttributes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1011:17
    t.method("SetAttributes", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::SetAttributes));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::CheckElementOrientation(bool) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::CheckElementOrientation(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1027:8
    t.method("CheckElementOrientation", static_cast<int (mfem::Mesh::*)(bool) >(&mfem::Mesh::CheckElementOrientation));
    t.method("CheckElementOrientation", [](mfem::Mesh& a)->int { return a.CheckElementOrientation(); });
    t.method("CheckElementOrientation", [](mfem::Mesh* a)->int { return a->CheckElementOrientation(); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::CheckBdrElementOrientation(bool) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::CheckBdrElementOrientation(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1031:8
    t.method("CheckBdrElementOrientation", static_cast<int (mfem::Mesh::*)(bool) >(&mfem::Mesh::CheckBdrElementOrientation));
    t.method("CheckBdrElementOrientation", [](mfem::Mesh& a)->int { return a.CheckBdrElementOrientation(); });
    t.method("CheckBdrElementOrientation", [](mfem::Mesh* a)->int { return a->CheckBdrElementOrientation(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ReorientTetMesh() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ReorientTetMesh()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1041:33
    t.method("ReorientTetMesh", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::ReorientTetMesh));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RemoveUnusedVertices() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RemoveUnusedVertices()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1044:9
    t.method("RemoveUnusedVertices", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::RemoveUnusedVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RemoveInternalBoundaries() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RemoveInternalBoundaries()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1048:9
    t.method("RemoveInternalBoundaries", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::RemoveInternalBoundaries));

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetGeckoElementOrdering(mfem::Array<int> &, int, int, int, int, bool, double) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetGeckoElementOrdering(mfem::Array<int> &, int, int, int, int, bool, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1074:11
    t.method("GetGeckoElementOrdering", static_cast<double (mfem::Mesh::*)(mfem::Array<int> &, int, int, int, int, bool, double) >(&mfem::Mesh::GetGeckoElementOrdering));
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0)->double { return a.GetGeckoElementOrdering(arg0); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1)->double { return a.GetGeckoElementOrdering(arg0, arg1); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1, int arg2)->double { return a.GetGeckoElementOrdering(arg0, arg1, arg2); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3)->double { return a.GetGeckoElementOrdering(arg0, arg1, arg2, arg3); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3, int arg4)->double { return a.GetGeckoElementOrdering(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh& a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3, int arg4, bool arg5)->double { return a.GetGeckoElementOrdering(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0)->double { return a->GetGeckoElementOrdering(arg0); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1)->double { return a->GetGeckoElementOrdering(arg0, arg1); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1, int arg2)->double { return a->GetGeckoElementOrdering(arg0, arg1, arg2); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3)->double { return a->GetGeckoElementOrdering(arg0, arg1, arg2, arg3); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3, int arg4)->double { return a->GetGeckoElementOrdering(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetGeckoElementOrdering", [](mfem::Mesh* a, mfem::Array<int> & arg0, int arg1, int arg2, int arg3, int arg4, bool arg5)->double { return a->GetGeckoElementOrdering(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetHilbertElementOrdering(mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetHilbertElementOrdering(mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1083:9
    t.method("GetHilbertElementOrdering", static_cast<void (mfem::Mesh::*)(mfem::Array<int> &) >(&mfem::Mesh::GetHilbertElementOrdering));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ReorderElements(const mfem::Array<int> &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ReorderElements(const mfem::Array<int> &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1088:9
    t.method("ReorderElements", static_cast<void (mfem::Mesh::*)(const mfem::Array<int> &, bool) >(&mfem::Mesh::ReorderElements));
    t.method("ReorderElements", [](mfem::Mesh& a, const mfem::Array<int> & arg0)->void { a.ReorderElements(arg0); });
    t.method("ReorderElements", [](mfem::Mesh* a, const mfem::Array<int> & arg0)->void { a->ReorderElements(arg0); });


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, int, mfem::Element::Type, bool, double, double, double, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1100:4
    t.constructor<int, int, int, mfem::Element::Type>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, int, mfem::Element::Type, bool, double, double, double, bool>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, int, mfem::Element::Type, bool, double, double, bool) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1110:4
    t.constructor<int, int, mfem::Element::Type>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, mfem::Element::Type, bool>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, mfem::Element::Type, bool, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, mfem::Element::Type, bool, double, double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, int, mfem::Element::Type, bool, double, double, bool>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(int, double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1119:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<int, double>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Mesh(mfem::Mesh *, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1127:4
    t.constructor<mfem::Mesh *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::Dimension() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::Dimension()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1135:8
    t.method("Dimension", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::Dimension));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::SpaceDimension() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::SpaceDimension()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1138:8
    t.method("SpaceDimension", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::SpaceDimension));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::EulerNumber() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::EulerNumber()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1141:15
    t.method("EulerNumber", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::EulerNumber));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::EulerNumber2D() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::EulerNumber2D()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1144:15
    t.method("EulerNumber2D", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::EulerNumber2D));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::MeshGenerator() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::MeshGenerator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1162:15
    t.method("MeshGenerator", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::MeshGenerator));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::HasBoundaryElements() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::HasBoundaryElements()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1165:17
    t.method("HasBoundaryElements", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::HasBoundaryElements));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::HasGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::HasGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1169:9
    t.method("HasGeometry", static_cast<bool (mfem::Mesh::*)(mfem::Geometry::Type)  const>(&mfem::Mesh::HasGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumGeometries(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumGeometries(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1175:8
    t.method("GetNumGeometries", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetNumGeometries));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetGeometries(int, mfem::Array<mfem::Geometry::Type> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetGeometries(int, mfem::Array<mfem::Geometry::Type> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1181:9
    t.method("GetGeometries", static_cast<void (mfem::Mesh::*)(int, mfem::Array<mfem::Geometry::Type> &)  const>(&mfem::Mesh::GetGeometries));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBoundingBox(mfem::Vector &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBoundingBox(mfem::Vector &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1185:9
    t.method("GetBoundingBox", static_cast<void (mfem::Mesh::*)(mfem::Vector &, mfem::Vector &, int) >(&mfem::Mesh::GetBoundingBox));
    t.method("GetBoundingBox", [](mfem::Mesh& a, mfem::Vector & arg0, mfem::Vector & arg1)->void { a.GetBoundingBox(arg0, arg1); });
    t.method("GetBoundingBox", [](mfem::Mesh* a, mfem::Vector & arg0, mfem::Vector & arg1)->void { a->GetBoundingBox(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetCharacteristics(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetCharacteristics(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1187:9
    t.method("GetCharacteristics", static_cast<void (mfem::Mesh::*)(double &, double &, double &, double &, mfem::Vector *, mfem::Vector *) >(&mfem::Mesh::GetCharacteristics));
    t.method("GetCharacteristics", [](mfem::Mesh& a, double & arg0, double & arg1, double & arg2, double & arg3)->void { a.GetCharacteristics(arg0, arg1, arg2, arg3); });
    t.method("GetCharacteristics", [](mfem::Mesh& a, double & arg0, double & arg1, double & arg2, double & arg3, mfem::Vector * arg4)->void { a.GetCharacteristics(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetCharacteristics", [](mfem::Mesh* a, double & arg0, double & arg1, double & arg2, double & arg3)->void { a->GetCharacteristics(arg0, arg1, arg2, arg3); });
    t.method("GetCharacteristics", [](mfem::Mesh* a, double & arg0, double & arg1, double & arg2, double & arg3, mfem::Vector * arg4)->void { a->GetCharacteristics(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNV()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1198:15
    t.method("GetNV", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNV));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1201:15
    t.method("GetNE", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNE));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNBE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNBE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1204:15
    t.method("GetNBE", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNBE));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNEdges() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNEdges()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1207:15
    t.method("GetNEdges", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNEdges));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNFaces() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNFaces()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1210:15
    t.method("GetNFaces", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNFaces));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumFaces() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumFaces()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1213:8
    t.method("GetNumFaces", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNumFaces));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNumFacesWithGhost() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNumFacesWithGhost()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1217:8
    t.method("GetNumFacesWithGhost", static_cast<int (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNumFacesWithGhost));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetNFbyType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetNFbyType(mfem::FaceType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1227:16
    t.method("GetNFbyType", static_cast<int (mfem::Mesh::*)(mfem::FaceType)  const>(&mfem::Mesh::GetNFbyType));

    DEBUG_MSG("Adding wrapper for long long mfem::Mesh::GetGlobalNE() (" __HERE__ ")");
    // signature to use in the veto list: long long mfem::Mesh::GetGlobalNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1230:14
    t.method("GetGlobalNE", static_cast<long long (mfem::Mesh::*)()  const>(&mfem::Mesh::GetGlobalNE));

    DEBUG_MSG("Adding wrapper for const double * mfem::Mesh::GetVertex(int) (" __HERE__ ")");
    // signature to use in the veto list: const double * mfem::Mesh::GetVertex(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1240:18
    t.method("GetVertex", static_cast<const double * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetVertex));

    DEBUG_MSG("Adding wrapper for double * mfem::Mesh::GetVertex(int) (" __HERE__ ")");
    // signature to use in the veto list: double * mfem::Mesh::GetVertex(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1250:12
    t.method("GetVertex", static_cast<double * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetVertex));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1258:19
    t.method("GetElement", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElement));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::GetElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::GetElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1265:13
    t.method("GetElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElement));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetBdrElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetBdrElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1273:19
    t.method("GetBdrElement", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElement));

    DEBUG_MSG("Adding wrapper for mfem::Element * mfem::Mesh::GetBdrElement(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element * mfem::Mesh::GetBdrElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1280:13
    t.method("GetBdrElement", static_cast<mfem::Element * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrElement));

    DEBUG_MSG("Adding wrapper for const mfem::Element * mfem::Mesh::GetFace(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element * mfem::Mesh::GetFace(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1285:19
    t.method("GetFace", static_cast<const mfem::Element * (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFace));

    DEBUG_MSG("Adding wrapper for const mfem::Element *const * mfem::Mesh::GetElementsArray() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Element *const * mfem::Mesh::GetElementsArray()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1292:26
    t.method("GetElementsArray", static_cast<const mfem::Element *const * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetElementsArray));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementData(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementData(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1295:9
    t.method("GetElementData", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetElementData));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementData(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementData(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1298:9
    t.method("GetBdrElementData", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetBdrElementData));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1308:8
    t.method("GetAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1311:9
    t.method("SetAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1314:8
    t.method("GetBdrAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetBdrAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetBdrAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1317:9
    t.method("SetBdrAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetBdrAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetPatchAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetPatchAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1320:8
    t.method("GetPatchAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetPatchAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetPatchAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetPatchAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1323:9
    t.method("SetPatchAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetPatchAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetPatchBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetPatchBdrAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1326:8
    t.method("GetPatchBdrAttribute", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetPatchBdrAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetPatchBdrAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetPatchBdrAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1329:9
    t.method("SetPatchBdrAttribute", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::SetPatchBdrAttribute));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1332:18
    t.method("GetElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementType));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetBdrElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetBdrElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1335:18
    t.method("GetBdrElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementType));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceGeometryType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceGeometryType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1338:35
    t.method("GetFaceGeometryType", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceGeometryType));

    DEBUG_MSG("Adding wrapper for mfem::Element::Type mfem::Mesh::GetFaceElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Element::Type mfem::Mesh::GetFaceElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1341:19
    t.method("GetFaceElementType", static_cast<mfem::Element::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceElementType));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1344:19
    t.method("GetFaceGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetElementGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetElementGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1346:19
    t.method("GetElementGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetBdrElementGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetBdrElementGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1351:19
    t.method("GetBdrElementGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetFaceBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetFaceBaseGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1357:35
    t.method("GetFaceBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceBaseGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetElementBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetElementBaseGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1360:19
    t.method("GetElementBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetElementBaseGeometry));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::Mesh::GetBdrElementBaseGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::Mesh::GetBdrElementBaseGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1363:19
    t.method("GetBdrElementBaseGeometry", static_cast<mfem::Geometry::Type (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementBaseGeometry));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceIsInterior(int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceIsInterior(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1367:9
    t.method("FaceIsInterior", static_cast<bool (mfem::Mesh::*)(int)  const>(&mfem::Mesh::FaceIsInterior));

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementSize(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementSize(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1374:11
    t.method("GetElementSize", static_cast<double (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GetElementSize));
    t.method("GetElementSize", [](mfem::Mesh& a, int arg0)->double { return a.GetElementSize(arg0); });
    t.method("GetElementSize", [](mfem::Mesh* a, int arg0)->double { return a->GetElementSize(arg0); });

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementSize(int, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementSize(int, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1376:11
    t.method("GetElementSize", static_cast<double (mfem::Mesh::*)(int, const mfem::Vector &) >(&mfem::Mesh::GetElementSize));

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementSize(mfem::ElementTransformation *, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementSize(mfem::ElementTransformation *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1378:11
    t.method("GetElementSize", static_cast<double (mfem::Mesh::*)(mfem::ElementTransformation *, int)  const>(&mfem::Mesh::GetElementSize));
    t.method("GetElementSize", [](mfem::Mesh const& a, mfem::ElementTransformation * arg0)->double { return a.GetElementSize(arg0); });
    t.method("GetElementSize", [](mfem::Mesh const* a, mfem::ElementTransformation * arg0)->double { return a->GetElementSize(arg0); });

    DEBUG_MSG("Adding wrapper for double mfem::Mesh::GetElementVolume(int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Mesh::GetElementVolume(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1380:11
    t.method("GetElementVolume", static_cast<double (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElementVolume));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementCenter(int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementCenter(int, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1382:9
    t.method("GetElementCenter", static_cast<void (mfem::Mesh::*)(int, mfem::Vector &) >(&mfem::Mesh::GetElementCenter));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementJacobian(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementJacobian(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1387:9
    t.method("GetElementJacobian", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &, const mfem::IntegrationPoint *) >(&mfem::Mesh::GetElementJacobian));
    t.method("GetElementJacobian", [](mfem::Mesh& a, int arg0, mfem::DenseMatrix & arg1)->void { a.GetElementJacobian(arg0, arg1); });
    t.method("GetElementJacobian", [](mfem::Mesh* a, int arg0, mfem::DenseMatrix & arg1)->void { a->GetElementJacobian(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1413:9
    t.method("GetElementVertices", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &)  const>(&mfem::Mesh::GetElementVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1417:9
    t.method("GetBdrElementVertices", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &)  const>(&mfem::Mesh::GetBdrElementVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementEdges(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementEdges(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1421:9
    t.method("GetElementEdges", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetElementEdges));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementEdges(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementEdges(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1424:9
    t.method("GetBdrElementEdges", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetBdrElementEdges));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceEdges(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceEdges(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1428:9
    t.method("GetFaceEdges", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetFaceEdges));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1431:9
    t.method("GetFaceVertices", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &)  const>(&mfem::Mesh::GetFaceVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetEdgeVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetEdgeVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1444:9
    t.method("GetEdgeVertices", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &)  const>(&mfem::Mesh::GetEdgeVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementFaces(int, mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementFaces(int, mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1447:9
    t.method("GetElementFaces", static_cast<void (mfem::Mesh::*)(int, mfem::Array<int> &, mfem::Array<int> &)  const>(&mfem::Mesh::GetElementFaces));

    DEBUG_MSG("Adding wrapper for mfem::Array<int> mfem::Mesh::FindFaceNeighbors(const int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<int> mfem::Mesh::FindFaceNeighbors(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1451:15
    t.method("FindFaceNeighbors", static_cast<mfem::Array<int> (mfem::Mesh::*)(const int)  const>(&mfem::Mesh::FindFaceNeighbors));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementFace(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementFace(int, int *, int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1459:9
    t.method("GetBdrElementFace", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetBdrElementFace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementAdjacentElement(int, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementAdjacentElement(int, int &, int &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1468:9
    t.method("GetBdrElementAdjacentElement", static_cast<void (mfem::Mesh::*)(int, int &, int &)  const>(&mfem::Mesh::GetBdrElementAdjacentElement));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementAdjacentElement2(int, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementAdjacentElement2(int, int &, int &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1479:9
    t.method("GetBdrElementAdjacentElement2", static_cast<void (mfem::Mesh::*)(int, int &, int &)  const>(&mfem::Mesh::GetBdrElementAdjacentElement2));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrElementFaceIndex(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrElementFaceIndex(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1483:8
    t.method("GetBdrElementFaceIndex", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementFaceIndex));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrFace(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrFace(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1486:24
    t.method("GetBdrFace", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrFace));

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::GetBdrElementEdgeIndex(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::GetBdrElementEdgeIndex(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1493:24
    t.method("GetBdrElementEdgeIndex", static_cast<int (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetBdrElementEdgeIndex));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetVertexToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetVertexToElementTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1501:11
    t.method("GetVertexToElementTable", static_cast<mfem::Table * (mfem::Mesh::*)() >(&mfem::Mesh::GetVertexToElementTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetFaceToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetFaceToElementTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1507:11
    t.method("GetFaceToElementTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetFaceToElementTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetFaceEdgeTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetFaceEdgeTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1512:11
    t.method("GetFaceEdgeTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetFaceEdgeTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::Mesh::GetEdgeVertexTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::Mesh::GetEdgeVertexTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1517:11
    t.method("GetEdgeVertexTable", static_cast<mfem::Table * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetEdgeVertexTable));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetVertexToVertexTable(mfem::DSTable &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetVertexToVertexTable(mfem::DSTable &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1527:9
    t.method("GetVertexToVertexTable", static_cast<void (mfem::Mesh::*)(mfem::DSTable &)  const>(&mfem::Mesh::GetVertexToVertexTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToElementTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToElementTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1529:17
    t.method("ElementToElementTable", static_cast<const mfem::Table & (mfem::Mesh::*)() >(&mfem::Mesh::ElementToElementTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToFaceTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToFaceTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1531:17
    t.method("ElementToFaceTable", static_cast<const mfem::Table & (mfem::Mesh::*)()  const>(&mfem::Mesh::ElementToFaceTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::Mesh::ElementToEdgeTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::Mesh::ElementToEdgeTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1533:17
    t.method("ElementToEdgeTable", static_cast<const mfem::Table & (mfem::Mesh::*)()  const>(&mfem::Mesh::ElementToEdgeTable));

    DEBUG_MSG("Adding wrapper for mfem::Array<int> mfem::Mesh::GetFaceToBdrElMap() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<int> mfem::Mesh::GetFaceToBdrElMap()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1535:15
    t.method("GetFaceToBdrElMap", static_cast<mfem::Array<int> (mfem::Mesh::*)()  const>(&mfem::Mesh::GetFaceToBdrElMap));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElement * mfem::Mesh::GetTransformationFEforElementType(mfem::Element::Type) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElement * mfem::Mesh::GetTransformationFEforElementType(mfem::Element::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1543:26
    module_.method("mfem!Mesh!GetTransformationFEforElementType", static_cast<mfem::FiniteElement * (*)(mfem::Element::Type) >(&mfem::Mesh::GetTransformationFEforElementType));

    DEBUG_MSG("Adding wrapper for mfem::IntegrationPoint mfem::Mesh::TransformBdrElementToFace(mfem::Geometry::Type, int, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::IntegrationPoint mfem::Mesh::TransformBdrElementToFace(mfem::Geometry::Type, int, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1550:28
    module_.method("mfem!Mesh!TransformBdrElementToFace", static_cast<mfem::IntegrationPoint (*)(mfem::Geometry::Type, int, const mfem::IntegrationPoint &) >(&mfem::Mesh::TransformBdrElementToFace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1567:9
    t.method("GetElementTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetElementTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1575:27
    t.method("GetElementTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementTransformation(int, const mfem::Vector &, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementTransformation(int, const mfem::Vector &, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1584:9
    t.method("GetElementTransformation", static_cast<void (mfem::Mesh::*)(int, const mfem::Vector &, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetBdrElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetBdrElementTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1593:27
    t.method("GetBdrElementTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1602:9
    t.method("GetBdrElementTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetFaceTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetFaceTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1611:27
    t.method("GetFaceTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetFaceTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1620:9
    t.method("GetFaceTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetFaceTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetLocalFaceTransformation(int, int, mfem::IsoparametricTransformation &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetLocalFaceTransformation(int, int, mfem::IsoparametricTransformation &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1627:9
    t.method("GetLocalFaceTransformation", static_cast<void (mfem::Mesh::*)(int, int, mfem::IsoparametricTransformation &, int)  const>(&mfem::Mesh::GetLocalFaceTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetEdgeTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetEdgeTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1638:9
    t.method("GetEdgeTransformation", static_cast<void (mfem::Mesh::*)(int, mfem::IsoparametricTransformation *)  const>(&mfem::Mesh::GetEdgeTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::Mesh::GetEdgeTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::Mesh::GetEdgeTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1646:27
    t.method("GetEdgeTransformation", static_cast<mfem::ElementTransformation * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetEdgeTransformation));

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetFaceElementTransformations(int, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetFaceElementTransformations(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1683:4
    t.method("GetFaceElementTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GetFaceElementTransformations));
    t.method("GetFaceElementTransformations", [](mfem::Mesh& a, int arg0)->mfem::FaceElementTransformations * { return a.GetFaceElementTransformations(arg0); });
    t.method("GetFaceElementTransformations", [](mfem::Mesh* a, int arg0)->mfem::FaceElementTransformations * { return a->GetFaceElementTransformations(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceElementTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceElementTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1687:17
    t.method("GetFaceElementTransformations", static_cast<void (mfem::Mesh::*)(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &, int)  const>(&mfem::Mesh::GetFaceElementTransformations));
    t.method("GetFaceElementTransformations", [](mfem::Mesh const& a, int arg0, mfem::FaceElementTransformations & arg1, mfem::IsoparametricTransformation & arg2, mfem::IsoparametricTransformation & arg3)->void { a.GetFaceElementTransformations(arg0, arg1, arg2, arg3); });
    t.method("GetFaceElementTransformations", [](mfem::Mesh const* a, int arg0, mfem::FaceElementTransformations & arg1, mfem::IsoparametricTransformation & arg2, mfem::IsoparametricTransformation & arg3)->void { a->GetFaceElementTransformations(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetInteriorFaceTransformations(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetInteriorFaceTransformations(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1698:32
    t.method("GetInteriorFaceTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetInteriorFaceTransformations));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetInteriorFaceTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetInteriorFaceTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1702:9
    t.method("GetInteriorFaceTransformations", static_cast<void (mfem::Mesh::*)(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &)  const>(&mfem::Mesh::GetInteriorFaceTransformations));

    DEBUG_MSG("Adding wrapper for mfem::FaceElementTransformations * mfem::Mesh::GetBdrFaceTransformations(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceElementTransformations * mfem::Mesh::GetBdrFaceTransformations(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1712:32
    t.method("GetBdrFaceTransformations", static_cast<mfem::FaceElementTransformations * (mfem::Mesh::*)(int) >(&mfem::Mesh::GetBdrFaceTransformations));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrFaceTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrFaceTransformations(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1716:9
    t.method("GetBdrFaceTransformations", static_cast<void (mfem::Mesh::*)(int, mfem::FaceElementTransformations &, mfem::IsoparametricTransformation &, mfem::IsoparametricTransformation &)  const>(&mfem::Mesh::GetBdrFaceTransformations));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetPointMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetPointMatrix(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1952:9
    t.method("GetPointMatrix", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &)  const>(&mfem::Mesh::GetPointMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetBdrPointMatrix(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetBdrPointMatrix(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1956:9
    t.method("GetBdrPointMatrix", static_cast<void (mfem::Mesh::*)(int, mfem::DenseMatrix &)  const>(&mfem::Mesh::GetBdrPointMatrix));

    DEBUG_MSG("Adding wrapper for mfem::Mesh::FaceInformation mfem::Mesh::GetFaceInformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh::FaceInformation mfem::Mesh::GetFaceInformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1961:20
    t.method("GetFaceInformation", static_cast<mfem::Mesh::FaceInformation (mfem::Mesh::*)(int)  const>(&mfem::Mesh::GetFaceInformation));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceElements(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceElements(int, int *, int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1963:9
    t.method("GetFaceElements", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetFaceElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceInfos(int, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceInfos(int, int *, int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1964:9
    t.method("GetFaceInfos", static_cast<void (mfem::Mesh::*)(int, int *, int *)  const>(&mfem::Mesh::GetFaceInfos));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetFaceInfos(int, int *, int *, int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetFaceInfos(int, int *, int *, int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1965:9
    t.method("GetFaceInfos", static_cast<void (mfem::Mesh::*)(int, int *, int *, int *)  const>(&mfem::Mesh::GetFaceInfos));

    DEBUG_MSG("Adding wrapper for int * mfem::Mesh::CartesianPartitioning(int[]) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::Mesh::CartesianPartitioning(int[])
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1973:9
    t.method("CartesianPartitioning", static_cast<int * (mfem::Mesh::*)(int[]) >(&mfem::Mesh::CartesianPartitioning));

    DEBUG_MSG("Adding wrapper for int * mfem::Mesh::GeneratePartitioning(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int * mfem::Mesh::GeneratePartitioning(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1975:9
    t.method("GeneratePartitioning", static_cast<int * (mfem::Mesh::*)(int, int) >(&mfem::Mesh::GeneratePartitioning));
    t.method("GeneratePartitioning", [](mfem::Mesh& a, int arg0)->int * { return a.GeneratePartitioning(arg0); });
    t.method("GeneratePartitioning", [](mfem::Mesh* a, int arg0)->int * { return a->GeneratePartitioning(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::CheckPartitioning(int *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::CheckPartitioning(int *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1977:9
    t.method("CheckPartitioning", static_cast<void (mfem::Mesh::*)(int *) >(&mfem::Mesh::CheckPartitioning));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::MoveVertices(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::MoveVertices(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1989:9
    t.method("MoveVertices", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::MoveVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetVertices(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetVertices(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1990:9
    t.method("GetVertices", static_cast<void (mfem::Mesh::*)(mfem::Vector &)  const>(&mfem::Mesh::GetVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetVertices(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetVertices(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1991:9
    t.method("SetVertices", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::SetVertices));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ChangeVertexDataOwnership(double *, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ChangeVertexDataOwnership(double *, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1998:9
    t.method("ChangeVertexDataOwnership", static_cast<void (mfem::Mesh::*)(double *, int, bool) >(&mfem::Mesh::ChangeVertexDataOwnership));
    t.method("ChangeVertexDataOwnership", [](mfem::Mesh& a, double * arg0, int arg1)->void { a.ChangeVertexDataOwnership(arg0, arg1); });
    t.method("ChangeVertexDataOwnership", [](mfem::Mesh* a, double * arg0, int arg1)->void { a->ChangeVertexDataOwnership(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNode(int, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNode(int, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2004:9
    t.method("GetNode", static_cast<void (mfem::Mesh::*)(int, double *)  const>(&mfem::Mesh::GetNode));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNode(int, const double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNode(int, const double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2005:9
    t.method("SetNode", static_cast<void (mfem::Mesh::*)(int, const double *) >(&mfem::Mesh::SetNode));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::MoveNodes(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::MoveNodes(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2010:9
    t.method("MoveNodes", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::MoveNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNodes(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNodes(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2011:9
    t.method("GetNodes", static_cast<void (mfem::Mesh::*)(mfem::Vector &)  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodes(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodes(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2013:9
    t.method("SetNodes", static_cast<void (mfem::Mesh::*)(const mfem::Vector &) >(&mfem::Mesh::SetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ScaleSubdomains(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ScaleSubdomains(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2015:9
    t.method("ScaleSubdomains", static_cast<void (mfem::Mesh::*)(double) >(&mfem::Mesh::ScaleSubdomains));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::ScaleElements(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::ScaleElements(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2016:9
    t.method("ScaleElements", static_cast<void (mfem::Mesh::*)(double) >(&mfem::Mesh::ScaleElements));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Transform(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Transform(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2019:9
    t.method("Transform", static_cast<void (mfem::Mesh::*)(mfem::VectorCoefficient &) >(&mfem::Mesh::Transform));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::NodesUpdated() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::NodesUpdated()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2029:9
    t.method("NodesUpdated", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::NodesUpdated));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction * mfem::Mesh::GetNodes() (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction * mfem::Mesh::GetNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2047:18
    t.method("GetNodes", static_cast<mfem::GridFunction * (mfem::Mesh::*)() >(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for const mfem::GridFunction * mfem::Mesh::GetNodes() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::GridFunction * mfem::Mesh::GetNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2048:24
    t.method("GetNodes", static_cast<const mfem::GridFunction * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::OwnsNodes() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::OwnsNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2050:9
    t.method("OwnsNodes", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::OwnsNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodesOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodesOwner(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2052:9
    t.method("SetNodesOwner", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::SetNodesOwner));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::NewNodes(mfem::GridFunction &, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::NewNodes(mfem::GridFunction &, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2055:9
    t.method("NewNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction &, bool) >(&mfem::Mesh::NewNodes));
    t.method("NewNodes", [](mfem::Mesh& a, mfem::GridFunction & arg0)->void { a.NewNodes(arg0); });
    t.method("NewNodes", [](mfem::Mesh* a, mfem::GridFunction & arg0)->void { a->NewNodes(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SwapNodes(mfem::GridFunction *&, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SwapNodes(mfem::GridFunction *&, int &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2059:9
    t.method("SwapNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction *&, int &) >(&mfem::Mesh::SwapNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetNodes(mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetNodes(mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2062:9
    t.method("GetNodes", static_cast<void (mfem::Mesh::*)(mfem::GridFunction &)  const>(&mfem::Mesh::GetNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodalFESpace(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodalFESpace(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2066:17
    t.method("SetNodalFESpace", static_cast<void (mfem::Mesh::*)(mfem::FiniteElementSpace *) >(&mfem::Mesh::SetNodalFESpace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetNodalGridFunction(mfem::GridFunction *, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetNodalGridFunction(mfem::GridFunction *, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2070:9
    t.method("SetNodalGridFunction", static_cast<void (mfem::Mesh::*)(mfem::GridFunction *, bool) >(&mfem::Mesh::SetNodalGridFunction));
    t.method("SetNodalGridFunction", [](mfem::Mesh& a, mfem::GridFunction * arg0)->void { a.SetNodalGridFunction(arg0); });
    t.method("SetNodalGridFunction", [](mfem::Mesh* a, mfem::GridFunction * arg0)->void { a->SetNodalGridFunction(arg0); });

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::Mesh::GetNodalFESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::Mesh::GetNodalFESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2073:30
    t.method("GetNodalFESpace", static_cast<const mfem::FiniteElementSpace * (mfem::Mesh::*)()  const>(&mfem::Mesh::GetNodalFESpace));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::EnsureNodes() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::EnsureNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2079:9
    t.method("EnsureNodes", static_cast<void (mfem::Mesh::*)() >(&mfem::Mesh::EnsureNodes));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::SetCurvature(int, bool, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::SetCurvature(int, bool, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2090:17
    t.method("SetCurvature", static_cast<void (mfem::Mesh::*)(int, bool, int, int) >(&mfem::Mesh::SetCurvature));
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0)->void { a.SetCurvature(arg0); });
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0, bool arg1)->void { a.SetCurvature(arg0, arg1); });
    t.method("SetCurvature", [](mfem::Mesh& a, int arg0, bool arg1, int arg2)->void { a.SetCurvature(arg0, arg1, arg2); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0)->void { a->SetCurvature(arg0); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0, bool arg1)->void { a->SetCurvature(arg0, arg1); });
    t.method("SetCurvature", [](mfem::Mesh* a, int arg0, bool arg1, int arg2)->void { a->SetCurvature(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::UniformRefinement(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::UniformRefinement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2109:9
    t.method("UniformRefinement", static_cast<void (mfem::Mesh::*)(int) >(&mfem::Mesh::UniformRefinement));
    t.method("UniformRefinement", [](mfem::Mesh& a)->void { a.UniformRefinement(); });
    t.method("UniformRefinement", [](mfem::Mesh* a)->void { a->UniformRefinement(); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeneralRefinement(const mfem::Array<mfem::Refinement> &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GeneralRefinement(const mfem::Array<mfem::Refinement> &, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2119:9
    t.method("GeneralRefinement", static_cast<void (mfem::Mesh::*)(const mfem::Array<mfem::Refinement> &, int, int) >(&mfem::Mesh::GeneralRefinement));
    t.method("GeneralRefinement", [](mfem::Mesh& a, const mfem::Array<mfem::Refinement> & arg0)->void { a.GeneralRefinement(arg0); });
    t.method("GeneralRefinement", [](mfem::Mesh& a, const mfem::Array<mfem::Refinement> & arg0, int arg1)->void { a.GeneralRefinement(arg0, arg1); });
    t.method("GeneralRefinement", [](mfem::Mesh* a, const mfem::Array<mfem::Refinement> & arg0)->void { a->GeneralRefinement(arg0); });
    t.method("GeneralRefinement", [](mfem::Mesh* a, const mfem::Array<mfem::Refinement> & arg0, int arg1)->void { a->GeneralRefinement(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeneralRefinement(const mfem::Array<int> &, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GeneralRefinement(const mfem::Array<int> &, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2124:9
    t.method("GeneralRefinement", static_cast<void (mfem::Mesh::*)(const mfem::Array<int> &, int, int) >(&mfem::Mesh::GeneralRefinement));
    t.method("GeneralRefinement", [](mfem::Mesh& a, const mfem::Array<int> & arg0)->void { a.GeneralRefinement(arg0); });
    t.method("GeneralRefinement", [](mfem::Mesh& a, const mfem::Array<int> & arg0, int arg1)->void { a.GeneralRefinement(arg0, arg1); });
    t.method("GeneralRefinement", [](mfem::Mesh* a, const mfem::Array<int> & arg0)->void { a->GeneralRefinement(arg0); });
    t.method("GeneralRefinement", [](mfem::Mesh* a, const mfem::Array<int> & arg0, int arg1)->void { a->GeneralRefinement(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RandomRefinement(double, bool, int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RandomRefinement(double, bool, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2128:9
    t.method("RandomRefinement", static_cast<void (mfem::Mesh::*)(double, bool, int, int) >(&mfem::Mesh::RandomRefinement));
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0)->void { a.RandomRefinement(arg0); });
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0, bool arg1)->void { a.RandomRefinement(arg0, arg1); });
    t.method("RandomRefinement", [](mfem::Mesh& a, double arg0, bool arg1, int arg2)->void { a.RandomRefinement(arg0, arg1, arg2); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0)->void { a->RandomRefinement(arg0); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0, bool arg1)->void { a->RandomRefinement(arg0, arg1); });
    t.method("RandomRefinement", [](mfem::Mesh* a, double arg0, bool arg1, int arg2)->void { a->RandomRefinement(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RefineAtVertex(const mfem::Vertex &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RefineAtVertex(const mfem::Vertex &, double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2132:9
    t.method("RefineAtVertex", static_cast<void (mfem::Mesh::*)(const mfem::Vertex &, double, int) >(&mfem::Mesh::RefineAtVertex));
    t.method("RefineAtVertex", [](mfem::Mesh& a, const mfem::Vertex & arg0)->void { a.RefineAtVertex(arg0); });
    t.method("RefineAtVertex", [](mfem::Mesh& a, const mfem::Vertex & arg0, double arg1)->void { a.RefineAtVertex(arg0, arg1); });
    t.method("RefineAtVertex", [](mfem::Mesh* a, const mfem::Vertex & arg0)->void { a->RefineAtVertex(arg0); });
    t.method("RefineAtVertex", [](mfem::Mesh* a, const mfem::Vertex & arg0, double arg1)->void { a->RefineAtVertex(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::RefineByError(const mfem::Array<double> &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::RefineByError(const mfem::Array<double> &, double, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2137:9
    t.method("RefineByError", static_cast<bool (mfem::Mesh::*)(const mfem::Array<double> &, double, int, int) >(&mfem::Mesh::RefineByError));
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Array<double> & arg0, double arg1)->bool { return a.RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Array<double> & arg0, double arg1, int arg2)->bool { return a.RefineByError(arg0, arg1, arg2); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Array<double> & arg0, double arg1)->bool { return a->RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Array<double> & arg0, double arg1, int arg2)->bool { return a->RefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::RefineByError(const mfem::Vector &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::RefineByError(const mfem::Vector &, double, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2142:9
    t.method("RefineByError", static_cast<bool (mfem::Mesh::*)(const mfem::Vector &, double, int, int) >(&mfem::Mesh::RefineByError));
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1)->bool { return a.RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1, int arg2)->bool { return a.RefineByError(arg0, arg1, arg2); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1)->bool { return a->RefineByError(arg0, arg1); });
    t.method("RefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1, int arg2)->bool { return a->RefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::DerefineByError(mfem::Array<double> &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::DerefineByError(mfem::Array<double> &, double, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2150:9
    t.method("DerefineByError", static_cast<bool (mfem::Mesh::*)(mfem::Array<double> &, double, int, int) >(&mfem::Mesh::DerefineByError));
    t.method("DerefineByError", [](mfem::Mesh& a, mfem::Array<double> & arg0, double arg1)->bool { return a.DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh& a, mfem::Array<double> & arg0, double arg1, int arg2)->bool { return a.DerefineByError(arg0, arg1, arg2); });
    t.method("DerefineByError", [](mfem::Mesh* a, mfem::Array<double> & arg0, double arg1)->bool { return a->DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh* a, mfem::Array<double> & arg0, double arg1, int arg2)->bool { return a->DerefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::DerefineByError(const mfem::Vector &, double, int, int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::DerefineByError(const mfem::Vector &, double, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2154:9
    t.method("DerefineByError", static_cast<bool (mfem::Mesh::*)(const mfem::Vector &, double, int, int) >(&mfem::Mesh::DerefineByError));
    t.method("DerefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1)->bool { return a.DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh& a, const mfem::Vector & arg0, double arg1, int arg2)->bool { return a.DerefineByError(arg0, arg1, arg2); });
    t.method("DerefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1)->bool { return a->DerefineByError(arg0, arg1); });
    t.method("DerefineByError", [](mfem::Mesh* a, const mfem::Vector & arg0, double arg1, int arg2)->bool { return a->DerefineByError(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::EnsureNCMesh(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::EnsureNCMesh(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2160:9
    t.method("EnsureNCMesh", static_cast<void (mfem::Mesh::*)(bool) >(&mfem::Mesh::EnsureNCMesh));
    t.method("EnsureNCMesh", [](mfem::Mesh& a)->void { a.EnsureNCMesh(); });
    t.method("EnsureNCMesh", [](mfem::Mesh* a)->void { a->EnsureNCMesh(); });

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::Conforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::Conforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2162:9
    t.method("Conforming", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::Conforming));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::Nonconforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::Nonconforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2163:9
    t.method("Nonconforming", static_cast<bool (mfem::Mesh::*)()  const>(&mfem::Mesh::Nonconforming));

    DEBUG_MSG("Adding wrapper for const mfem::CoarseFineTransformations & mfem::Mesh::GetRefinementTransforms() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::CoarseFineTransformations & mfem::Mesh::GetRefinementTransforms()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2167:37
    t.method("GetRefinementTransforms", static_cast<const mfem::CoarseFineTransformations & (mfem::Mesh::*)()  const>(&mfem::Mesh::GetRefinementTransforms));

    DEBUG_MSG("Adding wrapper for mfem::Mesh::Operation mfem::Mesh::GetLastOperation() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh::Operation mfem::Mesh::GetLastOperation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2170:14
    t.method("GetLastOperation", static_cast<mfem::Mesh::Operation (mfem::Mesh::*)()  const>(&mfem::Mesh::GetLastOperation));

    DEBUG_MSG("Adding wrapper for long mfem::Mesh::GetSequence() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::Mesh::GetSequence()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2176:9
    t.method("GetSequence", static_cast<long (mfem::Mesh::*)()  const>(&mfem::Mesh::GetSequence));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::RefineNURBSFromFile(std::string) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::RefineNURBSFromFile(std::string)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2189:9
    t.method("RefineNURBSFromFile", static_cast<void (mfem::Mesh::*)(std::string) >(&mfem::Mesh::RefineNURBSFromFile));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::KnotInsert(mfem::Array<mfem::KnotVector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::KnotInsert(mfem::Array<mfem::KnotVector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2190:9
    t.method("KnotInsert", static_cast<void (mfem::Mesh::*)(mfem::Array<mfem::KnotVector *> &) >(&mfem::Mesh::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::KnotInsert(mfem::Array<mfem::Vector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::KnotInsert(mfem::Array<mfem::Vector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2191:9
    t.method("KnotInsert", static_cast<void (mfem::Mesh::*)(mfem::Array<mfem::Vector *> &) >(&mfem::Mesh::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::DegreeElevate(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::DegreeElevate(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2194:9
    t.method("DegreeElevate", static_cast<void (mfem::Mesh::*)(int, int) >(&mfem::Mesh::DegreeElevate));
    t.method("DegreeElevate", [](mfem::Mesh& a, int arg0)->void { a.DegreeElevate(arg0); });
    t.method("DegreeElevate", [](mfem::Mesh* a, int arg0)->void { a->DegreeElevate(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::Save(const std::string &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::Save(const std::string &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2213:17
    t.method("Save", static_cast<void (mfem::Mesh::*)(const std::string &, int)  const>(&mfem::Mesh::Save));
    t.method("Save", [](mfem::Mesh const& a, const std::string & arg0)->void { a.Save(arg0); });
    t.method("Save", [](mfem::Mesh const* a, const std::string & arg0)->void { a->Save(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::PrintVTU(std::string, mfem::VTKFormat, bool, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::PrintVTU(std::string, mfem::VTKFormat, bool, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2239:17
    t.method("PrintVTU", static_cast<void (mfem::Mesh::*)(std::string, mfem::VTKFormat, bool, int, bool) >(&mfem::Mesh::PrintVTU));
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0)->void { a.PrintVTU(arg0); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1)->void { a.PrintVTU(arg0, arg1); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void { a.PrintVTU(arg0, arg1, arg2); });
    t.method("PrintVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2, int arg3)->void { a.PrintVTU(arg0, arg1, arg2, arg3); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0)->void { a->PrintVTU(arg0); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1)->void { a->PrintVTU(arg0, arg1); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void { a->PrintVTU(arg0, arg1, arg2); });
    t.method("PrintVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2, int arg3)->void { a->PrintVTU(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::PrintBdrVTU(std::string, mfem::VTKFormat, bool, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::PrintBdrVTU(std::string, mfem::VTKFormat, bool, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2246:9
    t.method("PrintBdrVTU", static_cast<void (mfem::Mesh::*)(std::string, mfem::VTKFormat, bool, int) >(&mfem::Mesh::PrintBdrVTU));
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0)->void { a.PrintBdrVTU(arg0); });
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1)->void { a.PrintBdrVTU(arg0, arg1); });
    t.method("PrintBdrVTU", [](mfem::Mesh& a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void { a.PrintBdrVTU(arg0, arg1, arg2); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0)->void { a->PrintBdrVTU(arg0); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1)->void { a->PrintBdrVTU(arg0, arg1); });
    t.method("PrintBdrVTU", [](mfem::Mesh* a, std::string arg0, mfem::VTKFormat arg1, bool arg2)->void { a->PrintBdrVTU(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for std::vector<int> mfem::Mesh::CreatePeriodicVertexMapping(const std::vector<mfem::Vector> &, double) (" __HERE__ ")");
    // signature to use in the veto list: std::vector<int> mfem::Mesh::CreatePeriodicVertexMapping(const std::vector<mfem::Vector> &, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2310:21
    t.method("CreatePeriodicVertexMapping", static_cast<std::vector<int> (mfem::Mesh::*)(const std::vector<mfem::Vector> &, double)  const>(&mfem::Mesh::CreatePeriodicVertexMapping));
    t.method("CreatePeriodicVertexMapping", [](mfem::Mesh const& a, const std::vector<mfem::Vector> & arg0)->std::vector<int> { return a.CreatePeriodicVertexMapping(arg0); });
    t.method("CreatePeriodicVertexMapping", [](mfem::Mesh const* a, const std::vector<mfem::Vector> & arg0)->std::vector<int> { return a->CreatePeriodicVertexMapping(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::Mesh::FindPoints(mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<mfem::IntegrationPoint> &, bool, mfem::InverseElementTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Mesh::FindPoints(mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<mfem::IntegrationPoint> &, bool, mfem::InverseElementTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2338:16
    t.method("FindPoints", static_cast<int (mfem::Mesh::*)(mfem::DenseMatrix &, mfem::Array<int> &, mfem::Array<mfem::IntegrationPoint> &, bool, mfem::InverseElementTransformation *) >(&mfem::Mesh::FindPoints));
    t.method("FindPoints", [](mfem::Mesh& a, mfem::DenseMatrix & arg0, mfem::Array<int> & arg1, mfem::Array<mfem::IntegrationPoint> & arg2)->int { return a.FindPoints(arg0, arg1, arg2); });
    t.method("FindPoints", [](mfem::Mesh& a, mfem::DenseMatrix & arg0, mfem::Array<int> & arg1, mfem::Array<mfem::IntegrationPoint> & arg2, bool arg3)->int { return a.FindPoints(arg0, arg1, arg2, arg3); });
    t.method("FindPoints", [](mfem::Mesh* a, mfem::DenseMatrix & arg0, mfem::Array<int> & arg1, mfem::Array<mfem::IntegrationPoint> & arg2)->int { return a->FindPoints(arg0, arg1, arg2); });
    t.method("FindPoints", [](mfem::Mesh* a, mfem::DenseMatrix & arg0, mfem::Array<int> & arg1, mfem::Array<mfem::IntegrationPoint> & arg2, bool arg3)->int { return a->FindPoints(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetGeometricParametersFromJacobian(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetGeometricParametersFromJacobian(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2351:9
    t.method("GetGeometricParametersFromJacobian", static_cast<void (mfem::Mesh::*)(const mfem::DenseMatrix &, double &, mfem::Vector &, mfem::Vector &, mfem::Vector &)  const>(&mfem::Mesh::GetGeometricParametersFromJacobian));

    DEBUG_MSG("Adding wrapper for long long mfem::Mesh::ReduceInt(int) (" __HERE__ ")");
    // signature to use in the veto list: long long mfem::Mesh::ReduceInt(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2358:22
    t.method("ReduceInt", static_cast<long long (mfem::Mesh::*)(int)  const>(&mfem::Mesh::ReduceInt));

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GetElementColoring(mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::GetElementColoring(mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2361:9
    t.method("GetElementColoring", static_cast<void (mfem::Mesh::*)(mfem::Array<int> &, int) >(&mfem::Mesh::GetElementColoring));
    t.method("GetElementColoring", [](mfem::Mesh& a, mfem::Array<int> & arg0)->void { a.GetElementColoring(arg0); });
    t.method("GetElementColoring", [](mfem::Mesh* a, mfem::Array<int> & arg0)->void { a->GetElementColoring(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Mesh::CheckDisplacements(const mfem::Vector &, double &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Mesh::CheckDisplacements(const mfem::Vector &, double &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2367:9
    t.method("CheckDisplacements", static_cast<void (mfem::Mesh::*)(const mfem::Vector &, double &) >(&mfem::Mesh::CheckDisplacements));

    DEBUG_MSG("Adding attributes methods  to provide read access to the field attributes (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:273:15
    // signature to use in the veto list: mfem::Mesh::attributes
    t.method("attributes", [](const mfem::Mesh& a) -> const mfem::Array<int>& { return a.attributes; });
    t.method("attributes", [](mfem::Mesh& a) -> mfem::Array<int>& { return a.attributes; });
    t.method("attributes", [](const mfem::Mesh* a) -> const mfem::Array<int>& { return a->attributes; });
    t.method("attributes", [](mfem::Mesh* a) -> mfem::Array<int>& { return a->attributes; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:273:15
    // signature to use in the veto list: mfem::Mesh::attributes
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding attributes! methods to provide write access to the field attributes (" __HERE__ ")");
    t.method("attributes!", [](mfem::Mesh& a, const mfem::Array<int>& val) -> mfem::Array<int>& { return a.attributes = val; });

    DEBUG_MSG("Adding attributes! methods to provide write access to the field attributes (" __HERE__ ")");
    t.method("attributes!", [](mfem::Mesh* a, const mfem::Array<int>& val) -> mfem::Array<int>& { return a->attributes = val; });

    DEBUG_MSG("Adding bdr_attributes methods  to provide read access to the field bdr_attributes (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:275:15
    // signature to use in the veto list: mfem::Mesh::bdr_attributes
    t.method("bdr_attributes", [](const mfem::Mesh& a) -> const mfem::Array<int>& { return a.bdr_attributes; });
    t.method("bdr_attributes", [](mfem::Mesh& a) -> mfem::Array<int>& { return a.bdr_attributes; });
    t.method("bdr_attributes", [](const mfem::Mesh* a) -> const mfem::Array<int>& { return a->bdr_attributes; });
    t.method("bdr_attributes", [](mfem::Mesh* a) -> mfem::Array<int>& { return a->bdr_attributes; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:275:15
    // signature to use in the veto list: mfem::Mesh::bdr_attributes
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding bdr_attributes! methods to provide write access to the field bdr_attributes (" __HERE__ ")");
    t.method("bdr_attributes!", [](mfem::Mesh& a, const mfem::Array<int>& val) -> mfem::Array<int>& { return a.bdr_attributes = val; });

    DEBUG_MSG("Adding bdr_attributes! methods to provide write access to the field bdr_attributes (" __HERE__ ")");
    t.method("bdr_attributes!", [](mfem::Mesh* a, const mfem::Array<int>& val) -> mfem::Array<int>& { return a->bdr_attributes = val; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DenseMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DenseMatrix> : std::false_type { };
}

// Class generating the wrapper for type mfem::DenseMatrix
// signature to use in the veto file: mfem::DenseMatrix
struct Jlmfem_DenseMatrix: public Wrapper {

  Jlmfem_DenseMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DenseMatrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/densemat.hpp:23:7
    jlcxx::TypeWrapper<mfem::DenseMatrix>  t = jlModule.add_type<mfem::DenseMatrix>("mfem!DenseMatrix");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseMatrix>>(new jlcxx::TypeWrapper<mfem::DenseMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DenseMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DenseMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DenseMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSExtension> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSExtension> : std::false_type { };
}

// Class generating the wrapper for type mfem::NURBSExtension
// signature to use in the veto file: mfem::NURBSExtension
struct Jlmfem_NURBSExtension: public Wrapper {

  Jlmfem_NURBSExtension(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSExtension (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:201:7
    jlcxx::TypeWrapper<mfem::NURBSExtension>  t = jlModule.add_type<mfem::NURBSExtension>("mfem!NURBSExtension");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSExtension>>(new jlcxx::TypeWrapper<mfem::NURBSExtension>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::NURBSExtension(const mfem::NURBSExtension &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:371:4
    t.constructor<const mfem::NURBSExtension &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::NURBSExtension(mfem::NURBSExtension *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:378:4
    t.constructor<mfem::NURBSExtension *, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::NURBSExtension(mfem::NURBSExtension *, const mfem::Array<int> &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:384:4
    t.constructor<mfem::NURBSExtension *, const mfem::Array<int> &>(/*finalize=*/jlcxx::finalize_policy::yes);


    // DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::NURBSExtension(Mesh *[], int) (" __HERE__ ")");
    // // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:386:4
    // t.constructor<Mesh *[], int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::ConnectBoundaries(mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::ConnectBoundaries(mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:392:9
    t.method("ConnectBoundaries", static_cast<void (mfem::NURBSExtension::*)(mfem::Array<int> &, mfem::Array<int> &) >(&mfem::NURBSExtension::ConnectBoundaries));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::NURBSExtension::GetMaster() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::NURBSExtension::GetMaster()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:393:22
    t.method("GetMaster", static_cast<const mfem::Array<int> & (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetMaster));

    DEBUG_MSG("Adding wrapper for mfem::Array<int> & mfem::NURBSExtension::GetMaster() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<int> & mfem::NURBSExtension::GetMaster()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:394:16
    t.method("GetMaster", static_cast<mfem::Array<int> & (mfem::NURBSExtension::*)() >(&mfem::NURBSExtension::GetMaster));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::NURBSExtension::GetSlave() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::NURBSExtension::GetSlave()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:395:22
    t.method("GetSlave", static_cast<const mfem::Array<int> & (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetSlave));

    DEBUG_MSG("Adding wrapper for mfem::Array<int> & mfem::NURBSExtension::GetSlave() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Array<int> & mfem::NURBSExtension::GetSlave()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:396:16
    t.method("GetSlave", static_cast<mfem::Array<int> & (mfem::NURBSExtension::*)() >(&mfem::NURBSExtension::GetSlave));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::PrintFunctions(const char *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::PrintFunctions(const char *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:406:9
    t.method("PrintFunctions", static_cast<void (mfem::NURBSExtension::*)(const char *, int)  const>(&mfem::NURBSExtension::PrintFunctions));
    t.method("PrintFunctions", [](mfem::NURBSExtension const& a, const char * arg0)->void { a.PrintFunctions(arg0); });
    t.method("PrintFunctions", [](mfem::NURBSExtension const* a, const char * arg0)->void { a->PrintFunctions(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::Dimension() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::Dimension()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:409:8
    t.method("Dimension", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::Dimension));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetNP() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetNP()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:410:8
    t.method("GetNP", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetNP));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetNBP() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetNBP()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:411:8
    t.method("GetNBP", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetNBP));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::NURBSExtension::GetOrders() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::NURBSExtension::GetOrders()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:414:22
    t.method("GetOrders", static_cast<const mfem::Array<int> & (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetOrders));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:417:8
    t.method("GetOrder", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetOrder));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetNKV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetNKV()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:419:8
    t.method("GetNKV", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetNKV));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetGNV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetGNV()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:421:8
    t.method("GetGNV", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetGNV));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetNV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetNV()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:422:8
    t.method("GetNV", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetNV));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetGNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetGNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:423:8
    t.method("GetGNE", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetGNE));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:424:8
    t.method("GetNE", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetNE));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetGNBE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetGNBE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:425:8
    t.method("GetGNBE", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetGNBE));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetNBE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetNBE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:426:8
    t.method("GetNBE", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetNBE));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetNTotalDof() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetNTotalDof()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:428:8
    t.method("GetNTotalDof", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetNTotalDof));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetNDof() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetNDof()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:429:8
    t.method("GetNDof", static_cast<int (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetNDof));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::GetPatchKnotVectors(int, mfem::Array<const mfem::KnotVector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::GetPatchKnotVectors(int, mfem::Array<const mfem::KnotVector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:432:9
    t.method("GetPatchKnotVectors", static_cast<void (mfem::NURBSExtension::*)(int, mfem::Array<const mfem::KnotVector *> &)  const>(&mfem::NURBSExtension::GetPatchKnotVectors));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::GetBdrPatchKnotVectors(int, mfem::Array<const mfem::KnotVector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::GetBdrPatchKnotVectors(int, mfem::Array<const mfem::KnotVector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:434:9
    t.method("GetBdrPatchKnotVectors", static_cast<void (mfem::NURBSExtension::*)(int, mfem::Array<const mfem::KnotVector *> &)  const>(&mfem::NURBSExtension::GetBdrPatchKnotVectors));

    DEBUG_MSG("Adding wrapper for const mfem::KnotVector * mfem::NURBSExtension::GetKnotVector(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::KnotVector * mfem::NURBSExtension::GetKnotVector(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:437:22
    t.method("GetKnotVector", static_cast<const mfem::KnotVector * (mfem::NURBSExtension::*)(int)  const>(&mfem::NURBSExtension::GetKnotVector));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::GetElementTopo(mfem::Array<mfem::Element *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::GetElementTopo(mfem::Array<mfem::Element *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:440:9
    t.method("GetElementTopo", static_cast<void (mfem::NURBSExtension::*)(mfem::Array<mfem::Element *> &)  const>(&mfem::NURBSExtension::GetElementTopo));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::GetBdrElementTopo(mfem::Array<mfem::Element *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::GetBdrElementTopo(mfem::Array<mfem::Element *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:441:9
    t.method("GetBdrElementTopo", static_cast<void (mfem::NURBSExtension::*)(mfem::Array<mfem::Element *> &)  const>(&mfem::NURBSExtension::GetBdrElementTopo));

    DEBUG_MSG("Adding wrapper for bool mfem::NURBSExtension::HavePatches() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::NURBSExtension::HavePatches()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:443:9
    t.method("HavePatches", static_cast<bool (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::HavePatches));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::NURBSExtension::GetElementDofTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::NURBSExtension::GetElementDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:446:11
    t.method("GetElementDofTable", static_cast<mfem::Table * (mfem::NURBSExtension::*)() >(&mfem::NURBSExtension::GetElementDofTable));

    DEBUG_MSG("Adding wrapper for mfem::Table * mfem::NURBSExtension::GetBdrElementDofTable() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Table * mfem::NURBSExtension::GetBdrElementDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:448:11
    t.method("GetBdrElementDofTable", static_cast<mfem::Table * (mfem::NURBSExtension::*)() >(&mfem::NURBSExtension::GetBdrElementDofTable));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::GetVertexLocalToGlobal(mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::GetVertexLocalToGlobal(mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:450:9
    t.method("GetVertexLocalToGlobal", static_cast<void (mfem::NURBSExtension::*)(mfem::Array<int> &) >(&mfem::NURBSExtension::GetVertexLocalToGlobal));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::GetElementLocalToGlobal(mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::GetElementLocalToGlobal(mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:451:9
    t.method("GetElementLocalToGlobal", static_cast<void (mfem::NURBSExtension::*)(mfem::Array<int> &) >(&mfem::NURBSExtension::GetElementLocalToGlobal));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::SetPatchAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::SetPatchAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:455:9
    t.method("SetPatchAttribute", static_cast<void (mfem::NURBSExtension::*)(int, int) >(&mfem::NURBSExtension::SetPatchAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetPatchAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetPatchAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:459:8
    t.method("GetPatchAttribute", static_cast<int (mfem::NURBSExtension::*)(int)  const>(&mfem::NURBSExtension::GetPatchAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::SetPatchBdrAttribute(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::SetPatchBdrAttribute(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:463:9
    t.method("SetPatchBdrAttribute", static_cast<void (mfem::NURBSExtension::*)(int, int) >(&mfem::NURBSExtension::SetPatchBdrAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetPatchBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetPatchBdrAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:467:8
    t.method("GetPatchBdrAttribute", static_cast<int (mfem::NURBSExtension::*)(int)  const>(&mfem::NURBSExtension::GetPatchBdrAttribute));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::LoadFE(int, const mfem::FiniteElement *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::LoadFE(int, const mfem::FiniteElement *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:471:9
    t.method("LoadFE", static_cast<void (mfem::NURBSExtension::*)(int, const mfem::FiniteElement *)  const>(&mfem::NURBSExtension::LoadFE));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::LoadBE(int, const mfem::FiniteElement *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::LoadBE(int, const mfem::FiniteElement *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:472:9
    t.method("LoadBE", static_cast<void (mfem::NURBSExtension::*)(int, const mfem::FiniteElement *)  const>(&mfem::NURBSExtension::LoadBE));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::NURBSExtension::GetWeights() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::NURBSExtension::GetWeights()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:474:18
    t.method("GetWeights", static_cast<const mfem::Vector & (mfem::NURBSExtension::*)()  const>(&mfem::NURBSExtension::GetWeights));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::NURBSExtension::GetWeights() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::NURBSExtension::GetWeights()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:475:18
    t.method("GetWeights", static_cast<mfem::Vector & (mfem::NURBSExtension::*)() >(&mfem::NURBSExtension::GetWeights));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::ConvertToPatches(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::ConvertToPatches(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:479:9
    t.method("ConvertToPatches", static_cast<void (mfem::NURBSExtension::*)(const mfem::Vector &) >(&mfem::NURBSExtension::ConvertToPatches));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::SetKnotsFromPatches() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::SetKnotsFromPatches()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:480:9
    t.method("SetKnotsFromPatches", static_cast<void (mfem::NURBSExtension::*)() >(&mfem::NURBSExtension::SetKnotsFromPatches));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::SetCoordsFromPatches(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::SetCoordsFromPatches(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:481:9
    t.method("SetCoordsFromPatches", static_cast<void (mfem::NURBSExtension::*)(mfem::Vector &) >(&mfem::NURBSExtension::SetCoordsFromPatches));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::DegreeElevate(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::DegreeElevate(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:490:9
    t.method("DegreeElevate", static_cast<void (mfem::NURBSExtension::*)(int, int) >(&mfem::NURBSExtension::DegreeElevate));
    t.method("DegreeElevate", [](mfem::NURBSExtension& a, int arg0)->void { a.DegreeElevate(arg0); });
    t.method("DegreeElevate", [](mfem::NURBSExtension* a, int arg0)->void { a->DegreeElevate(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::UniformRefinement() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::UniformRefinement()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:491:9
    t.method("UniformRefinement", static_cast<void (mfem::NURBSExtension::*)() >(&mfem::NURBSExtension::UniformRefinement));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::KnotInsert(mfem::Array<mfem::KnotVector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::KnotInsert(mfem::Array<mfem::KnotVector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:492:9
    t.method("KnotInsert", static_cast<void (mfem::NURBSExtension::*)(mfem::Array<mfem::KnotVector *> &) >(&mfem::NURBSExtension::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::KnotInsert(mfem::Array<mfem::Vector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::KnotInsert(mfem::Array<mfem::Vector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:493:9
    t.method("KnotInsert", static_cast<void (mfem::NURBSExtension::*)(mfem::Array<mfem::Vector *> &) >(&mfem::NURBSExtension::KnotInsert));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSExtension::GetElementPatch(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSExtension::GetElementPatch(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:496:8
    t.method("GetElementPatch", static_cast<int (mfem::NURBSExtension::*)(int)  const>(&mfem::NURBSExtension::GetElementPatch));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::GetElementIJK(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::GetElementIJK(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:500:9
    t.method("GetElementIJK", static_cast<void (mfem::NURBSExtension::*)(int, mfem::Array<int> &) >(&mfem::NURBSExtension::GetElementIJK));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSExtension::GetPatchDofs(const int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSExtension::GetPatchDofs(const int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:503:9
    t.method("GetPatchDofs", static_cast<void (mfem::NURBSExtension::*)(const int, mfem::Array<int> &) >(&mfem::NURBSExtension::GetPatchDofs));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::NURBSExtension::GetPatchElements(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::NURBSExtension::GetPatchElements(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:505:22
    t.method("GetPatchElements", static_cast<const mfem::Array<int> & (mfem::NURBSExtension::*)(int) >(&mfem::NURBSExtension::GetPatchElements));

    DEBUG_MSG("Adding wrapper for const mfem::Array<int> & mfem::NURBSExtension::GetPatchBdrElements(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Array<int> & mfem::NURBSExtension::GetPatchBdrElements(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:506:22
    t.method("GetPatchBdrElements", static_cast<const mfem::Array<int> & (mfem::NURBSExtension::*)(int) >(&mfem::NURBSExtension::GetPatchBdrElements));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSExtension>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSExtension(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSExtension(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Element> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Element> : std::false_type { };
}

// Class generating the wrapper for type mfem::Element
// signature to use in the veto file: mfem::Element
struct Jlmfem_Element: public Wrapper {

  Jlmfem_Element(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Element (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/element.hpp:28:7
    jlcxx::TypeWrapper<mfem::Element>  t = jlModule.add_type<mfem::Element>("mfem!Element");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Element>>(new jlcxx::TypeWrapper<mfem::Element>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Element>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Element(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Element(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Vector> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Vector> : std::false_type { };
}

// Class generating the wrapper for type mfem::Vector
// signature to use in the veto file: mfem::Vector
struct Jlmfem_Vector: public Wrapper {

  Jlmfem_Vector(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Vector (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../linalg/vector.hpp:58:7
    jlcxx::TypeWrapper<mfem::Vector>  t = jlModule.add_type<mfem::Vector>("mfem!Vector");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Vector>>(new jlcxx::TypeWrapper<mfem::Vector>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Vector>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Vector(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Vector(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ElementTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ElementTransformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::ElementTransformation
// signature to use in the veto file: mfem::ElementTransformation
struct Jlmfem_ElementTransformation: public Wrapper {

  Jlmfem_ElementTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ElementTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/eltrans.hpp:23:7
    jlcxx::TypeWrapper<mfem::ElementTransformation>  t = jlModule.add_type<mfem::ElementTransformation>("mfem!ElementTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementTransformation>>(new jlcxx::TypeWrapper<mfem::ElementTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ElementTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ElementTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh::GeometryList> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh::GeometryList> : std::false_type { };
}

// Class generating the wrapper for type mfem::Mesh::GeometryList
// signature to use in the veto file: mfem::Mesh::GeometryList
struct Jlmfem_Mesh_GeometryList: public Wrapper {

  Jlmfem_Mesh_GeometryList(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh::GeometryList (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1393:10
    jlcxx::TypeWrapper<mfem::Mesh::GeometryList>  t = jlModule.add_type<mfem::Mesh::GeometryList>("mfem!Mesh!GeometryList");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::GeometryList>>(new jlcxx::TypeWrapper<mfem::Mesh::GeometryList>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeometryList::GeometryList(const mfem::Mesh &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1399:7
    t.constructor<const mfem::Mesh &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::Mesh::GeometryList::GeometryList(const mfem::Mesh &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1404:7
    t.constructor<const mfem::Mesh &, int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::GeometryList>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh_GeometryList(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh_GeometryList(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DSTable> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DSTable> : std::false_type { };
}

// Class generating the wrapper for type mfem::DSTable
// signature to use in the veto file: mfem::DSTable
struct Jlmfem_DSTable: public Wrapper {

  Jlmfem_DSTable(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DSTable (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../general/table.hpp:244:7
    jlcxx::TypeWrapper<mfem::DSTable>  t = jlModule.add_type<mfem::DSTable>("mfem!DSTable");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DSTable>>(new jlcxx::TypeWrapper<mfem::DSTable>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DSTable>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DSTable(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DSTable(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElement> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElement> : std::false_type { };
}

// Class generating the wrapper for type mfem::FiniteElement
// signature to use in the veto file: mfem::FiniteElement
struct Jlmfem_FiniteElement: public Wrapper {

  Jlmfem_FiniteElement(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElement (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/fe/fe_base.hpp:238:7
    jlcxx::TypeWrapper<mfem::FiniteElement>  t = jlModule.add_type<mfem::FiniteElement>("mfem!FiniteElement");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElement>>(new jlcxx::TypeWrapper<mfem::FiniteElement>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElement>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElement(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElement(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IsoparametricTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IsoparametricTransformation> : std::false_type { };
template<> struct SuperType<mfem::IsoparametricTransformation> { typedef mfem::ElementTransformation type; };
}

// Class generating the wrapper for type mfem::IsoparametricTransformation
// signature to use in the veto file: mfem::IsoparametricTransformation
struct Jlmfem_IsoparametricTransformation: public Wrapper {

  Jlmfem_IsoparametricTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IsoparametricTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/eltrans.hpp:361:7
    jlcxx::TypeWrapper<mfem::IsoparametricTransformation>  t = jlModule.add_type<mfem::IsoparametricTransformation>("mfem!IsoparametricTransformation",
      jlcxx::julia_base_type<mfem::ElementTransformation>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IsoparametricTransformation>>(new jlcxx::TypeWrapper<mfem::IsoparametricTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IsoparametricTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IsoparametricTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IsoparametricTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceElementTransformations> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceElementTransformations> : std::false_type { };
template<> struct SuperType<mfem::FaceElementTransformations> { typedef mfem::IsoparametricTransformation type; };
}

// Class generating the wrapper for type mfem::FaceElementTransformations
// signature to use in the veto file: mfem::FaceElementTransformations
struct Jlmfem_FaceElementTransformations: public Wrapper {

  Jlmfem_FaceElementTransformations(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceElementTransformations (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/eltrans.hpp:480:7
    jlcxx::TypeWrapper<mfem::FaceElementTransformations>  t = jlModule.add_type<mfem::FaceElementTransformations>("mfem!FaceElementTransformations",
      jlcxx::julia_base_type<mfem::IsoparametricTransformation>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceElementTransformations>>(new jlcxx::TypeWrapper<mfem::FaceElementTransformations>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceElementTransformations>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceElementTransformations(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceElementTransformations(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Mesh::FaceInformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Mesh::FaceInformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::Mesh::FaceInformation
// signature to use in the veto file: mfem::Mesh::FaceInformation
struct Jlmfem_Mesh_FaceInformation: public Wrapper {

  Jlmfem_Mesh_FaceInformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Mesh::FaceInformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1858:11
    jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>  t = jlModule.add_type<mfem::Mesh::FaceInformation>("mfem!Mesh!FaceInformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>>(new jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsLocal() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsLocal()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1877:12
    t.method("IsLocal", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsLocal));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsShared() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsShared()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1884:12
    t.method("IsShared", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsShared));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsInterior() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsInterior()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1893:12
    t.method("IsInterior", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsInterior));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsBoundary() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsBoundary()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1900:12
    t.method("IsBoundary", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsBoundary));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsOfFaceType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsOfFaceType(mfem::FaceType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1906:12
    t.method("IsOfFaceType", static_cast<bool (mfem::Mesh::FaceInformation::*)(mfem::FaceType)  const>(&mfem::Mesh::FaceInformation::IsOfFaceType));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsConforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsConforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1920:12
    t.method("IsConforming", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsConforming));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsNonconformingFine() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsNonconformingFine()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1926:12
    t.method("IsNonconformingFine", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsNonconformingFine));

    DEBUG_MSG("Adding wrapper for bool mfem::Mesh::FaceInformation::IsNonconformingCoarse() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Mesh::FaceInformation::IsNonconformingCoarse()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1937:12
    t.method("IsNonconformingCoarse", static_cast<bool (mfem::Mesh::FaceInformation::*)()  const>(&mfem::Mesh::FaceInformation::IsNonconformingCoarse));

    DEBUG_MSG("Adding topology methods  to provide read access to the field topology (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1860:20
    // signature to use in the veto list: mfem::Mesh::FaceInformation::topology
    t.method("topology", [](const mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceTopology { return a.topology; });
    t.method("topology", [](mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceTopology { return a.topology; });
    t.method("topology", [](const mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceTopology { return a->topology; });
    t.method("topology", [](mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceTopology { return a->topology; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1860:20
    // signature to use in the veto list: mfem::Mesh::FaceInformation::topology
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding topology! methods to provide write access to the field topology (" __HERE__ ")");
    t.method("topology!", [](mfem::Mesh::FaceInformation& a, mfem::Mesh::FaceTopology val) -> mfem::Mesh::FaceTopology { return a.topology = val; });

    DEBUG_MSG("Adding topology! methods to provide write access to the field topology (" __HERE__ ")");
    t.method("topology!", [](mfem::Mesh::FaceInformation* a, mfem::Mesh::FaceTopology val) -> mfem::Mesh::FaceTopology { return a->topology = val; });

    DEBUG_MSG("Adding tag methods  to provide read access to the field tag (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1871:19
    // signature to use in the veto list: mfem::Mesh::FaceInformation::tag
    t.method("tag", [](const mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceInfoTag { return a.tag; });
    t.method("tag", [](mfem::Mesh::FaceInformation& a) -> mfem::Mesh::FaceInfoTag { return a.tag; });
    t.method("tag", [](const mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceInfoTag { return a->tag; });
    t.method("tag", [](mfem::Mesh::FaceInformation* a) -> mfem::Mesh::FaceInfoTag { return a->tag; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1871:19
    // signature to use in the veto list: mfem::Mesh::FaceInformation::tag
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding tag! methods to provide write access to the field tag (" __HERE__ ")");
    t.method("tag!", [](mfem::Mesh::FaceInformation& a, mfem::Mesh::FaceInfoTag val) -> mfem::Mesh::FaceInfoTag { return a.tag = val; });

    DEBUG_MSG("Adding tag! methods to provide write access to the field tag (" __HERE__ ")");
    t.method("tag!", [](mfem::Mesh::FaceInformation* a, mfem::Mesh::FaceInfoTag val) -> mfem::Mesh::FaceInfoTag { return a->tag = val; });

    DEBUG_MSG("Adding ncface methods  to provide read access to the field ncface (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1872:11
    // signature to use in the veto list: mfem::Mesh::FaceInformation::ncface
    t.method("ncface", [](const mfem::Mesh::FaceInformation& a) -> int { return a.ncface; });
    t.method("ncface", [](mfem::Mesh::FaceInformation& a) -> int { return a.ncface; });
    t.method("ncface", [](const mfem::Mesh::FaceInformation* a) -> int { return a->ncface; });
    t.method("ncface", [](mfem::Mesh::FaceInformation* a) -> int { return a->ncface; });
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1872:11
    // signature to use in the veto list: mfem::Mesh::FaceInformation::ncface
    // with ! suffix to veto the setter only.
    DEBUG_MSG("Adding ncface! methods to provide write access to the field ncface (" __HERE__ ")");
    t.method("ncface!", [](mfem::Mesh::FaceInformation& a, int val) -> int { return a.ncface = val; });

    DEBUG_MSG("Adding ncface! methods to provide write access to the field ncface (" __HERE__ ")");
    t.method("ncface!", [](mfem::Mesh::FaceInformation* a, int val) -> int { return a->ncface = val; });

    DEBUG_MSG("Adding point_matrix methods  to provide read access to the field point_matrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1873:26
    // signature to use in the veto list: mfem::Mesh::FaceInformation::point_matrix
    t.method("point_matrix", [](const mfem::Mesh::FaceInformation& a) -> const mfem::DenseMatrix * { return a.point_matrix; });
    t.method("point_matrix", [](const mfem::Mesh::FaceInformation* a) -> const mfem::DenseMatrix * { return a->point_matrix; });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Mesh::FaceInformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Mesh_FaceInformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Mesh_FaceInformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::VectorCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::VectorCoefficient> : std::false_type { };
}

// Class generating the wrapper for type mfem::VectorCoefficient
// signature to use in the veto file: mfem::VectorCoefficient
struct Jlmfem_VectorCoefficient: public Wrapper {

  Jlmfem_VectorCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::VectorCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/coefficient.hpp:566:7
    jlcxx::TypeWrapper<mfem::VectorCoefficient>  t = jlModule.add_type<mfem::VectorCoefficient>("mfem!VectorCoefficient");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCoefficient>>(new jlcxx::TypeWrapper<mfem::VectorCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::VectorCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_VectorCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_VectorCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GridFunction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GridFunction> : std::false_type { };
template<> struct SuperType<mfem::GridFunction> { typedef mfem::Vector type; };
}

// Class generating the wrapper for type mfem::GridFunction
// signature to use in the veto file: mfem::GridFunction
struct Jlmfem_GridFunction: public Wrapper {

  Jlmfem_GridFunction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GridFunction (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:30:7
    jlcxx::TypeWrapper<mfem::GridFunction>  t = jlModule.add_type<mfem::GridFunction>("mfem!GridFunction",
      jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunction>>(new jlcxx::TypeWrapper<mfem::GridFunction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(const mfem::GridFunction &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:78:4
    t.constructor<const mfem::GridFunction &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:83:4
    t.constructor<mfem::FiniteElementSpace *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(mfem::FiniteElementSpace *, double *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:92:4
    t.constructor<mfem::FiniteElementSpace *, double *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:98:4
    t.constructor<mfem::FiniteElementSpace *, mfem::Vector &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::FiniteElementSpace *, mfem::Vector &, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    // DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GridFunction(mfem::Mesh *, GridFunction *[], int) (" __HERE__ ")");
    // // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:108:4
    // t.constructor<mfem::Mesh *, GridFunction *[], int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::GridFunction & mfem::GridFunction::operator=(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction & mfem::GridFunction::operator=(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:116:18
    t.method("assign", static_cast<mfem::GridFunction & (mfem::GridFunction::*)(const mfem::GridFunction &) >(&mfem::GridFunction::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeOwner(mfem::FiniteElementCollection *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeOwner(mfem::FiniteElementCollection *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:122:9
    t.method("MakeOwner", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementCollection *) >(&mfem::GridFunction::MakeOwner));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::GridFunction::OwnFEC() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::GridFunction::OwnFEC()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:124:29
    t.method("OwnFEC", static_cast<mfem::FiniteElementCollection * (mfem::GridFunction::*)() >(&mfem::GridFunction::OwnFEC));

    DEBUG_MSG("Adding wrapper for int mfem::GridFunction::VectorDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GridFunction::VectorDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:126:8
    t.method("VectorDim", static_cast<int (mfem::GridFunction::*)()  const>(&mfem::GridFunction::VectorDim));

    DEBUG_MSG("Adding wrapper for int mfem::GridFunction::CurlDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GridFunction::CurlDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:127:8
    t.method("CurlDim", static_cast<int (mfem::GridFunction::*)()  const>(&mfem::GridFunction::CurlDim));

    DEBUG_MSG("Adding wrapper for const mfem::Vector & mfem::GridFunction::GetTrueVector() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Vector & mfem::GridFunction::GetTrueVector()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:130:18
    t.method("GetTrueVector", static_cast<const mfem::Vector & (mfem::GridFunction::*)()  const>(&mfem::GridFunction::GetTrueVector));

    DEBUG_MSG("Adding wrapper for mfem::Vector & mfem::GridFunction::GetTrueVector() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Vector & mfem::GridFunction::GetTrueVector()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:137:12
    t.method("GetTrueVector", static_cast<mfem::Vector & (mfem::GridFunction::*)() >(&mfem::GridFunction::GetTrueVector));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetTrueDofs(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetTrueDofs(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:141:9
    t.method("GetTrueDofs", static_cast<void (mfem::GridFunction::*)(mfem::Vector &)  const>(&mfem::GridFunction::GetTrueDofs));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::SetTrueVector() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::SetTrueVector()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:144:9
    t.method("SetTrueVector", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::SetTrueVector));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::SetFromTrueDofs(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::SetFromTrueDofs(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:147:17
    t.method("SetFromTrueDofs", static_cast<void (mfem::GridFunction::*)(const mfem::Vector &) >(&mfem::GridFunction::SetFromTrueDofs));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::SetFromTrueVector() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::SetFromTrueVector()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:150:9
    t.method("SetFromTrueVector", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::SetFromTrueVector));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetNodalValues(int, mfem::Array<double> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetNodalValues(int, mfem::Array<double> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:153:9
    t.method("GetNodalValues", static_cast<void (mfem::GridFunction::*)(int, mfem::Array<double> &, int)  const>(&mfem::GridFunction::GetNodalValues));
    t.method("GetNodalValues", [](mfem::GridFunction const& a, int arg0, mfem::Array<double> & arg1)->void { a.GetNodalValues(arg0, arg1); });
    t.method("GetNodalValues", [](mfem::GridFunction const* a, int arg0, mfem::Array<double> & arg1)->void { a->GetNodalValues(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for double mfem::GridFunction::GetValue(int, const mfem::IntegrationPoint &, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunction::GetValue(int, const mfem::IntegrationPoint &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:169:19
    t.method("GetValue", static_cast<double (mfem::GridFunction::*)(int, const mfem::IntegrationPoint &, int)  const>(&mfem::GridFunction::GetValue));
    t.method("GetValue", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationPoint & arg1)->double { return a.GetValue(arg0, arg1); });
    t.method("GetValue", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationPoint & arg1)->double { return a->GetValue(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorValue(int, const mfem::IntegrationPoint &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorValue(int, const mfem::IntegrationPoint &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:173:17
    t.method("GetVectorValue", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationPoint &, mfem::Vector &)  const>(&mfem::GridFunction::GetVectorValue));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetValues(int, const mfem::IntegrationRule &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetValues(int, const mfem::IntegrationRule &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:194:9
    t.method("GetValues", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::Vector &, int)  const>(&mfem::GridFunction::GetValues));
    t.method("GetValues", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a.GetValues(arg0, arg1, arg2); });
    t.method("GetValues", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a->GetValues(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetValues(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetValues(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:199:9
    t.method("GetValues", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetValues));
    t.method("GetValues", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, mfem::DenseMatrix & arg3)->void { a.GetValues(arg0, arg1, arg2, arg3); });
    t.method("GetValues", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, mfem::DenseMatrix & arg3)->void { a->GetValues(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorValues(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorValues(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:202:9
    t.method("GetVectorValues", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetVectorValues));

    DEBUG_MSG("Adding wrapper for double mfem::GridFunction::GetValue(mfem::ElementTransformation &, const mfem::IntegrationPoint &, int, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunction::GetValue(mfem::ElementTransformation &, const mfem::IntegrationPoint &, int, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:220:19
    t.method("GetValue", static_cast<double (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &, int, mfem::Vector *)  const>(&mfem::GridFunction::GetValue));
    t.method("GetValue", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1)->double { return a.GetValue(arg0, arg1); });
    t.method("GetValue", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1, int arg2)->double { return a.GetValue(arg0, arg1, arg2); });
    t.method("GetValue", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1)->double { return a->GetValue(arg0, arg1); });
    t.method("GetValue", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1, int arg2)->double { return a->GetValue(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorValue(mfem::ElementTransformation &, const mfem::IntegrationPoint &, mfem::Vector &, mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorValue(mfem::ElementTransformation &, const mfem::IntegrationPoint &, mfem::Vector &, mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:225:17
    t.method("GetVectorValue", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &, mfem::Vector &, mfem::Vector *)  const>(&mfem::GridFunction::GetVectorValue));
    t.method("GetVectorValue", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1, mfem::Vector & arg2)->void { a.GetVectorValue(arg0, arg1, arg2); });
    t.method("GetVectorValue", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationPoint & arg1, mfem::Vector & arg2)->void { a->GetVectorValue(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetValues(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::Vector &, int, mfem::DenseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetValues(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::Vector &, int, mfem::DenseMatrix *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:248:9
    t.method("GetValues", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::Vector &, int, mfem::DenseMatrix *)  const>(&mfem::GridFunction::GetValues));
    t.method("GetValues", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a.GetValues(arg0, arg1, arg2); });
    t.method("GetValues", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, int arg3)->void { a.GetValues(arg0, arg1, arg2, arg3); });
    t.method("GetValues", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a->GetValues(arg0, arg1, arg2); });
    t.method("GetValues", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, int arg3)->void { a->GetValues(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorValues(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorValues(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:253:9
    t.method("GetVectorValues", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix *)  const>(&mfem::GridFunction::GetVectorValues));
    t.method("GetVectorValues", [](mfem::GridFunction const& a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2)->void { a.GetVectorValues(arg0, arg1, arg2); });
    t.method("GetVectorValues", [](mfem::GridFunction const* a, mfem::ElementTransformation & arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2)->void { a->GetVectorValues(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for int mfem::GridFunction::GetFaceValues(int, int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GridFunction::GetFaceValues(int, int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:275:8
    t.method("GetFaceValues", static_cast<int (mfem::GridFunction::*)(int, int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetFaceValues));
    t.method("GetFaceValues", [](mfem::GridFunction const& a, int arg0, int arg1, const mfem::IntegrationRule & arg2, mfem::Vector & arg3, mfem::DenseMatrix & arg4)->int { return a.GetFaceValues(arg0, arg1, arg2, arg3, arg4); });
    t.method("GetFaceValues", [](mfem::GridFunction const* a, int arg0, int arg1, const mfem::IntegrationRule & arg2, mfem::Vector & arg3, mfem::DenseMatrix & arg4)->int { return a->GetFaceValues(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for int mfem::GridFunction::GetFaceVectorValues(int, int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GridFunction::GetFaceVectorValues(int, int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:280:8
    t.method("GetFaceVectorValues", static_cast<int (mfem::GridFunction::*)(int, int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetFaceVectorValues));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetLaplacians(int, const mfem::IntegrationRule &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetLaplacians(int, const mfem::IntegrationRule &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:284:9
    t.method("GetLaplacians", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::Vector &, int)  const>(&mfem::GridFunction::GetLaplacians));
    t.method("GetLaplacians", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a.GetLaplacians(arg0, arg1, arg2); });
    t.method("GetLaplacians", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2)->void { a->GetLaplacians(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetLaplacians(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetLaplacians(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:287:9
    t.method("GetLaplacians", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::Vector &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetLaplacians));
    t.method("GetLaplacians", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, mfem::DenseMatrix & arg3)->void { a.GetLaplacians(arg0, arg1, arg2, arg3); });
    t.method("GetLaplacians", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::Vector & arg2, mfem::DenseMatrix & arg3)->void { a->GetLaplacians(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetHessians(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetHessians(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:290:9
    t.method("GetHessians", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetHessians));
    t.method("GetHessians", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2)->void { a.GetHessians(arg0, arg1, arg2); });
    t.method("GetHessians", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2)->void { a->GetHessians(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetHessians(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetHessians(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:293:9
    t.method("GetHessians", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetHessians));
    t.method("GetHessians", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2, mfem::DenseMatrix & arg3)->void { a.GetHessians(arg0, arg1, arg2, arg3); });
    t.method("GetHessians", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2, mfem::DenseMatrix & arg3)->void { a->GetHessians(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetValuesFrom(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetValuesFrom(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:296:9
    t.method("GetValuesFrom", static_cast<void (mfem::GridFunction::*)(const mfem::GridFunction &) >(&mfem::GridFunction::GetValuesFrom));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetBdrValuesFrom(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetBdrValuesFrom(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:298:9
    t.method("GetBdrValuesFrom", static_cast<void (mfem::GridFunction::*)(const mfem::GridFunction &) >(&mfem::GridFunction::GetBdrValuesFrom));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorFieldValues(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorFieldValues(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:300:9
    t.method("GetVectorFieldValues", static_cast<void (mfem::GridFunction::*)(int, const mfem::IntegrationRule &, mfem::DenseMatrix &, mfem::DenseMatrix &, int)  const>(&mfem::GridFunction::GetVectorFieldValues));
    t.method("GetVectorFieldValues", [](mfem::GridFunction const& a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2, mfem::DenseMatrix & arg3)->void { a.GetVectorFieldValues(arg0, arg1, arg2, arg3); });
    t.method("GetVectorFieldValues", [](mfem::GridFunction const* a, int arg0, const mfem::IntegrationRule & arg1, mfem::DenseMatrix & arg2, mfem::DenseMatrix & arg3)->void { a->GetVectorFieldValues(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ReorderByNodes() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ReorderByNodes()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:305:9
    t.method("ReorderByNodes", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::ReorderByNodes));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetNodalValues(mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetNodalValues(mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:308:9
    t.method("GetNodalValues", static_cast<void (mfem::GridFunction::*)(mfem::Vector &, int)  const>(&mfem::GridFunction::GetNodalValues));
    t.method("GetNodalValues", [](mfem::GridFunction const& a, mfem::Vector & arg0)->void { a.GetNodalValues(arg0); });
    t.method("GetNodalValues", [](mfem::GridFunction const* a, mfem::Vector & arg0)->void { a->GetNodalValues(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorFieldNodalValues(mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorFieldNodalValues(mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:310:9
    t.method("GetVectorFieldNodalValues", static_cast<void (mfem::GridFunction::*)(mfem::Vector &, int)  const>(&mfem::GridFunction::GetVectorFieldNodalValues));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectVectorFieldOn(mfem::GridFunction &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectVectorFieldOn(mfem::GridFunction &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:312:9
    t.method("ProjectVectorFieldOn", static_cast<void (mfem::GridFunction::*)(mfem::GridFunction &, int) >(&mfem::GridFunction::ProjectVectorFieldOn));
    t.method("ProjectVectorFieldOn", [](mfem::GridFunction& a, mfem::GridFunction & arg0)->void { a.ProjectVectorFieldOn(arg0); });
    t.method("ProjectVectorFieldOn", [](mfem::GridFunction* a, mfem::GridFunction & arg0)->void { a->ProjectVectorFieldOn(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetDerivative(int, int, mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetDerivative(int, int, mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:324:9
    t.method("GetDerivative", static_cast<void (mfem::GridFunction::*)(int, int, mfem::GridFunction &) >(&mfem::GridFunction::GetDerivative));

    DEBUG_MSG("Adding wrapper for double mfem::GridFunction::GetDivergence(mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunction::GetDivergence(mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:326:11
    t.method("GetDivergence", static_cast<double (mfem::GridFunction::*)(mfem::ElementTransformation &)  const>(&mfem::GridFunction::GetDivergence));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetCurl(mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetCurl(mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:328:9
    t.method("GetCurl", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, mfem::Vector &)  const>(&mfem::GridFunction::GetCurl));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetGradient(mfem::ElementTransformation &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetGradient(mfem::ElementTransformation &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:339:9
    t.method("GetGradient", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, mfem::Vector &)  const>(&mfem::GridFunction::GetGradient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetGradients(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetGradients(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:342:9
    t.method("GetGradients", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, const mfem::IntegrationRule &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetGradients));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetGradients(const int, const mfem::IntegrationRule &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetGradients(const int, const mfem::IntegrationRule &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:346:9
    t.method("GetGradients", static_cast<void (mfem::GridFunction::*)(const int, const mfem::IntegrationRule &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetGradients));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorGradient(mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorGradient(mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:352:9
    t.method("GetVectorGradient", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetVectorGradient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetVectorGradientHat(mfem::ElementTransformation &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetVectorGradientHat(mfem::ElementTransformation &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:356:9
    t.method("GetVectorGradientHat", static_cast<void (mfem::GridFunction::*)(mfem::ElementTransformation &, mfem::DenseMatrix &)  const>(&mfem::GridFunction::GetVectorGradientHat));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetElementAverages(mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetElementAverages(mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:361:9
    t.method("GetElementAverages", static_cast<void (mfem::GridFunction::*)(mfem::GridFunction &)  const>(&mfem::GridFunction::GetElementAverages));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::GetElementDofValues(int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::GetElementDofValues(int, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:365:17
    t.method("GetElementDofValues", static_cast<void (mfem::GridFunction::*)(int, mfem::Vector &)  const>(&mfem::GridFunction::GetElementDofValues));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ImposeBounds(int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ImposeBounds(int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:371:9
    t.method("ImposeBounds", static_cast<void (mfem::GridFunction::*)(int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &) >(&mfem::GridFunction::ImposeBounds));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ImposeBounds(int, const mfem::Vector &, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ImposeBounds(int, const mfem::Vector &, double, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:373:9
    t.method("ImposeBounds", static_cast<void (mfem::GridFunction::*)(int, const mfem::Vector &, double, double) >(&mfem::GridFunction::ImposeBounds));
    t.method("ImposeBounds", [](mfem::GridFunction& a, int arg0, const mfem::Vector & arg1)->void { a.ImposeBounds(arg0, arg1); });
    t.method("ImposeBounds", [](mfem::GridFunction& a, int arg0, const mfem::Vector & arg1, double arg2)->void { a.ImposeBounds(arg0, arg1, arg2); });
    t.method("ImposeBounds", [](mfem::GridFunction* a, int arg0, const mfem::Vector & arg1)->void { a->ImposeBounds(arg0, arg1); });
    t.method("ImposeBounds", [](mfem::GridFunction* a, int arg0, const mfem::Vector & arg1, double arg2)->void { a->ImposeBounds(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::RestrictConforming() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::RestrictConforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:379:9
    t.method("RestrictConforming", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::RestrictConforming));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectGridFunction(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectGridFunction(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:385:9
    t.method("ProjectGridFunction", static_cast<void (mfem::GridFunction::*)(const mfem::GridFunction &) >(&mfem::GridFunction::ProjectGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::Coefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::Coefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:391:17
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::Coefficient &) >(&mfem::GridFunction::ProjectCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::Coefficient &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::Coefficient &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:396:9
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::Coefficient &, mfem::Array<int> &, int) >(&mfem::GridFunction::ProjectCoefficient));
    t.method("ProjectCoefficient", [](mfem::GridFunction& a, mfem::Coefficient & arg0, mfem::Array<int> & arg1)->void { a.ProjectCoefficient(arg0, arg1); });
    t.method("ProjectCoefficient", [](mfem::GridFunction* a, mfem::Coefficient & arg0, mfem::Array<int> & arg1)->void { a->ProjectCoefficient(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:402:9
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &) >(&mfem::GridFunction::ProjectCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:407:9
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectCoefficient(mfem::VectorCoefficient &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:411:9
    t.method("ProjectCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, int) >(&mfem::GridFunction::ProjectCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectDiscCoefficient(mfem::VectorCoefficient &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectDiscCoefficient(mfem::VectorCoefficient &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:420:17
    t.method("ProjectDiscCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &) >(&mfem::GridFunction::ProjectDiscCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectDiscCoefficient(mfem::Coefficient &, mfem::GridFunction::AvgType) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectDiscCoefficient(mfem::Coefficient &, mfem::GridFunction::AvgType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:425:17
    t.method("ProjectDiscCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::Coefficient &, mfem::GridFunction::AvgType) >(&mfem::GridFunction::ProjectDiscCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectDiscCoefficient(mfem::VectorCoefficient &, mfem::GridFunction::AvgType) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectDiscCoefficient(mfem::VectorCoefficient &, mfem::GridFunction::AvgType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:429:17
    t.method("ProjectDiscCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::GridFunction::AvgType) >(&mfem::GridFunction::ProjectDiscCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::CountElementsPerVDof(mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::CountElementsPerVDof(mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:463:17
    t.method("CountElementsPerVDof", static_cast<void (mfem::GridFunction::*)(mfem::Array<int> &)  const>(&mfem::GridFunction::CountElementsPerVDof));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectBdrCoefficient(mfem::Coefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectBdrCoefficient(mfem::Coefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:468:9
    t.method("ProjectBdrCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::Coefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectBdrCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectBdrCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectBdrCoefficient(mfem::VectorCoefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:477:17
    t.method("ProjectBdrCoefficient", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectBdrCoefficient));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectBdrCoefficientNormal(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectBdrCoefficientNormal(mfem::VectorCoefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:490:9
    t.method("ProjectBdrCoefficientNormal", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectBdrCoefficientNormal));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ProjectBdrCoefficientTangent(mfem::VectorCoefficient &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ProjectBdrCoefficientTangent(mfem::VectorCoefficient &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:496:17
    t.method("ProjectBdrCoefficientTangent", static_cast<void (mfem::GridFunction::*)(mfem::VectorCoefficient &, mfem::Array<int> &) >(&mfem::GridFunction::ProjectBdrCoefficientTangent));

    DEBUG_MSG("Adding wrapper for double mfem::GridFunction::ComputeH1Error(mfem::Coefficient *, mfem::VectorCoefficient *, mfem::Coefficient *, double, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::GridFunction::ComputeH1Error(mfem::Coefficient *, mfem::VectorCoefficient *, mfem::Coefficient *, double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:554:19
    t.method("ComputeH1Error", static_cast<double (mfem::GridFunction::*)(mfem::Coefficient *, mfem::VectorCoefficient *, mfem::Coefficient *, double, int)  const>(&mfem::GridFunction::ComputeH1Error));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::ComputeFlux(mfem::BilinearFormIntegrator &, mfem::GridFunction &, bool, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::ComputeFlux(mfem::BilinearFormIntegrator &, mfem::GridFunction &, bool, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:675:17
    t.method("ComputeFlux", static_cast<void (mfem::GridFunction::*)(mfem::BilinearFormIntegrator &, mfem::GridFunction &, bool, int) >(&mfem::GridFunction::ComputeFlux));
    t.method("ComputeFlux", [](mfem::GridFunction& a, mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1)->void { a.ComputeFlux(arg0, arg1); });
    t.method("ComputeFlux", [](mfem::GridFunction& a, mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, bool arg2)->void { a.ComputeFlux(arg0, arg1, arg2); });
    t.method("ComputeFlux", [](mfem::GridFunction* a, mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1)->void { a->ComputeFlux(arg0, arg1); });
    t.method("ComputeFlux", [](mfem::GridFunction* a, mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, bool arg2)->void { a->ComputeFlux(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::GridFunction & mfem::GridFunction::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction & mfem::GridFunction::operator=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:680:18
    t.method("assign", static_cast<mfem::GridFunction & (mfem::GridFunction::*)(double) >(&mfem::GridFunction::operator=));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction & mfem::GridFunction::operator=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction & mfem::GridFunction::operator=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:685:18
    t.method("assign", static_cast<mfem::GridFunction & (mfem::GridFunction::*)(const mfem::Vector &) >(&mfem::GridFunction::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::Update() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::Update()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:688:17
    t.method("Update", static_cast<void (mfem::GridFunction::*)() >(&mfem::GridFunction::Update));

    DEBUG_MSG("Adding wrapper for long mfem::GridFunction::GetSequence() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::GridFunction::GetSequence()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:692:9
    t.method("GetSequence", static_cast<long (mfem::GridFunction::*)()  const>(&mfem::GridFunction::GetSequence));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementSpace * mfem::GridFunction::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementSpace * mfem::GridFunction::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:694:24
    t.method("FESpace", static_cast<mfem::FiniteElementSpace * (mfem::GridFunction::*)() >(&mfem::GridFunction::FESpace));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementSpace * mfem::GridFunction::FESpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementSpace * mfem::GridFunction::FESpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:695:30
    t.method("FESpace", static_cast<const mfem::FiniteElementSpace * (mfem::GridFunction::*)()  const>(&mfem::GridFunction::FESpace));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::SetSpace(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::SetSpace(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:699:17
    t.method("SetSpace", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *) >(&mfem::GridFunction::SetSpace));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeRef(mfem::FiniteElementSpace *, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeRef(mfem::FiniteElementSpace *, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:708:17
    t.method("MakeRef", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *, double *) >(&mfem::GridFunction::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeRef(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeRef(mfem::FiniteElementSpace *, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:717:17
    t.method("MakeRef", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *, mfem::Vector &, int) >(&mfem::GridFunction::MakeRef));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeTRef(mfem::FiniteElementSpace *, double *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeTRef(mfem::FiniteElementSpace *, double *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:726:9
    t.method("MakeTRef", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *, double *) >(&mfem::GridFunction::MakeTRef));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::MakeTRef(mfem::FiniteElementSpace *, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::MakeTRef(mfem::FiniteElementSpace *, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:736:9
    t.method("MakeTRef", static_cast<void (mfem::GridFunction::*)(mfem::FiniteElementSpace *, mfem::Vector &, int) >(&mfem::GridFunction::MakeTRef));

    DEBUG_MSG("Adding wrapper for void mfem::GridFunction::Save(const char *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GridFunction::Save(const char *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:743:17
    t.method("Save", static_cast<void (mfem::GridFunction::*)(const char *, int)  const>(&mfem::GridFunction::Save));
    t.method("Save", [](mfem::GridFunction const& a, const char * arg0)->void { a.Save(arg0); });
    t.method("Save", [](mfem::GridFunction const* a, const char * arg0)->void { a->Save(arg0); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GridFunction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GridFunction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GridFunction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElementSpace> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElementSpace> : std::false_type { };
}

// Class generating the wrapper for type mfem::FiniteElementSpace
// signature to use in the veto file: mfem::FiniteElementSpace
struct Jlmfem_FiniteElementSpace: public Wrapper {

  Jlmfem_FiniteElementSpace(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElementSpace (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:219:7
    jlcxx::TypeWrapper<mfem::FiniteElementSpace>  t = jlModule.add_type<mfem::FiniteElementSpace>("mfem!FiniteElementSpace");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementSpace>>(new jlcxx::TypeWrapper<mfem::FiniteElementSpace>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::FiniteElementSpace(const mfem::FiniteElementSpace &, mfem::Mesh *, const mfem::FiniteElementCollection *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:538:4
    t.constructor<const mfem::FiniteElementSpace &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::FiniteElementSpace &, mfem::Mesh *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const mfem::FiniteElementSpace &, mfem::Mesh *, const mfem::FiniteElementCollection *>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::FiniteElementSpace(mfem::Mesh *, const mfem::FiniteElementCollection *, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:541:4
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Mesh *, const mfem::FiniteElementCollection *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::FiniteElementSpace(mfem::Mesh *, mfem::NURBSExtension *, const mfem::FiniteElementCollection *, int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:550:4
    t.constructor<mfem::Mesh *, mfem::NURBSExtension *, const mfem::FiniteElementCollection *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Mesh *, mfem::NURBSExtension *, const mfem::FiniteElementCollection *, int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::Mesh *, mfem::NURBSExtension *, const mfem::FiniteElementCollection *, int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::FiniteElementSpace::GetMesh() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::FiniteElementSpace::GetMesh()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:559:17
    t.method("GetMesh", static_cast<mfem::Mesh * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetMesh));

    DEBUG_MSG("Adding wrapper for const mfem::NURBSExtension * mfem::FiniteElementSpace::GetNURBSext() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::NURBSExtension * mfem::FiniteElementSpace::GetNURBSext()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:561:26
    t.method("GetNURBSext", static_cast<const mfem::NURBSExtension * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNURBSext));

    DEBUG_MSG("Adding wrapper for mfem::NURBSExtension * mfem::FiniteElementSpace::GetNURBSext() (" __HERE__ ")");
    // signature to use in the veto list: mfem::NURBSExtension * mfem::FiniteElementSpace::GetNURBSext()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:562:20
    t.method("GetNURBSext", static_cast<mfem::NURBSExtension * (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::GetNURBSext));

    DEBUG_MSG("Adding wrapper for mfem::NURBSExtension * mfem::FiniteElementSpace::StealNURBSext() (" __HERE__ ")");
    // signature to use in the veto list: mfem::NURBSExtension * mfem::FiniteElementSpace::StealNURBSext()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:563:20
    t.method("StealNURBSext", static_cast<mfem::NURBSExtension * (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::StealNURBSext));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::Conforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::Conforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:565:9
    t.method("Conforming", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::Conforming));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::Nonconforming() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::Nonconforming()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:566:9
    t.method("Nonconforming", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::Nonconforming));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetElementOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetElementOrder(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:571:9
    t.method("SetElementOrder", static_cast<void (mfem::FiniteElementSpace::*)(int, int) >(&mfem::FiniteElementSpace::SetElementOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementOrder(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:574:8
    t.method("GetElementOrder", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetMaxElementOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetMaxElementOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:577:8
    t.method("GetMaxElementOrder", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetMaxElementOrder));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::IsVariableOrder() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::IsVariableOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:581:9
    t.method("IsVariableOrder", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::IsVariableOrder));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingProlongation() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingProlongation()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:584:24
    t.method("GetConformingProlongation", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingProlongation));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetConformingRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:587:24
    t.method("GetConformingRestriction", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpConformingRestriction() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpConformingRestriction()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:594:24
    t.method("GetHpConformingRestriction", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetHpConformingRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetProlongationMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetProlongationMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:597:28
    t.method("GetProlongationMatrix", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetProlongationMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionTransposeOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionTransposeOperator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:611:20
    t.method("GetRestrictionTransposeOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionTransposeOperator));

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetRestrictionOperator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:616:28
    t.method("GetRestrictionOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionOperator));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetRestrictionMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetRestrictionMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:620:32
    t.method("GetRestrictionMatrix", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpRestrictionMatrix() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::SparseMatrix * mfem::FiniteElementSpace::GetHpRestrictionMatrix()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:624:32
    t.method("GetHpRestrictionMatrix", static_cast<const mfem::SparseMatrix * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetHpRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for const mfem::ElementRestrictionOperator * mfem::FiniteElementSpace::GetElementRestriction(mfem::ElementDofOrdering) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::ElementRestrictionOperator * mfem::FiniteElementSpace::GetElementRestriction(mfem::ElementDofOrdering)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:644:38
    t.method("GetElementRestriction", static_cast<const mfem::ElementRestrictionOperator * (mfem::FiniteElementSpace::*)(mfem::ElementDofOrdering)  const>(&mfem::FiniteElementSpace::GetElementRestriction));

    DEBUG_MSG("Adding wrapper for const mfem::FaceRestriction * mfem::FiniteElementSpace::GetFaceRestriction(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FaceRestriction * mfem::FiniteElementSpace::GetFaceRestriction(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:648:35
    t.method("GetFaceRestriction", static_cast<const mfem::FaceRestriction * (mfem::FiniteElementSpace::*)(mfem::ElementDofOrdering, mfem::FaceType, mfem::L2FaceValues)  const>(&mfem::FiniteElementSpace::GetFaceRestriction));
    t.method("GetFaceRestriction", [](mfem::FiniteElementSpace const& a, mfem::ElementDofOrdering arg0, mfem::FaceType arg1)->const mfem::FaceRestriction * { return a.GetFaceRestriction(arg0, arg1); });
    t.method("GetFaceRestriction", [](mfem::FiniteElementSpace const* a, mfem::ElementDofOrdering arg0, mfem::FaceType arg1)->const mfem::FaceRestriction * { return a->GetFaceRestriction(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureInterpolator * mfem::FiniteElementSpace::GetQuadratureInterpolator(const mfem::IntegrationRule &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureInterpolator * mfem::FiniteElementSpace::GetQuadratureInterpolator(const mfem::IntegrationRule &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:665:34
    t.method("GetQuadratureInterpolator", static_cast<const mfem::QuadratureInterpolator * (mfem::FiniteElementSpace::*)(const mfem::IntegrationRule &)  const>(&mfem::FiniteElementSpace::GetQuadratureInterpolator));

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureInterpolator * mfem::FiniteElementSpace::GetQuadratureInterpolator(const mfem::QuadratureSpace &) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureInterpolator * mfem::FiniteElementSpace::GetQuadratureInterpolator(const mfem::QuadratureSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:681:34
    t.method("GetQuadratureInterpolator", static_cast<const mfem::QuadratureInterpolator * (mfem::FiniteElementSpace::*)(const mfem::QuadratureSpace &)  const>(&mfem::FiniteElementSpace::GetQuadratureInterpolator));

    DEBUG_MSG("Adding wrapper for const mfem::FaceQuadratureInterpolator * mfem::FiniteElementSpace::GetFaceQuadratureInterpolator(const mfem::IntegrationRule &, mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FaceQuadratureInterpolator * mfem::FiniteElementSpace::GetFaceQuadratureInterpolator(const mfem::IntegrationRule &, mfem::FaceType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:691:38
    t.method("GetFaceQuadratureInterpolator", static_cast<const mfem::FaceQuadratureInterpolator * (mfem::FiniteElementSpace::*)(const mfem::IntegrationRule &, mfem::FaceType)  const>(&mfem::FiniteElementSpace::GetFaceQuadratureInterpolator));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetOrder(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:696:8
    t.method("GetOrder", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetOrder));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetEdgeOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetEdgeOrder(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:700:8
    t.method("GetEdgeOrder", static_cast<int (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetEdgeOrder));
    t.method("GetEdgeOrder", [](mfem::FiniteElementSpace const& a, int arg0)->int { return a.GetEdgeOrder(arg0); });
    t.method("GetEdgeOrder", [](mfem::FiniteElementSpace const* a, int arg0)->int { return a->GetEdgeOrder(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetFaceOrder(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetFaceOrder(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:703:8
    t.method("GetFaceOrder", static_cast<int (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetFaceOrder));
    t.method("GetFaceOrder", [](mfem::FiniteElementSpace const& a, int arg0)->int { return a.GetFaceOrder(arg0); });
    t.method("GetFaceOrder", [](mfem::FiniteElementSpace const* a, int arg0)->int { return a->GetFaceOrder(arg0); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetVDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:706:15
    t.method("GetVDim", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetVDim));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:710:15
    t.method("GetNDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetVSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:713:15
    t.method("GetVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetVSize));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetTrueVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetTrueVSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:716:16
    t.method("GetTrueVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetTrueVSize));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNConformingDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNConformingDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:720:8
    t.method("GetNConformingDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNConformingDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetConformingVSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetConformingVSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:722:8
    t.method("GetConformingVSize", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetConformingVSize));

    DEBUG_MSG("Adding wrapper for mfem::Ordering::Type mfem::FiniteElementSpace::GetOrdering() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Ordering::Type mfem::FiniteElementSpace::GetOrdering()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:725:26
    t.method("GetOrdering", static_cast<mfem::Ordering::Type (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetOrdering));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElementCollection * mfem::FiniteElementSpace::FEColl() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElementCollection * mfem::FiniteElementSpace::FEColl()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:727:35
    t.method("FEColl", static_cast<const mfem::FiniteElementCollection * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::FEColl));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNVDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNVDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:730:8
    t.method("GetNVDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNVDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNEDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNEDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:732:8
    t.method("GetNEDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNEDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNFDofs() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNFDofs()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:734:8
    t.method("GetNFDofs", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNFDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNV()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:737:15
    t.method("GetNV", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNV));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:740:15
    t.method("GetNE", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNF() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNF()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:746:15
    t.method("GetNF", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNF));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNBE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNBE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:749:15
    t.method("GetNBE", static_cast<int (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetNBE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNFbyType(mfem::FaceType) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNFbyType(mfem::FaceType)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:757:15
    t.method("GetNFbyType", static_cast<int (mfem::FiniteElementSpace::*)(mfem::FaceType)  const>(&mfem::FiniteElementSpace::GetNFbyType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:761:15
    t.method("GetElementType", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementType));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementVertices(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementVertices(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:765:16
    t.method("GetElementVertices", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementVertices));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetBdrElementType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetBdrElementType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:769:15
    t.method("GetBdrElementType", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrElementType));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::FiniteElementSpace::GetElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::FiniteElementSpace::GetElementTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:773:27
    t.method("GetElementTransformation", static_cast<mfem::ElementTransformation * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementTransformation(int, mfem::IsoparametricTransformation *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementTransformation(int, mfem::IsoparametricTransformation *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:778:9
    t.method("GetElementTransformation", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::IsoparametricTransformation *) >(&mfem::FiniteElementSpace::GetElementTransformation));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::FiniteElementSpace::GetBdrElementTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::FiniteElementSpace::GetBdrElementTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:782:27
    t.method("GetBdrElementTransformation", static_cast<mfem::ElementTransformation * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrElementTransformation));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:785:8
    t.method("GetAttribute", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetAttribute));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetBdrAttribute(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetBdrAttribute(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:787:8
    t.method("GetBdrAttribute", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBdrAttribute));

    DEBUG_MSG("Adding wrapper for mfem::DofTransformation * mfem::FiniteElementSpace::GetElementDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DofTransformation * mfem::FiniteElementSpace::GetElementDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:810:23
    t.method("GetElementDofs", static_cast<mfem::DofTransformation * (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementDofs(int, mfem::Array<int> &, mfem::DofTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementDofs(int, mfem::Array<int> &, mfem::DofTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:818:17
    t.method("GetElementDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, mfem::DofTransformation &)  const>(&mfem::FiniteElementSpace::GetElementDofs));

    DEBUG_MSG("Adding wrapper for mfem::DofTransformation * mfem::FiniteElementSpace::GetBdrElementDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DofTransformation * mfem::FiniteElementSpace::GetBdrElementDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:833:23
    t.method("GetBdrElementDofs", static_cast<mfem::DofTransformation * (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetBdrElementDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetBdrElementDofs(int, mfem::Array<int> &, mfem::DofTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetBdrElementDofs(int, mfem::Array<int> &, mfem::DofTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:841:17
    t.method("GetBdrElementDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, mfem::DofTransformation &)  const>(&mfem::FiniteElementSpace::GetBdrElementDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetFaceDofs(int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetFaceDofs(int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:854:16
    t.method("GetFaceDofs", static_cast<int (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetFaceDofs));
    t.method("GetFaceDofs", [](mfem::FiniteElementSpace const& a, int arg0, mfem::Array<int> & arg1)->int { return a.GetFaceDofs(arg0, arg1); });
    t.method("GetFaceDofs", [](mfem::FiniteElementSpace const* a, int arg0, mfem::Array<int> & arg1)->int { return a->GetFaceDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetEdgeDofs(int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetEdgeDofs(int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:868:8
    t.method("GetEdgeDofs", static_cast<int (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetEdgeDofs));
    t.method("GetEdgeDofs", [](mfem::FiniteElementSpace const& a, int arg0, mfem::Array<int> & arg1)->int { return a.GetEdgeDofs(arg0, arg1); });
    t.method("GetEdgeDofs", [](mfem::FiniteElementSpace const* a, int arg0, mfem::Array<int> & arg1)->int { return a->GetEdgeDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetVertexDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetVertexDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:875:9
    t.method("GetVertexDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetVertexDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementInteriorDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementInteriorDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:887:9
    t.method("GetElementInteriorDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementInteriorDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetNumElementInteriorDofs(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetNumElementInteriorDofs(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:894:8
    t.method("GetNumElementInteriorDofs", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetNumElementInteriorDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetFaceInteriorDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetFaceInteriorDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:906:9
    t.method("GetFaceInteriorDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetFaceInteriorDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEdgeInteriorDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEdgeInteriorDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:913:9
    t.method("GetEdgeInteriorDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetEdgeInteriorDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetPatchDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetPatchDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:919:9
    t.method("GetPatchDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetPatchDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetVDofs(int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetVDofs(int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:951:9
    t.method("GetVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetVDofs));
    t.method("GetVDofs", [](mfem::FiniteElementSpace const& a, int arg0, mfem::Array<int> & arg1)->void { a.GetVDofs(arg0, arg1); });
    t.method("GetVDofs", [](mfem::FiniteElementSpace const* a, int arg0, mfem::Array<int> & arg1)->void { a->GetVDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::DofsToVDofs(mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::DofsToVDofs(mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:967:9
    t.method("DofsToVDofs", static_cast<void (mfem::FiniteElementSpace::*)(mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::DofsToVDofs));
    t.method("DofsToVDofs", [](mfem::FiniteElementSpace const& a, mfem::Array<int> & arg0)->void { a.DofsToVDofs(arg0); });
    t.method("DofsToVDofs", [](mfem::FiniteElementSpace const* a, mfem::Array<int> & arg0)->void { a->DofsToVDofs(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::DofsToVDofs(int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::DofsToVDofs(int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:979:9
    t.method("DofsToVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::DofsToVDofs));
    t.method("DofsToVDofs", [](mfem::FiniteElementSpace const& a, int arg0, mfem::Array<int> & arg1)->void { a.DofsToVDofs(arg0, arg1); });
    t.method("DofsToVDofs", [](mfem::FiniteElementSpace const* a, int arg0, mfem::Array<int> & arg1)->void { a->DofsToVDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DofToVDof(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DofToVDof(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:988:8
    t.method("DofToVDof", static_cast<int (mfem::FiniteElementSpace::*)(int, int, int)  const>(&mfem::FiniteElementSpace::DofToVDof));
    t.method("DofToVDof", [](mfem::FiniteElementSpace const& a, int arg0, int arg1)->int { return a.DofToVDof(arg0, arg1); });
    t.method("DofToVDof", [](mfem::FiniteElementSpace const* a, int arg0, int arg1)->int { return a->DofToVDof(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::VDofToDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::VDofToDof(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:995:8
    t.method("VDofToDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::VDofToDof));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::AdjustVDofs(mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::AdjustVDofs(mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1010:16
    module_.method("mfem!FiniteElementSpace!AdjustVDofs", static_cast<void (*)(mfem::Array<int> &) >(&mfem::FiniteElementSpace::AdjustVDofs));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::EncodeDof(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::EncodeDof(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1013:22
    module_.method("mfem!FiniteElementSpace!EncodeDof", static_cast<int (*)(int, int) >(&mfem::FiniteElementSpace::EncodeDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DecodeDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DecodeDof(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1017:22
    module_.method("mfem!FiniteElementSpace!DecodeDof", static_cast<int (*)(int) >(&mfem::FiniteElementSpace::DecodeDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::DecodeDof(int, double &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::DecodeDof(int, double &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1021:22
    module_.method("mfem!FiniteElementSpace!DecodeDof", static_cast<int (*)(int, double &) >(&mfem::FiniteElementSpace::DecodeDof));

    DEBUG_MSG("Adding wrapper for mfem::DofTransformation * mfem::FiniteElementSpace::GetElementVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DofTransformation * mfem::FiniteElementSpace::GetElementVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1045:23
    t.method("GetElementVDofs", static_cast<mfem::DofTransformation * (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementVDofs(int, mfem::Array<int> &, mfem::DofTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementVDofs(int, mfem::Array<int> &, mfem::DofTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1053:9
    t.method("GetElementVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, mfem::DofTransformation &)  const>(&mfem::FiniteElementSpace::GetElementVDofs));

    DEBUG_MSG("Adding wrapper for mfem::DofTransformation * mfem::FiniteElementSpace::GetBdrElementVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DofTransformation * mfem::FiniteElementSpace::GetBdrElementVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1069:23
    t.method("GetBdrElementVDofs", static_cast<mfem::DofTransformation * (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetBdrElementVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetBdrElementVDofs(int, mfem::Array<int> &, mfem::DofTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetBdrElementVDofs(int, mfem::Array<int> &, mfem::DofTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1077:9
    t.method("GetBdrElementVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &, mfem::DofTransformation &)  const>(&mfem::FiniteElementSpace::GetBdrElementVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetPatchVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetPatchVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1081:9
    t.method("GetPatchVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetPatchVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetFaceVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetFaceVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1088:9
    t.method("GetFaceVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetFaceVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEdgeVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEdgeVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1095:9
    t.method("GetEdgeVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetEdgeVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetVertexVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetVertexVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1102:9
    t.method("GetVertexVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetVertexVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetElementInteriorVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetElementInteriorVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1110:9
    t.method("GetElementInteriorVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetElementInteriorVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEdgeInteriorVDofs(int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEdgeInteriorVDofs(int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1117:9
    t.method("GetEdgeInteriorVDofs", static_cast<void (mfem::FiniteElementSpace::*)(int, mfem::Array<int> &)  const>(&mfem::FiniteElementSpace::GetEdgeInteriorVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::RebuildElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::RebuildElementToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1121:25
    t.method("RebuildElementToDofTable", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::RebuildElementToDofTable));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ReorderElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ReorderElementToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1130:9
    t.method("ReorderElementToDofTable", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::ReorderElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table * mfem::FiniteElementSpace::GetElementToFaceOrientationTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table * mfem::FiniteElementSpace::GetElementToFaceOrientationTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1132:17
    t.method("GetElementToFaceOrientationTable", static_cast<const mfem::Table * (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetElementToFaceOrientationTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetElementToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1136:17
    t.method("GetElementToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetBdrElementToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetBdrElementToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1141:17
    t.method("GetBdrElementToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetBdrElementToDofTable));

    DEBUG_MSG("Adding wrapper for const mfem::Table & mfem::FiniteElementSpace::GetFaceToDofTable() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Table & mfem::FiniteElementSpace::GetFaceToDofTable()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1149:17
    t.method("GetFaceToDofTable", static_cast<const mfem::Table & (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetFaceToDofTable));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::BuildDofToArrays() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::BuildDofToArrays()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1154:9
    t.method("BuildDofToArrays", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::BuildDofToArrays));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetElementForDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetElementForDof(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1159:8
    t.method("GetElementForDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetElementForDof));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementSpace::GetLocalDofForDof(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementSpace::GetLocalDofForDof(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1163:8
    t.method("GetLocalDofForDof", static_cast<int (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetLocalDofForDof));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetFE(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetFE(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1169:33
    t.method("GetFE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetFE));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetBE(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetBE(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1173:25
    t.method("GetBE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetBE));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetFaceElement(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetFaceElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1179:25
    t.method("GetFaceElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int)  const>(&mfem::FiniteElementSpace::GetFaceElement));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetEdgeElement(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetEdgeElement(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1183:25
    t.method("GetEdgeElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int, int)  const>(&mfem::FiniteElementSpace::GetEdgeElement));
    t.method("GetEdgeElement", [](mfem::FiniteElementSpace const& a, int arg0)->const mfem::FiniteElement * { return a.GetEdgeElement(arg0); });
    t.method("GetEdgeElement", [](mfem::FiniteElementSpace const* a, int arg0)->const mfem::FiniteElement * { return a->GetEdgeElement(arg0); });

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementSpace::GetTraceElement(int, mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementSpace::GetTraceElement(int, mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1186:25
    t.method("GetTraceElement", static_cast<const mfem::FiniteElement * (mfem::FiniteElementSpace::*)(int, mfem::Geometry::Type)  const>(&mfem::FiniteElementSpace::GetTraceElement));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEssentialVDofs(const mfem::Array<int> &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEssentialVDofs(const mfem::Array<int> &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1192:17
    t.method("GetEssentialVDofs", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::Array<int> &, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetEssentialVDofs));
    t.method("GetEssentialVDofs", [](mfem::FiniteElementSpace const& a, const mfem::Array<int> & arg0, mfem::Array<int> & arg1)->void { a.GetEssentialVDofs(arg0, arg1); });
    t.method("GetEssentialVDofs", [](mfem::FiniteElementSpace const* a, const mfem::Array<int> & arg0, mfem::Array<int> & arg1)->void { a->GetEssentialVDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetEssentialTrueDofs(const mfem::Array<int> &, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetEssentialTrueDofs(const mfem::Array<int> &, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1200:17
    t.method("GetEssentialTrueDofs", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::Array<int> &, mfem::Array<int> &, int)  const>(&mfem::FiniteElementSpace::GetEssentialTrueDofs));
    t.method("GetEssentialTrueDofs", [](mfem::FiniteElementSpace const& a, const mfem::Array<int> & arg0, mfem::Array<int> & arg1)->void { a.GetEssentialTrueDofs(arg0, arg1); });
    t.method("GetEssentialTrueDofs", [](mfem::FiniteElementSpace const* a, const mfem::Array<int> & arg0, mfem::Array<int> & arg1)->void { a->GetEssentialTrueDofs(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetBoundaryTrueDofs(mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetBoundaryTrueDofs(mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1209:9
    t.method("GetBoundaryTrueDofs", static_cast<void (mfem::FiniteElementSpace::*)(mfem::Array<int> &, int) >(&mfem::FiniteElementSpace::GetBoundaryTrueDofs));
    t.method("GetBoundaryTrueDofs", [](mfem::FiniteElementSpace& a, mfem::Array<int> & arg0)->void { a.GetBoundaryTrueDofs(arg0); });
    t.method("GetBoundaryTrueDofs", [](mfem::FiniteElementSpace* a, mfem::Array<int> & arg0)->void { a->GetBoundaryTrueDofs(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::MarkerToList(const mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::MarkerToList(const mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1212:16
    module_.method("mfem!FiniteElementSpace!MarkerToList", static_cast<void (*)(const mfem::Array<int> &, mfem::Array<int> &) >(&mfem::FiniteElementSpace::MarkerToList));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ListToMarker(const mfem::Array<int> &, int, mfem::Array<int> &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ListToMarker(const mfem::Array<int> &, int, mfem::Array<int> &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1217:16
    module_.method("mfem!FiniteElementSpace!ListToMarker", static_cast<void (*)(const mfem::Array<int> &, int, mfem::Array<int> &, int) >(&mfem::FiniteElementSpace::ListToMarker));
    module_.method("mfem!FiniteElementSpace!ListToMarker", [](const mfem::Array<int> & arg0, int arg1, mfem::Array<int> & arg2)->void { mfem::FiniteElementSpace::ListToMarker(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ConvertToConformingVDofs(const mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ConvertToConformingVDofs(const mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1224:9
    t.method("ConvertToConformingVDofs", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::Array<int> &, mfem::Array<int> &) >(&mfem::FiniteElementSpace::ConvertToConformingVDofs));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::ConvertFromConformingVDofs(const mfem::Array<int> &, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::ConvertFromConformingVDofs(const mfem::Array<int> &, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1232:9
    t.method("ConvertFromConformingVDofs", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::Array<int> &, mfem::Array<int> &) >(&mfem::FiniteElementSpace::ConvertFromConformingVDofs));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1236:18
    t.method("D2C_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::D2C_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1240:18
    t.method("D2Const_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::D2Const_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix(mfem::FiniteElementSpace *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix(mfem::FiniteElementSpace *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1245:18
    t.method("H2L_GlobalRestrictionMatrix", static_cast<mfem::SparseMatrix * (mfem::FiniteElementSpace::*)(mfem::FiniteElementSpace *) >(&mfem::FiniteElementSpace::H2L_GlobalRestrictionMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1259:9
    t.method("GetTransferOperator", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)  const>(&mfem::FiniteElementSpace::GetTransferOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetTrueTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetTrueTransferOperator(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1276:17
    t.method("GetTrueTransferOperator", static_cast<void (mfem::FiniteElementSpace::*)(const mfem::FiniteElementSpace &, mfem::OperatorHandle &)  const>(&mfem::FiniteElementSpace::GetTrueTransferOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::Update(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::Update(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1282:17
    t.method("Update", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::Update));
    t.method("Update", [](mfem::FiniteElementSpace& a)->void { a.Update(); });
    t.method("Update", [](mfem::FiniteElementSpace* a)->void { a->Update(); });

    DEBUG_MSG("Adding wrapper for const mfem::Operator * mfem::FiniteElementSpace::GetUpdateOperator() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::Operator * mfem::FiniteElementSpace::GetUpdateOperator()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1285:20
    t.method("GetUpdateOperator", static_cast<const mfem::Operator * (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::GetUpdateOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::GetUpdateOperator(mfem::OperatorHandle &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::GetUpdateOperator(mfem::OperatorHandle &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1288:9
    t.method("GetUpdateOperator", static_cast<void (mfem::FiniteElementSpace::*)(mfem::OperatorHandle &) >(&mfem::FiniteElementSpace::GetUpdateOperator));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetUpdateOperatorOwner(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetUpdateOperatorOwner(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1295:9
    t.method("SetUpdateOperatorOwner", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::SetUpdateOperatorOwner));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetUpdateOperatorType(mfem::Operator::Type) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetUpdateOperatorType(mfem::Operator::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1303:9
    t.method("SetUpdateOperatorType", static_cast<void (mfem::FiniteElementSpace::*)(mfem::Operator::Type) >(&mfem::FiniteElementSpace::SetUpdateOperatorType));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::UpdatesFinished() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::UpdatesFinished()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1306:17
    t.method("UpdatesFinished", static_cast<void (mfem::FiniteElementSpace::*)() >(&mfem::FiniteElementSpace::UpdatesFinished));

    DEBUG_MSG("Adding wrapper for long mfem::FiniteElementSpace::GetSequence() (" __HERE__ ")");
    // signature to use in the veto list: long mfem::FiniteElementSpace::GetSequence()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1310:9
    t.method("GetSequence", static_cast<long (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::GetSequence));

    DEBUG_MSG("Adding wrapper for bool mfem::FiniteElementSpace::IsDGSpace() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::FiniteElementSpace::IsDGSpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1313:9
    t.method("IsDGSpace", static_cast<bool (mfem::FiniteElementSpace::*)()  const>(&mfem::FiniteElementSpace::IsDGSpace));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementSpace::SetRelaxedHpConformity(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementSpace::SetRelaxedHpConformity(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1327:9
    t.method("SetRelaxedHpConformity", static_cast<void (mfem::FiniteElementSpace::*)(bool) >(&mfem::FiniteElementSpace::SetRelaxedHpConformity));
    t.method("SetRelaxedHpConformity", [](mfem::FiniteElementSpace& a)->void { a.SetRelaxedHpConformity(); });
    t.method("SetRelaxedHpConformity", [](mfem::FiniteElementSpace* a)->void { a->SetRelaxedHpConformity(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementSpace>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElementSpace(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElementSpace(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Vertex> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Vertex> : std::false_type { };
}

// Class generating the wrapper for type mfem::Vertex
// signature to use in the veto file: mfem::Vertex
struct Jlmfem_Vertex: public Wrapper {

  Jlmfem_Vertex(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Vertex (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/vertex.hpp:22:7
    jlcxx::TypeWrapper<mfem::Vertex>  t = jlModule.add_type<mfem::Vertex>("mfem!Vertex");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Vertex>>(new jlcxx::TypeWrapper<mfem::Vertex>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Vertex>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Vertex(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Vertex(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::InverseElementTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::InverseElementTransformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::InverseElementTransformation
// signature to use in the veto file: mfem::InverseElementTransformation
struct Jlmfem_InverseElementTransformation: public Wrapper {

  Jlmfem_InverseElementTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::InverseElementTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/eltrans.hpp:185:7
    jlcxx::TypeWrapper<mfem::InverseElementTransformation>  t = jlModule.add_type<mfem::InverseElementTransformation>("mfem!InverseElementTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseElementTransformation>>(new jlcxx::TypeWrapper<mfem::InverseElementTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::InverseElementTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_InverseElementTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_InverseElementTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::IntegrationRule> : std::false_type { };
  template<> struct DefaultConstructible<mfem::IntegrationRule> : std::false_type { };
}

// Class generating the wrapper for type mfem::IntegrationRule
// signature to use in the veto file: mfem::IntegrationRule
struct Jlmfem_IntegrationRule: public Wrapper {

  Jlmfem_IntegrationRule(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::IntegrationRule (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/fe/../intrules.hpp:99:7
    jlcxx::TypeWrapper<mfem::IntegrationRule>  t = jlModule.add_type<mfem::IntegrationRule>("mfem!IntegrationRule");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRule>>(new jlcxx::TypeWrapper<mfem::IntegrationRule>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::IntegrationRule>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_IntegrationRule(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_IntegrationRule(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NodeExtrudeCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NodeExtrudeCoefficient> : std::false_type { };
template<> struct SuperType<mfem::NodeExtrudeCoefficient> { typedef mfem::VectorCoefficient type; };
}

// Class generating the wrapper for type mfem::NodeExtrudeCoefficient
// signature to use in the veto file: mfem::NodeExtrudeCoefficient
struct Jlmfem_NodeExtrudeCoefficient: public Wrapper {

  Jlmfem_NodeExtrudeCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NodeExtrudeCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2486:7
    jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>  t = jlModule.add_type<mfem::NodeExtrudeCoefficient>("mfem!NodeExtrudeCoefficient",
      jlcxx::julia_base_type<mfem::VectorCoefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>>(new jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::NodeExtrudeCoefficient(const int, const int, const double) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2493:4
    t.constructor<const int, const int, const double>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::SetLayer(const int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NodeExtrudeCoefficient::SetLayer(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2494:9
    t.method("SetLayer", static_cast<void (mfem::NodeExtrudeCoefficient::*)(const int) >(&mfem::NodeExtrudeCoefficient::SetLayer));

    DEBUG_MSG("Adding wrapper for void mfem::NodeExtrudeCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NodeExtrudeCoefficient::Eval(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2496:17
    t.method("Eval", static_cast<void (mfem::NodeExtrudeCoefficient::*)(mfem::Vector &, mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::NodeExtrudeCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NodeExtrudeCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NodeExtrudeCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NodeExtrudeCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FiniteElementCollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FiniteElementCollection> : std::false_type { };
}

// Class generating the wrapper for type mfem::FiniteElementCollection
// signature to use in the veto file: mfem::FiniteElementCollection
struct Jlmfem_FiniteElementCollection: public Wrapper {

  Jlmfem_FiniteElementCollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FiniteElementCollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:26:7
    jlcxx::TypeWrapper<mfem::FiniteElementCollection>  t = jlModule.add_type<mfem::FiniteElementCollection>("mfem!FiniteElementCollection");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementCollection>>(new jlcxx::TypeWrapper<mfem::FiniteElementCollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:52:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForDim(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::FiniteElementForDim(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:59:33
    t.method("FiniteElementForDim", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::FiniteElementForDim));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:61:16
    t.method("DofForGeometry", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::StatelessDofTransformation * mfem::FiniteElementCollection::DofTransformationForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::StatelessDofTransformation * mfem::FiniteElementCollection::DofTransformationForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:67:4
    t.method("DofTransformationForGeometry", static_cast<const mfem::StatelessDofTransformation * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::DofTransformationForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::FiniteElementCollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::FiniteElementCollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:76:23
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::FiniteElementCollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::FiniteElementCollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:79:24
    t.method("Name", [](mfem::FiniteElementCollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::FiniteElementCollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:81:16
    t.method("GetContType", static_cast<int (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetContType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetRangeType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetRangeType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:87:8
    t.method("GetRangeType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetRangeType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivRangeType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivRangeType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:88:8
    t.method("GetDerivRangeType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivRangeType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetMapType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetMapType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:89:8
    t.method("GetMapType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetMapType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:90:8
    t.method("GetDerivType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetDerivMapType(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetDerivMapType(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:91:8
    t.method("GetDerivMapType", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetDerivMapType));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetRangeDim(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetRangeDim(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:92:8
    t.method("GetRangeDim", static_cast<int (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::GetRangeDim));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::HasFaceDofs(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::HasFaceDofs(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:95:8
    t.method("HasFaceDofs", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::HasFaceDofs));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::TraceFiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::TraceFiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:97:33
    t.method("TraceFiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type)  const>(&mfem::FiniteElementCollection::TraceFiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:103:37
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::New(const char *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::New(const char *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:175:36
    module_.method("mfem!FiniteElementCollection!New", static_cast<mfem::FiniteElementCollection * (*)(const char *) >(&mfem::FiniteElementCollection::New));

    DEBUG_MSG("Adding wrapper for void mfem::FiniteElementCollection::SubDofOrder(mfem::Geometry::Type, int, int, mfem::Array<int> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FiniteElementCollection::SubDofOrder(mfem::Geometry::Type, int, int, mfem::Array<int> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:184:9
    t.method("SubDofOrder", static_cast<void (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int, int, mfem::Array<int> &)  const>(&mfem::FiniteElementCollection::SubDofOrder));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::FiniteElementCollection::GetFE(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::FiniteElementCollection::GetFE(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:191:25
    t.method("GetFE", static_cast<const mfem::FiniteElement * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::GetFE));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetNumDof(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetNumDof(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:203:8
    t.method("GetNumDof", static_cast<int (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int)  const>(&mfem::FiniteElementCollection::GetNumDof));

    DEBUG_MSG("Adding wrapper for const int * mfem::FiniteElementCollection::GetDofOrdering(mfem::Geometry::Type, int, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::FiniteElementCollection::GetDofOrdering(mfem::Geometry::Type, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:215:15
    t.method("GetDofOrdering", static_cast<const int * (mfem::FiniteElementCollection::*)(mfem::Geometry::Type, int, int)  const>(&mfem::FiniteElementCollection::GetDofOrdering));

    DEBUG_MSG("Adding wrapper for int mfem::FiniteElementCollection::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FiniteElementCollection::GetOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:225:8
    t.method("GetOrder", static_cast<int (mfem::FiniteElementCollection::*)()  const>(&mfem::FiniteElementCollection::GetOrder));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::FiniteElementCollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::FiniteElementCollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:232:37
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::FiniteElementCollection::*)(int)  const>(&mfem::FiniteElementCollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FiniteElementCollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FiniteElementCollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FiniteElementCollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::StatelessDofTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::StatelessDofTransformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::StatelessDofTransformation
// signature to use in the veto file: mfem::StatelessDofTransformation
struct Jlmfem_StatelessDofTransformation: public Wrapper {

  Jlmfem_StatelessDofTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::StatelessDofTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/doftrans.hpp:68:7
    jlcxx::TypeWrapper<mfem::StatelessDofTransformation>  t = jlModule.add_type<mfem::StatelessDofTransformation>("mfem!StatelessDofTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::StatelessDofTransformation>>(new jlcxx::TypeWrapper<mfem::StatelessDofTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::StatelessDofTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_StatelessDofTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_StatelessDofTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::H1_FECollection
// signature to use in the veto file: mfem::H1_FECollection
struct Jlmfem_H1_FECollection: public Wrapper {

  Jlmfem_H1_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:259:7
    jlcxx::TypeWrapper<mfem::H1_FECollection>  t = jlModule.add_type<mfem::H1_FECollection>("mfem!H1_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_FECollection>>(new jlcxx::TypeWrapper<mfem::H1_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1_FECollection::H1_FECollection(const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:269:13
    t.constructor<const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::H1_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::H1_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:273:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:275:8
    t.method("DofForGeometry", static_cast<int (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:278:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::H1_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::H1_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::H1_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:281:16
    t.method("Name", [](mfem::H1_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::H1_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:283:8
    t.method("GetContType", static_cast<int (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for int mfem::H1_FECollection::GetBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::H1_FECollection::GetBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:285:8
    t.method("GetBasisType", static_cast<int (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::H1_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::H1_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:287:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::H1_FECollection::*)()  const>(&mfem::H1_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:290:15
    t.method("GetDofMap", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::H1_FECollection::GetDofMap));

    DEBUG_MSG("Adding wrapper for const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::H1_FECollection::GetDofMap(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:292:15
    t.method("GetDofMap", static_cast<const int * (mfem::H1_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::H1_FECollection::GetDofMap));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::H1_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::H1_FECollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:294:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::H1_FECollection::*)(int)  const>(&mfem::H1_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1Pos_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1Pos_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1Pos_FECollection> { typedef mfem::H1_FECollection type; };
}

// Class generating the wrapper for type mfem::H1Pos_FECollection
// signature to use in the veto file: mfem::H1Pos_FECollection
struct Jlmfem_H1Pos_FECollection: public Wrapper {

  Jlmfem_H1Pos_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1Pos_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:302:7
    jlcxx::TypeWrapper<mfem::H1Pos_FECollection>  t = jlModule.add_type<mfem::H1Pos_FECollection>("mfem!H1Pos_FECollection",
      jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Pos_FECollection>>(new jlcxx::TypeWrapper<mfem::H1Pos_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1Pos_FECollection::H1Pos_FECollection(const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:305:13
    t.constructor<const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Pos_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1Pos_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1Pos_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1Ser_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1Ser_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1Ser_FECollection> { typedef mfem::H1_FECollection type; };
}

// Class generating the wrapper for type mfem::H1Ser_FECollection
// signature to use in the veto file: mfem::H1Ser_FECollection
struct Jlmfem_H1Ser_FECollection: public Wrapper {

  Jlmfem_H1Ser_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1Ser_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:311:7
    jlcxx::TypeWrapper<mfem::H1Ser_FECollection>  t = jlModule.add_type<mfem::H1Ser_FECollection>("mfem!H1Ser_FECollection",
      jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Ser_FECollection>>(new jlcxx::TypeWrapper<mfem::H1Ser_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1Ser_FECollection::H1Ser_FECollection(const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:314:13
    t.constructor<const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1Ser_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1Ser_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1Ser_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::H1_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::H1_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::H1_Trace_FECollection> { typedef mfem::H1_FECollection type; };
}

// Class generating the wrapper for type mfem::H1_Trace_FECollection
// signature to use in the veto file: mfem::H1_Trace_FECollection
struct Jlmfem_H1_Trace_FECollection: public Wrapper {

  Jlmfem_H1_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::H1_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:321:7
    jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>  t = jlModule.add_type<mfem::H1_Trace_FECollection>("mfem!H1_Trace_FECollection",
      jlcxx::julia_base_type<mfem::H1_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::H1_Trace_FECollection::H1_Trace_FECollection(const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:324:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::H1_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_H1_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_H1_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::L2_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::L2_FECollection> : std::false_type { };
template<> struct SuperType<mfem::L2_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::L2_FECollection
// signature to use in the veto file: mfem::L2_FECollection
struct Jlmfem_L2_FECollection: public Wrapper {

  Jlmfem_L2_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::L2_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:329:7
    jlcxx::TypeWrapper<mfem::L2_FECollection>  t = jlModule.add_type<mfem::L2_FECollection>("mfem!L2_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::L2_FECollection>>(new jlcxx::TypeWrapper<mfem::L2_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::L2_FECollection::L2_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:344:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::L2_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::L2_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:349:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:351:8
    t.method("DofForGeometry", static_cast<int (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::L2_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::L2_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:360:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::L2_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::L2_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::L2_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::L2_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:363:16
    t.method("Name", [](mfem::L2_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::L2_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:365:8
    t.method("GetContType", static_cast<int (mfem::L2_FECollection::*)()  const>(&mfem::L2_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::L2_FECollection::TraceFiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::L2_FECollection::TraceFiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:368:4
    t.method("TraceFiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::L2_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::L2_FECollection::TraceFiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::L2_FECollection::GetBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::L2_FECollection::GetBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:373:8
    t.method("GetBasisType", static_cast<int (mfem::L2_FECollection::*)()  const>(&mfem::L2_FECollection::GetBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::L2_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::L2_FECollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:375:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::L2_FECollection::*)(int)  const>(&mfem::L2_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::L2_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_L2_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_L2_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT_FECollection
// signature to use in the veto file: mfem::RT_FECollection
struct Jlmfem_RT_FECollection: public Wrapper {

  Jlmfem_RT_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:385:7
    jlcxx::TypeWrapper<mfem::RT_FECollection>  t = jlModule.add_type<mfem::RT_FECollection>("mfem!RT_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_FECollection::RT_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:413:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:418:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:420:8
    t.method("DofForGeometry", static_cast<int (mfem::RT_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:423:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:426:16
    t.method("Name", [](mfem::RT_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:428:8
    t.method("GetContType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:430:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetClosedBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetClosedBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:432:8
    t.method("GetClosedBasisType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetClosedBasisType));

    DEBUG_MSG("Adding wrapper for int mfem::RT_FECollection::GetOpenBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_FECollection::GetOpenBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:433:8
    t.method("GetOpenBasisType", static_cast<int (mfem::RT_FECollection::*)()  const>(&mfem::RT_FECollection::GetOpenBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_FECollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:435:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::RT_FECollection::*)(int)  const>(&mfem::RT_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_Trace_FECollection> { typedef mfem::RT_FECollection type; };
}

// Class generating the wrapper for type mfem::RT_Trace_FECollection
// signature to use in the veto file: mfem::RT_Trace_FECollection
struct Jlmfem_RT_Trace_FECollection: public Wrapper {

  Jlmfem_RT_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:444:7
    jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>  t = jlModule.add_type<mfem::RT_Trace_FECollection>("mfem!RT_Trace_FECollection",
      jlcxx::julia_base_type<mfem::RT_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_Trace_FECollection::RT_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:447:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DG_Interface_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DG_Interface_FECollection> : std::false_type { };
template<> struct SuperType<mfem::DG_Interface_FECollection> { typedef mfem::RT_FECollection type; };
}

// Class generating the wrapper for type mfem::DG_Interface_FECollection
// signature to use in the veto file: mfem::DG_Interface_FECollection
struct Jlmfem_DG_Interface_FECollection: public Wrapper {

  Jlmfem_DG_Interface_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DG_Interface_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:455:7
    jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>  t = jlModule.add_type<mfem::DG_Interface_FECollection>("mfem!DG_Interface_FECollection",
      jlcxx::julia_base_type<mfem::RT_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>>(new jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::DG_Interface_FECollection::DG_Interface_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:458:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DG_Interface_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DG_Interface_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DG_Interface_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::ND_FECollection
// signature to use in the veto file: mfem::ND_FECollection
struct Jlmfem_ND_FECollection: public Wrapper {

  Jlmfem_ND_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:464:7
    jlcxx::TypeWrapper<mfem::ND_FECollection>  t = jlModule.add_type<mfem::ND_FECollection>("mfem!ND_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_FECollection::ND_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:476:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:481:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:483:8
    t.method("DofForGeometry", static_cast<int (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::StatelessDofTransformation * mfem::ND_FECollection::DofTransformationForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::StatelessDofTransformation * mfem::ND_FECollection::DofTransformationForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:487:4
    t.method("DofTransformationForGeometry", static_cast<const mfem::StatelessDofTransformation * (mfem::ND_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_FECollection::DofTransformationForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:489:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:492:16
    t.method("Name", [](mfem::ND_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::ND_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:494:8
    t.method("GetContType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:496:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetTraceCollection));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetClosedBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetClosedBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:498:8
    t.method("GetClosedBasisType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetClosedBasisType));

    DEBUG_MSG("Adding wrapper for int mfem::ND_FECollection::GetOpenBasisType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_FECollection::GetOpenBasisType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:499:8
    t.method("GetOpenBasisType", static_cast<int (mfem::ND_FECollection::*)()  const>(&mfem::ND_FECollection::GetOpenBasisType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_FECollection::Clone(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_FECollection::Clone(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:501:29
    t.method("Clone", static_cast<mfem::FiniteElementCollection * (mfem::ND_FECollection::*)(int)  const>(&mfem::ND_FECollection::Clone));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_Trace_FECollection> { typedef mfem::ND_FECollection type; };
}

// Class generating the wrapper for type mfem::ND_Trace_FECollection
// signature to use in the veto file: mfem::ND_Trace_FECollection
struct Jlmfem_ND_Trace_FECollection: public Wrapper {

  Jlmfem_ND_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:510:7
    jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>  t = jlModule.add_type<mfem::ND_Trace_FECollection>("mfem!ND_Trace_FECollection",
      jlcxx::julia_base_type<mfem::ND_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_Trace_FECollection::ND_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:513:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R1D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R1D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R1D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::ND_R1D_FECollection
// signature to use in the veto file: mfem::ND_R1D_FECollection
struct Jlmfem_ND_R1D_FECollection: public Wrapper {

  Jlmfem_ND_R1D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R1D_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:519:7
    jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>  t = jlModule.add_type<mfem::ND_R1D_FECollection>("mfem!ND_R1D_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R1D_FECollection::ND_R1D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:527:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:532:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R1D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_R1D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R1D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:535:8
    t.method("DofForGeometry", static_cast<int (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R1D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:538:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_R1D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_R1D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_R1D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_R1D_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:541:16
    t.method("Name", [](mfem::ND_R1D_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::ND_R1D_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::ND_R1D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R1D_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:543:8
    t.method("GetContType", static_cast<int (mfem::ND_R1D_FECollection::*)()  const>(&mfem::ND_R1D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_R1D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_R1D_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:545:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_R1D_FECollection::*)()  const>(&mfem::ND_R1D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R1D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R1D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R1D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R1D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R1D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R1D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT_R1D_FECollection
// signature to use in the veto file: mfem::RT_R1D_FECollection
struct Jlmfem_RT_R1D_FECollection: public Wrapper {

  Jlmfem_RT_R1D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R1D_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:551:7
    jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>  t = jlModule.add_type<mfem::RT_R1D_FECollection>("mfem!RT_R1D_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R1D_FECollection::RT_R1D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:559:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_R1D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:564:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R1D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_R1D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R1D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:567:8
    t.method("DofForGeometry", static_cast<int (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R1D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_R1D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:570:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_R1D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_R1D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_R1D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_R1D_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:573:16
    t.method("Name", [](mfem::RT_R1D_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT_R1D_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT_R1D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R1D_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:575:8
    t.method("GetContType", static_cast<int (mfem::RT_R1D_FECollection::*)()  const>(&mfem::RT_R1D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_R1D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_R1D_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:577:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_R1D_FECollection::*)()  const>(&mfem::RT_R1D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R1D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R1D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R1D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R2D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R2D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R2D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::ND_R2D_FECollection
// signature to use in the veto file: mfem::ND_R2D_FECollection
struct Jlmfem_ND_R2D_FECollection: public Wrapper {

  Jlmfem_ND_R2D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R2D_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:583:7
    jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>  t = jlModule.add_type<mfem::ND_R2D_FECollection>("mfem!ND_R2D_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R2D_FECollection::ND_R2D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:592:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:597:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R2D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND_R2D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R2D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:600:8
    t.method("DofForGeometry", static_cast<int (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND_R2D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:603:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND_R2D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND_R2D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND_R2D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND_R2D_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:606:16
    t.method("Name", [](mfem::ND_R2D_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::ND_R2D_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::ND_R2D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND_R2D_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:608:8
    t.method("GetContType", static_cast<int (mfem::ND_R2D_FECollection::*)()  const>(&mfem::ND_R2D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::ND_R2D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::ND_R2D_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:610:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::ND_R2D_FECollection::*)()  const>(&mfem::ND_R2D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R2D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND_R2D_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND_R2D_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::ND_R2D_Trace_FECollection> { typedef mfem::ND_R2D_FECollection type; };
}

// Class generating the wrapper for type mfem::ND_R2D_Trace_FECollection
// signature to use in the veto file: mfem::ND_R2D_Trace_FECollection
struct Jlmfem_ND_R2D_Trace_FECollection: public Wrapper {

  Jlmfem_ND_R2D_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND_R2D_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:618:7
    jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>  t = jlModule.add_type<mfem::ND_R2D_Trace_FECollection>("mfem!ND_R2D_Trace_FECollection",
      jlcxx::julia_base_type<mfem::ND_R2D_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ND_R2D_Trace_FECollection::ND_R2D_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:621:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND_R2D_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND_R2D_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R2D_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R2D_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R2D_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT_R2D_FECollection
// signature to use in the veto file: mfem::RT_R2D_FECollection
struct Jlmfem_RT_R2D_FECollection: public Wrapper {

  Jlmfem_RT_R2D_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R2D_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:627:7
    jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>  t = jlModule.add_type<mfem::RT_R2D_FECollection>("mfem!RT_R2D_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R2D_FECollection::RT_R2D_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:646:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT_R2D_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:651:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R2D_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT_R2D_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R2D_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:654:8
    t.method("DofForGeometry", static_cast<int (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT_R2D_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT_R2D_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:657:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT_R2D_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT_R2D_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT_R2D_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT_R2D_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:660:16
    t.method("Name", [](mfem::RT_R2D_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT_R2D_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT_R2D_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT_R2D_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:662:8
    t.method("GetContType", static_cast<int (mfem::RT_R2D_FECollection::*)()  const>(&mfem::RT_R2D_FECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::RT_R2D_FECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::RT_R2D_FECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:664:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::RT_R2D_FECollection::*)()  const>(&mfem::RT_R2D_FECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R2D_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT_R2D_Trace_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT_R2D_Trace_FECollection> : std::false_type { };
template<> struct SuperType<mfem::RT_R2D_Trace_FECollection> { typedef mfem::RT_R2D_FECollection type; };
}

// Class generating the wrapper for type mfem::RT_R2D_Trace_FECollection
// signature to use in the veto file: mfem::RT_R2D_Trace_FECollection
struct Jlmfem_RT_R2D_Trace_FECollection: public Wrapper {

  Jlmfem_RT_R2D_Trace_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT_R2D_Trace_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:672:7
    jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>  t = jlModule.add_type<mfem::RT_R2D_Trace_FECollection>("mfem!RT_R2D_Trace_FECollection",
      jlcxx::julia_base_type<mfem::RT_R2D_FECollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>>(new jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::RT_R2D_Trace_FECollection::RT_R2D_Trace_FECollection(const int, const int, const int, const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:675:4
    t.constructor<const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<const int, const int, const int, const int>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT_R2D_Trace_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_Trace_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT_R2D_Trace_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSFECollection> : std::false_type { };
template<> struct SuperType<mfem::NURBSFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::NURBSFECollection
// signature to use in the veto file: mfem::NURBSFECollection
struct Jlmfem_NURBSFECollection: public Wrapper {

  Jlmfem_NURBSFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:681:7
    jlcxx::TypeWrapper<mfem::NURBSFECollection>  t = jlModule.add_type<mfem::NURBSFECollection>("mfem!NURBSFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSFECollection>>(new jlcxx::TypeWrapper<mfem::NURBSFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::NURBSFECollection(int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:702:13
    t.constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::Reset() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSFECollection::Reset()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:704:9
    t.method("Reset", static_cast<void (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::Reset));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::GetOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:714:8
    t.method("GetOrder", static_cast<int (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetOrder));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSFECollection::SetOrder(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSFECollection::SetOrder(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:718:9
    t.method("SetOrder", static_cast<void (mfem::NURBSFECollection::*)(int)  const>(&mfem::NURBSFECollection::SetOrder));

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::NURBSFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::NURBSFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:721:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::NURBSFECollection::*)(mfem::Geometry::Type)  const>(&mfem::NURBSFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:723:8
    t.method("DofForGeometry", static_cast<int (mfem::NURBSFECollection::*)(mfem::Geometry::Type)  const>(&mfem::NURBSFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::NURBSFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::NURBSFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:725:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::NURBSFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::NURBSFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::NURBSFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::NURBSFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:728:16
    t.method("Name", [](mfem::NURBSFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::NURBSFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::NURBSFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:730:8
    t.method("GetContType", static_cast<int (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetContType));

    DEBUG_MSG("Adding wrapper for mfem::FiniteElementCollection * mfem::NURBSFECollection::GetTraceCollection() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FiniteElementCollection * mfem::NURBSFECollection::GetTraceCollection()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:732:29
    t.method("GetTraceCollection", static_cast<mfem::FiniteElementCollection * (mfem::NURBSFECollection::*)()  const>(&mfem::NURBSFECollection::GetTraceCollection));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::LinearFECollection
// signature to use in the veto file: mfem::LinearFECollection
struct Jlmfem_LinearFECollection: public Wrapper {

  Jlmfem_LinearFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:738:7
    jlcxx::TypeWrapper<mfem::LinearFECollection>  t = jlModule.add_type<mfem::LinearFECollection>("mfem!LinearFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFECollection>>(new jlcxx::TypeWrapper<mfem::LinearFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:753:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:755:8
    t.method("DofForGeometry", static_cast<int (mfem::LinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:757:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:760:16
    t.method("Name", [](mfem::LinearFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::LinearFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::LinearFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:762:8
    t.method("GetContType", static_cast<int (mfem::LinearFECollection::*)()  const>(&mfem::LinearFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticFECollection
// signature to use in the veto file: mfem::QuadraticFECollection
struct Jlmfem_QuadraticFECollection: public Wrapper {

  Jlmfem_QuadraticFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:766:7
    jlcxx::TypeWrapper<mfem::QuadraticFECollection>  t = jlModule.add_type<mfem::QuadraticFECollection>("mfem!QuadraticFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:782:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:784:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:786:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:789:16
    t.method("Name", [](mfem::QuadraticFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:791:8
    t.method("GetContType", static_cast<int (mfem::QuadraticFECollection::*)()  const>(&mfem::QuadraticFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticPosFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticPosFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticPosFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticPosFECollection
// signature to use in the veto file: mfem::QuadraticPosFECollection
struct Jlmfem_QuadraticPosFECollection: public Wrapper {

  Jlmfem_QuadraticPosFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticPosFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:795:7
    jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>  t = jlModule.add_type<mfem::QuadraticPosFECollection>("mfem!QuadraticPosFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticPosFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticPosFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:805:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:807:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticPosFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticPosFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:809:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticPosFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticPosFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticPosFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticPosFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:812:16
    t.method("Name", [](mfem::QuadraticPosFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticPosFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:814:8
    t.method("GetContType", static_cast<int (mfem::QuadraticPosFECollection::*)()  const>(&mfem::QuadraticPosFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticPosFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CubicFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CubicFECollection> : std::false_type { };
template<> struct SuperType<mfem::CubicFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::CubicFECollection
// signature to use in the veto file: mfem::CubicFECollection
struct Jlmfem_CubicFECollection: public Wrapper {

  Jlmfem_CubicFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CubicFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:818:7
    jlcxx::TypeWrapper<mfem::CubicFECollection>  t = jlModule.add_type<mfem::CubicFECollection>("mfem!CubicFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicFECollection>>(new jlcxx::TypeWrapper<mfem::CubicFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CubicFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CubicFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:836:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CubicFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CubicFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:838:8
    t.method("DofForGeometry", static_cast<int (mfem::CubicFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CubicFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CubicFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:840:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CubicFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CubicFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CubicFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CubicFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:843:16
    t.method("Name", [](mfem::CubicFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::CubicFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::CubicFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:845:8
    t.method("GetContType", static_cast<int (mfem::CubicFECollection::*)()  const>(&mfem::CubicFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CubicFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CubicFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CrouzeixRaviartFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CrouzeixRaviartFECollection> : std::false_type { };
template<> struct SuperType<mfem::CrouzeixRaviartFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::CrouzeixRaviartFECollection
// signature to use in the veto file: mfem::CrouzeixRaviartFECollection
struct Jlmfem_CrouzeixRaviartFECollection: public Wrapper {

  Jlmfem_CrouzeixRaviartFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CrouzeixRaviartFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:849:7
    jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>  t = jlModule.add_type<mfem::CrouzeixRaviartFECollection>("mfem!CrouzeixRaviartFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>>(new jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:859:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CrouzeixRaviartFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CrouzeixRaviartFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CrouzeixRaviartFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:861:8
    t.method("DofForGeometry", static_cast<int (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CrouzeixRaviartFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CrouzeixRaviartFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CrouzeixRaviartFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:863:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CrouzeixRaviartFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CrouzeixRaviartFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CrouzeixRaviartFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CrouzeixRaviartFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:866:16
    t.method("Name", [](mfem::CrouzeixRaviartFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::CrouzeixRaviartFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::CrouzeixRaviartFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CrouzeixRaviartFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:868:8
    t.method("GetContType", static_cast<int (mfem::CrouzeixRaviartFECollection::*)()  const>(&mfem::CrouzeixRaviartFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CrouzeixRaviartFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CrouzeixRaviartFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CrouzeixRaviartFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearNonConf3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearNonConf3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearNonConf3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::LinearNonConf3DFECollection
// signature to use in the veto file: mfem::LinearNonConf3DFECollection
struct Jlmfem_LinearNonConf3DFECollection: public Wrapper {

  Jlmfem_LinearNonConf3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearNonConf3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:872:7
    jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>  t = jlModule.add_type<mfem::LinearNonConf3DFECollection>("mfem!LinearNonConf3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearNonConf3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearNonConf3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:884:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearNonConf3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearNonConf3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearNonConf3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:886:8
    t.method("DofForGeometry", static_cast<int (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearNonConf3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearNonConf3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearNonConf3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:888:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearNonConf3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearNonConf3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearNonConf3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearNonConf3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:891:16
    t.method("Name", [](mfem::LinearNonConf3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::LinearNonConf3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::LinearNonConf3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearNonConf3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:893:8
    t.method("GetContType", static_cast<int (mfem::LinearNonConf3DFECollection::*)()  const>(&mfem::LinearNonConf3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearNonConf3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearNonConf3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearNonConf3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT0_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT0_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT0_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT0_2DFECollection
// signature to use in the veto file: mfem::RT0_2DFECollection
struct Jlmfem_RT0_2DFECollection: public Wrapper {

  Jlmfem_RT0_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT0_2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:898:7
    jlcxx::TypeWrapper<mfem::RT0_2DFECollection>  t = jlModule.add_type<mfem::RT0_2DFECollection>("mfem!RT0_2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT0_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT0_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT0_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:908:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT0_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:910:8
    t.method("DofForGeometry", static_cast<int (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT0_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT0_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:912:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT0_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT0_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT0_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT0_2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:915:16
    t.method("Name", [](mfem::RT0_2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT0_2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT0_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:917:8
    t.method("GetContType", static_cast<int (mfem::RT0_2DFECollection::*)()  const>(&mfem::RT0_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT0_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT0_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT1_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT1_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT1_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT1_2DFECollection
// signature to use in the veto file: mfem::RT1_2DFECollection
struct Jlmfem_RT1_2DFECollection: public Wrapper {

  Jlmfem_RT1_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT1_2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:922:7
    jlcxx::TypeWrapper<mfem::RT1_2DFECollection>  t = jlModule.add_type<mfem::RT1_2DFECollection>("mfem!RT1_2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT1_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT1_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT1_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:932:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT1_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:934:8
    t.method("DofForGeometry", static_cast<int (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT1_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT1_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:936:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT1_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT1_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT1_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT1_2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:939:16
    t.method("Name", [](mfem::RT1_2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT1_2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT1_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:941:8
    t.method("GetContType", static_cast<int (mfem::RT1_2DFECollection::*)()  const>(&mfem::RT1_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT1_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT1_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT2_2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT2_2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT2_2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT2_2DFECollection
// signature to use in the veto file: mfem::RT2_2DFECollection
struct Jlmfem_RT2_2DFECollection: public Wrapper {

  Jlmfem_RT2_2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT2_2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:946:7
    jlcxx::TypeWrapper<mfem::RT2_2DFECollection>  t = jlModule.add_type<mfem::RT2_2DFECollection>("mfem!RT2_2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT2_2DFECollection>>(new jlcxx::TypeWrapper<mfem::RT2_2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT2_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT2_2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:956:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT2_2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT2_2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT2_2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:958:8
    t.method("DofForGeometry", static_cast<int (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT2_2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT2_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT2_2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:960:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT2_2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT2_2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT2_2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT2_2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:963:16
    t.method("Name", [](mfem::RT2_2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT2_2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT2_2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT2_2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:965:8
    t.method("GetContType", static_cast<int (mfem::RT2_2DFECollection::*)()  const>(&mfem::RT2_2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT2_2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT2_2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT2_2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Const2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Const2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::Const2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::Const2DFECollection
// signature to use in the veto file: mfem::Const2DFECollection
struct Jlmfem_Const2DFECollection: public Wrapper {

  Jlmfem_Const2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Const2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:971:7
    jlcxx::TypeWrapper<mfem::Const2DFECollection>  t = jlModule.add_type<mfem::Const2DFECollection>("mfem!Const2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Const2DFECollection>>(new jlcxx::TypeWrapper<mfem::Const2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Const2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Const2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:980:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Const2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Const2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:982:8
    t.method("DofForGeometry", static_cast<int (mfem::Const2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Const2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Const2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:984:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Const2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Const2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Const2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Const2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:987:16
    t.method("Name", [](mfem::Const2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::Const2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::Const2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:989:8
    t.method("GetContType", static_cast<int (mfem::Const2DFECollection::*)()  const>(&mfem::Const2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Const2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Const2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Const2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::LinearDiscont2DFECollection
// signature to use in the veto file: mfem::LinearDiscont2DFECollection
struct Jlmfem_LinearDiscont2DFECollection: public Wrapper {

  Jlmfem_LinearDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:995:7
    jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>  t = jlModule.add_type<mfem::LinearDiscont2DFECollection>("mfem!LinearDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1005:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1007:8
    t.method("DofForGeometry", static_cast<int (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1009:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1012:16
    t.method("Name", [](mfem::LinearDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::LinearDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1014:8
    t.method("GetContType", static_cast<int (mfem::LinearDiscont2DFECollection::*)()  const>(&mfem::LinearDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GaussLinearDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GaussLinearDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::GaussLinearDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::GaussLinearDiscont2DFECollection
// signature to use in the veto file: mfem::GaussLinearDiscont2DFECollection
struct Jlmfem_GaussLinearDiscont2DFECollection: public Wrapper {

  Jlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GaussLinearDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1018:7
    jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>  t = jlModule.add_type<mfem::GaussLinearDiscont2DFECollection>("mfem!GaussLinearDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1029:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussLinearDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::GaussLinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussLinearDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1031:8
    t.method("DofForGeometry", static_cast<int (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussLinearDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1033:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::GaussLinearDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::GaussLinearDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::GaussLinearDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::GaussLinearDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1036:16
    t.method("Name", [](mfem::GaussLinearDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::GaussLinearDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::GaussLinearDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussLinearDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1038:8
    t.method("GetContType", static_cast<int (mfem::GaussLinearDiscont2DFECollection::*)()  const>(&mfem::GaussLinearDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussLinearDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GaussLinearDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::P1OnQuadFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::P1OnQuadFECollection> : std::false_type { };
template<> struct SuperType<mfem::P1OnQuadFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::P1OnQuadFECollection
// signature to use in the veto file: mfem::P1OnQuadFECollection
struct Jlmfem_P1OnQuadFECollection: public Wrapper {

  Jlmfem_P1OnQuadFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::P1OnQuadFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1042:7
    jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>  t = jlModule.add_type<mfem::P1OnQuadFECollection>("mfem!P1OnQuadFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>>(new jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::P1OnQuadFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::P1OnQuadFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1050:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type)  const>(&mfem::P1OnQuadFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::P1OnQuadFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::P1OnQuadFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1052:8
    t.method("DofForGeometry", static_cast<int (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type)  const>(&mfem::P1OnQuadFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::P1OnQuadFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::P1OnQuadFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1054:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::P1OnQuadFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::P1OnQuadFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::P1OnQuadFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::P1OnQuadFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1057:16
    t.method("Name", [](mfem::P1OnQuadFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::P1OnQuadFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::P1OnQuadFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::P1OnQuadFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1059:8
    t.method("GetContType", static_cast<int (mfem::P1OnQuadFECollection::*)()  const>(&mfem::P1OnQuadFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::P1OnQuadFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_P1OnQuadFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_P1OnQuadFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticDiscont2DFECollection
// signature to use in the veto file: mfem::QuadraticDiscont2DFECollection
struct Jlmfem_QuadraticDiscont2DFECollection: public Wrapper {

  Jlmfem_QuadraticDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1065:7
    jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>  t = jlModule.add_type<mfem::QuadraticDiscont2DFECollection>("mfem!QuadraticDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1075:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1077:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1079:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1082:16
    t.method("Name", [](mfem::QuadraticDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1084:8
    t.method("GetContType", static_cast<int (mfem::QuadraticDiscont2DFECollection::*)()  const>(&mfem::QuadraticDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticPosDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticPosDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticPosDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticPosDiscont2DFECollection
// signature to use in the veto file: mfem::QuadraticPosDiscont2DFECollection
struct Jlmfem_QuadraticPosDiscont2DFECollection: public Wrapper {

  Jlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticPosDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1088:7
    jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>  t = jlModule.add_type<mfem::QuadraticPosDiscont2DFECollection>("mfem!QuadraticPosDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1097:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1099:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticPosDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1101:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticPosDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticPosDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticPosDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticPosDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1105:16
    t.method("Name", [](mfem::QuadraticPosDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticPosDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticPosDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticPosDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1107:8
    t.method("GetContType", static_cast<int (mfem::QuadraticPosDiscont2DFECollection::*)()  const>(&mfem::QuadraticPosDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticPosDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticPosDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::GaussQuadraticDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::GaussQuadraticDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::GaussQuadraticDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::GaussQuadraticDiscont2DFECollection
// signature to use in the veto file: mfem::GaussQuadraticDiscont2DFECollection
struct Jlmfem_GaussQuadraticDiscont2DFECollection: public Wrapper {

  Jlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::GaussQuadraticDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1111:7
    jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>  t = jlModule.add_type<mfem::GaussQuadraticDiscont2DFECollection>("mfem!GaussQuadraticDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1122:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussQuadraticDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1124:8
    t.method("DofForGeometry", static_cast<int (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::GaussQuadraticDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1126:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::GaussQuadraticDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::GaussQuadraticDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::GaussQuadraticDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::GaussQuadraticDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1129:16
    t.method("Name", [](mfem::GaussQuadraticDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::GaussQuadraticDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::GaussQuadraticDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GaussQuadraticDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1131:8
    t.method("GetContType", static_cast<int (mfem::GaussQuadraticDiscont2DFECollection::*)()  const>(&mfem::GaussQuadraticDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::GaussQuadraticDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_GaussQuadraticDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::CubicDiscont2DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::CubicDiscont2DFECollection> : std::false_type { };
template<> struct SuperType<mfem::CubicDiscont2DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::CubicDiscont2DFECollection
// signature to use in the veto file: mfem::CubicDiscont2DFECollection
struct Jlmfem_CubicDiscont2DFECollection: public Wrapper {

  Jlmfem_CubicDiscont2DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::CubicDiscont2DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1137:7
    jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>  t = jlModule.add_type<mfem::CubicDiscont2DFECollection>("mfem!CubicDiscont2DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>>(new jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::CubicDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::CubicDiscont2DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1147:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicDiscont2DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::CubicDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicDiscont2DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1149:8
    t.method("DofForGeometry", static_cast<int (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::CubicDiscont2DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::CubicDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::CubicDiscont2DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1151:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::CubicDiscont2DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::CubicDiscont2DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::CubicDiscont2DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::CubicDiscont2DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1154:16
    t.method("Name", [](mfem::CubicDiscont2DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::CubicDiscont2DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::CubicDiscont2DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::CubicDiscont2DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1156:8
    t.method("GetContType", static_cast<int (mfem::CubicDiscont2DFECollection::*)()  const>(&mfem::CubicDiscont2DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::CubicDiscont2DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_CubicDiscont2DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_CubicDiscont2DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Const3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Const3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::Const3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::Const3DFECollection
// signature to use in the veto file: mfem::Const3DFECollection
struct Jlmfem_Const3DFECollection: public Wrapper {

  Jlmfem_Const3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Const3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1162:7
    jlcxx::TypeWrapper<mfem::Const3DFECollection>  t = jlModule.add_type<mfem::Const3DFECollection>("mfem!Const3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Const3DFECollection>>(new jlcxx::TypeWrapper<mfem::Const3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Const3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Const3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1174:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Const3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Const3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1176:8
    t.method("DofForGeometry", static_cast<int (mfem::Const3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::Const3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Const3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Const3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1178:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Const3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Const3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Const3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Const3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1181:16
    t.method("Name", [](mfem::Const3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::Const3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::Const3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Const3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1183:8
    t.method("GetContType", static_cast<int (mfem::Const3DFECollection::*)()  const>(&mfem::Const3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Const3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Const3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Const3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::LinearDiscont3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::LinearDiscont3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::LinearDiscont3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::LinearDiscont3DFECollection
// signature to use in the veto file: mfem::LinearDiscont3DFECollection
struct Jlmfem_LinearDiscont3DFECollection: public Wrapper {

  Jlmfem_LinearDiscont3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::LinearDiscont3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1189:7
    jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>  t = jlModule.add_type<mfem::LinearDiscont3DFECollection>("mfem!LinearDiscont3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>>(new jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::LinearDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::LinearDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1201:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1203:8
    t.method("DofForGeometry", static_cast<int (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::LinearDiscont3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::LinearDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::LinearDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1205:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::LinearDiscont3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::LinearDiscont3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::LinearDiscont3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::LinearDiscont3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1208:16
    t.method("Name", [](mfem::LinearDiscont3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::LinearDiscont3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::LinearDiscont3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::LinearDiscont3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1210:8
    t.method("GetContType", static_cast<int (mfem::LinearDiscont3DFECollection::*)()  const>(&mfem::LinearDiscont3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::LinearDiscont3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_LinearDiscont3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadraticDiscont3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadraticDiscont3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::QuadraticDiscont3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::QuadraticDiscont3DFECollection
// signature to use in the veto file: mfem::QuadraticDiscont3DFECollection
struct Jlmfem_QuadraticDiscont3DFECollection: public Wrapper {

  Jlmfem_QuadraticDiscont3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadraticDiscont3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1216:7
    jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>  t = jlModule.add_type<mfem::QuadraticDiscont3DFECollection>("mfem!QuadraticDiscont3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>>(new jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1227:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1229:8
    t.method("DofForGeometry", static_cast<int (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::QuadraticDiscont3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1231:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::QuadraticDiscont3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::QuadraticDiscont3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::QuadraticDiscont3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::QuadraticDiscont3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1234:16
    t.method("Name", [](mfem::QuadraticDiscont3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::QuadraticDiscont3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::QuadraticDiscont3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadraticDiscont3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1236:8
    t.method("GetContType", static_cast<int (mfem::QuadraticDiscont3DFECollection::*)()  const>(&mfem::QuadraticDiscont3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadraticDiscont3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadraticDiscont3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RefinedLinearFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RefinedLinearFECollection> : std::false_type { };
template<> struct SuperType<mfem::RefinedLinearFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RefinedLinearFECollection
// signature to use in the veto file: mfem::RefinedLinearFECollection
struct Jlmfem_RefinedLinearFECollection: public Wrapper {

  Jlmfem_RefinedLinearFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RefinedLinearFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1240:7
    jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>  t = jlModule.add_type<mfem::RefinedLinearFECollection>("mfem!RefinedLinearFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>>(new jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RefinedLinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RefinedLinearFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1254:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RefinedLinearFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RefinedLinearFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RefinedLinearFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1256:8
    t.method("DofForGeometry", static_cast<int (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RefinedLinearFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RefinedLinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RefinedLinearFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1258:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RefinedLinearFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RefinedLinearFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RefinedLinearFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RefinedLinearFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1261:16
    t.method("Name", [](mfem::RefinedLinearFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RefinedLinearFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RefinedLinearFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RefinedLinearFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1263:8
    t.method("GetContType", static_cast<int (mfem::RefinedLinearFECollection::*)()  const>(&mfem::RefinedLinearFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RefinedLinearFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RefinedLinearFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RefinedLinearFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ND1_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ND1_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::ND1_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::ND1_3DFECollection
// signature to use in the veto file: mfem::ND1_3DFECollection
struct Jlmfem_ND1_3DFECollection: public Wrapper {

  Jlmfem_ND1_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ND1_3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1269:7
    jlcxx::TypeWrapper<mfem::ND1_3DFECollection>  t = jlModule.add_type<mfem::ND1_3DFECollection>("mfem!ND1_3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ND1_3DFECollection>>(new jlcxx::TypeWrapper<mfem::ND1_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::ND1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::ND1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1281:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND1_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::ND1_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND1_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1283:8
    t.method("DofForGeometry", static_cast<int (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::ND1_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::ND1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::ND1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1285:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::ND1_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::ND1_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::ND1_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::ND1_3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1288:16
    t.method("Name", [](mfem::ND1_3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::ND1_3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::ND1_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::ND1_3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1290:8
    t.method("GetContType", static_cast<int (mfem::ND1_3DFECollection::*)()  const>(&mfem::ND1_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ND1_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ND1_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ND1_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT0_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT0_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT0_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT0_3DFECollection
// signature to use in the veto file: mfem::RT0_3DFECollection
struct Jlmfem_RT0_3DFECollection: public Wrapper {

  Jlmfem_RT0_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT0_3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1295:7
    jlcxx::TypeWrapper<mfem::RT0_3DFECollection>  t = jlModule.add_type<mfem::RT0_3DFECollection>("mfem!RT0_3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_3DFECollection>>(new jlcxx::TypeWrapper<mfem::RT0_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT0_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT0_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1308:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT0_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1310:8
    t.method("DofForGeometry", static_cast<int (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT0_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT0_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT0_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1312:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT0_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT0_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT0_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT0_3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1315:16
    t.method("Name", [](mfem::RT0_3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT0_3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT0_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT0_3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1317:8
    t.method("GetContType", static_cast<int (mfem::RT0_3DFECollection::*)()  const>(&mfem::RT0_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT0_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT0_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT0_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::RT1_3DFECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::RT1_3DFECollection> : std::false_type { };
template<> struct SuperType<mfem::RT1_3DFECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::RT1_3DFECollection
// signature to use in the veto file: mfem::RT1_3DFECollection
struct Jlmfem_RT1_3DFECollection: public Wrapper {

  Jlmfem_RT1_3DFECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::RT1_3DFECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1322:7
    jlcxx::TypeWrapper<mfem::RT1_3DFECollection>  t = jlModule.add_type<mfem::RT1_3DFECollection>("mfem!RT1_3DFECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_3DFECollection>>(new jlcxx::TypeWrapper<mfem::RT1_3DFECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::RT1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::RT1_3DFECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1332:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_3DFECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::RT1_3DFECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_3DFECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1334:8
    t.method("DofForGeometry", static_cast<int (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type)  const>(&mfem::RT1_3DFECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::RT1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::RT1_3DFECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1336:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::RT1_3DFECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::RT1_3DFECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::RT1_3DFECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::RT1_3DFECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1339:16
    t.method("Name", [](mfem::RT1_3DFECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::RT1_3DFECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::RT1_3DFECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::RT1_3DFECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1341:8
    t.method("GetContType", static_cast<int (mfem::RT1_3DFECollection::*)()  const>(&mfem::RT1_3DFECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::RT1_3DFECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_RT1_3DFECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_RT1_3DFECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Local_FECollection> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Local_FECollection> : std::false_type { };
template<> struct SuperType<mfem::Local_FECollection> { typedef mfem::FiniteElementCollection type; };
}

// Class generating the wrapper for type mfem::Local_FECollection
// signature to use in the veto file: mfem::Local_FECollection
struct Jlmfem_Local_FECollection: public Wrapper {

  Jlmfem_Local_FECollection(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Local_FECollection (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1345:7
    jlcxx::TypeWrapper<mfem::Local_FECollection>  t = jlModule.add_type<mfem::Local_FECollection>("mfem!Local_FECollection",
      jlcxx::julia_base_type<mfem::FiniteElementCollection>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Local_FECollection>>(new jlcxx::TypeWrapper<mfem::Local_FECollection>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::Local_FECollection::Local_FECollection(const char *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1353:4
    t.constructor<const char *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for const mfem::FiniteElement * mfem::Local_FECollection::FiniteElementForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::FiniteElement * mfem::Local_FECollection::FiniteElementForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1356:4
    t.method("FiniteElementForGeometry", static_cast<const mfem::FiniteElement * (mfem::Local_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::Local_FECollection::FiniteElementForGeometry));

    DEBUG_MSG("Adding wrapper for int mfem::Local_FECollection::DofForGeometry(mfem::Geometry::Type) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Local_FECollection::DofForGeometry(mfem::Geometry::Type)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1359:8
    t.method("DofForGeometry", static_cast<int (mfem::Local_FECollection::*)(mfem::Geometry::Type)  const>(&mfem::Local_FECollection::DofForGeometry));

    DEBUG_MSG("Adding wrapper for const int * mfem::Local_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int) (" __HERE__ ")");
    // signature to use in the veto list: const int * mfem::Local_FECollection::DofOrderForOrientation(mfem::Geometry::Type, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1362:15
    t.method("DofOrderForOrientation", static_cast<const int * (mfem::Local_FECollection::*)(mfem::Geometry::Type, int)  const>(&mfem::Local_FECollection::DofOrderForOrientation));

    DEBUG_MSG("Adding wrapper for const char * mfem::Local_FECollection::Name() (" __HERE__ ")");
    // signature to use in the veto list: const char * mfem::Local_FECollection::Name()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1366:16
    t.method("Name", [](mfem::Local_FECollection const& a) { return (std::string)a.Name(); });
    t.method("Name", [](mfem::Local_FECollection const* a) { return (std::string)a->Name(); });

    DEBUG_MSG("Adding wrapper for int mfem::Local_FECollection::GetContType() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::Local_FECollection::GetContType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:1368:8
    t.method("GetContType", static_cast<int (mfem::Local_FECollection::*)()  const>(&mfem::Local_FECollection::GetContType));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Local_FECollection>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Local_FECollection(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Local_FECollection(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Ordering> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Ordering> : std::false_type { };
}

// Class generating the wrapper for type mfem::Ordering
// signature to use in the veto file: mfem::Ordering
struct Jlmfem_Ordering: public Wrapper {

  Jlmfem_Ordering(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Ordering (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:29:7
    jlcxx::TypeWrapper<mfem::Ordering>  t = jlModule.add_type<mfem::Ordering>("mfem!Ordering");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Ordering>>(new jlcxx::TypeWrapper<mfem::Ordering>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Ordering>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Ordering(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Ordering(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::SparseMatrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::SparseMatrix> : std::false_type { };
}

// Class generating the wrapper for type mfem::SparseMatrix
// signature to use in the veto file: mfem::SparseMatrix
struct Jlmfem_SparseMatrix: public Wrapper {

  Jlmfem_SparseMatrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::SparseMatrix (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/sparsemat.hpp:50:7
    jlcxx::TypeWrapper<mfem::SparseMatrix>  t = jlModule.add_type<mfem::SparseMatrix>("mfem!SparseMatrix");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::SparseMatrix>>(new jlcxx::TypeWrapper<mfem::SparseMatrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::SparseMatrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_SparseMatrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_SparseMatrix(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Operator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Operator> : std::false_type { };
}

// Class generating the wrapper for type mfem::Operator
// signature to use in the veto file: mfem::Operator
struct Jlmfem_Operator: public Wrapper {

  Jlmfem_Operator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Operator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:24:7
    jlcxx::TypeWrapper<mfem::Operator>  t = jlModule.add_type<mfem::Operator>("mfem!Operator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Operator>>(new jlcxx::TypeWrapper<mfem::Operator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Operator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Operator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Operator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ElementRestrictionOperator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ElementRestrictionOperator> : std::false_type { };
template<> struct SuperType<mfem::ElementRestrictionOperator> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::ElementRestrictionOperator
// signature to use in the veto file: mfem::ElementRestrictionOperator
struct Jlmfem_ElementRestrictionOperator: public Wrapper {

  Jlmfem_ElementRestrictionOperator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ElementRestrictionOperator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/restriction.hpp:25:7
    jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>  t = jlModule.add_type<mfem::ElementRestrictionOperator>("mfem!ElementRestrictionOperator",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>>(new jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ElementRestrictionOperator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ElementRestrictionOperator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ElementRestrictionOperator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceRestriction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceRestriction> : std::false_type { };
template<> struct SuperType<mfem::FaceRestriction> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::FaceRestriction
// signature to use in the veto file: mfem::FaceRestriction
struct Jlmfem_FaceRestriction: public Wrapper {

  Jlmfem_FaceRestriction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceRestriction (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/restriction.hpp:159:7
    jlcxx::TypeWrapper<mfem::FaceRestriction>  t = jlModule.add_type<mfem::FaceRestriction>("mfem!FaceRestriction",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceRestriction>>(new jlcxx::TypeWrapper<mfem::FaceRestriction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceRestriction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceRestriction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceRestriction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureInterpolator> : std::false_type { };
}

// Class generating the wrapper for type mfem::QuadratureInterpolator
// signature to use in the veto file: mfem::QuadratureInterpolator
struct Jlmfem_QuadratureInterpolator: public Wrapper {

  Jlmfem_QuadratureInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:29:7
    jlcxx::TypeWrapper<mfem::QuadratureInterpolator>  t = jlModule.add_type<mfem::QuadratureInterpolator>("mfem!QuadratureInterpolator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureInterpolator>>(new jlcxx::TypeWrapper<mfem::QuadratureInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::QuadratureInterpolator(const mfem::FiniteElementSpace &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:62:4
    t.constructor<const mfem::FiniteElementSpace &, const mfem::IntegrationRule &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::QuadratureInterpolator(const mfem::FiniteElementSpace &, const mfem::QuadratureSpace &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:65:4
    t.constructor<const mfem::FiniteElementSpace &, const mfem::QuadratureSpace &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::DisableTensorProducts(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::DisableTensorProducts(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:72:9
    t.method("DisableTensorProducts", static_cast<void (mfem::QuadratureInterpolator::*)(bool)  const>(&mfem::QuadratureInterpolator::DisableTensorProducts));
    t.method("DisableTensorProducts", [](mfem::QuadratureInterpolator const& a)->void { a.DisableTensorProducts(); });
    t.method("DisableTensorProducts", [](mfem::QuadratureInterpolator const* a)->void { a->DisableTensorProducts(); });

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::EnableTensorProducts() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::EnableTensorProducts()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:78:9
    t.method("EnableTensorProducts", static_cast<void (mfem::QuadratureInterpolator::*)()  const>(&mfem::QuadratureInterpolator::EnableTensorProducts));

    DEBUG_MSG("Adding wrapper for bool mfem::QuadratureInterpolator::UsesTensorProducts() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::QuadratureInterpolator::UsesTensorProducts()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:82:9
    t.method("UsesTensorProducts", static_cast<bool (mfem::QuadratureInterpolator::*)()  const>(&mfem::QuadratureInterpolator::UsesTensorProducts));

    DEBUG_MSG("Adding wrapper for mfem::QVectorLayout mfem::QuadratureInterpolator::GetOutputLayout() (" __HERE__ ")");
    // signature to use in the veto list: mfem::QVectorLayout mfem::QuadratureInterpolator::GetOutputLayout()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:87:18
    t.method("GetOutputLayout", static_cast<mfem::QVectorLayout (mfem::QuadratureInterpolator::*)()  const>(&mfem::QuadratureInterpolator::GetOutputLayout));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::SetOutputLayout(mfem::QVectorLayout) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::SetOutputLayout(mfem::QVectorLayout)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:92:9
    t.method("SetOutputLayout", static_cast<void (mfem::QuadratureInterpolator::*)(mfem::QVectorLayout)  const>(&mfem::QuadratureInterpolator::SetOutputLayout));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::Mult(const mfem::Vector &, unsigned int, mfem::Vector &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::Mult(const mfem::Vector &, unsigned int, mfem::Vector &, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:112:9
    t.method("Mult", static_cast<void (mfem::QuadratureInterpolator::*)(const mfem::Vector &, unsigned int, mfem::Vector &, mfem::Vector &, mfem::Vector &)  const>(&mfem::QuadratureInterpolator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::Values(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::Values(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:116:9
    t.method("Values", static_cast<void (mfem::QuadratureInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::QuadratureInterpolator::Values));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::Derivatives(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::Derivatives(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:120:9
    t.method("Derivatives", static_cast<void (mfem::QuadratureInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::QuadratureInterpolator::Derivatives));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::PhysDerivatives(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::PhysDerivatives(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:124:9
    t.method("PhysDerivatives", static_cast<void (mfem::QuadratureInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::QuadratureInterpolator::PhysDerivatives));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::Determinants(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::Determinants(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:128:9
    t.method("Determinants", static_cast<void (mfem::QuadratureInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::QuadratureInterpolator::Determinants));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureInterpolator::MultTranspose(unsigned int, const mfem::Vector &, const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureInterpolator::MultTranspose(unsigned int, const mfem::Vector &, const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:131:9
    t.method("MultTranspose", static_cast<void (mfem::QuadratureInterpolator::*)(unsigned int, const mfem::Vector &, const mfem::Vector &, mfem::Vector &)  const>(&mfem::QuadratureInterpolator::MultTranspose));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureSpaceBase> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureSpaceBase> : std::false_type { };
}

// Class generating the wrapper for type mfem::QuadratureSpaceBase
// signature to use in the veto file: mfem::QuadratureSpaceBase
struct Jlmfem_QuadratureSpaceBase: public Wrapper {

  Jlmfem_QuadratureSpaceBase(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureSpaceBase (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:25:7
    jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>  t = jlModule.add_type<mfem::QuadratureSpaceBase>("mfem!QuadratureSpaceBase");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>>(new jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureSpaceBase::GetSize() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureSpaceBase::GetSize()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:55:8
    t.method("GetSize", static_cast<int (mfem::QuadratureSpaceBase::*)()  const>(&mfem::QuadratureSpaceBase::GetSize));

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureSpaceBase::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureSpaceBase::GetOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:58:8
    t.method("GetOrder", static_cast<int (mfem::QuadratureSpaceBase::*)()  const>(&mfem::QuadratureSpaceBase::GetOrder));

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureSpaceBase::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureSpaceBase::GetNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:61:8
    t.method("GetNE", static_cast<int (mfem::QuadratureSpaceBase::*)()  const>(&mfem::QuadratureSpaceBase::GetNE));

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::QuadratureSpaceBase::GetMesh() (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::QuadratureSpaceBase::GetMesh()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:64:17
    t.method("GetMesh", static_cast<mfem::Mesh * (mfem::QuadratureSpaceBase::*)()  const>(&mfem::QuadratureSpaceBase::GetMesh));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::QuadratureSpaceBase::GetTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::QuadratureSpaceBase::GetTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:67:35
    t.method("GetTransformation", static_cast<mfem::ElementTransformation * (mfem::QuadratureSpaceBase::*)(int) >(&mfem::QuadratureSpaceBase::GetTransformation));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::QuadratureSpaceBase::GetGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::QuadratureSpaceBase::GetGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:70:27
    t.method("GetGeometry", static_cast<mfem::Geometry::Type (mfem::QuadratureSpaceBase::*)(int)  const>(&mfem::QuadratureSpaceBase::GetGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::QuadratureSpaceBase::GetIntRule(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::QuadratureSpaceBase::GetIntRule(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:73:27
    t.method("GetIntRule", static_cast<const mfem::IntegrationRule & (mfem::QuadratureSpaceBase::*)(int)  const>(&mfem::QuadratureSpaceBase::GetIntRule));

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureSpaceBase::GetPermutedIndex(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureSpaceBase::GetPermutedIndex(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:83:16
    t.method("GetPermutedIndex", static_cast<int (mfem::QuadratureSpaceBase::*)(int, int)  const>(&mfem::QuadratureSpaceBase::GetPermutedIndex));

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureSpaceBase::GetEntityIndex(const mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureSpaceBase::GetEntityIndex(const mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:92:16
    t.method("GetEntityIndex", static_cast<int (mfem::QuadratureSpaceBase::*)(const mfem::ElementTransformation &)  const>(&mfem::QuadratureSpaceBase::GetEntityIndex));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpaceBase>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpaceBase(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureSpaceBase(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureSpace> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureSpace> : std::false_type { };
template<> struct SuperType<mfem::QuadratureSpace> { typedef mfem::QuadratureSpaceBase type; };
}

// Class generating the wrapper for type mfem::QuadratureSpace
// signature to use in the veto file: mfem::QuadratureSpace
struct Jlmfem_QuadratureSpace: public Wrapper {

  Jlmfem_QuadratureSpace(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureSpace (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:102:7
    jlcxx::TypeWrapper<mfem::QuadratureSpace>  t = jlModule.add_type<mfem::QuadratureSpace>("mfem!QuadratureSpace",
      jlcxx::julia_base_type<mfem::QuadratureSpaceBase>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpace>>(new jlcxx::TypeWrapper<mfem::QuadratureSpace>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureSpace::QuadratureSpace(mfem::Mesh *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:109:4
    t.constructor<mfem::Mesh *, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureSpace::QuadratureSpace(mfem::Mesh &, const mfem::IntegrationRule &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:114:4
    t.constructor<mfem::Mesh &, const mfem::IntegrationRule &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureSpace::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureSpace::GetNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:120:15
    t.method("GetNE", static_cast<int (mfem::QuadratureSpace::*)()  const>(&mfem::QuadratureSpace::GetNE));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::QuadratureSpace::GetTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::QuadratureSpace::GetTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:123:27
    t.method("GetTransformation", static_cast<mfem::ElementTransformation * (mfem::QuadratureSpace::*)(int) >(&mfem::QuadratureSpace::GetTransformation));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::QuadratureSpace::GetGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::QuadratureSpace::GetGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:127:19
    t.method("GetGeometry", static_cast<mfem::Geometry::Type (mfem::QuadratureSpace::*)(int)  const>(&mfem::QuadratureSpace::GetGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::QuadratureSpace::GetElementIntRule(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::QuadratureSpace::GetElementIntRule(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:131:27
    t.method("GetElementIntRule", static_cast<const mfem::IntegrationRule & (mfem::QuadratureSpace::*)(int)  const>(&mfem::QuadratureSpace::GetElementIntRule));

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureSpace::GetPermutedIndex(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureSpace::GetPermutedIndex(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:139:8
    t.method("GetPermutedIndex", static_cast<int (mfem::QuadratureSpace::*)(int, int)  const>(&mfem::QuadratureSpace::GetPermutedIndex));

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureSpace::GetEntityIndex(const mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureSpace::GetEntityIndex(const mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:142:8
    t.method("GetEntityIndex", static_cast<int (mfem::QuadratureSpace::*)(const mfem::ElementTransformation &)  const>(&mfem::QuadratureSpace::GetEntityIndex));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureSpace>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpace(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureSpace(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceQuadratureInterpolator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceQuadratureInterpolator> : std::false_type { };
}

// Class generating the wrapper for type mfem::FaceQuadratureInterpolator
// signature to use in the veto file: mfem::FaceQuadratureInterpolator
struct Jlmfem_FaceQuadratureInterpolator: public Wrapper {

  Jlmfem_FaceQuadratureInterpolator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceQuadratureInterpolator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator_face.hpp:25:7
    jlcxx::TypeWrapper<mfem::FaceQuadratureInterpolator>  t = jlModule.add_type<mfem::FaceQuadratureInterpolator>("mfem!FaceQuadratureInterpolator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceQuadratureInterpolator>>(new jlcxx::TypeWrapper<mfem::FaceQuadratureInterpolator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::FaceQuadratureInterpolator::FaceQuadratureInterpolator(const mfem::FiniteElementSpace &, const mfem::IntegrationRule &, mfem::FaceType) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator_face.hpp:64:4
    t.constructor<const mfem::FiniteElementSpace &, const mfem::IntegrationRule &, mfem::FaceType>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::FaceQuadratureInterpolator::DisableTensorProducts(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FaceQuadratureInterpolator::DisableTensorProducts(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator_face.hpp:71:9
    t.method("DisableTensorProducts", static_cast<void (mfem::FaceQuadratureInterpolator::*)(bool)  const>(&mfem::FaceQuadratureInterpolator::DisableTensorProducts));
    t.method("DisableTensorProducts", [](mfem::FaceQuadratureInterpolator const& a)->void { a.DisableTensorProducts(); });
    t.method("DisableTensorProducts", [](mfem::FaceQuadratureInterpolator const* a)->void { a->DisableTensorProducts(); });

    DEBUG_MSG("Adding wrapper for mfem::QVectorLayout mfem::FaceQuadratureInterpolator::GetOutputLayout() (" __HERE__ ")");
    // signature to use in the veto list: mfem::QVectorLayout mfem::FaceQuadratureInterpolator::GetOutputLayout()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator_face.hpp:77:18
    t.method("GetOutputLayout", static_cast<mfem::QVectorLayout (mfem::FaceQuadratureInterpolator::*)()  const>(&mfem::FaceQuadratureInterpolator::GetOutputLayout));

    DEBUG_MSG("Adding wrapper for void mfem::FaceQuadratureInterpolator::SetOutputLayout(mfem::QVectorLayout) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FaceQuadratureInterpolator::SetOutputLayout(mfem::QVectorLayout)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator_face.hpp:82:9
    t.method("SetOutputLayout", static_cast<void (mfem::FaceQuadratureInterpolator::*)(mfem::QVectorLayout)  const>(&mfem::FaceQuadratureInterpolator::SetOutputLayout));

    DEBUG_MSG("Adding wrapper for void mfem::FaceQuadratureInterpolator::Mult(const mfem::Vector &, unsigned int, mfem::Vector &, mfem::Vector &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FaceQuadratureInterpolator::Mult(const mfem::Vector &, unsigned int, mfem::Vector &, mfem::Vector &, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator_face.hpp:93:9
    t.method("Mult", static_cast<void (mfem::FaceQuadratureInterpolator::*)(const mfem::Vector &, unsigned int, mfem::Vector &, mfem::Vector &, mfem::Vector &, mfem::Vector &)  const>(&mfem::FaceQuadratureInterpolator::Mult));

    DEBUG_MSG("Adding wrapper for void mfem::FaceQuadratureInterpolator::Values(const mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::FaceQuadratureInterpolator::Values(const mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator_face.hpp:97:9
    t.method("Values", static_cast<void (mfem::FaceQuadratureInterpolator::*)(const mfem::Vector &, mfem::Vector &)  const>(&mfem::FaceQuadratureInterpolator::Values));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceQuadratureInterpolator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceQuadratureInterpolator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceQuadratureInterpolator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::DofTransformation> : std::false_type { };
  template<> struct DefaultConstructible<mfem::DofTransformation> : std::false_type { };
}

// Class generating the wrapper for type mfem::DofTransformation
// signature to use in the veto file: mfem::DofTransformation
struct Jlmfem_DofTransformation: public Wrapper {

  Jlmfem_DofTransformation(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::DofTransformation (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/doftrans.hpp:141:7
    jlcxx::TypeWrapper<mfem::DofTransformation>  t = jlModule.add_type<mfem::DofTransformation>("mfem!DofTransformation");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::DofTransformation>>(new jlcxx::TypeWrapper<mfem::DofTransformation>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::DofTransformation>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_DofTransformation(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_DofTransformation(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::OperatorHandle> : std::false_type { };
  template<> struct DefaultConstructible<mfem::OperatorHandle> : std::false_type { };
}

// Class generating the wrapper for type mfem::OperatorHandle
// signature to use in the veto file: mfem::OperatorHandle
struct Jlmfem_OperatorHandle: public Wrapper {

  Jlmfem_OperatorHandle(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::OperatorHandle (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/../linalg/handle.hpp:33:7
    jlcxx::TypeWrapper<mfem::OperatorHandle>  t = jlModule.add_type<mfem::OperatorHandle>("mfem!OperatorHandle");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorHandle>>(new jlcxx::TypeWrapper<mfem::OperatorHandle>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::OperatorHandle>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_OperatorHandle(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_OperatorHandle(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::FaceQuadratureSpace> : std::false_type { };
  template<> struct DefaultConstructible<mfem::FaceQuadratureSpace> : std::false_type { };
template<> struct SuperType<mfem::FaceQuadratureSpace> { typedef mfem::QuadratureSpaceBase type; };
}

// Class generating the wrapper for type mfem::FaceQuadratureSpace
// signature to use in the veto file: mfem::FaceQuadratureSpace
struct Jlmfem_FaceQuadratureSpace: public Wrapper {

  Jlmfem_FaceQuadratureSpace(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::FaceQuadratureSpace (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:151:7
    jlcxx::TypeWrapper<mfem::FaceQuadratureSpace>  t = jlModule.add_type<mfem::FaceQuadratureSpace>("mfem!FaceQuadratureSpace",
      jlcxx::julia_base_type<mfem::QuadratureSpaceBase>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceQuadratureSpace>>(new jlcxx::TypeWrapper<mfem::FaceQuadratureSpace>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::FaceQuadratureSpace::FaceQuadratureSpace(mfem::Mesh &, int, mfem::FaceType) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:167:4
    t.constructor<mfem::Mesh &, int, mfem::FaceType>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::FaceQuadratureSpace::FaceQuadratureSpace(mfem::Mesh &, const mfem::IntegrationRule &, mfem::FaceType) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:171:4
    t.constructor<mfem::Mesh &, const mfem::IntegrationRule &, mfem::FaceType>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::FaceQuadratureSpace::GetNumFaces() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FaceQuadratureSpace::GetNumFaces()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:175:15
    t.method("GetNumFaces", static_cast<int (mfem::FaceQuadratureSpace::*)()  const>(&mfem::FaceQuadratureSpace::GetNumFaces));

    DEBUG_MSG("Adding wrapper for mfem::FaceType mfem::FaceQuadratureSpace::GetFaceType() (" __HERE__ ")");
    // signature to use in the veto list: mfem::FaceType mfem::FaceQuadratureSpace::GetFaceType()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:178:13
    t.method("GetFaceType", static_cast<mfem::FaceType (mfem::FaceQuadratureSpace::*)()  const>(&mfem::FaceQuadratureSpace::GetFaceType));

    DEBUG_MSG("Adding wrapper for mfem::ElementTransformation * mfem::FaceQuadratureSpace::GetTransformation(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementTransformation * mfem::FaceQuadratureSpace::GetTransformation(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:181:27
    t.method("GetTransformation", static_cast<mfem::ElementTransformation * (mfem::FaceQuadratureSpace::*)(int) >(&mfem::FaceQuadratureSpace::GetTransformation));

    DEBUG_MSG("Adding wrapper for mfem::Geometry::Type mfem::FaceQuadratureSpace::GetGeometry(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Geometry::Type mfem::FaceQuadratureSpace::GetGeometry(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:185:19
    t.method("GetGeometry", static_cast<mfem::Geometry::Type (mfem::FaceQuadratureSpace::*)(int)  const>(&mfem::FaceQuadratureSpace::GetGeometry));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::FaceQuadratureSpace::GetFaceIntRule(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::FaceQuadratureSpace::GetFaceIntRule(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:189:27
    t.method("GetFaceIntRule", static_cast<const mfem::IntegrationRule & (mfem::FaceQuadratureSpace::*)(int)  const>(&mfem::FaceQuadratureSpace::GetFaceIntRule));

    DEBUG_MSG("Adding wrapper for int mfem::FaceQuadratureSpace::GetPermutedIndex(int, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FaceQuadratureSpace::GetPermutedIndex(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:197:8
    t.method("GetPermutedIndex", static_cast<int (mfem::FaceQuadratureSpace::*)(int, int)  const>(&mfem::FaceQuadratureSpace::GetPermutedIndex));

    DEBUG_MSG("Adding wrapper for int mfem::FaceQuadratureSpace::GetEntityIndex(const mfem::ElementTransformation &) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::FaceQuadratureSpace::GetEntityIndex(const mfem::ElementTransformation &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qspace.hpp:203:8
    t.method("GetEntityIndex", static_cast<int (mfem::FaceQuadratureSpace::*)(const mfem::ElementTransformation &)  const>(&mfem::FaceQuadratureSpace::GetEntityIndex));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::FaceQuadratureSpace>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_FaceQuadratureSpace(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_FaceQuadratureSpace(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::QuadratureFunction> : std::false_type { };
  template<> struct DefaultConstructible<mfem::QuadratureFunction> : std::false_type { };
template<> struct SuperType<mfem::QuadratureFunction> { typedef mfem::Vector type; };
}

// Class generating the wrapper for type mfem::QuadratureFunction
// signature to use in the veto file: mfem::QuadratureFunction
struct Jlmfem_QuadratureFunction: public Wrapper {

  Jlmfem_QuadratureFunction(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::QuadratureFunction (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:23:7
    jlcxx::TypeWrapper<mfem::QuadratureFunction>  t = jlModule.add_type<mfem::QuadratureFunction>("mfem!QuadratureFunction",
      jlcxx::julia_base_type<mfem::Vector>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunction>>(new jlcxx::TypeWrapper<mfem::QuadratureFunction>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::QuadratureFunction(mfem::QuadratureSpaceBase &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:39:4
    t.constructor<mfem::QuadratureSpaceBase &>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::QuadratureSpaceBase &, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::QuadratureFunction(mfem::QuadratureSpaceBase *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:48:4
    t.constructor<mfem::QuadratureSpaceBase *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::QuadratureSpaceBase *, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::QuadratureFunction(mfem::QuadratureSpaceBase *, double *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:58:4
    t.constructor<mfem::QuadratureSpaceBase *, double *>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<mfem::QuadratureSpaceBase *, double *, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::QuadratureFunction(const mfem::QuadratureFunction &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:64:4
    t.constructor<const mfem::QuadratureFunction &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::QuadratureFunction::GetVDim() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::QuadratureFunction::GetVDim()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:75:8
    t.method("GetVDim", static_cast<int (mfem::QuadratureFunction::*)()  const>(&mfem::QuadratureFunction::GetVDim));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::SetVDim(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::SetVDim(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:78:9
    t.method("SetVDim", static_cast<void (mfem::QuadratureFunction::*)(int) >(&mfem::QuadratureFunction::SetVDim));

    DEBUG_MSG("Adding wrapper for mfem::QuadratureSpaceBase * mfem::QuadratureFunction::GetSpace() (" __HERE__ ")");
    // signature to use in the veto list: mfem::QuadratureSpaceBase * mfem::QuadratureFunction::GetSpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:82:25
    t.method("GetSpace", static_cast<mfem::QuadratureSpaceBase * (mfem::QuadratureFunction::*)() >(&mfem::QuadratureFunction::GetSpace));

    DEBUG_MSG("Adding wrapper for const mfem::QuadratureSpaceBase * mfem::QuadratureFunction::GetSpace() (" __HERE__ ")");
    // signature to use in the veto list: const mfem::QuadratureSpaceBase * mfem::QuadratureFunction::GetSpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:85:31
    t.method("GetSpace", static_cast<const mfem::QuadratureSpaceBase * (mfem::QuadratureFunction::*)()  const>(&mfem::QuadratureFunction::GetSpace));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::SetSpace(mfem::QuadratureSpaceBase *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::SetSpace(mfem::QuadratureSpaceBase *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:96:16
    t.method("SetSpace", static_cast<void (mfem::QuadratureFunction::*)(mfem::QuadratureSpaceBase *, int) >(&mfem::QuadratureFunction::SetSpace));
    t.method("SetSpace", [](mfem::QuadratureFunction& a, mfem::QuadratureSpaceBase * arg0)->void { a.SetSpace(arg0); });
    t.method("SetSpace", [](mfem::QuadratureFunction* a, mfem::QuadratureSpaceBase * arg0)->void { a->SetSpace(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::SetSpace(mfem::QuadratureSpaceBase *, double *, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::SetSpace(mfem::QuadratureSpaceBase *, double *, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:108:16
    t.method("SetSpace", static_cast<void (mfem::QuadratureFunction::*)(mfem::QuadratureSpaceBase *, double *, int) >(&mfem::QuadratureFunction::SetSpace));
    t.method("SetSpace", [](mfem::QuadratureFunction& a, mfem::QuadratureSpaceBase * arg0, double * arg1)->void { a.SetSpace(arg0, arg1); });
    t.method("SetSpace", [](mfem::QuadratureFunction* a, mfem::QuadratureSpaceBase * arg0, double * arg1)->void { a->SetSpace(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for bool mfem::QuadratureFunction::OwnsSpace() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::QuadratureFunction::OwnsSpace()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:112:9
    t.method("OwnsSpace", static_cast<bool (mfem::QuadratureFunction::*)() >(&mfem::QuadratureFunction::OwnsSpace));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::SetOwnsSpace(bool) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::SetOwnsSpace(bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:115:9
    t.method("SetOwnsSpace", static_cast<void (mfem::QuadratureFunction::*)(bool) >(&mfem::QuadratureFunction::SetOwnsSpace));

    DEBUG_MSG("Adding wrapper for mfem::QuadratureFunction & mfem::QuadratureFunction::operator=(double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::QuadratureFunction & mfem::QuadratureFunction::operator=(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:118:24
    t.method("assign", static_cast<mfem::QuadratureFunction & (mfem::QuadratureFunction::*)(double) >(&mfem::QuadratureFunction::operator=));

    DEBUG_MSG("Adding wrapper for mfem::QuadratureFunction & mfem::QuadratureFunction::operator=(const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::QuadratureFunction & mfem::QuadratureFunction::operator=(const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:124:24
    t.method("assign", static_cast<mfem::QuadratureFunction & (mfem::QuadratureFunction::*)(const mfem::Vector &) >(&mfem::QuadratureFunction::operator=));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::ProjectGridFunction(const mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::ProjectGridFunction(const mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:127:9
    t.method("ProjectGridFunction", static_cast<void (mfem::QuadratureFunction::*)(const mfem::GridFunction &) >(&mfem::QuadratureFunction::ProjectGridFunction));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::GetValues(int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::GetValues(int, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:136:16
    t.method("GetValues", static_cast<void (mfem::QuadratureFunction::*)(int, mfem::Vector &) >(&mfem::QuadratureFunction::GetValues));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::GetValues(int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::GetValues(int, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:145:16
    t.method("GetValues", static_cast<void (mfem::QuadratureFunction::*)(int, mfem::Vector &)  const>(&mfem::QuadratureFunction::GetValues));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::GetValues(int, const int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::GetValues(int, const int, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:150:16
    t.method("GetValues", static_cast<void (mfem::QuadratureFunction::*)(int, const int, mfem::Vector &) >(&mfem::QuadratureFunction::GetValues));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::GetValues(int, const int, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::GetValues(int, const int, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:155:16
    t.method("GetValues", static_cast<void (mfem::QuadratureFunction::*)(int, const int, mfem::Vector &)  const>(&mfem::QuadratureFunction::GetValues));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::GetValues(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::GetValues(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:164:16
    t.method("GetValues", static_cast<void (mfem::QuadratureFunction::*)(int, mfem::DenseMatrix &) >(&mfem::QuadratureFunction::GetValues));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::GetValues(int, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::GetValues(int, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:173:16
    t.method("GetValues", static_cast<void (mfem::QuadratureFunction::*)(int, mfem::DenseMatrix &)  const>(&mfem::QuadratureFunction::GetValues));

    DEBUG_MSG("Adding wrapper for const mfem::IntegrationRule & mfem::QuadratureFunction::GetIntRule(int) (" __HERE__ ")");
    // signature to use in the veto list: const mfem::IntegrationRule & mfem::QuadratureFunction::GetIntRule(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:176:27
    t.method("GetIntRule", static_cast<const mfem::IntegrationRule & (mfem::QuadratureFunction::*)(int)  const>(&mfem::QuadratureFunction::GetIntRule));

    DEBUG_MSG("Adding wrapper for void mfem::QuadratureFunction::SaveVTU(const std::string &, mfem::VTKFormat, int, const std::string &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::QuadratureFunction::SaveVTU(const std::string &, mfem::VTKFormat, int, const std::string &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/qfunction.hpp:195:9
    t.method("SaveVTU", static_cast<void (mfem::QuadratureFunction::*)(const std::string &, mfem::VTKFormat, int, const std::string &)  const>(&mfem::QuadratureFunction::SaveVTU));
    t.method("SaveVTU", [](mfem::QuadratureFunction const& a, const std::string & arg0)->void { a.SaveVTU(arg0); });
    t.method("SaveVTU", [](mfem::QuadratureFunction const& a, const std::string & arg0, mfem::VTKFormat arg1)->void { a.SaveVTU(arg0, arg1); });
    t.method("SaveVTU", [](mfem::QuadratureFunction const& a, const std::string & arg0, mfem::VTKFormat arg1, int arg2)->void { a.SaveVTU(arg0, arg1, arg2); });
    t.method("SaveVTU", [](mfem::QuadratureFunction const* a, const std::string & arg0)->void { a->SaveVTU(arg0); });
    t.method("SaveVTU", [](mfem::QuadratureFunction const* a, const std::string & arg0, mfem::VTKFormat arg1)->void { a->SaveVTU(arg0, arg1); });
    t.method("SaveVTU", [](mfem::QuadratureFunction const* a, const std::string & arg0, mfem::VTKFormat arg1, int arg2)->void { a->SaveVTU(arg0, arg1, arg2); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::QuadratureFunction>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunction(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_QuadratureFunction(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Coefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Coefficient> : std::false_type { };
}

// Class generating the wrapper for type mfem::Coefficient
// signature to use in the veto file: mfem::Coefficient
struct Jlmfem_Coefficient: public Wrapper {

  Jlmfem_Coefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Coefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/coefficient.hpp:41:7
    jlcxx::TypeWrapper<mfem::Coefficient>  t = jlModule.add_type<mfem::Coefficient>("mfem!Coefficient");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Coefficient>>(new jlcxx::TypeWrapper<mfem::Coefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Coefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Coefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Coefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::BilinearFormIntegrator> : std::false_type { };
  template<> struct DefaultConstructible<mfem::BilinearFormIntegrator> : std::false_type { };
}

// Class generating the wrapper for type mfem::BilinearFormIntegrator
// signature to use in the veto file: mfem::BilinearFormIntegrator
struct Jlmfem_BilinearFormIntegrator: public Wrapper {

  Jlmfem_BilinearFormIntegrator(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::BilinearFormIntegrator (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/bilininteg.hpp:26:7
    jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>  t = jlModule.add_type<mfem::BilinearFormIntegrator>("mfem!BilinearFormIntegrator");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>>(new jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::BilinearFormIntegrator>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_BilinearFormIntegrator(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_BilinearFormIntegrator(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::JumpScaling> : std::false_type { };
  template<> struct DefaultConstructible<mfem::JumpScaling> : std::false_type { };
}

// Class generating the wrapper for type mfem::JumpScaling
// signature to use in the veto file: mfem::JumpScaling
struct Jlmfem_JumpScaling: public Wrapper {

  Jlmfem_JumpScaling(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::JumpScaling (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:772:7
    jlcxx::TypeWrapper<mfem::JumpScaling>  t = jlModule.add_type<mfem::JumpScaling>("mfem!JumpScaling");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::JumpScaling>>(new jlcxx::TypeWrapper<mfem::JumpScaling>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::JumpScaling::JumpScaling(double, mfem::JumpScaling::JumpScalingType) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:785:4
    t.constructor<double>(/*finalize=*/jlcxx::finalize_policy::yes);
    t.constructor<double, mfem::JumpScaling::JumpScalingType>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::JumpScaling::Eval(double, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::JumpScaling::Eval(double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:787:11
    t.method("Eval", static_cast<double (mfem::JumpScaling::*)(double, int)  const>(&mfem::JumpScaling::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::JumpScaling>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_JumpScaling(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_JumpScaling(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::ExtrudeCoefficient> : std::false_type { };
  template<> struct DefaultConstructible<mfem::ExtrudeCoefficient> : std::false_type { };
template<> struct SuperType<mfem::ExtrudeCoefficient> { typedef mfem::Coefficient type; };
}

// Class generating the wrapper for type mfem::ExtrudeCoefficient
// signature to use in the veto file: mfem::ExtrudeCoefficient
struct Jlmfem_ExtrudeCoefficient: public Wrapper {

  Jlmfem_ExtrudeCoefficient(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::ExtrudeCoefficient (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:866:7
    jlcxx::TypeWrapper<mfem::ExtrudeCoefficient>  t = jlModule.add_type<mfem::ExtrudeCoefficient>("mfem!ExtrudeCoefficient",
      jlcxx::julia_base_type<mfem::Coefficient>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::ExtrudeCoefficient>>(new jlcxx::TypeWrapper<mfem::ExtrudeCoefficient>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::ExtrudeCoefficient::ExtrudeCoefficient(mfem::Mesh *, mfem::Coefficient &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:873:4
    t.constructor<mfem::Mesh *, mfem::Coefficient &, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for double mfem::ExtrudeCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ExtrudeCoefficient::Eval(mfem::ElementTransformation &, const mfem::IntegrationPoint &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:875:19
    t.method("Eval", static_cast<double (mfem::ExtrudeCoefficient::*)(mfem::ElementTransformation &, const mfem::IntegrationPoint &) >(&mfem::ExtrudeCoefficient::Eval));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::ExtrudeCoefficient>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_ExtrudeCoefficient(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_ExtrudeCoefficient(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::KnotVector> : std::false_type { };
  template<> struct DefaultConstructible<mfem::KnotVector> : std::false_type { };
}

// Class generating the wrapper for type mfem::KnotVector
// signature to use in the veto file: mfem::KnotVector
struct Jlmfem_KnotVector: public Wrapper {

  Jlmfem_KnotVector(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::KnotVector (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:32:7
    jlcxx::TypeWrapper<mfem::KnotVector>  t = jlModule.add_type<mfem::KnotVector>("mfem!KnotVector");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::KnotVector>>(new jlcxx::TypeWrapper<mfem::KnotVector>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;
    t.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::KnotVector(int, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:44:4
    t.constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::KnotVector(const mfem::KnotVector &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:45:4
    t.constructor<const mfem::KnotVector &>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for mfem::KnotVector & mfem::KnotVector::operator=(const mfem::KnotVector &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::KnotVector & mfem::KnotVector::operator=(const mfem::KnotVector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:47:16
    t.method("assign", static_cast<mfem::KnotVector & (mfem::KnotVector::*)(const mfem::KnotVector &) >(&mfem::KnotVector::operator=));

    DEBUG_MSG("Adding wrapper for int mfem::KnotVector::GetNE() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::KnotVector::GetNE()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:49:8
    t.method("GetNE", static_cast<int (mfem::KnotVector::*)()  const>(&mfem::KnotVector::GetNE));

    DEBUG_MSG("Adding wrapper for int mfem::KnotVector::GetNKS() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::KnotVector::GetNKS()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:50:8
    t.method("GetNKS", static_cast<int (mfem::KnotVector::*)()  const>(&mfem::KnotVector::GetNKS));

    DEBUG_MSG("Adding wrapper for int mfem::KnotVector::GetNCP() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::KnotVector::GetNCP()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:51:8
    t.method("GetNCP", static_cast<int (mfem::KnotVector::*)()  const>(&mfem::KnotVector::GetNCP));

    DEBUG_MSG("Adding wrapper for int mfem::KnotVector::GetOrder() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::KnotVector::GetOrder()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:52:8
    t.method("GetOrder", static_cast<int (mfem::KnotVector::*)()  const>(&mfem::KnotVector::GetOrder));

    DEBUG_MSG("Adding wrapper for int mfem::KnotVector::Size() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::KnotVector::Size()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:53:8
    t.method("Size", static_cast<int (mfem::KnotVector::*)()  const>(&mfem::KnotVector::Size));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::GetElements() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::GetElements()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:56:9
    t.method("GetElements", static_cast<void (mfem::KnotVector::*)() >(&mfem::KnotVector::GetElements));

    DEBUG_MSG("Adding wrapper for bool mfem::KnotVector::isElement(int) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::KnotVector::isElement(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:58:9
    t.method("isElement", static_cast<bool (mfem::KnotVector::*)(int)  const>(&mfem::KnotVector::isElement));

    DEBUG_MSG("Adding wrapper for double mfem::KnotVector::getKnotLocation(double, int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::KnotVector::getKnotLocation(double, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:60:11
    t.method("getKnotLocation", static_cast<double (mfem::KnotVector::*)(double, int)  const>(&mfem::KnotVector::getKnotLocation));

    DEBUG_MSG("Adding wrapper for int mfem::KnotVector::findKnotSpan(double) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::KnotVector::findKnotSpan(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:63:8
    t.method("findKnotSpan", static_cast<int (mfem::KnotVector::*)(double)  const>(&mfem::KnotVector::findKnotSpan));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::CalcShape(mfem::Vector &, int, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::CalcShape(mfem::Vector &, int, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:65:9
    t.method("CalcShape", static_cast<void (mfem::KnotVector::*)(mfem::Vector &, int, double)  const>(&mfem::KnotVector::CalcShape));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::CalcDShape(mfem::Vector &, int, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::CalcDShape(mfem::Vector &, int, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:66:9
    t.method("CalcDShape", static_cast<void (mfem::KnotVector::*)(mfem::Vector &, int, double)  const>(&mfem::KnotVector::CalcDShape));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::CalcDnShape(mfem::Vector &, int, int, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::CalcDnShape(mfem::Vector &, int, int, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:67:9
    t.method("CalcDnShape", static_cast<void (mfem::KnotVector::*)(mfem::Vector &, int, int, double)  const>(&mfem::KnotVector::CalcDnShape));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::CalcD2Shape(mfem::Vector &, int, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::CalcD2Shape(mfem::Vector &, int, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:68:9
    t.method("CalcD2Shape", static_cast<void (mfem::KnotVector::*)(mfem::Vector &, int, double)  const>(&mfem::KnotVector::CalcD2Shape));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::FindMaxima(mfem::Array<int> &, mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::FindMaxima(mfem::Array<int> &, mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:74:9
    t.method("FindMaxima", static_cast<void (mfem::KnotVector::*)(mfem::Array<int> &, mfem::Vector &, mfem::Vector &)  const>(&mfem::KnotVector::FindMaxima));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::FindInterpolant(mfem::Array<mfem::Vector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::FindInterpolant(mfem::Array<mfem::Vector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:78:9
    t.method("FindInterpolant", static_cast<void (mfem::KnotVector::*)(mfem::Array<mfem::Vector *> &) >(&mfem::KnotVector::FindInterpolant));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::Difference(const mfem::KnotVector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::Difference(const mfem::KnotVector &, mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:80:9
    t.method("Difference", static_cast<void (mfem::KnotVector::*)(const mfem::KnotVector &, mfem::Vector &)  const>(&mfem::KnotVector::Difference));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::UniformRefinement(mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::UniformRefinement(mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:81:9
    t.method("UniformRefinement", static_cast<void (mfem::KnotVector::*)(mfem::Vector &)  const>(&mfem::KnotVector::UniformRefinement));

    DEBUG_MSG("Adding wrapper for mfem::KnotVector * mfem::KnotVector::DegreeElevate(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::KnotVector * mfem::KnotVector::DegreeElevate(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:85:16
    t.method("DegreeElevate", static_cast<mfem::KnotVector * (mfem::KnotVector::*)(int)  const>(&mfem::KnotVector::DegreeElevate));

    DEBUG_MSG("Adding wrapper for void mfem::KnotVector::Flip() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::KnotVector::Flip()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:87:9
    t.method("Flip", static_cast<void (mfem::KnotVector::*)() >(&mfem::KnotVector::Flip));
    module_.set_override_module(jl_base_module);


    DEBUG_MSG("Adding setindex! method  to wrap double & mfem::KnotVector::operator[](int) (" __HERE__ ")");
// defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:100:12
    t.method("setindex!",
      [](mfem::KnotVector& a, int i, double const & val){
      return a[i] = val;
    });

    DEBUG_MSG("Adding getindex method to wrap double & mfem::KnotVector::operator[](int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:100:12
    t.method("getindex",
      [](mfem::KnotVector& a, int i){
      return a[i];
    });


    module_.unset_override_module();
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::KnotVector>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_KnotVector(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_KnotVector(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSPatch> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSPatch> : std::false_type { };
}

// Class generating the wrapper for type mfem::NURBSPatch
// signature to use in the veto file: mfem::NURBSPatch
struct Jlmfem_NURBSPatch: public Wrapper {

  Jlmfem_NURBSPatch(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSPatch (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:105:7
    jlcxx::TypeWrapper<mfem::NURBSPatch>  t = jlModule.add_type<mfem::NURBSPatch>("mfem!NURBSPatch");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSPatch>>(new jlcxx::TypeWrapper<mfem::NURBSPatch>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::NURBSPatch(const mfem::NURBSPatch &) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:132:4
    t.constructor<const mfem::NURBSPatch &>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::NURBSPatch(const mfem::KnotVector *, const mfem::KnotVector *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:134:4
    t.constructor<const mfem::KnotVector *, const mfem::KnotVector *, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::NURBSPatch(const mfem::KnotVector *, const mfem::KnotVector *, const mfem::KnotVector *, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:135:4
    t.constructor<const mfem::KnotVector *, const mfem::KnotVector *, const mfem::KnotVector *, int>(/*finalize=*/jlcxx::finalize_policy::yes);


    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::NURBSPatch(mfem::Array<const mfem::KnotVector *> &, int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:137:4
    t.constructor<mfem::Array<const mfem::KnotVector *> &, int>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::DegreeElevate(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::DegreeElevate(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:145:9
    t.method("DegreeElevate", static_cast<void (mfem::NURBSPatch::*)(int, int) >(&mfem::NURBSPatch::DegreeElevate));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::KnotInsert(int, const mfem::KnotVector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::KnotInsert(int, const mfem::KnotVector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:146:9
    t.method("KnotInsert", static_cast<void (mfem::NURBSPatch::*)(int, const mfem::KnotVector &) >(&mfem::NURBSPatch::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::KnotInsert(int, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::KnotInsert(int, const mfem::Vector &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:147:9
    t.method("KnotInsert", static_cast<void (mfem::NURBSPatch::*)(int, const mfem::Vector &) >(&mfem::NURBSPatch::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::KnotInsert(mfem::Array<mfem::Vector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::KnotInsert(mfem::Array<mfem::Vector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:149:9
    t.method("KnotInsert", static_cast<void (mfem::NURBSPatch::*)(mfem::Array<mfem::Vector *> &) >(&mfem::NURBSPatch::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::KnotInsert(mfem::Array<mfem::KnotVector *> &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::KnotInsert(mfem::Array<mfem::KnotVector *> &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:150:9
    t.method("KnotInsert", static_cast<void (mfem::NURBSPatch::*)(mfem::Array<mfem::KnotVector *> &) >(&mfem::NURBSPatch::KnotInsert));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::DegreeElevate(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::DegreeElevate(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:152:9
    t.method("DegreeElevate", static_cast<void (mfem::NURBSPatch::*)(int) >(&mfem::NURBSPatch::DegreeElevate));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::UniformRefinement() (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::UniformRefinement()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:153:9
    t.method("UniformRefinement", static_cast<void (mfem::NURBSPatch::*)() >(&mfem::NURBSPatch::UniformRefinement));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatch::GetNC() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatch::GetNC()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:156:8
    t.method("GetNC", static_cast<int (mfem::NURBSPatch::*)()  const>(&mfem::NURBSPatch::GetNC));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatch::GetNKV() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatch::GetNKV()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:157:8
    t.method("GetNKV", static_cast<int (mfem::NURBSPatch::*)()  const>(&mfem::NURBSPatch::GetNKV));

    DEBUG_MSG("Adding wrapper for mfem::KnotVector * mfem::NURBSPatch::GetKV(int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::KnotVector * mfem::NURBSPatch::GetKV(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:159:16
    t.method("GetKV", static_cast<mfem::KnotVector * (mfem::NURBSPatch::*)(int) >(&mfem::NURBSPatch::GetKV));

    DEBUG_MSG("Adding wrapper for double & mfem::NURBSPatch::operator()(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::NURBSPatch::operator()(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:162:25
    t.method("paren", static_cast<double & (mfem::NURBSPatch::*)(int, int) >(&mfem::NURBSPatch::operator()));

    DEBUG_MSG("Adding wrapper for const double & mfem::NURBSPatch::operator()(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::NURBSPatch::operator()(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:163:25
    t.method("paren", static_cast<const double & (mfem::NURBSPatch::*)(int, int)  const>(&mfem::NURBSPatch::operator()));

    DEBUG_MSG("Adding wrapper for double & mfem::NURBSPatch::operator()(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::NURBSPatch::operator()(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:165:25
    t.method("paren", static_cast<double & (mfem::NURBSPatch::*)(int, int, int) >(&mfem::NURBSPatch::operator()));

    DEBUG_MSG("Adding wrapper for const double & mfem::NURBSPatch::operator()(int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::NURBSPatch::operator()(int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:166:25
    t.method("paren", static_cast<const double & (mfem::NURBSPatch::*)(int, int, int)  const>(&mfem::NURBSPatch::operator()));

    DEBUG_MSG("Adding wrapper for double & mfem::NURBSPatch::operator()(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::NURBSPatch::operator()(int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:168:25
    t.method("paren", static_cast<double & (mfem::NURBSPatch::*)(int, int, int, int) >(&mfem::NURBSPatch::operator()));

    DEBUG_MSG("Adding wrapper for const double & mfem::NURBSPatch::operator()(int, int, int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::NURBSPatch::operator()(int, int, int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:169:25
    t.method("paren", static_cast<const double & (mfem::NURBSPatch::*)(int, int, int, int)  const>(&mfem::NURBSPatch::operator()));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::Get2DRotationMatrix(double, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::Get2DRotationMatrix(double, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:171:16
    module_.method("mfem!NURBSPatch!Get2DRotationMatrix", static_cast<void (*)(double, mfem::DenseMatrix &) >(&mfem::NURBSPatch::Get2DRotationMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::Get3DRotationMatrix(double[], double, double, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::Get3DRotationMatrix(double[], double, double, mfem::DenseMatrix &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:173:16
    module_.method("mfem!NURBSPatch!Get3DRotationMatrix", static_cast<void (*)(double[], double, double, mfem::DenseMatrix &) >(&mfem::NURBSPatch::Get3DRotationMatrix));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::FlipDirection(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::FlipDirection(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:175:9
    t.method("FlipDirection", static_cast<void (mfem::NURBSPatch::*)(int) >(&mfem::NURBSPatch::FlipDirection));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::SwapDirections(int, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::SwapDirections(int, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:176:9
    t.method("SwapDirections", static_cast<void (mfem::NURBSPatch::*)(int, int) >(&mfem::NURBSPatch::SwapDirections));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::Rotate(double, double[]) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::Rotate(double, double[])
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:181:9
    t.method("Rotate", static_cast<void (mfem::NURBSPatch::*)(double, double[]) >(&mfem::NURBSPatch::Rotate));
    t.method("Rotate", [](mfem::NURBSPatch& a, double arg0)->void { a.Rotate(arg0); });
    t.method("Rotate", [](mfem::NURBSPatch* a, double arg0)->void { a->Rotate(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::Rotate2D(double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::Rotate2D(double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:182:9
    t.method("Rotate2D", static_cast<void (mfem::NURBSPatch::*)(double) >(&mfem::NURBSPatch::Rotate2D));

    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatch::Rotate3D(double[], double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::NURBSPatch::Rotate3D(double[], double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:183:9
    t.method("Rotate3D", static_cast<void (mfem::NURBSPatch::*)(double[], double) >(&mfem::NURBSPatch::Rotate3D));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatch::MakeUniformDegree(int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatch::MakeUniformDegree(int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:185:8
    t.method("MakeUniformDegree", static_cast<int (mfem::NURBSPatch::*)(int) >(&mfem::NURBSPatch::MakeUniformDegree));
    t.method("MakeUniformDegree", [](mfem::NURBSPatch& a)->int { return a.MakeUniformDegree(); });
    t.method("MakeUniformDegree", [](mfem::NURBSPatch* a)->int { return a->MakeUniformDegree(); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSPatch>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSPatch(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSPatch(module));
}

namespace jlcxx {
  template<> struct IsMirroredType<mfem::NURBSPatchMap> : std::false_type { };
  template<> struct DefaultConstructible<mfem::NURBSPatchMap> : std::false_type { };
}

// Class generating the wrapper for type mfem::NURBSPatchMap
// signature to use in the veto file: mfem::NURBSPatchMap
struct Jlmfem_NURBSPatchMap: public Wrapper {

  Jlmfem_NURBSPatchMap(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::NURBSPatchMap (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:545:7
    jlcxx::TypeWrapper<mfem::NURBSPatchMap>  t = jlModule.add_type<mfem::NURBSPatchMap>("mfem!NURBSPatchMap");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSPatchMap>>(new jlcxx::TypeWrapper<mfem::NURBSPatchMap>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;


    DEBUG_MSG("Adding wrapper for void mfem::NURBSPatchMap::NURBSPatchMap(const mfem::NURBSExtension *) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:567:4
    t.constructor<const mfem::NURBSExtension *>(/*finalize=*/jlcxx::finalize_policy::yes);

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatchMap::nx() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatchMap::nx()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:569:8
    t.method("nx", static_cast<int (mfem::NURBSPatchMap::*)() >(&mfem::NURBSPatchMap::nx));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatchMap::ny() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatchMap::ny()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:570:8
    t.method("ny", static_cast<int (mfem::NURBSPatchMap::*)() >(&mfem::NURBSPatchMap::ny));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatchMap::nz() (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatchMap::nz()
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:571:8
    t.method("nz", static_cast<int (mfem::NURBSPatchMap::*)() >(&mfem::NURBSPatchMap::nz));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatchMap::operator()(const int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatchMap::operator()(const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:579:15
    t.method("paren", static_cast<int (mfem::NURBSPatchMap::*)(const int)  const>(&mfem::NURBSPatchMap::operator()));
    module_.set_override_module(jl_base_module);


    DEBUG_MSG("Adding getindex method to wrap int mfem::NURBSPatchMap::operator[](const int) (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:580:15
    t.method("getindex",
      [](mfem::NURBSPatchMap& a, const int i){
      return a[i];
    });

    module_.unset_override_module();

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatchMap::operator()(const int, const int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatchMap::operator()(const int, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:582:15
    t.method("paren", static_cast<int (mfem::NURBSPatchMap::*)(const int, const int)  const>(&mfem::NURBSPatchMap::operator()));

    DEBUG_MSG("Adding wrapper for int mfem::NURBSPatchMap::operator()(const int, const int, const int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::NURBSPatchMap::operator()(const int, const int, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/nurbs.hpp:584:15
    t.method("paren", static_cast<int (mfem::NURBSPatchMap::*)(const int, const int, const int)  const>(&mfem::NURBSPatchMap::operator()));
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::NURBSPatchMap>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_NURBSPatchMap(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_NURBSPatchMap(module));
}
// Class generating the wrapper for type 
// signature to use in the veto file: 
struct JlGlobal: public Wrapper {

  JlGlobal(jlcxx::Module& jlModule): Wrapper(jlModule){
  }

  void add_methods() const{
    auto& t = module_;

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::CoarseFineTransformations &, mfem::CoarseFineTransformations &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::CoarseFineTransformations &, mfem::CoarseFineTransformations &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:95:6
    t.method("mfem!Swap", static_cast<void (*)(mfem::CoarseFineTransformations &, mfem::CoarseFineTransformations &) >(&mfem::Swap));

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::Extrude1D(mfem::Mesh *, const int, const double, const bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::Extrude1D(mfem::Mesh *, const int, const double, const bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2503:7
    t.method("mfem!Extrude1D", static_cast<mfem::Mesh * (*)(mfem::Mesh *, const int, const double, const bool) >(&mfem::Extrude1D));
    t.method("mfem!Extrude1D", [](mfem::Mesh * arg0, const int arg1, const double arg2)->mfem::Mesh * { return mfem::Extrude1D(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::Extrude2D(mfem::Mesh *, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::Extrude2D(mfem::Mesh *, const int, const double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2507:7
    t.method("mfem!Extrude2D", static_cast<mfem::Mesh * (*)(mfem::Mesh *, const int, const double) >(&mfem::Extrude2D));

    DEBUG_MSG("Adding wrapper for void mfem::ShiftRight(int &, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ShiftRight(int &, int &, int &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:2510:13
    t.method("mfem!ShiftRight", static_cast<void (*)(int &, int &, int &) >(&mfem::ShiftRight));

    DEBUG_MSG("Adding wrapper for bool mfem::UsesTensorBasis(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::UsesTensorBasis(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1345:13
    t.method("mfem!UsesTensorBasis", static_cast<bool (*)(const mfem::FiniteElementSpace &) >(&mfem::UsesTensorBasis));

    DEBUG_MSG("Adding wrapper for mfem::ElementDofOrdering mfem::GetEVectorOrdering(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::ElementDofOrdering mfem::GetEVectorOrdering(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:1356:20
    t.method("mfem!GetEVectorOrdering", static_cast<mfem::ElementDofOrdering (*)(const mfem::FiniteElementSpace &) >(&mfem::GetEVectorOrdering));

    DEBUG_MSG("Adding wrapper for double mfem::ZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::GridFunction &, mfem::Vector &, mfem::Array<int> *, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::GridFunction &, mfem::Vector &, mfem::Array<int> *, int, bool)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:800:8
    t.method("mfem!ZZErrorEstimator", static_cast<double (*)(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::GridFunction &, mfem::Vector &, mfem::Array<int> *, int, bool) >(&mfem::ZZErrorEstimator));
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3); });
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3, mfem::Array<int> * arg4)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3, mfem::Array<int> * arg4, int arg5)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3, arg4, arg5); });

    DEBUG_MSG("Adding wrapper for void mfem::TensorProductLegendre(int, int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, const mfem::Vector *) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::TensorProductLegendre(int, int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, const mfem::Vector *)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:812:6
    t.method("mfem!TensorProductLegendre", static_cast<void (*)(int, int, const mfem::Vector &, const mfem::Vector &, const mfem::Vector &, mfem::Vector &, double, const mfem::Vector *) >(&mfem::TensorProductLegendre));
    t.method("mfem!TensorProductLegendre", [](int arg0, int arg1, const mfem::Vector & arg2, const mfem::Vector & arg3, const mfem::Vector & arg4, mfem::Vector & arg5)->void { mfem::TensorProductLegendre(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!TensorProductLegendre", [](int arg0, int arg1, const mfem::Vector & arg2, const mfem::Vector & arg3, const mfem::Vector & arg4, mfem::Vector & arg5, double arg6)->void { mfem::TensorProductLegendre(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::BoundingBox(const mfem::Array<int> &, mfem::FiniteElementSpace *, int, mfem::Vector &, mfem::Vector &, double &, mfem::Vector &, int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BoundingBox(const mfem::Array<int> &, mfem::FiniteElementSpace *, int, mfem::Vector &, mfem::Vector &, double &, mfem::Vector &, int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:836:6
    t.method("mfem!BoundingBox", static_cast<void (*)(const mfem::Array<int> &, mfem::FiniteElementSpace *, int, mfem::Vector &, mfem::Vector &, double &, mfem::Vector &, int) >(&mfem::BoundingBox));
    t.method("mfem!BoundingBox", [](const mfem::Array<int> & arg0, mfem::FiniteElementSpace * arg1, int arg2, mfem::Vector & arg3, mfem::Vector & arg4, double & arg5, mfem::Vector & arg6)->void { mfem::BoundingBox(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for double mfem::LSZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::Vector &, bool, bool, double) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::LSZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::Vector &, bool, bool, double)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:853:8
    t.method("mfem!LSZZErrorEstimator", static_cast<double (*)(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::Vector &, bool, bool, double) >(&mfem::LSZZErrorEstimator));
    t.method("mfem!LSZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::Vector & arg2)->double { return mfem::LSZZErrorEstimator(arg0, arg1, arg2); });
    t.method("mfem!LSZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::Vector & arg2, bool arg3)->double { return mfem::LSZZErrorEstimator(arg0, arg1, arg2, arg3); });
    t.method("mfem!LSZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::Vector & arg2, bool arg3, bool arg4)->double { return mfem::LSZZErrorEstimator(arg0, arg1, arg2, arg3, arg4); });

    DEBUG_MSG("Adding wrapper for double mfem::ComputeElementLpDistance(double, int, mfem::GridFunction &, mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ComputeElementLpDistance(double, int, mfem::GridFunction &, mfem::GridFunction &)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:861:8
    t.method("mfem!ComputeElementLpDistance", static_cast<double (*)(double, int, mfem::GridFunction &, mfem::GridFunction &) >(&mfem::ComputeElementLpDistance));

    DEBUG_MSG("Adding wrapper for mfem::GridFunction * mfem::Extrude1DGridFunction(mfem::Mesh *, mfem::Mesh *, mfem::GridFunction *, const int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction * mfem::Extrude1DGridFunction(mfem::Mesh *, mfem::Mesh *, mfem::GridFunction *, const int)
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:880:15
    t.method("mfem!Extrude1DGridFunction", static_cast<mfem::GridFunction * (*)(mfem::Mesh *, mfem::Mesh *, mfem::GridFunction *, const int) >(&mfem::Extrude1DGridFunction));

    DEBUG_MSG("Adding mfem!Mesh!remove_unused_vertices methods to provide access to the global variable mfem::Mesh::remove_unused_vertices (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:286:16
    module_.method("mfem!Mesh!remove_unused_vertices", []()-> bool { return mfem::Mesh::remove_unused_vertices; });
    module_.method("mfem!Mesh!remove_unused_vertices!", [](bool val)-> bool { return mfem::Mesh::remove_unused_vertices = val; });

    DEBUG_MSG("Adding mfem!QuadratureInterpolator!MAX_NQ2D methods to provide access to the global variable mfem::QuadratureInterpolator::MAX_NQ2D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:43:21
    module_.method("mfem!QuadratureInterpolator!MAX_NQ2D", []()-> int { return mfem::QuadratureInterpolator::MAX_NQ2D; });

    DEBUG_MSG("Adding mfem!QuadratureInterpolator!MAX_ND2D methods to provide access to the global variable mfem::QuadratureInterpolator::MAX_ND2D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:44:21
    module_.method("mfem!QuadratureInterpolator!MAX_ND2D", []()-> int { return mfem::QuadratureInterpolator::MAX_ND2D; });

    DEBUG_MSG("Adding mfem!QuadratureInterpolator!MAX_VDIM2D methods to provide access to the global variable mfem::QuadratureInterpolator::MAX_VDIM2D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:45:21
    module_.method("mfem!QuadratureInterpolator!MAX_VDIM2D", []()-> int { return mfem::QuadratureInterpolator::MAX_VDIM2D; });

    DEBUG_MSG("Adding mfem!QuadratureInterpolator!MAX_NQ3D methods to provide access to the global variable mfem::QuadratureInterpolator::MAX_NQ3D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:47:21
    module_.method("mfem!QuadratureInterpolator!MAX_NQ3D", []()-> int { return mfem::QuadratureInterpolator::MAX_NQ3D; });

    DEBUG_MSG("Adding mfem!QuadratureInterpolator!MAX_ND3D methods to provide access to the global variable mfem::QuadratureInterpolator::MAX_ND3D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:48:21
    module_.method("mfem!QuadratureInterpolator!MAX_ND3D", []()-> int { return mfem::QuadratureInterpolator::MAX_ND3D; });

    DEBUG_MSG("Adding mfem!QuadratureInterpolator!MAX_VDIM3D methods to provide access to the global variable mfem::QuadratureInterpolator::MAX_VDIM3D (" __HERE__ ")");
    // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:49:21
    module_.method("mfem!QuadratureInterpolator!MAX_VDIM3D", []()-> int { return mfem::QuadratureInterpolator::MAX_VDIM3D; });
  }
};
std::shared_ptr<Wrapper> newJlGlobal(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlGlobal(module));
}

class Jlmfem_Array;
class Jlmfem_Embedding;
class Jlmfem_Refinement;
class Jlmfem_IntegrationPoint;
class Jlmfem_Array;
class Jlmfem_CoarseFineTransformations;
class Jlmfem_Table;
class Jlmfem_Mesh;
class Jlmfem_DenseMatrix;
class Jlmfem_NURBSExtension;
class Jlmfem_Element;
class Jlmfem_Vector;
class Jlmfem_ElementTransformation;
class Jlmfem_Mesh_GeometryList;
class Jlmfem_DSTable;
class Jlmfem_FiniteElement;
class Jlmfem_IsoparametricTransformation;
class Jlmfem_FaceElementTransformations;
class Jlmfem_Mesh_FaceInformation;
class Jlmfem_VectorCoefficient;
class Jlmfem_GridFunction;
class Jlmfem_FiniteElementSpace;
class Jlmfem_Vertex;
class Jlmfem_InverseElementTransformation;
class Jlmfem_IntegrationRule;
class Jlmfem_NodeExtrudeCoefficient;
class Jlmfem_FiniteElementCollection;
class Jlmfem_StatelessDofTransformation;
class Jlmfem_H1_FECollection;
class Jlmfem_H1Pos_FECollection;
class Jlmfem_H1Ser_FECollection;
class Jlmfem_H1_Trace_FECollection;
class Jlmfem_L2_FECollection;
class Jlmfem_RT_FECollection;
class Jlmfem_RT_Trace_FECollection;
class Jlmfem_DG_Interface_FECollection;
class Jlmfem_ND_FECollection;
class Jlmfem_ND_Trace_FECollection;
class Jlmfem_ND_R1D_FECollection;
class Jlmfem_RT_R1D_FECollection;
class Jlmfem_ND_R2D_FECollection;
class Jlmfem_ND_R2D_Trace_FECollection;
class Jlmfem_RT_R2D_FECollection;
class Jlmfem_RT_R2D_Trace_FECollection;
class Jlmfem_NURBSFECollection;
class Jlmfem_LinearFECollection;
class Jlmfem_QuadraticFECollection;
class Jlmfem_QuadraticPosFECollection;
class Jlmfem_CubicFECollection;
class Jlmfem_CrouzeixRaviartFECollection;
class Jlmfem_LinearNonConf3DFECollection;
class Jlmfem_RT0_2DFECollection;
class Jlmfem_RT1_2DFECollection;
class Jlmfem_RT2_2DFECollection;
class Jlmfem_Const2DFECollection;
class Jlmfem_LinearDiscont2DFECollection;
class Jlmfem_GaussLinearDiscont2DFECollection;
class Jlmfem_P1OnQuadFECollection;
class Jlmfem_QuadraticDiscont2DFECollection;
class Jlmfem_QuadraticPosDiscont2DFECollection;
class Jlmfem_GaussQuadraticDiscont2DFECollection;
class Jlmfem_CubicDiscont2DFECollection;
class Jlmfem_Const3DFECollection;
class Jlmfem_LinearDiscont3DFECollection;
class Jlmfem_QuadraticDiscont3DFECollection;
class Jlmfem_RefinedLinearFECollection;
class Jlmfem_ND1_3DFECollection;
class Jlmfem_RT0_3DFECollection;
class Jlmfem_RT1_3DFECollection;
class Jlmfem_Local_FECollection;
class Jlmfem_Ordering;
class Jlmfem_SparseMatrix;
class Jlmfem_Operator;
class Jlmfem_ElementRestrictionOperator;
class Jlmfem_FaceRestriction;
class Jlmfem_QuadratureInterpolator;
class Jlmfem_QuadratureSpaceBase;
class Jlmfem_QuadratureSpace;
class Jlmfem_FaceQuadratureInterpolator;
class Jlmfem_DofTransformation;
class Jlmfem_OperatorHandle;
class Jlmfem_FaceQuadratureSpace;
class Jlmfem_QuadratureFunction;
class Jlmfem_Coefficient;
class Jlmfem_BilinearFormIntegrator;
class Jlmfem_JumpScaling;
class Jlmfem_ExtrudeCoefficient;
class Jlmfem_KnotVector;
class Jlmfem_NURBSPatch;
class Jlmfem_NURBSPatchMap;
class JlGlobal;

std::shared_ptr<Wrapper> newJlmfem_Array(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Embedding(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Refinement(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IntegrationPoint(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Array(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CoarseFineTransformations(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Table(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DenseMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSExtension(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Element(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Vector(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ElementTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh_GeometryList(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DSTable(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElement(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IsoparametricTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceElementTransformations(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Mesh_FaceInformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_VectorCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GridFunction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElementSpace(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Vertex(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_InverseElementTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_IntegrationRule(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NodeExtrudeCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FiniteElementCollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_StatelessDofTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1Pos_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1Ser_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_H1_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_L2_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DG_Interface_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R1D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R1D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND_R2D_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT_R2D_Trace_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CubicFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CrouzeixRaviartFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearNonConf3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT0_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT1_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT2_2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Const2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GaussLinearDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_P1OnQuadFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticPosDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_GaussQuadraticDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_CubicDiscont2DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Const3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_LinearDiscont3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadraticDiscont3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RefinedLinearFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ND1_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT0_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_RT1_3DFECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Local_FECollection(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Ordering(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_SparseMatrix(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Operator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ElementRestrictionOperator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceRestriction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpaceBase(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureSpace(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceQuadratureInterpolator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_DofTransformation(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_OperatorHandle(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_FaceQuadratureSpace(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_QuadratureFunction(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_Coefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_BilinearFormIntegrator(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_JumpScaling(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_ExtrudeCoefficient(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_KnotVector(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSPatch(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlmfem_NURBSPatchMap(jlcxx::Module&);
std::shared_ptr<Wrapper> newJlGlobal(jlcxx::Module&);
//method from libcxxwrap returning its version
extern "C" JLCXX_API const char* cxxwrap_version_string();

//Check the code is compiled with a compatible version of libcxxwrap:
static_assert(1000*1000*JLCXX_VERSION_MAJOR  + 1000 * JLCXX_VERSION_MINOR + JLCXX_VERSION_PATCH >= 12000
  && 1000 * 1000 * JLCXX_VERSION_MAJOR  + 1000 * JLCXX_VERSION_MINOR + JLCXX_VERSION_PATCH < 14000,
  "The code was generated with WrapIt! for "
  "a different CxxWrap version (controlled with the cxxwrap_version parameter).");

//Check the version of loaded libcxxwrap library:
void throw_if_version_incompatibility(){
  std::string version_str = cxxwrap_version_string();
  static std::regex r("([[:digit:]]{1,3})\\.([[:digit:]]{1,3})\\.([[:digit:]]{1,3})");
  std::smatch matches;
  if(!std::regex_match(version_str, matches, r)){
    std::cerr << "Warning: Failed to check libcxxwrap version.";
  } else{    long version_int =   1000*1000*strtol(matches[1].str().c_str(), 0, 10)
                       +      1000*strtol(matches[2].str().c_str(), 0, 10)
                       +           strtol(matches[3].str().c_str(), 0, 10);
    if(version_int < 12000 || version_int >= 14000){
      throw std::runtime_error(std::string("Found libcxxwrap_jll version ")
       + version_str + ", while module MFEM requires a version in "
      "[0.12.0, 0.14.0)."
      " Note: if the module was installed with the package manager, the Project.toml file "
      "of the package is probably missing a compat specification that would have prevented "
      "the inconsistency.");
    }
  }
}


JLCXX_MODULE define_julia_module(jlcxx::Module& jlModule){
  
throw_if_version_incompatibility();
  DEBUG_MSG("Adding wrapper for enum mfem::MemoryType (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/linalg/../general/mem_manager.hpp:31:12
  jlModule.add_bits<mfem::MemoryType>("mfem!MemoryType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!MemoryType!HOST", mfem::MemoryType::HOST);
  jlModule.set_const("mfem!MemoryType!HOST_32", mfem::MemoryType::HOST_32);
  jlModule.set_const("mfem!MemoryType!HOST_64", mfem::MemoryType::HOST_64);
  jlModule.set_const("mfem!MemoryType!HOST_DEBUG", mfem::MemoryType::HOST_DEBUG);
  jlModule.set_const("mfem!MemoryType!HOST_UMPIRE", mfem::MemoryType::HOST_UMPIRE);
  jlModule.set_const("mfem!MemoryType!HOST_PINNED", mfem::MemoryType::HOST_PINNED);
  jlModule.set_const("mfem!MemoryType!MANAGED", mfem::MemoryType::MANAGED);
  jlModule.set_const("mfem!MemoryType!DEVICE", mfem::MemoryType::DEVICE);
  jlModule.set_const("mfem!MemoryType!DEVICE_DEBUG", mfem::MemoryType::DEVICE_DEBUG);
  jlModule.set_const("mfem!MemoryType!DEVICE_UMPIRE", mfem::MemoryType::DEVICE_UMPIRE);
  jlModule.set_const("mfem!MemoryType!DEVICE_UMPIRE_2", mfem::MemoryType::DEVICE_UMPIRE_2);
  jlModule.set_const("mfem!MemoryType!SIZE", mfem::MemoryType::SIZE);
  jlModule.set_const("mfem!MemoryType!PRESERVE", mfem::MemoryType::PRESERVE);
  jlModule.set_const("mfem!MemoryType!DEFAULT", mfem::MemoryType::DEFAULT);

  DEBUG_MSG("Adding anonymous enum defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:38:4 (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/ncmesh.hpp:38:4
  jlModule.set_const("mfem!Refinement!X", static_cast<int>(mfem::Refinement::X));
  jlModule.set_const("mfem!Refinement!Y", static_cast<int>(mfem::Refinement::Y));
  jlModule.set_const("mfem!Refinement!Z", static_cast<int>(mfem::Refinement::Z));
  jlModule.set_const("mfem!Refinement!XY", static_cast<int>(mfem::Refinement::XY));
  jlModule.set_const("mfem!Refinement!XZ", static_cast<int>(mfem::Refinement::XZ));
  jlModule.set_const("mfem!Refinement!YZ", static_cast<int>(mfem::Refinement::YZ));
  jlModule.set_const("mfem!Refinement!XYZ", static_cast<int>(mfem::Refinement::XYZ));

  DEBUG_MSG("Adding wrapper for enum mfem::Geometry::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/fe/../geom.hpp:35:9
  jlModule.add_bits<mfem::Geometry::Type>("mfem!Geometry!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Geometry!INVALID", mfem::Geometry::INVALID);
  jlModule.set_const("mfem!Geometry!POINT", mfem::Geometry::POINT);
  jlModule.set_const("mfem!Geometry!SEGMENT", mfem::Geometry::SEGMENT);
  jlModule.set_const("mfem!Geometry!TRIANGLE", mfem::Geometry::TRIANGLE);
  jlModule.set_const("mfem!Geometry!SQUARE", mfem::Geometry::SQUARE);
  jlModule.set_const("mfem!Geometry!TETRAHEDRON", mfem::Geometry::TETRAHEDRON);
  jlModule.set_const("mfem!Geometry!CUBE", mfem::Geometry::CUBE);
  jlModule.set_const("mfem!Geometry!PRISM", mfem::Geometry::PRISM);
  jlModule.set_const("mfem!Geometry!PYRAMID", mfem::Geometry::PYRAMID);
  jlModule.set_const("mfem!Geometry!NUM_GEOMETRIES", mfem::Geometry::NUM_GEOMETRIES);

  DEBUG_MSG("Adding wrapper for enum mfem::FaceType (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:45:12
  jlModule.add_bits<mfem::FaceType>("mfem!FaceType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!FaceType!Interior", mfem::FaceType::Interior);
  jlModule.set_const("mfem!FaceType!Boundary", mfem::FaceType::Boundary);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::Operation (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:270:9
  jlModule.add_bits<mfem::Mesh::Operation>("mfem!Mesh!Operation", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!NONE", mfem::Mesh::NONE);
  jlModule.set_const("mfem!Mesh!REFINE", mfem::Mesh::REFINE);
  jlModule.set_const("mfem!Mesh!DEREFINE", mfem::Mesh::DEREFINE);
  jlModule.set_const("mfem!Mesh!REBALANCE", mfem::Mesh::REBALANCE);

  DEBUG_MSG("Adding wrapper for enum mfem::Element::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/element.hpp:41:9
  jlModule.add_bits<mfem::Element::Type>("mfem!Element!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Element!POINT", mfem::Element::POINT);
  jlModule.set_const("mfem!Element!SEGMENT", mfem::Element::SEGMENT);
  jlModule.set_const("mfem!Element!TRIANGLE", mfem::Element::TRIANGLE);
  jlModule.set_const("mfem!Element!QUADRILATERAL", mfem::Element::QUADRILATERAL);
  jlModule.set_const("mfem!Element!TETRAHEDRON", mfem::Element::TETRAHEDRON);
  jlModule.set_const("mfem!Element!HEXAHEDRON", mfem::Element::HEXAHEDRON);
  jlModule.set_const("mfem!Element!WEDGE", mfem::Element::WEDGE);
  jlModule.set_const("mfem!Element!PYRAMID", mfem::Element::PYRAMID);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::FaceTopology (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1792:15
  jlModule.add_bits<mfem::Mesh::FaceTopology>("mfem!Mesh!FaceTopology", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!FaceTopology!Boundary", mfem::Mesh::FaceTopology::Boundary);
  jlModule.set_const("mfem!Mesh!FaceTopology!Conforming", mfem::Mesh::FaceTopology::Conforming);
  jlModule.set_const("mfem!Mesh!FaceTopology!Nonconforming", mfem::Mesh::FaceTopology::Nonconforming);
  jlModule.set_const("mfem!Mesh!FaceTopology!NA", mfem::Mesh::FaceTopology::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::ElementLocation (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1804:15
  jlModule.add_bits<mfem::Mesh::ElementLocation>("mfem!Mesh!ElementLocation", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!ElementLocation!Local", mfem::Mesh::ElementLocation::Local);
  jlModule.set_const("mfem!Mesh!ElementLocation!FaceNbr", mfem::Mesh::ElementLocation::FaceNbr);
  jlModule.set_const("mfem!Mesh!ElementLocation!NA", mfem::Mesh::ElementLocation::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::ElementConformity (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1819:15
  jlModule.add_bits<mfem::Mesh::ElementConformity>("mfem!Mesh!ElementConformity", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!ElementConformity!Coincident", mfem::Mesh::ElementConformity::Coincident);
  jlModule.set_const("mfem!Mesh!ElementConformity!Superset", mfem::Mesh::ElementConformity::Superset);
  jlModule.set_const("mfem!Mesh!ElementConformity!Subset", mfem::Mesh::ElementConformity::Subset);
  jlModule.set_const("mfem!Mesh!ElementConformity!NA", mfem::Mesh::ElementConformity::NA);

  DEBUG_MSG("Adding wrapper for enum mfem::Mesh::FaceInfoTag (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/submesh/../mesh.hpp:1838:15
  jlModule.add_bits<mfem::Mesh::FaceInfoTag>("mfem!Mesh!FaceInfoTag", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Mesh!FaceInfoTag!Boundary", mfem::Mesh::FaceInfoTag::Boundary);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!LocalConforming", mfem::Mesh::FaceInfoTag::LocalConforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!LocalSlaveNonconforming", mfem::Mesh::FaceInfoTag::LocalSlaveNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!SharedConforming", mfem::Mesh::FaceInfoTag::SharedConforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!SharedSlaveNonconforming", mfem::Mesh::FaceInfoTag::SharedSlaveNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!MasterNonconforming", mfem::Mesh::FaceInfoTag::MasterNonconforming);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!GhostSlave", mfem::Mesh::FaceInfoTag::GhostSlave);
  jlModule.set_const("mfem!Mesh!FaceInfoTag!GhostMaster", mfem::Mesh::FaceInfoTag::GhostMaster);

  DEBUG_MSG("Adding wrapper for enum mfem::VTKFormat (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/vtk.hpp:98:12
  jlModule.add_bits<mfem::VTKFormat>("mfem!VTKFormat", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!VTKFormat!ASCII", mfem::VTKFormat::ASCII);
  jlModule.set_const("mfem!VTKFormat!BINARY", mfem::VTKFormat::BINARY);
  jlModule.set_const("mfem!VTKFormat!BINARY32", mfem::VTKFormat::BINARY32);

  DEBUG_MSG("Adding anonymous enum defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:45:4 (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:45:4
  jlModule.set_const("mfem!FiniteElementCollection!CONTINUOUS", static_cast<int>(mfem::FiniteElementCollection::CONTINUOUS));
  jlModule.set_const("mfem!FiniteElementCollection!TANGENTIAL", static_cast<int>(mfem::FiniteElementCollection::TANGENTIAL));
  jlModule.set_const("mfem!FiniteElementCollection!NORMAL", static_cast<int>(mfem::FiniteElementCollection::NORMAL));
  jlModule.set_const("mfem!FiniteElementCollection!DISCONTINUOUS", static_cast<int>(mfem::FiniteElementCollection::DISCONTINUOUS));

  DEBUG_MSG("Adding anonymous enum defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:698:4 (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fe_coll.hpp:698:4
  jlModule.set_const("mfem!NURBSFECollection!VariableOrder", static_cast<int>(mfem::NURBSFECollection::VariableOrder));

  DEBUG_MSG("Adding wrapper for enum mfem::Ordering::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:33:9
  jlModule.add_bits<mfem::Ordering::Type>("mfem!Ordering!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Ordering!byNODES", mfem::Ordering::byNODES);
  jlModule.set_const("mfem!Ordering!byVDIM", mfem::Ordering::byVDIM);

  DEBUG_MSG("Adding wrapper for enum mfem::QVectorLayout (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:52:12
  jlModule.add_bits<mfem::QVectorLayout>("mfem!QVectorLayout", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!QVectorLayout!byNODES", mfem::QVectorLayout::byNODES);
  jlModule.set_const("mfem!QVectorLayout!byVDIM", mfem::QVectorLayout::byVDIM);

  DEBUG_MSG("Adding wrapper for enum mfem::ElementDofOrdering (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/fespace.hpp:74:12
  jlModule.add_bits<mfem::ElementDofOrdering>("mfem!ElementDofOrdering", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!ElementDofOrdering!NATIVE", mfem::ElementDofOrdering::NATIVE);
  jlModule.set_const("mfem!ElementDofOrdering!LEXICOGRAPHIC", mfem::ElementDofOrdering::LEXICOGRAPHIC);

  DEBUG_MSG("Adding wrapper for enum mfem::L2FaceValues (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/restriction.hpp:136:12
  jlModule.add_bits<mfem::L2FaceValues>("mfem!L2FaceValues", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!L2FaceValues!SingleValued", mfem::L2FaceValues::SingleValued);
  jlModule.set_const("mfem!L2FaceValues!DoubleValued", mfem::L2FaceValues::DoubleValued);

  DEBUG_MSG("Adding wrapper for enum mfem::Operator::Type (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/mesh/../fem/ceed/interface/../../../linalg/operator.hpp:283:9
  jlModule.add_bits<mfem::Operator::Type>("mfem!Operator!Type", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!Operator!ANY_TYPE", mfem::Operator::ANY_TYPE);
  jlModule.set_const("mfem!Operator!MFEM_SPARSEMAT", mfem::Operator::MFEM_SPARSEMAT);
  jlModule.set_const("mfem!Operator!Hypre_ParCSR", mfem::Operator::Hypre_ParCSR);
  jlModule.set_const("mfem!Operator!PETSC_MATAIJ", mfem::Operator::PETSC_MATAIJ);
  jlModule.set_const("mfem!Operator!PETSC_MATIS", mfem::Operator::PETSC_MATIS);
  jlModule.set_const("mfem!Operator!PETSC_MATSHELL", mfem::Operator::PETSC_MATSHELL);
  jlModule.set_const("mfem!Operator!PETSC_MATNEST", mfem::Operator::PETSC_MATNEST);
  jlModule.set_const("mfem!Operator!PETSC_MATHYPRE", mfem::Operator::PETSC_MATHYPRE);
  jlModule.set_const("mfem!Operator!PETSC_MATGENERIC", mfem::Operator::PETSC_MATGENERIC);
  jlModule.set_const("mfem!Operator!Complex_Operator", mfem::Operator::Complex_Operator);
  jlModule.set_const("mfem!Operator!MFEM_ComplexSparseMat", mfem::Operator::MFEM_ComplexSparseMat);
  jlModule.set_const("mfem!Operator!Complex_Hypre_ParCSR", mfem::Operator::Complex_Hypre_ParCSR);
  jlModule.set_const("mfem!Operator!Complex_DenseMat", mfem::Operator::Complex_DenseMat);
  jlModule.set_const("mfem!Operator!MFEM_Block_Matrix", mfem::Operator::MFEM_Block_Matrix);
  jlModule.set_const("mfem!Operator!MFEM_Block_Operator", mfem::Operator::MFEM_Block_Operator);

  DEBUG_MSG("Adding wrapper for enum mfem::GridFunction::AvgType (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:422:9
  jlModule.add_bits<mfem::GridFunction::AvgType>("mfem!GridFunction!AvgType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!GridFunction!ARITHMETIC", mfem::GridFunction::ARITHMETIC);
  jlModule.set_const("mfem!GridFunction!HARMONIC", mfem::GridFunction::HARMONIC);

  DEBUG_MSG("Adding wrapper for enum mfem::JumpScaling::JumpScalingType (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/gridfunc.hpp:775:9
  jlModule.add_bits<mfem::JumpScaling::JumpScalingType>("mfem!JumpScaling!JumpScalingType", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!JumpScaling!CONSTANT", mfem::JumpScaling::CONSTANT);
  jlModule.set_const("mfem!JumpScaling!ONE_OVER_H", mfem::JumpScaling::ONE_OVER_H);
  jlModule.set_const("mfem!JumpScaling!P_SQUARED_OVER_H", mfem::JumpScaling::P_SQUARED_OVER_H);

  DEBUG_MSG("Adding wrapper for enum mfem::QuadratureInterpolator::EvalFlags (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator.hpp:51:9
  jlModule.add_bits<mfem::QuadratureInterpolator::EvalFlags>("mfem!QuadratureInterpolator!EvalFlags", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!QuadratureInterpolator!VALUES", mfem::QuadratureInterpolator::VALUES);
  jlModule.set_const("mfem!QuadratureInterpolator!DERIVATIVES", mfem::QuadratureInterpolator::DERIVATIVES);
  jlModule.set_const("mfem!QuadratureInterpolator!DETERMINANTS", mfem::QuadratureInterpolator::DETERMINANTS);
  jlModule.set_const("mfem!QuadratureInterpolator!PHYSICAL_DERIVATIVES", mfem::QuadratureInterpolator::PHYSICAL_DERIVATIVES);

  DEBUG_MSG("Adding wrapper for enum mfem::FaceQuadratureInterpolator::FaceEvalFlags (" __HERE__ ")");
  // defined in /home/dogiermann/Builds/mfem-test/install/include/mfem/fem/quadinterpolator_face.hpp:53:9
  jlModule.add_bits<mfem::FaceQuadratureInterpolator::FaceEvalFlags>("mfem!FaceQuadratureInterpolator!FaceEvalFlags", jlcxx::julia_type("CppEnum"));
  jlModule.set_const("mfem!FaceQuadratureInterpolator!VALUES", mfem::FaceQuadratureInterpolator::VALUES);
  jlModule.set_const("mfem!FaceQuadratureInterpolator!DERIVATIVES", mfem::FaceQuadratureInterpolator::DERIVATIVES);
  jlModule.set_const("mfem!FaceQuadratureInterpolator!DETERMINANTS", mfem::FaceQuadratureInterpolator::DETERMINANTS);
  jlModule.set_const("mfem!FaceQuadratureInterpolator!NORMALS", mfem::FaceQuadratureInterpolator::NORMALS);

  std::vector<std::shared_ptr<Wrapper>> wrappers = {
    std::shared_ptr<Wrapper>(newJlmfem_Embedding(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IntegrationPoint(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Element(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Refinement(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_KnotVector(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Vector(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Array(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSExtension(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ElementTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DenseMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh_GeometryList(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Table(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DSTable(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElement(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IsoparametricTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceElementTransformations(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Mesh_FaceInformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Coefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_VectorCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GridFunction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElementSpace(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Vertex(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CoarseFineTransformations(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_InverseElementTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_IntegrationRule(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NodeExtrudeCoefficient(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Ordering(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_StatelessDofTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FiniteElementCollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1Pos_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1Ser_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_H1_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_L2_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DG_Interface_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R1D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R1D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R2D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND_R2D_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R2D_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT_R2D_Trace_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticPosFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CubicFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CrouzeixRaviartFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearNonConf3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT0_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT1_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT2_2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Const2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GaussLinearDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_P1OnQuadFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticPosDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_GaussQuadraticDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_CubicDiscont2DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Const3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_LinearDiscont3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadraticDiscont3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RefinedLinearFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ND1_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT0_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_RT1_3DFECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Local_FECollection(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_SparseMatrix(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_Operator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_ElementRestrictionOperator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceRestriction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureSpaceBase(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureSpace(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceQuadratureInterpolator(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_DofTransformation(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_OperatorHandle(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_FaceQuadratureSpace(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_QuadratureFunction(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSPatch(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_NURBSPatchMap(jlModule)),
    std::shared_ptr<Wrapper>(newJlmfem_BilinearFormIntegrator(jlModule)),
    std::shared_ptr<Wrapper>(newJlGlobal(jlModule))
  };
  for(const auto& w: wrappers) w->add_methods();
}
