// this file was auto-generated by wrapit v1.5.0
#include "Wrapper.h"

#include "jllibMFEM.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<mfem::Array<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<mfem::Array<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<mfem::Array<T>> : std::false_type { };
}

// Class generating the wrapper for type mfem::Array
// signature to use in the veto file: mfem::Array
struct Jlmfem_Array: public Wrapper {

  Jlmfem_Array(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Array (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:45:7
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("mfem!Array");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
    auto t1_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<mfem::Array<T>> wrapped){
      auto module_ = this->module_;
      typedef mfem::Array<T> WrappedType;
      wrapped.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(mfem::MemoryType) (" __HERE__ ")");
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:67:11
      wrapped.template constructor<mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(int) (" __HERE__ ")");
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:70:20
      wrapped.template constructor<int>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(int, mfem::MemoryType) (" __HERE__ ")");
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:74:11
      wrapped.template constructor<int, mfem::MemoryType>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array::Array<T>(T *, int) (" __HERE__ ")");
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:80:11
      wrapped.template constructor<T *, int>(/*finalize=*/jlcxx::finalize_policy::yes);

      DEBUG_MSG("Adding wrapper for T * mfem::Array::GetData() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::GetData()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:112:14
      wrapped.method("GetData", [](WrappedType& a)->T * { return a.GetData(); });
      wrapped.method("GetData", [](WrappedType* a)->T * { return a->GetData(); });

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::GetData() (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::GetData()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:114:20
      wrapped.method("GetData", [](WrappedType const& a)->const T * { return a.GetData(); });
      wrapped.method("GetData", [](WrappedType const* a)->const T * { return a->GetData(); });

      DEBUG_MSG("Adding wrapper for bool mfem::Array::UseDevice() (" __HERE__ ")");
      // signature to use in the veto list: bool mfem::Array::UseDevice()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:123:9
      wrapped.method("UseDevice", [](WrappedType const& a)->bool { return a.UseDevice(); });
      wrapped.method("UseDevice", [](WrappedType const* a)->bool { return a->UseDevice(); });

      DEBUG_MSG("Adding wrapper for bool mfem::Array::OwnsData() (" __HERE__ ")");
      // signature to use in the veto list: bool mfem::Array::OwnsData()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:126:16
      wrapped.method("OwnsData", [](WrappedType const& a)->bool { return a.OwnsData(); });
      wrapped.method("OwnsData", [](WrappedType const* a)->bool { return a->OwnsData(); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::StealData(T **) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::StealData(T **)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:129:16
      wrapped.method("StealData", [](WrappedType& a, T ** arg0)->void { a.StealData(arg0); });
      wrapped.method("StealData", [](WrappedType* a, T ** arg0)->void { a->StealData(arg0); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::LoseData() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::LoseData()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:132:16
      wrapped.method("LoseData", [](WrappedType& a)->void { a.LoseData(); });
      wrapped.method("LoseData", [](WrappedType* a)->void { a->LoseData(); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::MakeDataOwner() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::MakeDataOwner()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:135:9
      wrapped.method("MakeDataOwner", [](WrappedType const& a)->void { a.MakeDataOwner(); });
      wrapped.method("MakeDataOwner", [](WrappedType const* a)->void { a->MakeDataOwner(); });

      DEBUG_MSG("Adding wrapper for int mfem::Array::Size() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Size()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:138:15
      wrapped.method("Size", [](WrappedType const& a)->int { return a.Size(); });
      wrapped.method("Size", [](WrappedType const* a)->int { return a->Size(); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:141:16
      wrapped.method("SetSize", [](WrappedType& a, int arg0)->void { a.SetSize(arg0); });
      wrapped.method("SetSize", [](WrappedType* a, int arg0)->void { a->SetSize(arg0); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int, const T &) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int, const T &)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:144:16
      wrapped.method("SetSize", [](WrappedType& a, int arg0, const T & arg1)->void { a.SetSize(arg0, arg1); });
      wrapped.method("SetSize", [](WrappedType* a, int arg0, const T & arg1)->void { a->SetSize(arg0, arg1); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::SetSize(int, mfem::MemoryType) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::SetSize(int, mfem::MemoryType)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:149:16
      wrapped.method("SetSize", [](WrappedType& a, int arg0, mfem::MemoryType arg1)->void { a.SetSize(arg0, arg1); });
      wrapped.method("SetSize", [](WrappedType* a, int arg0, mfem::MemoryType arg1)->void { a->SetSize(arg0, arg1); });

      DEBUG_MSG("Adding wrapper for int mfem::Array::Capacity() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Capacity()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:153:15
      wrapped.method("Capacity", [](WrappedType const& a)->int { return a.Capacity(); });
      wrapped.method("Capacity", [](WrappedType const* a)->int { return a->Capacity(); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::Reserve(int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::Reserve(int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:156:16
      wrapped.method("Reserve", [](WrappedType& a, int arg0)->void { a.Reserve(arg0); });
      wrapped.method("Reserve", [](WrappedType* a, int arg0)->void { a->Reserve(arg0); });
      module_.set_override_module(jl_base_module);


      DEBUG_MSG("Adding setindex! method  to wrap T & mfem::Array::operator[](int) (" __HERE__ ")");
// defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:160:15
      wrapped.method("setindex!",
        [](WrappedType& a, int i, T const & val){
        return a[i] = val;
      });

      DEBUG_MSG("Adding getindex method to wrap T & mfem::Array::operator[](int) (" __HERE__ ")");
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:160:15
      wrapped.method("getindex",
        [](WrappedType& a, int i){
        return a[i];
      });


      module_.unset_override_module();

      DEBUG_MSG("Adding wrapper for int mfem::Array::Append(const T &) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Append(const T &)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:166:15
      wrapped.method("Append", [](WrappedType& a, const T & arg0)->int { return a.Append(arg0); });
      wrapped.method("Append", [](WrappedType* a, const T & arg0)->int { return a->Append(arg0); });

      DEBUG_MSG("Adding wrapper for int mfem::Array::Append(const T *, int) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Append(const T *, int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:169:15
      wrapped.method("Append", [](WrappedType& a, const T * arg0, int arg1)->int { return a.Append(arg0, arg1); });
      wrapped.method("Append", [](WrappedType* a, const T * arg0, int arg1)->int { return a->Append(arg0, arg1); });

      DEBUG_MSG("Adding wrapper for int mfem::Array::Prepend(const T &) (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array::Prepend(const T &)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:175:15
      wrapped.method("Prepend", [](WrappedType& a, const T & arg0)->int { return a.Prepend(arg0); });
      wrapped.method("Prepend", [](WrappedType* a, const T & arg0)->int { return a->Prepend(arg0); });

      DEBUG_MSG("Adding wrapper for T & mfem::Array::Last() (" __HERE__ ")");
      // signature to use in the veto list: T & mfem::Array::Last()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:178:14
      wrapped.method("Last", [](WrappedType& a)->T & { return a.Last(); });
      wrapped.method("Last", [](WrappedType* a)->T & { return a->Last(); });

      DEBUG_MSG("Adding wrapper for const T & mfem::Array::Last() (" __HERE__ ")");
      // signature to use in the veto list: const T & mfem::Array::Last()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:181:20
      wrapped.method("Last", [](WrappedType const& a)->const T & { return a.Last(); });
      wrapped.method("Last", [](WrappedType const* a)->const T & { return a->Last(); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::DeleteLast() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::DeleteLast()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:193:16
      wrapped.method("DeleteLast", [](WrappedType& a)->void { a.DeleteLast(); });
      wrapped.method("DeleteLast", [](WrappedType* a)->void { a->DeleteLast(); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::DeleteAll() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::DeleteAll()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:199:16
      wrapped.method("DeleteAll", [](WrappedType& a)->void { a.DeleteAll(); });
      wrapped.method("DeleteAll", [](WrappedType* a)->void { a->DeleteAll(); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::MakeRef(T *, int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::MakeRef(T *, int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:206:16
      wrapped.method("MakeRef", [](WrappedType& a, T * arg0, int arg1)->void { a.MakeRef(arg0, arg1); });
      wrapped.method("MakeRef", [](WrappedType* a, T * arg0, int arg1)->void { a->MakeRef(arg0, arg1); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::operator=(const T &) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::operator=(const T &)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:272:16
      wrapped.method("assign", [](WrappedType& a, const T & arg0)->void { a.operator=(arg0); });
      wrapped.method("assign", [](WrappedType* a, const T & arg0)->void { a->operator=(arg0); });

      DEBUG_MSG("Adding wrapper for void mfem::Array::Assign(const T *) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array::Assign(const T *)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:275:16
      wrapped.method("Assign", [](WrappedType& a, const T * arg0)->void { a.Assign(arg0); });
      wrapped.method("Assign", [](WrappedType* a, const T * arg0)->void { a->Assign(arg0); });

      DEBUG_MSG("Adding wrapper for long mfem::Array::MemoryUsage() (" __HERE__ ")");
      // signature to use in the veto list: long mfem::Array::MemoryUsage()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:301:9
      wrapped.method("MemoryUsage", [](WrappedType const& a)->long { return a.MemoryUsage(); });
      wrapped.method("MemoryUsage", [](WrappedType const* a)->long { return a->MemoryUsage(); });

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::Read(bool) (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::Read(bool)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:304:13
      wrapped.method("Read", [](WrappedType const& a)->const T * { return a.Read(); });
      wrapped.method("Read", [](WrappedType const& a, bool arg0)->const T * { return a.Read(arg0); });
      wrapped.method("Read", [](WrappedType const* a)->const T * { return a->Read(); });
      wrapped.method("Read", [](WrappedType const* a, bool arg0)->const T * { return a->Read(arg0); });

      DEBUG_MSG("Adding wrapper for const T * mfem::Array::HostRead() (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array::HostRead()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:308:13
      wrapped.method("HostRead", [](WrappedType const& a)->const T * { return a.HostRead(); });
      wrapped.method("HostRead", [](WrappedType const* a)->const T * { return a->HostRead(); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array::Write(bool) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::Write(bool)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:312:7
      wrapped.method("Write", [](WrappedType& a)->T * { return a.Write(); });
      wrapped.method("Write", [](WrappedType& a, bool arg0)->T * { return a.Write(arg0); });
      wrapped.method("Write", [](WrappedType* a)->T * { return a->Write(); });
      wrapped.method("Write", [](WrappedType* a, bool arg0)->T * { return a->Write(arg0); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array::HostWrite() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::HostWrite()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:316:7
      wrapped.method("HostWrite", [](WrappedType& a)->T * { return a.HostWrite(); });
      wrapped.method("HostWrite", [](WrappedType* a)->T * { return a->HostWrite(); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array::ReadWrite(bool) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::ReadWrite(bool)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:320:7
      wrapped.method("ReadWrite", [](WrappedType& a)->T * { return a.ReadWrite(); });
      wrapped.method("ReadWrite", [](WrappedType& a, bool arg0)->T * { return a.ReadWrite(arg0); });
      wrapped.method("ReadWrite", [](WrappedType* a)->T * { return a->ReadWrite(); });
      wrapped.method("ReadWrite", [](WrappedType* a, bool arg0)->T * { return a->ReadWrite(arg0); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array::HostReadWrite() (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array::HostReadWrite()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:324:7
      wrapped.method("HostReadWrite", [](WrappedType& a)->T * { return a.HostReadWrite(); });
      wrapped.method("HostReadWrite", [](WrappedType* a)->T * { return a->HostReadWrite(); });
    };
    t.apply<mfem::Array<mfem::FiniteElementSpace *>, mfem::Array<mfem::NonlinearFormIntegrator *>, mfem::Array<mfem::BilinearFormIntegrator *>, mfem::Array<mfem::Array<int> *>, mfem::Array<mfem::DeltaLFIntegrator *>, mfem::Array<mfem::LinearFormIntegrator *>, mfem::Array<mfem::IntegrationPoint>, mfem::Array<mfem::Vector *>, mfem::Array<mfem::KnotVector *>, mfem::Array<mfem::Geometry::Type>, mfem::Array<mfem::FaceGeometricFactors *>, mfem::Array<mfem::GeometricFactors *>, mfem::Array<mfem::Coefficient *>, mfem::Array<mfem::DenseMatrix *>, mfem::Array<mfem::NCMesh::Slave>, mfem::Array<mfem::NCMesh::Master>, mfem::Array<mfem::NCMesh::MeshId>, mfem::Array<mfem::Refinement>, mfem::Array<mfem::Embedding>, mfem::Array<mfem::SparseMatrix *>, mfem::Array<int>>(t1_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Array(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Array(module));
}
