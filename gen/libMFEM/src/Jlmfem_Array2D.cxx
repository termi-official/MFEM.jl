// this file was auto-generated by wrapit v1.5.0
#include "Wrapper.h"

#include "jllibMFEM.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {

  template<typename T>
  struct BuildParameterList<mfem::Array2D<T>>
  {
    typedef ParameterList<T> type;
  };

  template<typename T> struct IsMirroredType<mfem::Array2D<T>> : std::false_type { };
  template<typename T> struct DefaultConstructible<mfem::Array2D<T>> : std::false_type { };
}

// Class generating the wrapper for type mfem::Array2D
// signature to use in the veto file: mfem::Array2D
struct Jlmfem_Array2D: public Wrapper {

  Jlmfem_Array2D(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Array2D (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:358:7
    jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>  t =  jlModule.add_type<jlcxx::Parametric<jlcxx::TypeVar<1>>>("mfem!Array2D");
    type_ = std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>>(new jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>(jlModule, t));
    t.constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);
    auto t4_decl_methods = [this]<typename T> (jlcxx::TypeWrapper<mfem::Array2D<T>> wrapped){
      auto module_ = this->module_;
      typedef mfem::Array2D<T> WrappedType;
      wrapped.template constructor<>(/*finalize=*/jlcxx::finalize_policy::yes);


      DEBUG_MSG("Adding wrapper for void mfem::Array2D::Array2D<T>(int, int) (" __HERE__ ")");
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:368:4
      wrapped.template constructor<int, int>(/*finalize=*/jlcxx::finalize_policy::yes);

      DEBUG_MSG("Adding wrapper for void mfem::Array2D::SetSize(int, int) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array2D::SetSize(int, int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:370:9
      wrapped.method("SetSize", [](WrappedType& a, int arg0, int arg1)->void { a.SetSize(arg0, arg1); });
      wrapped.method("SetSize", [](WrappedType* a, int arg0, int arg1)->void { a->SetSize(arg0, arg1); });

      DEBUG_MSG("Adding wrapper for int mfem::Array2D::NumRows() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array2D::NumRows()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:372:8
      wrapped.method("NumRows", [](WrappedType const& a)->int { return a.NumRows(); });
      wrapped.method("NumRows", [](WrappedType const* a)->int { return a->NumRows(); });

      DEBUG_MSG("Adding wrapper for int mfem::Array2D::NumCols() (" __HERE__ ")");
      // signature to use in the veto list: int mfem::Array2D::NumCols()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:373:8
      wrapped.method("NumCols", [](WrappedType const& a)->int { return a.NumCols(); });
      wrapped.method("NumCols", [](WrappedType const* a)->int { return a->NumCols(); });

      DEBUG_MSG("Adding wrapper for const T & mfem::Array2D::operator()(int, int) (" __HERE__ ")");
      // signature to use in the veto list: const T & mfem::Array2D::operator()(int, int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:375:20
      wrapped.method("paren", [](WrappedType const& a, int arg0, int arg1)->const T & { return a.operator()(arg0, arg1); });
      wrapped.method("paren", [](WrappedType const* a, int arg0, int arg1)->const T & { return a->operator()(arg0, arg1); });

      DEBUG_MSG("Adding wrapper for T & mfem::Array2D::operator()(int, int) (" __HERE__ ")");
      // signature to use in the veto list: T & mfem::Array2D::operator()(int, int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:376:20
      wrapped.method("paren", [](WrappedType& a, int arg0, int arg1)->T & { return a.operator()(arg0, arg1); });
      wrapped.method("paren", [](WrappedType* a, int arg0, int arg1)->T & { return a->operator()(arg0, arg1); });
      module_.set_override_module(jl_base_module);



      module_.unset_override_module();

      DEBUG_MSG("Adding wrapper for const T * mfem::Array2D::operator()(int) (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array2D::operator()(int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:381:13
      wrapped.method("paren", [](WrappedType const& a, int arg0)->const T * { return a.operator()(arg0); });
      wrapped.method("paren", [](WrappedType const* a, int arg0)->const T * { return a->operator()(arg0); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array2D::operator()(int) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array2D::operator()(int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:382:13
      wrapped.method("paren", [](WrappedType& a, int arg0)->T * { return a.operator()(arg0); });
      wrapped.method("paren", [](WrappedType* a, int arg0)->T * { return a->operator()(arg0); });

      DEBUG_MSG("Adding wrapper for const T * mfem::Array2D::GetRow(int) (" __HERE__ ")");
      // signature to use in the veto list: const T * mfem::Array2D::GetRow(int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:384:13
      wrapped.method("GetRow", [](WrappedType const& a, int arg0)->const T * { return a.GetRow(arg0); });
      wrapped.method("GetRow", [](WrappedType const* a, int arg0)->const T * { return a->GetRow(arg0); });

      DEBUG_MSG("Adding wrapper for T * mfem::Array2D::GetRow(int) (" __HERE__ ")");
      // signature to use in the veto list: T * mfem::Array2D::GetRow(int)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:385:13
      wrapped.method("GetRow", [](WrappedType& a, int arg0)->T * { return a.GetRow(arg0); });
      wrapped.method("GetRow", [](WrappedType* a, int arg0)->T * { return a->GetRow(arg0); });

      DEBUG_MSG("Adding wrapper for void mfem::Array2D::operator=(const T &) (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array2D::operator=(const T &)
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:429:16
      wrapped.method("assign", [](WrappedType& a, const T & arg0)->void { a.operator=(arg0); });
      wrapped.method("assign", [](WrappedType* a, const T & arg0)->void { a->operator=(arg0); });

      DEBUG_MSG("Adding wrapper for void mfem::Array2D::DeleteAll() (" __HERE__ ")");
      // signature to use in the veto list: void mfem::Array2D::DeleteAll()
      // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/general/array.hpp:439:16
      wrapped.method("DeleteAll", [](WrappedType& a)->void { a.DeleteAll(); });
      wrapped.method("DeleteAll", [](WrappedType* a)->void { a->DeleteAll(); });
    };
    t.apply<mfem::Array2D<mfem::SparseMatrix *>>(t4_decl_methods);
  }

  void add_methods() const{
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<jlcxx::Parametric<jlcxx::TypeVar<1>>>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Array2D(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Array2D(module));
}
