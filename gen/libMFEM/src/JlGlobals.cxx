// this file was auto-generated by wrapit v1.5.0
#include "Wrapper.h"

#include "jllibMFEM.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"
// Class generating the wrapper for type 
// signature to use in the veto file: 
struct JlGlobal: public Wrapper {

  JlGlobal(jlcxx::Module& jlModule): Wrapper(jlModule){
  }

  void add_methods() const{
    auto& t = module_;

    DEBUG_MSG("Adding wrapper for double mfem::infinity() (" __HERE__ ")");
    // signature to use in the veto list: double mfem::infinity()
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/vector.hpp:46:15
    t.method("mfem!infinity", []()->double { return mfem::infinity(); });

    DEBUG_MSG("Adding wrapper for bool mfem::IsFinite(const double &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::IsFinite(const double &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/vector.hpp:490:13
    t.method("mfem!IsFinite", [](const double & arg0)->bool { return mfem::IsFinite(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::Vector &, mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::Vector &, mfem::Vector &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/vector.hpp:630:24
    t.method("mfem!Swap", [](mfem::Vector & arg0, mfem::Vector & arg1)->void { mfem::Swap(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for double mfem::DistanceSquared(const double *, const double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::DistanceSquared(const double *, const double *, const int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/vector.hpp:640:15
    t.method("mfem!DistanceSquared", [](const double * arg0, const double * arg1, const int arg2)->double { return mfem::DistanceSquared(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for double mfem::Distance(const double *, const double *, const int) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::Distance(const double *, const double *, const int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/vector.hpp:652:15
    t.method("mfem!Distance", [](const double * arg0, const double * arg1, const int arg2)->double { return mfem::Distance(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for double mfem::InnerProduct(const mfem::Vector &, const mfem::Vector &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::InnerProduct(const mfem::Vector &, const mfem::Vector &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/vector.hpp:671:15
    t.method("mfem!InnerProduct", [](const mfem::Vector & arg0, const mfem::Vector & arg1)->double { return mfem::InnerProduct(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for bool mfem::IsIdentityProlongation(const mfem::Operator *) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::IsIdentityProlongation(const mfem::Operator *)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/operator.hpp:689:13
    t.method("mfem!IsIdentityProlongation", [](const mfem::Operator * arg0)->bool { return mfem::IsIdentityProlongation(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::SparseMatrixFunction(mfem::SparseMatrix &, double (*)(double)) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SparseMatrixFunction(mfem::SparseMatrix &, double (*)(double))
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:687:6
    t.method("mfem!SparseMatrixFunction", [](mfem::SparseMatrix & arg0, double (*arg1)(double))->void { mfem::SparseMatrixFunction(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Transpose(const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Transpose(const mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:691:15
    t.method("mfem!Transpose", [](const mfem::SparseMatrix & arg0)->mfem::SparseMatrix * { return mfem::Transpose(arg0); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::TransposeAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::TransposeAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:693:15
    t.method("mfem!TransposeAbstractSparseMatrix", [](const mfem::AbstractSparseMatrix & arg0, int arg1)->mfem::SparseMatrix * { return mfem::TransposeAbstractSparseMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Mult(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Mult(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:702:15
    t.method("mfem!Mult", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::Mult(arg0, arg1); });
    t.method("mfem!Mult", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1, mfem::SparseMatrix * arg2)->mfem::SparseMatrix * { return mfem::Mult(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::TransposeMult(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::TransposeMult(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:706:15
    t.method("mfem!TransposeMult", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::TransposeMult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::MultAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, const mfem::AbstractSparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::MultAbstractSparseMatrix(const mfem::AbstractSparseMatrix &, const mfem::AbstractSparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:709:15
    t.method("mfem!MultAbstractSparseMatrix", [](const mfem::AbstractSparseMatrix & arg0, const mfem::AbstractSparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::MultAbstractSparseMatrix(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::Mult(const mfem::SparseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::Mult(const mfem::SparseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:713:14
    t.method("mfem!Mult", [](const mfem::SparseMatrix & arg0, mfem::DenseMatrix & arg1)->mfem::DenseMatrix * { return mfem::Mult(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::RAP(const mfem::SparseMatrix &, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::RAP(const mfem::SparseMatrix &, mfem::DenseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:716:14
    t.method("mfem!RAP", [](const mfem::SparseMatrix & arg0, mfem::DenseMatrix & arg1)->mfem::DenseMatrix * { return mfem::RAP(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::RAP(mfem::DenseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::RAP(mfem::DenseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:719:14
    t.method("mfem!RAP", [](mfem::DenseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::DenseMatrix * { return mfem::RAP(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, mfem::SparseMatrix *)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:723:15
    t.method("mfem!RAP", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::RAP(arg0, arg1); });
    t.method("mfem!RAP", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1, mfem::SparseMatrix * arg2)->mfem::SparseMatrix * { return mfem::RAP(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::RAP(const mfem::SparseMatrix &, const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:727:15
    t.method("mfem!RAP", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1, const mfem::SparseMatrix & arg2)->mfem::SparseMatrix * { return mfem::RAP(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Mult_AtDA(const mfem::SparseMatrix &, const mfem::Vector &, mfem::SparseMatrix *) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Mult_AtDA(const mfem::SparseMatrix &, const mfem::Vector &, mfem::SparseMatrix *)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:731:15
    t.method("mfem!Mult_AtDA", [](const mfem::SparseMatrix & arg0, const mfem::Vector & arg1)->mfem::SparseMatrix * { return mfem::Mult_AtDA(arg0, arg1); });
    t.method("mfem!Mult_AtDA", [](const mfem::SparseMatrix & arg0, const mfem::Vector & arg1, mfem::SparseMatrix * arg2)->mfem::SparseMatrix * { return mfem::Mult_AtDA(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Add(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Add(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:736:16
    t.method("mfem!Add", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::Add(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Add(double, const mfem::SparseMatrix &, double, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Add(double, const mfem::SparseMatrix &, double, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:738:16
    t.method("mfem!Add", [](double arg0, const mfem::SparseMatrix & arg1, double arg2, const mfem::SparseMatrix & arg3)->mfem::SparseMatrix * { return mfem::Add(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::Add(mfem::Array<mfem::SparseMatrix *> &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::Add(mfem::Array<mfem::SparseMatrix *> &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:741:16
    t.method("mfem!Add", [](mfem::Array<mfem::SparseMatrix *> & arg0)->mfem::SparseMatrix * { return mfem::Add(arg0); });

    DEBUG_MSG("Adding wrapper for void mfem::Add(const mfem::SparseMatrix &, double, mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Add(const mfem::SparseMatrix &, double, mfem::DenseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:744:6
    t.method("mfem!Add", [](const mfem::SparseMatrix & arg0, double arg1, mfem::DenseMatrix & arg2)->void { mfem::Add(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for mfem::DenseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::DenseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::DenseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:747:14
    t.method("mfem!OuterProduct", [](const mfem::DenseMatrix & arg0, const mfem::DenseMatrix & arg1)->mfem::DenseMatrix * { return mfem::OuterProduct(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::DenseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:750:15
    t.method("mfem!OuterProduct", [](const mfem::DenseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::OuterProduct(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::DenseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::DenseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:753:15
    t.method("mfem!OuterProduct", [](const mfem::SparseMatrix & arg0, const mfem::DenseMatrix & arg1)->mfem::SparseMatrix * { return mfem::OuterProduct(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: mfem::SparseMatrix * mfem::OuterProduct(const mfem::SparseMatrix &, const mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:756:15
    t.method("mfem!OuterProduct", [](const mfem::SparseMatrix & arg0, const mfem::SparseMatrix & arg1)->mfem::SparseMatrix * { return mfem::OuterProduct(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::SparseMatrix &, mfem::SparseMatrix &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::SparseMatrix &, mfem::SparseMatrix &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/sparsemat.hpp:900:24
    t.method("mfem!Swap", [](mfem::SparseMatrix & arg0, mfem::SparseMatrix & arg1)->void { mfem::Swap(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for void mfem::SLI(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLI(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:454:6
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { mfem::SLI(arg0, arg1, arg2); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void { mfem::SLI(arg0, arg1, arg2, arg3); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5, double arg6)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::SLI(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::SLI(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:459:6
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::SLI(arg0, arg1, arg2, arg3); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });
    t.method("mfem!SLI", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6, double arg7)->void { mfem::SLI(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for void mfem::CG(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::CG(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:486:6
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { mfem::CG(arg0, arg1, arg2); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void { mfem::CG(arg0, arg1, arg2, arg3); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void { mfem::CG(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void { mfem::CG(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!CG", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5, double arg6)->void { mfem::CG(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::PCG(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::PCG(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:491:6
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::PCG(arg0, arg1, arg2, arg3); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::PCG(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::PCG(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void { mfem::PCG(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });
    t.method("mfem!PCG", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6, double arg7)->void { mfem::PCG(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for int mfem::GMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, int, double &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::GMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, int, double &, double, int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:534:5
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Vector & arg1, const mfem::Vector & arg2, mfem::Solver & arg3, int & arg4, int arg5, double & arg6, double arg7, int arg8)->int { return mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8); });

    DEBUG_MSG("Adding wrapper for void mfem::GMRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::GMRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, int, double, double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:538:6
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::GMRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, int arg6)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, int arg6, double arg7)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });
    t.method("mfem!GMRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, int arg6, double arg7, double arg8)->void { mfem::GMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8); });

    DEBUG_MSG("Adding wrapper for int mfem::BiCGSTAB(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, double &, double, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::BiCGSTAB(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, mfem::Solver &, int &, double &, double, int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:565:5
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Vector & arg1, const mfem::Vector & arg2, mfem::Solver & arg3, int & arg4, double & arg5, double arg6, int arg7)->int { return mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for void mfem::BiCGSTAB(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::BiCGSTAB(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:569:6
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });
    t.method("mfem!BiCGSTAB", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6, double arg7)->void { mfem::BiCGSTAB(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for void mfem::MINRES(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRES(const mfem::Operator &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:600:6
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2)->void { mfem::MINRES(arg0, arg1, arg2); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3)->void { mfem::MINRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, const mfem::Vector & arg1, mfem::Vector & arg2, int arg3, int arg4, double arg5, double arg6)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for void mfem::MINRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::MINRES(const mfem::Operator &, mfem::Solver &, const mfem::Vector &, mfem::Vector &, int, int, double, double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:604:6
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3)->void { mfem::MINRES(arg0, arg1, arg2, arg3); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });
    t.method("mfem!MINRES", [](const mfem::Operator & arg0, mfem::Solver & arg1, const mfem::Vector & arg2, mfem::Vector & arg3, int arg4, int arg5, double arg6, double arg7)->void { mfem::MINRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7); });

    DEBUG_MSG("Adding wrapper for int mfem::aGMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, const mfem::Operator &, int &, int, int, int, double, double &, double &, int) (" __HERE__ ")");
    // signature to use in the veto list: int mfem::aGMRES(const mfem::Operator &, mfem::Vector &, const mfem::Vector &, const mfem::Operator &, int &, int, int, int, double, double &, double &, int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/solvers.hpp:763:5
    t.method("mfem!aGMRES", [](const mfem::Operator & arg0, mfem::Vector & arg1, const mfem::Vector & arg2, const mfem::Operator & arg3, int & arg4, int arg5, int arg6, int arg7, double arg8, double & arg9, double & arg10, int arg11)->int { return mfem::aGMRES(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11); });

    DEBUG_MSG("Adding wrapper for void mfem::Swap(mfem::CoarseFineTransformations &, mfem::CoarseFineTransformations &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Swap(mfem::CoarseFineTransformations &, mfem::CoarseFineTransformations &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/ncmesh.hpp:94:6
    t.method("mfem!Swap", [](mfem::CoarseFineTransformations & arg0, mfem::CoarseFineTransformations & arg1)->void { mfem::Swap(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::Extrude1D(mfem::Mesh *, const int, const double, const bool) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::Extrude1D(mfem::Mesh *, const int, const double, const bool)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/mesh.hpp:1936:7
    t.method("mfem!Extrude1D", [](mfem::Mesh * arg0, const int arg1, const double arg2)->mfem::Mesh * { return mfem::Extrude1D(arg0, arg1, arg2); });
    t.method("mfem!Extrude1D", [](mfem::Mesh * arg0, const int arg1, const double arg2, const bool arg3)->mfem::Mesh * { return mfem::Extrude1D(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for mfem::Mesh * mfem::Extrude2D(mfem::Mesh *, const int, const double) (" __HERE__ ")");
    // signature to use in the veto list: mfem::Mesh * mfem::Extrude2D(mfem::Mesh *, const int, const double)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/mesh.hpp:1940:7
    t.method("mfem!Extrude2D", [](mfem::Mesh * arg0, const int arg1, const double arg2)->mfem::Mesh * { return mfem::Extrude2D(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for void mfem::ShiftRight(int &, int &, int &) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::ShiftRight(int &, int &, int &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/mesh.hpp:1943:13
    t.method("mfem!ShiftRight", [](int & arg0, int & arg1, int & arg2)->void { mfem::ShiftRight(arg0, arg1, arg2); });

    DEBUG_MSG("Adding wrapper for bool mfem::UsesTensorBasis(const mfem::FiniteElementSpace &) (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::UsesTensorBasis(const mfem::FiniteElementSpace &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/fespace.hpp:983:13
    t.method("mfem!UsesTensorBasis", [](const mfem::FiniteElementSpace & arg0)->bool { return mfem::UsesTensorBasis(arg0); });

    DEBUG_MSG("Adding wrapper for double mfem::ZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::GridFunction &, mfem::Vector &, mfem::Array<int> *, int, bool) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ZZErrorEstimator(mfem::BilinearFormIntegrator &, mfem::GridFunction &, mfem::GridFunction &, mfem::Vector &, mfem::Array<int> *, int, bool)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/gridfunc.hpp:928:8
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3); });
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3, mfem::Array<int> * arg4)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3, arg4); });
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3, mfem::Array<int> * arg4, int arg5)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3, arg4, arg5); });
    t.method("mfem!ZZErrorEstimator", [](mfem::BilinearFormIntegrator & arg0, mfem::GridFunction & arg1, mfem::GridFunction & arg2, mfem::Vector & arg3, mfem::Array<int> * arg4, int arg5, bool arg6)->double { return mfem::ZZErrorEstimator(arg0, arg1, arg2, arg3, arg4, arg5, arg6); });

    DEBUG_MSG("Adding wrapper for double mfem::ComputeElementLpDistance(double, int, mfem::GridFunction &, mfem::GridFunction &) (" __HERE__ ")");
    // signature to use in the veto list: double mfem::ComputeElementLpDistance(double, int, mfem::GridFunction &, mfem::GridFunction &)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/gridfunc.hpp:937:8
    t.method("mfem!ComputeElementLpDistance", [](double arg0, int arg1, mfem::GridFunction & arg2, mfem::GridFunction & arg3)->double { return mfem::ComputeElementLpDistance(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding wrapper for mfem::GridFunction * mfem::Extrude1DGridFunction(mfem::Mesh *, mfem::Mesh *, mfem::GridFunction *, const int) (" __HERE__ ")");
    // signature to use in the veto list: mfem::GridFunction * mfem::Extrude1DGridFunction(mfem::Mesh *, mfem::Mesh *, mfem::GridFunction *, const int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/gridfunc.hpp:956:15
    t.method("mfem!Extrude1DGridFunction", [](mfem::Mesh * arg0, mfem::Mesh * arg1, mfem::GridFunction * arg2, const int arg3)->mfem::GridFunction * { return mfem::Extrude1DGridFunction(arg0, arg1, arg2, arg3); });

    DEBUG_MSG("Adding mfem!IntRules methods to provide access to the global variable mfem::IntRules (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/intrules.hpp:379:25
    t.method("mfem!IntRules", []()-> mfem::IntegrationRules& { return mfem::IntRules; });
    // t.method("mfem!IntRules!", [](const mfem::IntegrationRules& val)-> mfem::IntegrationRules& { return mfem::IntRules = val; });

    DEBUG_MSG("Adding mfem!RefinedIntRules methods to provide access to the global variable mfem::RefinedIntRules (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/intrules.hpp:382:25
    t.method("mfem!RefinedIntRules", []()-> mfem::IntegrationRules& { return mfem::RefinedIntRules; });
    // t.method("mfem!RefinedIntRules!", [](const mfem::IntegrationRules& val)-> mfem::IntegrationRules& { return mfem::RefinedIntRules = val; });

    DEBUG_MSG("Adding mfem!Mesh!remove_unused_vertices methods to provide access to the global variable mfem::Mesh::remove_unused_vertices (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/mesh.hpp:281:16
    module_.method("mfem!Mesh!remove_unused_vertices", []()-> bool { return mfem::Mesh::remove_unused_vertices; });
    module_.method("mfem!Mesh!remove_unused_vertices!", [](bool val)-> bool { return mfem::Mesh::remove_unused_vertices = val; });

    DEBUG_MSG("Adding mfem!HCURL_MAX_D1D methods to provide access to the global variable mfem::HCURL_MAX_D1D (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/bilininteg.hpp:23:15
    t.method("mfem!HCURL_MAX_D1D", []()-> int { return mfem::HCURL_MAX_D1D; });

    DEBUG_MSG("Adding mfem!HCURL_MAX_Q1D methods to provide access to the global variable mfem::HCURL_MAX_Q1D (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/bilininteg.hpp:27:15
    t.method("mfem!HCURL_MAX_Q1D", []()-> int { return mfem::HCURL_MAX_Q1D; });

    DEBUG_MSG("Adding mfem!HDIV_MAX_D1D methods to provide access to the global variable mfem::HDIV_MAX_D1D (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/bilininteg.hpp:30:15
    t.method("mfem!HDIV_MAX_D1D", []()-> int { return mfem::HDIV_MAX_D1D; });

    DEBUG_MSG("Adding mfem!HDIV_MAX_Q1D methods to provide access to the global variable mfem::HDIV_MAX_Q1D (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/mesh/../fem/bilininteg.hpp:31:15
    t.method("mfem!HDIV_MAX_Q1D", []()-> int { return mfem::HDIV_MAX_Q1D; });
  }
};
std::shared_ptr<Wrapper> newJlGlobal(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new JlGlobal(module));
}
