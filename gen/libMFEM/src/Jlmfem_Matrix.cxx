// this file was auto-generated by wrapit v1.5.0
#include "Wrapper.h"

#include "jllibMFEM.h"
#include "dbg_msg.h"
#include "jlcxx/functions.hpp"
#include "jlcxx/stl.hpp"

namespace jlcxx {
  template<> struct IsMirroredType<mfem::Matrix> : std::false_type { };
  template<> struct DefaultConstructible<mfem::Matrix> : std::false_type { };
template<> struct SuperType<mfem::Matrix> { typedef mfem::Operator type; };
}

// Class generating the wrapper for type mfem::Matrix
// signature to use in the veto file: mfem::Matrix
struct Jlmfem_Matrix: public Wrapper {

  Jlmfem_Matrix(jlcxx::Module& jlModule): Wrapper(jlModule){
    DEBUG_MSG("Adding wrapper for type mfem::Matrix (" __HERE__ ")");
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/matrix.hpp:27:7
    jlcxx::TypeWrapper<mfem::Matrix>  t = jlModule.add_type<mfem::Matrix>("mfem!Matrix",
      jlcxx::julia_base_type<mfem::Operator>());
    type_ = std::unique_ptr<jlcxx::TypeWrapper<mfem::Matrix>>(new jlcxx::TypeWrapper<mfem::Matrix>(jlModule, t));
  }

  void add_methods() const{
    auto& t = *type_;



    DEBUG_MSG("Adding wrapper for bool mfem::Matrix::IsSquare() (" __HERE__ ")");
    // signature to use in the veto list: bool mfem::Matrix::IsSquare()
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/matrix.hpp:39:9
    t.method("IsSquare", [](mfem::Matrix const& a)->bool { return a.IsSquare(); });
    t.method("IsSquare", [](mfem::Matrix const* a)->bool { return a->IsSquare(); });

    DEBUG_MSG("Adding wrapper for double & mfem::Matrix::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: double & mfem::Matrix::Elem(int, int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/matrix.hpp:42:20
    t.method("Elem", [](mfem::Matrix& a, int arg0, int arg1)->double & { return a.Elem(arg0, arg1); });
    t.method("Elem", [](mfem::Matrix* a, int arg0, int arg1)->double & { return a->Elem(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for const double & mfem::Matrix::Elem(int, int) (" __HERE__ ")");
    // signature to use in the veto list: const double & mfem::Matrix::Elem(int, int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/matrix.hpp:45:26
    t.method("Elem", [](mfem::Matrix const& a, int arg0, int arg1)->const double & { return a.Elem(arg0, arg1); });
    t.method("Elem", [](mfem::Matrix const* a, int arg0, int arg1)->const double & { return a->Elem(arg0, arg1); });

    DEBUG_MSG("Adding wrapper for mfem::MatrixInverse * mfem::Matrix::Inverse() (" __HERE__ ")");
    // signature to use in the veto list: mfem::MatrixInverse * mfem::Matrix::Inverse()
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/matrix.hpp:48:27
    t.method("Inverse", [](mfem::Matrix const& a)->mfem::MatrixInverse * { return a.Inverse(); });
    t.method("Inverse", [](mfem::Matrix const* a)->mfem::MatrixInverse * { return a->Inverse(); });

    DEBUG_MSG("Adding wrapper for void mfem::Matrix::Finalize(int) (" __HERE__ ")");
    // signature to use in the veto list: void mfem::Matrix::Finalize(int)
    // defined in /home/dogiermann/.julia/artifacts/820df874853553756f46ac6dc23173c05d8db01a/include/mfem/linalg/matrix.hpp:51:17
    t.method("Finalize", [](mfem::Matrix& a, int arg0)->void { a.Finalize(arg0); });
    t.method("Finalize", [](mfem::Matrix* a, int arg0)->void { a->Finalize(arg0); });
  }

private:
  std::unique_ptr<jlcxx::TypeWrapper<mfem::Matrix>> type_;
};
std::shared_ptr<Wrapper> newJlmfem_Matrix(jlcxx::Module& module){
  return std::shared_ptr<Wrapper>(new Jlmfem_Matrix(module));
}
